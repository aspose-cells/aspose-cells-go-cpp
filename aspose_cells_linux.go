// +build linux

/* ----------------------------------------------------------------
 * Copyright (c) 2001-2025 Aspose Pty Ltd. All Rights Reserved.
 * Powered by Aspose.Cells.
 * ---------------------------------------------------------------*/


package asposecells

// #cgo CXXFLAGS: -std=c++11
// #cgo CFLAGS: -I.
// #cgo LDFLAGS: -Wl,-rpath,"${SRCDIR}/lib/linux_x86_64" -L"${SRCDIR}/lib/linux_x86_64" -lAspose.Cells.CWrapper
// #include <AsposeCellsCWrapper.h>
import "C"
import (
	"fmt"  
	"time"  	
	"errors"	
	"runtime"
	"unsafe" 
)

/**************Enum AccessCacheOptions *****************/

// Cache options for data access. Can be combined with | operator for multiple options together.
type AccessCacheOptions int32

const(
// No cache for any data access.
AccessCacheOptions_None AccessCacheOptions = 0 

// Apply all possible optimizations for all kinds of data access in the workbook.
// All settings and data should not be changed during the optimized access.
AccessCacheOptions_All AccessCacheOptions = -1 

// Apply possible optimization for getting object(such as Shape)'s position and size.
// Row height and column width settings should not be changed during the optimized access.
AccessCacheOptions_PositionAndSize AccessCacheOptions = 3 

// Apply possible optimization for getting cells' values.
// Cells data(data and settings of Cell, Row) should not be changed during
// the optimized access, no new Cell/Row objects should be created either(such as
// by <see cref="Cells.this[int, int]"/>).
AccessCacheOptions_CellsData AccessCacheOptions = 9 

// Apply possible optimization for getting display-related results of
// cells(<see cref="Cell.DisplayStringValue"/>, <see cref="Cell.GetStyle()"/>, <see cref="Cell.GetDisplayStyle()"/>, etc.).
// Cells data and style-related objects(Cell/Row/Column styles, column width, etc.) should not be changed
// during the optimized access.
AccessCacheOptions_CellDisplay AccessCacheOptions = 1048710 

// Apply possible optimization for getting formulas.
// All data and settings which may affect the formula expression(Worksheet's name, Name's text,
// table's column, etc.) should not be changed during the optimized access.
AccessCacheOptions_GetFormula AccessCacheOptions = 2097152 

// Apply possible optimization for setting formulas.
// All data and settings which may affect the formula expression(Worksheet's name, Name's text,
// table's column, etc.) should not be changed during the optimized access.
AccessCacheOptions_SetFormula AccessCacheOptions = 4194304 

// Apply possible optimization for calculating formulas.
// Cells data should not be changed during the optimized access, none new objects(Cell, Row, etc.)
// should be created either(such as by <see cref="Cells.this[int, int]"/>).
AccessCacheOptions_CalculateFormula AccessCacheOptions = 8388617 

// Apply possible optimization for getting formatting result of conditional formattings.
// All data and settings which may affect the result of conditional formattings(settings of
// conditional formattings, dependent cell values, etc.) should not be changed during the optimized access.
AccessCacheOptions_ConditionalFormatting AccessCacheOptions = 16777225 

// Apply possible optimization for getting validation result.
// All data and settings which may affect the result of validation(settings of the validation,
// dependent cell values, etc.) should not be changed during the optimized access.
AccessCacheOptions_Validation AccessCacheOptions = 33554441 
)

func Int32ToAccessCacheOptions(value int32)(AccessCacheOptions ,error){
	switch value {
		case 0:  return AccessCacheOptions_None, nil  
		case -1:  return AccessCacheOptions_All, nil  
		case 3:  return AccessCacheOptions_PositionAndSize, nil  
		case 9:  return AccessCacheOptions_CellsData, nil  
		case 1048710:  return AccessCacheOptions_CellDisplay, nil  
		case 2097152:  return AccessCacheOptions_GetFormula, nil  
		case 4194304:  return AccessCacheOptions_SetFormula, nil  
		case 8388617:  return AccessCacheOptions_CalculateFormula, nil  
		case 16777225:  return AccessCacheOptions_ConditionalFormatting, nil  
		case 33554441:  return AccessCacheOptions_Validation, nil  
		default:
			return 0 ,fmt.Errorf("invalid AccessCacheOptions value: %d", value)
	}
}

/**************Enum AutoFillType *****************/

// Represents the auto fill type.
type AutoFillType int32

const(
// Copies the value and format of the source area to the target area
AutoFillType_Copy AutoFillType = 1 

// Automatically fills the target area with the value and format.
AutoFillType_Default AutoFillType = 0 

// Copies only the format of the source area to the target area,
AutoFillType_Formats AutoFillType = 3 

// Extend the value in the source area to the target area in the form of a series and copy format to the target area.
AutoFillType_Series AutoFillType = 2 

// Copies only the value of the source area to the target area,
AutoFillType_Values AutoFillType = 4 
)

func Int32ToAutoFillType(value int32)(AutoFillType ,error){
	switch value {
		case 1:  return AutoFillType_Copy, nil  
		case 0:  return AutoFillType_Default, nil  
		case 3:  return AutoFillType_Formats, nil  
		case 2:  return AutoFillType_Series, nil  
		case 4:  return AutoFillType_Values, nil  
		default:
			return 0 ,fmt.Errorf("invalid AutoFillType value: %d", value)
	}
}

/**************Enum AutoFitMergedCellsType *****************/

// Represents the type of auto fitting merged cells.
type AutoFitMergedCellsType int32

const(
// Ignore merged cells.
AutoFitMergedCellsType_None AutoFitMergedCellsType = 0 

// Only expands the height of the first row.
AutoFitMergedCellsType_FirstLine AutoFitMergedCellsType = 1 

// Only expands the height of the last row.
AutoFitMergedCellsType_LastLine AutoFitMergedCellsType = 2 

// Expands the height of each row.
AutoFitMergedCellsType_EachLine AutoFitMergedCellsType = 3 
)

func Int32ToAutoFitMergedCellsType(value int32)(AutoFitMergedCellsType ,error){
	switch value {
		case 0:  return AutoFitMergedCellsType_None, nil  
		case 1:  return AutoFitMergedCellsType_FirstLine, nil  
		case 2:  return AutoFitMergedCellsType_LastLine, nil  
		case 3:  return AutoFitMergedCellsType_EachLine, nil  
		default:
			return 0 ,fmt.Errorf("invalid AutoFitMergedCellsType value: %d", value)
	}
}

/**************Enum AutoFitWrappedTextType *****************/

// Represents the type of auto fitting wrapped text.
type AutoFitWrappedTextType int32

const(
// Works as MS Excel.
AutoFitWrappedTextType_Default AutoFitWrappedTextType = 0 

// Auto fit width with the longest paragraph.
AutoFitWrappedTextType_Paragraph AutoFitWrappedTextType = 1 
)

func Int32ToAutoFitWrappedTextType(value int32)(AutoFitWrappedTextType ,error){
	switch value {
		case 0:  return AutoFitWrappedTextType_Default, nil  
		case 1:  return AutoFitWrappedTextType_Paragraph, nil  
		default:
			return 0 ,fmt.Errorf("invalid AutoFitWrappedTextType value: %d", value)
	}
}

/**************Enum BackgroundType *****************/

// Enumerates cell background pattern types.
type BackgroundType int32

const(
// Represents diagonal crosshatch pattern.
BackgroundType_DiagonalCrosshatch BackgroundType = 9 

// Represents diagonal stripe pattern.
BackgroundType_DiagonalStripe BackgroundType = 8 

// Represents 6.25% gray pattern
BackgroundType_Gray6 BackgroundType = 18 

// Represents 12.5% gray pattern
BackgroundType_Gray12 BackgroundType = 17 

// Represents 25% gray pattern.
BackgroundType_Gray25 BackgroundType = 4 

// Represents 50% gray pattern.
BackgroundType_Gray50 BackgroundType = 2 

// Represents 75% gray pattern.
BackgroundType_Gray75 BackgroundType = 3 

// Represents horizontal stripe pattern.
BackgroundType_HorizontalStripe BackgroundType = 5 

// Represents no background.
BackgroundType_None BackgroundType = 0 

// Represents reverse diagonal stripe pattern.
BackgroundType_ReverseDiagonalStripe BackgroundType = 7 

// Represents solid pattern.
BackgroundType_Solid BackgroundType = 1 

// Represents thick diagonal crosshatch pattern.
BackgroundType_ThickDiagonalCrosshatch BackgroundType = 10 

// Represents thin diagonal crosshatch pattern.
BackgroundType_ThinDiagonalCrosshatch BackgroundType = 16 

// Represents thin diagonal stripe pattern.
BackgroundType_ThinDiagonalStripe BackgroundType = 14 

// Represents thin horizontal crosshatch pattern.
BackgroundType_ThinHorizontalCrosshatch BackgroundType = 15 

// Represents thin horizontal stripe pattern.
BackgroundType_ThinHorizontalStripe BackgroundType = 11 

// Represents thin reverse diagonal stripe pattern.
BackgroundType_ThinReverseDiagonalStripe BackgroundType = 13 

// Represents thin vertical stripe pattern.
BackgroundType_ThinVerticalStripe BackgroundType = 12 

// Represents vertical stripe pattern.
BackgroundType_VerticalStripe BackgroundType = 6 
)

func Int32ToBackgroundType(value int32)(BackgroundType ,error){
	switch value {
		case 9:  return BackgroundType_DiagonalCrosshatch, nil  
		case 8:  return BackgroundType_DiagonalStripe, nil  
		case 18:  return BackgroundType_Gray6, nil  
		case 17:  return BackgroundType_Gray12, nil  
		case 4:  return BackgroundType_Gray25, nil  
		case 2:  return BackgroundType_Gray50, nil  
		case 3:  return BackgroundType_Gray75, nil  
		case 5:  return BackgroundType_HorizontalStripe, nil  
		case 0:  return BackgroundType_None, nil  
		case 7:  return BackgroundType_ReverseDiagonalStripe, nil  
		case 1:  return BackgroundType_Solid, nil  
		case 10:  return BackgroundType_ThickDiagonalCrosshatch, nil  
		case 16:  return BackgroundType_ThinDiagonalCrosshatch, nil  
		case 14:  return BackgroundType_ThinDiagonalStripe, nil  
		case 15:  return BackgroundType_ThinHorizontalCrosshatch, nil  
		case 11:  return BackgroundType_ThinHorizontalStripe, nil  
		case 13:  return BackgroundType_ThinReverseDiagonalStripe, nil  
		case 12:  return BackgroundType_ThinVerticalStripe, nil  
		case 6:  return BackgroundType_VerticalStripe, nil  
		default:
			return 0 ,fmt.Errorf("invalid BackgroundType value: %d", value)
	}
}

/**************Enum BorderType *****************/

// Enumerates the border line and diagonal line types.
type BorderType int32

const(
// Represents left border line.
BorderType_LeftBorder BorderType = 1 

// Represents right border line exists.
BorderType_RightBorder BorderType = 2 

// Represents top border line.
BorderType_TopBorder BorderType = 4 

// Represents bottom border line.
BorderType_BottomBorder BorderType = 8 

// Represents the diagonal line from top left to right bottom.
BorderType_DiagonalDown BorderType = 16 

// Represents the diagonal line from bottom left to right top.
BorderType_DiagonalUp BorderType = 32 

// Only for dynamic style, such as conditional formatting.
BorderType_Vertical BorderType = 64 

// Only for dynamic style, such as conditional formatting.
BorderType_Horizontal BorderType = 128 

// Indicates the four side borders: <see cref="LeftBorder"/>,
// <see cref="RightBorder"/>, <see cref="TopBorder"/> and <see cref="BottomBorder"/>.
BorderType_SideBorders BorderType = 15 

// Special combination of multiple borders for user's convenience for some APIs.
// Indicates diagonal borders of <see cref="DiagonalUp"/> and <see cref="DiagonalDown"/>.
BorderType_Diagonal BorderType = 48 

// Indicates <see cref="Vertical"/> and <see cref="Horizontal"/> of dynamic style.
BorderType_DynamicStyleBorders BorderType = 192 

// No border has been specified.
BorderType_None BorderType = 0 
)

func Int32ToBorderType(value int32)(BorderType ,error){
	switch value {
		case 1:  return BorderType_LeftBorder, nil  
		case 2:  return BorderType_RightBorder, nil  
		case 4:  return BorderType_TopBorder, nil  
		case 8:  return BorderType_BottomBorder, nil  
		case 16:  return BorderType_DiagonalDown, nil  
		case 32:  return BorderType_DiagonalUp, nil  
		case 64:  return BorderType_Vertical, nil  
		case 128:  return BorderType_Horizontal, nil  
		case 15:  return BorderType_SideBorders, nil  
		case 48:  return BorderType_Diagonal, nil  
		case 192:  return BorderType_DynamicStyleBorders, nil  
		case 0:  return BorderType_None, nil  
		default:
			return 0 ,fmt.Errorf("invalid BorderType value: %d", value)
	}
}

/**************Enum BuiltinStyleType *****************/

// Represents all built-in style types.
type BuiltinStyleType int32

const(
BuiltinStyleType_TwentyPercentAccent1 BuiltinStyleType = 30 


BuiltinStyleType_TwentyPercentAccent2 BuiltinStyleType = 34 


BuiltinStyleType_TwentyPercentAccent3 BuiltinStyleType = 38 


BuiltinStyleType_TwentyPercentAccent4 BuiltinStyleType = 42 


BuiltinStyleType_TwentyPercentAccent5 BuiltinStyleType = 46 


BuiltinStyleType_TwentyPercentAccent6 BuiltinStyleType = 50 


BuiltinStyleType_FortyPercentAccent1 BuiltinStyleType = 31 


BuiltinStyleType_FortyPercentAccent2 BuiltinStyleType = 35 


BuiltinStyleType_FortyPercentAccent3 BuiltinStyleType = 39 


BuiltinStyleType_FortyPercentAccent4 BuiltinStyleType = 43 


BuiltinStyleType_FortyPercentAccent5 BuiltinStyleType = 47 


BuiltinStyleType_FortyPercentAccent6 BuiltinStyleType = 51 


BuiltinStyleType_SixtyPercentAccent1 BuiltinStyleType = 32 


BuiltinStyleType_SixtyPercentAccent2 BuiltinStyleType = 36 


BuiltinStyleType_SixtyPercentAccent3 BuiltinStyleType = 40 


BuiltinStyleType_SixtyPercentAccent4 BuiltinStyleType = 44 


BuiltinStyleType_SixtyPercentAccent5 BuiltinStyleType = 48 


BuiltinStyleType_SixtyPercentAccent6 BuiltinStyleType = 52 


BuiltinStyleType_Accent1 BuiltinStyleType = 29 


BuiltinStyleType_Accent2 BuiltinStyleType = 33 


BuiltinStyleType_Accent3 BuiltinStyleType = 37 


BuiltinStyleType_Accent4 BuiltinStyleType = 41 


BuiltinStyleType_Accent5 BuiltinStyleType = 45 


BuiltinStyleType_Accent6 BuiltinStyleType = 49 


BuiltinStyleType_Bad BuiltinStyleType = 27 


BuiltinStyleType_Calculation BuiltinStyleType = 22 


BuiltinStyleType_CheckCell BuiltinStyleType = 23 


BuiltinStyleType_Comma BuiltinStyleType = 3 


BuiltinStyleType_Comma1 BuiltinStyleType = 6 


BuiltinStyleType_Currency BuiltinStyleType = 4 


BuiltinStyleType_Currency1 BuiltinStyleType = 7 


BuiltinStyleType_ExplanatoryText BuiltinStyleType = 53 


BuiltinStyleType_Good BuiltinStyleType = 26 


BuiltinStyleType_Header1 BuiltinStyleType = 16 


BuiltinStyleType_Header2 BuiltinStyleType = 17 


BuiltinStyleType_Header3 BuiltinStyleType = 18 


BuiltinStyleType_Header4 BuiltinStyleType = 19 


BuiltinStyleType_Hyperlink BuiltinStyleType = 8 


BuiltinStyleType_FollowedHyperlink BuiltinStyleType = 9 


BuiltinStyleType_Input BuiltinStyleType = 20 


BuiltinStyleType_LinkedCell BuiltinStyleType = 24 


BuiltinStyleType_Neutral BuiltinStyleType = 28 


BuiltinStyleType_Normal BuiltinStyleType = 0 


BuiltinStyleType_Note BuiltinStyleType = 10 


BuiltinStyleType_Output BuiltinStyleType = 21 


BuiltinStyleType_Percent BuiltinStyleType = 5 


BuiltinStyleType_Title BuiltinStyleType = 15 


BuiltinStyleType_Total BuiltinStyleType = 25 


BuiltinStyleType_WarningText BuiltinStyleType = 11 


BuiltinStyleType_RowLevel BuiltinStyleType = 1 


BuiltinStyleType_ColumnLevel BuiltinStyleType = 2 
)

func Int32ToBuiltinStyleType(value int32)(BuiltinStyleType ,error){
	switch value {
		case 30:  return BuiltinStyleType_TwentyPercentAccent1, nil  
		case 34:  return BuiltinStyleType_TwentyPercentAccent2, nil  
		case 38:  return BuiltinStyleType_TwentyPercentAccent3, nil  
		case 42:  return BuiltinStyleType_TwentyPercentAccent4, nil  
		case 46:  return BuiltinStyleType_TwentyPercentAccent5, nil  
		case 50:  return BuiltinStyleType_TwentyPercentAccent6, nil  
		case 31:  return BuiltinStyleType_FortyPercentAccent1, nil  
		case 35:  return BuiltinStyleType_FortyPercentAccent2, nil  
		case 39:  return BuiltinStyleType_FortyPercentAccent3, nil  
		case 43:  return BuiltinStyleType_FortyPercentAccent4, nil  
		case 47:  return BuiltinStyleType_FortyPercentAccent5, nil  
		case 51:  return BuiltinStyleType_FortyPercentAccent6, nil  
		case 32:  return BuiltinStyleType_SixtyPercentAccent1, nil  
		case 36:  return BuiltinStyleType_SixtyPercentAccent2, nil  
		case 40:  return BuiltinStyleType_SixtyPercentAccent3, nil  
		case 44:  return BuiltinStyleType_SixtyPercentAccent4, nil  
		case 48:  return BuiltinStyleType_SixtyPercentAccent5, nil  
		case 52:  return BuiltinStyleType_SixtyPercentAccent6, nil  
		case 29:  return BuiltinStyleType_Accent1, nil  
		case 33:  return BuiltinStyleType_Accent2, nil  
		case 37:  return BuiltinStyleType_Accent3, nil  
		case 41:  return BuiltinStyleType_Accent4, nil  
		case 45:  return BuiltinStyleType_Accent5, nil  
		case 49:  return BuiltinStyleType_Accent6, nil  
		case 27:  return BuiltinStyleType_Bad, nil  
		case 22:  return BuiltinStyleType_Calculation, nil  
		case 23:  return BuiltinStyleType_CheckCell, nil  
		case 3:  return BuiltinStyleType_Comma, nil  
		case 6:  return BuiltinStyleType_Comma1, nil  
		case 4:  return BuiltinStyleType_Currency, nil  
		case 7:  return BuiltinStyleType_Currency1, nil  
		case 53:  return BuiltinStyleType_ExplanatoryText, nil  
		case 26:  return BuiltinStyleType_Good, nil  
		case 16:  return BuiltinStyleType_Header1, nil  
		case 17:  return BuiltinStyleType_Header2, nil  
		case 18:  return BuiltinStyleType_Header3, nil  
		case 19:  return BuiltinStyleType_Header4, nil  
		case 8:  return BuiltinStyleType_Hyperlink, nil  
		case 9:  return BuiltinStyleType_FollowedHyperlink, nil  
		case 20:  return BuiltinStyleType_Input, nil  
		case 24:  return BuiltinStyleType_LinkedCell, nil  
		case 28:  return BuiltinStyleType_Neutral, nil  
		case 0:  return BuiltinStyleType_Normal, nil  
		case 10:  return BuiltinStyleType_Note, nil  
		case 21:  return BuiltinStyleType_Output, nil  
		case 5:  return BuiltinStyleType_Percent, nil  
		case 15:  return BuiltinStyleType_Title, nil  
		case 25:  return BuiltinStyleType_Total, nil  
		case 11:  return BuiltinStyleType_WarningText, nil  
		case 1:  return BuiltinStyleType_RowLevel, nil  
		case 2:  return BuiltinStyleType_ColumnLevel, nil  
		default:
			return 0 ,fmt.Errorf("invalid BuiltinStyleType value: %d", value)
	}
}

/**************Enum CalcModeType *****************/

// Represents the mode type of calculating formulas.
type CalcModeType int32

const(
CalcModeType_Automatic CalcModeType = 0 


CalcModeType_AutomaticExceptTable CalcModeType = 1 


CalcModeType_Manual CalcModeType = 2 
)

func Int32ToCalcModeType(value int32)(CalcModeType ,error){
	switch value {
		case 0:  return CalcModeType_Automatic, nil  
		case 1:  return CalcModeType_AutomaticExceptTable, nil  
		case 2:  return CalcModeType_Manual, nil  
		default:
			return 0 ,fmt.Errorf("invalid CalcModeType value: %d", value)
	}
}

/**************Enum CalculationPrecisionStrategy *****************/

// Enumerates strategies for handling calculation precision.
// Because of the precision issue of IEEE 754 Floating-Point Arithmetic, some "seemingly simple" formulas may not be calculated as the expected result.
// Such as formula "=-0.45+0.43+0.02", when calculating operands by '+' operator directly, the result is not zero. For such kind of precision issue,
// some special strategies may give the expected result.
type CalculationPrecisionStrategy int32

const(
// No strategy applied on calculation.
// When calculating just use the original double value as operand and return the result directly.
// Most efficient for performance and applicable for most cases.
CalculationPrecisionStrategy_None CalculationPrecisionStrategy = 0 

// Rounds the calculation result according with significant digits.
CalculationPrecisionStrategy_Round CalculationPrecisionStrategy = 1 

// Uses decimal as operands when possible.
// Most inefficient for performance.
CalculationPrecisionStrategy_Decimal CalculationPrecisionStrategy = 2 
)

func Int32ToCalculationPrecisionStrategy(value int32)(CalculationPrecisionStrategy ,error){
	switch value {
		case 0:  return CalculationPrecisionStrategy_None, nil  
		case 1:  return CalculationPrecisionStrategy_Round, nil  
		case 2:  return CalculationPrecisionStrategy_Decimal, nil  
		default:
			return 0 ,fmt.Errorf("invalid CalculationPrecisionStrategy value: %d", value)
	}
}

/**************Enum CellBorderType *****************/

// Enumerates a cell's border type.
type CellBorderType int32

const(
// Represents thin dash-dotted line.
CellBorderType_DashDot CellBorderType = 9 

// Represents thin dash-dot-dotted line.
CellBorderType_DashDotDot CellBorderType = 11 

// Represents dashed line.
CellBorderType_Dashed CellBorderType = 3 

// Represents dotted line.
CellBorderType_Dotted CellBorderType = 4 

// Represents double line.
CellBorderType_Double CellBorderType = 6 

// Represents hair line.
CellBorderType_Hair CellBorderType = 7 

// Represents medium dash-dotted line.
CellBorderType_MediumDashDot CellBorderType = 10 

// Represents medium dash-dot-dotted line.
CellBorderType_MediumDashDotDot CellBorderType = 12 

// Represents medium dashed line.
CellBorderType_MediumDashed CellBorderType = 8 

// Represents no line.
CellBorderType_None CellBorderType = 0 

// Represents medium line.
CellBorderType_Medium CellBorderType = 2 

// Represents slanted medium dash-dotted line.
CellBorderType_SlantedDashDot CellBorderType = 13 

// Represents thick line.
CellBorderType_Thick CellBorderType = 5 

// Represents thin line.
CellBorderType_Thin CellBorderType = 1 
)

func Int32ToCellBorderType(value int32)(CellBorderType ,error){
	switch value {
		case 9:  return CellBorderType_DashDot, nil  
		case 11:  return CellBorderType_DashDotDot, nil  
		case 3:  return CellBorderType_Dashed, nil  
		case 4:  return CellBorderType_Dotted, nil  
		case 6:  return CellBorderType_Double, nil  
		case 7:  return CellBorderType_Hair, nil  
		case 10:  return CellBorderType_MediumDashDot, nil  
		case 12:  return CellBorderType_MediumDashDotDot, nil  
		case 8:  return CellBorderType_MediumDashed, nil  
		case 0:  return CellBorderType_None, nil  
		case 2:  return CellBorderType_Medium, nil  
		case 13:  return CellBorderType_SlantedDashDot, nil  
		case 5:  return CellBorderType_Thick, nil  
		case 1:  return CellBorderType_Thin, nil  
		default:
			return 0 ,fmt.Errorf("invalid CellBorderType value: %d", value)
	}
}

/**************Enum CellsUnitType *****************/

// Specifies the unit of measurement.
type CellsUnitType int32

const(
// Measurement is in pixels.
CellsUnitType_Pixel CellsUnitType = 1 

// Measurement is in points. A point represents 1/72 of an inch.
CellsUnitType_Point CellsUnitType = 2 

// Measurement is in inches.
CellsUnitType_Inch CellsUnitType = 4 

// Measurement is in centimeters.
CellsUnitType_Cm CellsUnitType = 6 

// In unit of characters.
CellsUnitType_Character CellsUnitType = 7 
)

func Int32ToCellsUnitType(value int32)(CellsUnitType ,error){
	switch value {
		case 1:  return CellsUnitType_Pixel, nil  
		case 2:  return CellsUnitType_Point, nil  
		case 4:  return CellsUnitType_Inch, nil  
		case 6:  return CellsUnitType_Cm, nil  
		case 7:  return CellsUnitType_Character, nil  
		default:
			return 0 ,fmt.Errorf("invalid CellsUnitType value: %d", value)
	}
}

/**************Enum CellValueFormatStrategy *****************/

// Specifies how to apply style for the value of the cell.
type CellValueFormatStrategy int32

const(
// Not formatted.
CellValueFormatStrategy_None CellValueFormatStrategy = 0 

// Only formatted with the cell's original style.
CellValueFormatStrategy_CellStyle CellValueFormatStrategy = 1 

// Formatted with the cell's displayed style.
CellValueFormatStrategy_DisplayStyle CellValueFormatStrategy = 2 

// Gets the displayed string shown in ms excel.
// The main difference from <see cref="DisplayStyle"/> is this option also considers the effect of column width.
// If the column width is too small to show the formatted string completely,
// "#" may be shown, just like what ms excel does.
CellValueFormatStrategy_DisplayString CellValueFormatStrategy = 3 
)

func Int32ToCellValueFormatStrategy(value int32)(CellValueFormatStrategy ,error){
	switch value {
		case 0:  return CellValueFormatStrategy_None, nil  
		case 1:  return CellValueFormatStrategy_CellStyle, nil  
		case 2:  return CellValueFormatStrategy_DisplayStyle, nil  
		case 3:  return CellValueFormatStrategy_DisplayString, nil  
		default:
			return 0 ,fmt.Errorf("invalid CellValueFormatStrategy value: %d", value)
	}
}

/**************Enum CellValueType *****************/

// Specifies a cell value type.
type CellValueType int32

const(
// Cell value type is unknown.
CellValueType_IsUnknown CellValueType = 0 

// Blank cell. Corresponding value should be null.
CellValueType_IsNull CellValueType = 1 

// Cell value is numeric. Corresponding value must be int or double.
CellValueType_IsNumeric CellValueType = 2 

// Cell value is datetime. Corresponding value must be DateTime.
CellValueType_IsDateTime CellValueType = 4 

// Cell value is string. Corresponding value must be string.
CellValueType_IsString CellValueType = 8 

// Cell value is boolean. Corresponding value must be bool.
CellValueType_IsBool CellValueType = 16 

// Cell contains error value. Corresponding value must be error string.
CellValueType_IsError CellValueType = 32 
)

func Int32ToCellValueType(value int32)(CellValueType ,error){
	switch value {
		case 0:  return CellValueType_IsUnknown, nil  
		case 1:  return CellValueType_IsNull, nil  
		case 2:  return CellValueType_IsNumeric, nil  
		case 4:  return CellValueType_IsDateTime, nil  
		case 8:  return CellValueType_IsString, nil  
		case 16:  return CellValueType_IsBool, nil  
		case 32:  return CellValueType_IsError, nil  
		default:
			return 0 ,fmt.Errorf("invalid CellValueType value: %d", value)
	}
}

/**************Enum ColorType *****************/

// Represents all color type
type ColorType int32

const(
// Automatic color.
ColorType_Automatic ColorType = 0 

// It's automatic color,but the displayed color depends the setting of the OS System.
ColorType_AutomaticIndex ColorType = 1 

// The RGB color.
ColorType_RGB ColorType = 2 

// The color index in the color palette.
ColorType_IndexedColor ColorType = 3 

// The theme color.
ColorType_Theme ColorType = 4 
)

func Int32ToColorType(value int32)(ColorType ,error){
	switch value {
		case 0:  return ColorType_Automatic, nil  
		case 1:  return ColorType_AutomaticIndex, nil  
		case 2:  return ColorType_RGB, nil  
		case 3:  return ColorType_IndexedColor, nil  
		case 4:  return ColorType_Theme, nil  
		default:
			return 0 ,fmt.Errorf("invalid ColorType value: %d", value)
	}
}

/**************Enum ConsolidationFunction *****************/

// Represents consolidation function.
type ConsolidationFunction int32

const(
// Represents Sum function.
ConsolidationFunction_Sum ConsolidationFunction = 0 

// Represents Count function.
ConsolidationFunction_Count ConsolidationFunction = 1 

// Represents Average function.
ConsolidationFunction_Average ConsolidationFunction = 2 

// Represents Max function.
ConsolidationFunction_Max ConsolidationFunction = 3 

// Represents Min function.
ConsolidationFunction_Min ConsolidationFunction = 4 

// Represents Product function.
ConsolidationFunction_Product ConsolidationFunction = 5 

// Represents Count Nums function.
ConsolidationFunction_CountNums ConsolidationFunction = 6 

// Represents StdDev function.
ConsolidationFunction_StdDev ConsolidationFunction = 7 

// Represents StdDevp function.
ConsolidationFunction_StdDevp ConsolidationFunction = 8 

// Represents Var function.
ConsolidationFunction_Var ConsolidationFunction = 9 

// Represents Varp function.
ConsolidationFunction_Varp ConsolidationFunction = 10 

// Represents Distinct Count function.
ConsolidationFunction_DistinctCount ConsolidationFunction = 11 
)

func Int32ToConsolidationFunction(value int32)(ConsolidationFunction ,error){
	switch value {
		case 0:  return ConsolidationFunction_Sum, nil  
		case 1:  return ConsolidationFunction_Count, nil  
		case 2:  return ConsolidationFunction_Average, nil  
		case 3:  return ConsolidationFunction_Max, nil  
		case 4:  return ConsolidationFunction_Min, nil  
		case 5:  return ConsolidationFunction_Product, nil  
		case 6:  return ConsolidationFunction_CountNums, nil  
		case 7:  return ConsolidationFunction_StdDev, nil  
		case 8:  return ConsolidationFunction_StdDevp, nil  
		case 9:  return ConsolidationFunction_Var, nil  
		case 10:  return ConsolidationFunction_Varp, nil  
		case 11:  return ConsolidationFunction_DistinctCount, nil  
		default:
			return 0 ,fmt.Errorf("invalid ConsolidationFunction value: %d", value)
	}
}

/**************Enum ContentDisposition *****************/

// The content disposition type.
type ContentDisposition int32

const(
ContentDisposition_Inline ContentDisposition = 0 


ContentDisposition_Attachment ContentDisposition = 1 
)

func Int32ToContentDisposition(value int32)(ContentDisposition ,error){
	switch value {
		case 0:  return ContentDisposition_Inline, nil  
		case 1:  return ContentDisposition_Attachment, nil  
		default:
			return 0 ,fmt.Errorf("invalid ContentDisposition value: %d", value)
	}
}

/**************Enum CopyFormatType *****************/

// Represents type of copying format when inserting rows.
type CopyFormatType int32

const(
// Formats same as above row.
CopyFormatType_SameAsAbove CopyFormatType = 0 

// Formats same as below row.
CopyFormatType_SameAsBelow CopyFormatType = 1 

// Clears formatting.
CopyFormatType_Clear CopyFormatType = 2 
)

func Int32ToCopyFormatType(value int32)(CopyFormatType ,error){
	switch value {
		case 0:  return CopyFormatType_SameAsAbove, nil  
		case 1:  return CopyFormatType_SameAsBelow, nil  
		case 2:  return CopyFormatType_Clear, nil  
		default:
			return 0 ,fmt.Errorf("invalid CopyFormatType value: %d", value)
	}
}

/**************Enum CountryCode *****************/

// Represents Excel country identifiers.
type CountryCode int32

const(
CountryCode_Default CountryCode = 0 

// United States
CountryCode_USA CountryCode = 1 

// Canada
CountryCode_Canada CountryCode = 2 

// Latin America, except Brazil
CountryCode_LatinAmeric CountryCode = 3 

// Russia
CountryCode_Russia CountryCode = 7 

// Egypt
CountryCode_Egypt CountryCode = 20 

// Greece
CountryCode_Greece CountryCode = 30 

// Netherlands
CountryCode_Netherlands CountryCode = 31 

// Belgium
CountryCode_Belgium CountryCode = 32 

// France
CountryCode_France CountryCode = 33 

// Spain
CountryCode_Spain CountryCode = 34 

// Hungary
CountryCode_Hungary CountryCode = 36 

// Italy
CountryCode_Italy CountryCode = 39 

// Switzerland
CountryCode_Switzerland CountryCode = 41 

// Austria
CountryCode_Austria CountryCode = 43 

// United Kingdom
CountryCode_UnitedKingdom CountryCode = 44 

// Denmark
CountryCode_Denmark CountryCode = 45 

// Sweden
CountryCode_Sweden CountryCode = 46 

// Norway
CountryCode_Norway CountryCode = 47 

// Poland
CountryCode_Poland CountryCode = 48 

// Germany
CountryCode_Germany CountryCode = 49 

// Mexico
CountryCode_Mexico CountryCode = 52 

// Brazil
CountryCode_Brazil CountryCode = 55 

// Australia
CountryCode_Australia CountryCode = 61 

// New Zealand
CountryCode_NewZealand CountryCode = 64 

// Thailand
CountryCode_Thailand CountryCode = 66 

// Japan
CountryCode_Japan CountryCode = 81 

// SouthKorea
CountryCode_SouthKorea CountryCode = 82 

// Viet Nam
CountryCode_VietNam CountryCode = 84 

// People's Republic of China
CountryCode_China CountryCode = 86 

// Turkey
CountryCode_Turkey CountryCode = 90 

// India
CountryCode_India CountryCode = 91 

// Algeria
CountryCode_Algeria CountryCode = 213 

// Morocco
CountryCode_Morocco CountryCode = 216 

// Libya
CountryCode_Libya CountryCode = 218 

// Portugal
CountryCode_Portugal CountryCode = 351 

// Iceland
CountryCode_Iceland CountryCode = 354 

// Finland
CountryCode_Finland CountryCode = 358 

// Czech Republic
CountryCode_Czech CountryCode = 420 

// Taiwan
CountryCode_Taiwan CountryCode = 886 

// Lebanon
CountryCode_Lebanon CountryCode = 961 

// Jordan
CountryCode_Jordan CountryCode = 962 

// Syria
CountryCode_Syria CountryCode = 963 

// Iraq
CountryCode_Iraq CountryCode = 964 

// Kuwait
CountryCode_Kuwait CountryCode = 965 

// Saudi Arabia
CountryCode_Saudi CountryCode = 966 

// United Arab Emirates
CountryCode_UnitedArabEmirates CountryCode = 971 

// Israel
CountryCode_Israel CountryCode = 972 

// Qatar
CountryCode_Qatar CountryCode = 974 

// Iran
CountryCode_Iran CountryCode = 981 
)

func Int32ToCountryCode(value int32)(CountryCode ,error){
	switch value {
		case 0:  return CountryCode_Default, nil  
		case 1:  return CountryCode_USA, nil  
		case 2:  return CountryCode_Canada, nil  
		case 3:  return CountryCode_LatinAmeric, nil  
		case 7:  return CountryCode_Russia, nil  
		case 20:  return CountryCode_Egypt, nil  
		case 30:  return CountryCode_Greece, nil  
		case 31:  return CountryCode_Netherlands, nil  
		case 32:  return CountryCode_Belgium, nil  
		case 33:  return CountryCode_France, nil  
		case 34:  return CountryCode_Spain, nil  
		case 36:  return CountryCode_Hungary, nil  
		case 39:  return CountryCode_Italy, nil  
		case 41:  return CountryCode_Switzerland, nil  
		case 43:  return CountryCode_Austria, nil  
		case 44:  return CountryCode_UnitedKingdom, nil  
		case 45:  return CountryCode_Denmark, nil  
		case 46:  return CountryCode_Sweden, nil  
		case 47:  return CountryCode_Norway, nil  
		case 48:  return CountryCode_Poland, nil  
		case 49:  return CountryCode_Germany, nil  
		case 52:  return CountryCode_Mexico, nil  
		case 55:  return CountryCode_Brazil, nil  
		case 61:  return CountryCode_Australia, nil  
		case 64:  return CountryCode_NewZealand, nil  
		case 66:  return CountryCode_Thailand, nil  
		case 81:  return CountryCode_Japan, nil  
		case 82:  return CountryCode_SouthKorea, nil  
		case 84:  return CountryCode_VietNam, nil  
		case 86:  return CountryCode_China, nil  
		case 90:  return CountryCode_Turkey, nil  
		case 91:  return CountryCode_India, nil  
		case 213:  return CountryCode_Algeria, nil  
		case 216:  return CountryCode_Morocco, nil  
		case 218:  return CountryCode_Libya, nil  
		case 351:  return CountryCode_Portugal, nil  
		case 354:  return CountryCode_Iceland, nil  
		case 358:  return CountryCode_Finland, nil  
		case 420:  return CountryCode_Czech, nil  
		case 886:  return CountryCode_Taiwan, nil  
		case 961:  return CountryCode_Lebanon, nil  
		case 962:  return CountryCode_Jordan, nil  
		case 963:  return CountryCode_Syria, nil  
		case 964:  return CountryCode_Iraq, nil  
		case 965:  return CountryCode_Kuwait, nil  
		case 966:  return CountryCode_Saudi, nil  
		case 971:  return CountryCode_UnitedArabEmirates, nil  
		case 972:  return CountryCode_Israel, nil  
		case 974:  return CountryCode_Qatar, nil  
		case 981:  return CountryCode_Iran, nil  
		default:
			return 0 ,fmt.Errorf("invalid CountryCode value: %d", value)
	}
}

/**************Enum DataBarAxisPosition *****************/

// Specifies the axis position for a range of cells with conditional formatting as data bars.
type DataBarAxisPosition int32

const(
// Display the axis at a variable position based on the ratio of the minimum negative value to the maximum positive value in the range.
// Positive values are displayed in a left-to-right direction.
// Negative values are displayed in a right-to-left direction.
// When all values are positive or all values are negative, no axis is displayed.
DataBarAxisPosition_Automatic DataBarAxisPosition = 0 

// Display the axis at the midpoint of the cell regardless of the set of values in the range.
// Positive values are displayed in a left-to-right direction.
// Negative values are displayed in a right-to-left direction.
DataBarAxisPosition_Midpoint DataBarAxisPosition = 1 

// No axis is displayed, and both positive and negative values are displayed in the left-to-right direction.
DataBarAxisPosition_None DataBarAxisPosition = 2 
)

func Int32ToDataBarAxisPosition(value int32)(DataBarAxisPosition ,error){
	switch value {
		case 0:  return DataBarAxisPosition_Automatic, nil  
		case 1:  return DataBarAxisPosition_Midpoint, nil  
		case 2:  return DataBarAxisPosition_None, nil  
		default:
			return 0 ,fmt.Errorf("invalid DataBarAxisPosition value: %d", value)
	}
}

/**************Enum DataBarBorderType *****************/

// Specifies the border type of a data bar.
type DataBarBorderType int32

const(
// The data bar has no border.
DataBarBorderType_None DataBarBorderType = 0 

// The data bar has a solid border.
DataBarBorderType_Solid DataBarBorderType = 1 
)

func Int32ToDataBarBorderType(value int32)(DataBarBorderType ,error){
	switch value {
		case 0:  return DataBarBorderType_None, nil  
		case 1:  return DataBarBorderType_Solid, nil  
		default:
			return 0 ,fmt.Errorf("invalid DataBarBorderType value: %d", value)
	}
}

/**************Enum DataBarFillType *****************/

// Specifies how a data bar is filled with color.
type DataBarFillType int32

const(
// The data bar is filled with solid color.
DataBarFillType_Solid DataBarFillType = 0 

// The data bar is filled with a color gradient.
DataBarFillType_Gradient DataBarFillType = 1 
)

func Int32ToDataBarFillType(value int32)(DataBarFillType ,error){
	switch value {
		case 0:  return DataBarFillType_Solid, nil  
		case 1:  return DataBarFillType_Gradient, nil  
		default:
			return 0 ,fmt.Errorf("invalid DataBarFillType value: %d", value)
	}
}

/**************Enum DataBarNegativeColorType *****************/

// Specifies whether to use the same border and fill color as positive data bars.
type DataBarNegativeColorType int32

const(
// Use the color specified in the Negative Value and Axis Setting dialog box
// or by using the ColorType and BorderColorType properties of the NegativeBarFormat object.
DataBarNegativeColorType_Color DataBarNegativeColorType = 0 

// Use the same color as positive data bars.
DataBarNegativeColorType_SameAsPositive DataBarNegativeColorType = 1 
)

func Int32ToDataBarNegativeColorType(value int32)(DataBarNegativeColorType ,error){
	switch value {
		case 0:  return DataBarNegativeColorType_Color, nil  
		case 1:  return DataBarNegativeColorType_SameAsPositive, nil  
		default:
			return 0 ,fmt.Errorf("invalid DataBarNegativeColorType value: %d", value)
	}
}

/**************Enum DateTimeGroupingType *****************/

// Specifies how to group dateTime values.
type DateTimeGroupingType int32

const(
// Group by day.
DateTimeGroupingType_Day DateTimeGroupingType = 0 

// Group by hour.
DateTimeGroupingType_Hour DateTimeGroupingType = 1 

// Group by Minute.
DateTimeGroupingType_Minute DateTimeGroupingType = 2 

// Group by Month.
DateTimeGroupingType_Month DateTimeGroupingType = 3 

// Group by Second.
DateTimeGroupingType_Second DateTimeGroupingType = 4 

// Group by Year.
DateTimeGroupingType_Year DateTimeGroupingType = 5 
)

func Int32ToDateTimeGroupingType(value int32)(DateTimeGroupingType ,error){
	switch value {
		case 0:  return DateTimeGroupingType_Day, nil  
		case 1:  return DateTimeGroupingType_Hour, nil  
		case 2:  return DateTimeGroupingType_Minute, nil  
		case 3:  return DateTimeGroupingType_Month, nil  
		case 4:  return DateTimeGroupingType_Second, nil  
		case 5:  return DateTimeGroupingType_Year, nil  
		default:
			return 0 ,fmt.Errorf("invalid DateTimeGroupingType value: %d", value)
	}
}

/**************Enum DefaultEditLanguage *****************/

// Represents the default edit language.
type DefaultEditLanguage int32

const(
// Represents auto detecting edit language according to the text itself.
DefaultEditLanguage_Auto DefaultEditLanguage = 0 

// Represents English language.
DefaultEditLanguage_English DefaultEditLanguage = 1 

// Represents Chinese, Japanese, Korean language.
DefaultEditLanguage_CJK DefaultEditLanguage = 2 
)

func Int32ToDefaultEditLanguage(value int32)(DefaultEditLanguage ,error){
	switch value {
		case 0:  return DefaultEditLanguage_Auto, nil  
		case 1:  return DefaultEditLanguage_English, nil  
		case 2:  return DefaultEditLanguage_CJK, nil  
		default:
			return 0 ,fmt.Errorf("invalid DefaultEditLanguage value: %d", value)
	}
}

/**************Enum DirectoryType *****************/

// Represents the directory  type of the file name.
type DirectoryType int32

const(
// Represents an MS-DOS drive letter. It is followed by the drive letter.
// Or UNC file names, such as \\server\share\myfile.xls
DirectoryType_Volume DirectoryType = 0 

// Indicates that the source workbook is on the same drive as the dependent workbook (the drive letter is omitted)
DirectoryType_SameVolume DirectoryType = 1 

// Indicates that the source workbook is in a subdirectory of the current directory.
DirectoryType_DownDirectory DirectoryType = 2 

// Indicates that the source workbook is in the parent directory of the current directory.
DirectoryType_UpDirectory DirectoryType = 3 
)

func Int32ToDirectoryType(value int32)(DirectoryType ,error){
	switch value {
		case 0:  return DirectoryType_Volume, nil  
		case 1:  return DirectoryType_SameVolume, nil  
		case 2:  return DirectoryType_DownDirectory, nil  
		case 3:  return DirectoryType_UpDirectory, nil  
		default:
			return 0 ,fmt.Errorf("invalid DirectoryType value: %d", value)
	}
}

/**************Enum DisplayDrawingObjects *****************/

// Represents whether and how to show objects in the workbook.
type DisplayDrawingObjects int32

const(
// Show all objects
DisplayDrawingObjects_DisplayShapes DisplayDrawingObjects = 0 

// Show placeholders
DisplayDrawingObjects_Placeholders DisplayDrawingObjects = 1 

// Hide all shapes.
DisplayDrawingObjects_Hide DisplayDrawingObjects = 2 
)

func Int32ToDisplayDrawingObjects(value int32)(DisplayDrawingObjects ,error){
	switch value {
		case 0:  return DisplayDrawingObjects_DisplayShapes, nil  
		case 1:  return DisplayDrawingObjects_Placeholders, nil  
		case 2:  return DisplayDrawingObjects_Hide, nil  
		default:
			return 0 ,fmt.Errorf("invalid DisplayDrawingObjects value: %d", value)
	}
}

/**************Enum DynamicFilterType *****************/

// Dynamic filter type.
type DynamicFilterType int32

const(
// Shows values that are above average.
DynamicFilterType_AboveAverage DynamicFilterType = 0 

// Shows values that are below average.
DynamicFilterType_BelowAverage DynamicFilterType = 1 

// Shows last month's dates.
DynamicFilterType_LastMonth DynamicFilterType = 2 

// Shows last quarter's dates.
DynamicFilterType_LastQuarter DynamicFilterType = 3 

// Shows last week's dates.
DynamicFilterType_LastWeek DynamicFilterType = 4 

// Shows last year's dates.
DynamicFilterType_LastYear DynamicFilterType = 5 

// Shows the dates that are in January, regardless of year.
DynamicFilterType_January DynamicFilterType = 6 

// Shows the dates that are in October, regardless of year.
DynamicFilterType_October DynamicFilterType = 7 

// Shows the dates that are in November, regardless of year.
DynamicFilterType_November DynamicFilterType = 8 

// Shows the dates that are in December, regardless of year.
DynamicFilterType_December DynamicFilterType = 9 

// Shows the dates that are in February, regardless of year.
DynamicFilterType_February DynamicFilterType = 10 

// Shows the dates that are in March, regardless of year.
DynamicFilterType_March DynamicFilterType = 11 

// Shows the dates that are in April, regardless of year.
DynamicFilterType_April DynamicFilterType = 12 

// Shows the dates that are in May, regardless of year.
DynamicFilterType_May DynamicFilterType = 13 

// Shows the dates that are in June, regardless of year.
DynamicFilterType_June DynamicFilterType = 14 

// Shows the dates that are in July, regardless of year.
DynamicFilterType_July DynamicFilterType = 15 

// Shows the dates that are in August, regardless of year.
DynamicFilterType_August DynamicFilterType = 16 

// Shows the dates that are in September, regardless of year.
DynamicFilterType_September DynamicFilterType = 17 

// Shows next month's dates.
DynamicFilterType_NextMonth DynamicFilterType = 18 

// Shows next quarter's dates.
DynamicFilterType_NextQuarter DynamicFilterType = 19 

// Shows next week's dates.
DynamicFilterType_NextWeek DynamicFilterType = 20 

// Shows next year's dates.
DynamicFilterType_NextYear DynamicFilterType = 21 

// None.
DynamicFilterType_None DynamicFilterType = 22 

// Shows the dates that are in the 1st quarter, regardless of year.
DynamicFilterType_Quarter1 DynamicFilterType = 23 

// Shows the dates that are in the 2nd quarter, regardless of year.
DynamicFilterType_Quarter2 DynamicFilterType = 24 

// Shows the dates that are in the 3rd quarter, regardless of year.
DynamicFilterType_Quarter3 DynamicFilterType = 25 

// Shows the dates that are in the 4th quarter, regardless of year.
DynamicFilterType_Quarter4 DynamicFilterType = 26 

// Shows this month's dates.
DynamicFilterType_ThisMonth DynamicFilterType = 27 

// Shows this quarter's dates.
DynamicFilterType_ThisQuarter DynamicFilterType = 28 

// Shows this week's dates.
DynamicFilterType_ThisWeek DynamicFilterType = 29 

// Shows this year's dates.
DynamicFilterType_ThisYear DynamicFilterType = 30 

// Shows today's dates.
DynamicFilterType_Today DynamicFilterType = 31 

// Shows tomorrow's dates.
DynamicFilterType_Tomorrow DynamicFilterType = 32 

// Shows the dates between the beginning of the year and today, inclusive.
DynamicFilterType_YearToDate DynamicFilterType = 33 

// Shows yesterday's dates.
DynamicFilterType_Yesterday DynamicFilterType = 34 
)

func Int32ToDynamicFilterType(value int32)(DynamicFilterType ,error){
	switch value {
		case 0:  return DynamicFilterType_AboveAverage, nil  
		case 1:  return DynamicFilterType_BelowAverage, nil  
		case 2:  return DynamicFilterType_LastMonth, nil  
		case 3:  return DynamicFilterType_LastQuarter, nil  
		case 4:  return DynamicFilterType_LastWeek, nil  
		case 5:  return DynamicFilterType_LastYear, nil  
		case 6:  return DynamicFilterType_January, nil  
		case 7:  return DynamicFilterType_October, nil  
		case 8:  return DynamicFilterType_November, nil  
		case 9:  return DynamicFilterType_December, nil  
		case 10:  return DynamicFilterType_February, nil  
		case 11:  return DynamicFilterType_March, nil  
		case 12:  return DynamicFilterType_April, nil  
		case 13:  return DynamicFilterType_May, nil  
		case 14:  return DynamicFilterType_June, nil  
		case 15:  return DynamicFilterType_July, nil  
		case 16:  return DynamicFilterType_August, nil  
		case 17:  return DynamicFilterType_September, nil  
		case 18:  return DynamicFilterType_NextMonth, nil  
		case 19:  return DynamicFilterType_NextQuarter, nil  
		case 20:  return DynamicFilterType_NextWeek, nil  
		case 21:  return DynamicFilterType_NextYear, nil  
		case 22:  return DynamicFilterType_None, nil  
		case 23:  return DynamicFilterType_Quarter1, nil  
		case 24:  return DynamicFilterType_Quarter2, nil  
		case 25:  return DynamicFilterType_Quarter3, nil  
		case 26:  return DynamicFilterType_Quarter4, nil  
		case 27:  return DynamicFilterType_ThisMonth, nil  
		case 28:  return DynamicFilterType_ThisQuarter, nil  
		case 29:  return DynamicFilterType_ThisWeek, nil  
		case 30:  return DynamicFilterType_ThisYear, nil  
		case 31:  return DynamicFilterType_Today, nil  
		case 32:  return DynamicFilterType_Tomorrow, nil  
		case 33:  return DynamicFilterType_YearToDate, nil  
		case 34:  return DynamicFilterType_Yesterday, nil  
		default:
			return 0 ,fmt.Errorf("invalid DynamicFilterType value: %d", value)
	}
}

/**************Enum EmfRenderSetting *****************/

// Setting for rendering Emf metafile.
type EmfRenderSetting int32

const(
// Only rendering Emf records.
EmfRenderSetting_EmfOnly EmfRenderSetting = 0 

// Prefer rendering EmfPlus records.
EmfRenderSetting_EmfPlusPrefer EmfRenderSetting = 1 
)

func Int32ToEmfRenderSetting(value int32)(EmfRenderSetting ,error){
	switch value {
		case 0:  return EmfRenderSetting_EmfOnly, nil  
		case 1:  return EmfRenderSetting_EmfPlusPrefer, nil  
		default:
			return 0 ,fmt.Errorf("invalid EmfRenderSetting value: %d", value)
	}
}

/**************Enum EncodingType *****************/

// Enums supported encoding types.
type EncodingType int32

const(
// Default encoding type.
EncodingType_Default EncodingType = 0 

// ASCII encoding type.
EncodingType_ASCII EncodingType = 1 

// UTF8 encoding type.
EncodingType_UTF8 EncodingType = 2 

// Little-endian Unicode encoding type.
EncodingType_Unicode EncodingType = 3 
)

func Int32ToEncodingType(value int32)(EncodingType ,error){
	switch value {
		case 0:  return EncodingType_Default, nil  
		case 1:  return EncodingType_ASCII, nil  
		case 2:  return EncodingType_UTF8, nil  
		case 3:  return EncodingType_Unicode, nil  
		default:
			return 0 ,fmt.Errorf("invalid EncodingType value: %d", value)
	}
}

/**************Enum EncryptionType *****************/

// Encryption Type.
// Only used by excel2003.
// We will encrypt 2007/2010 workbook using SHA AES the same as Excel does, and this EncryptionType will be ignored.
type EncryptionType int32

const(
// XOR encryption algorithm.
EncryptionType_XOR EncryptionType = 0 

// Office 97/2000 compatible.
EncryptionType_Compatible EncryptionType = 1 

// Enhanced encryption.
EncryptionType_EnhancedCryptographicProviderV1 EncryptionType = 2 

// Strong encryption algorithm.
EncryptionType_StrongCryptographicProvider EncryptionType = 3 
)

func Int32ToEncryptionType(value int32)(EncryptionType ,error){
	switch value {
		case 0:  return EncryptionType_XOR, nil  
		case 1:  return EncryptionType_Compatible, nil  
		case 2:  return EncryptionType_EnhancedCryptographicProviderV1, nil  
		case 3:  return EncryptionType_StrongCryptographicProvider, nil  
		default:
			return 0 ,fmt.Errorf("invalid EncryptionType value: %d", value)
	}
}

/**************Enum ErrorCellValueType *****************/

// Represents a cell value which contains an error.
type ErrorCellValueType int32

const(
// Represents the value of a cell containing a #BLOCKED! error.
ErrorCellValueType_Blocked ErrorCellValueType = 10 

// Represents the value of a cell containing a #BUSY! error.
ErrorCellValueType_Busy ErrorCellValueType = 14 

// Represents the value of a cell containing a #CALC! error.
ErrorCellValueType_Calc ErrorCellValueType = 13 

// Represents the value of a cell containing a #CONNECT! error.
ErrorCellValueType_Connect ErrorCellValueType = 9 

// Represents the value of a cell containing a #NAME? error.
ErrorCellValueType_Name ErrorCellValueType = 4 

// Represents the value of a cell containing a #FIELD! error.
ErrorCellValueType_Field ErrorCellValueType = 12 

// Represents the value of a cell containing a #SPILL! error.
ErrorCellValueType_Spill ErrorCellValueType = 8 

// Represents the value of a cell containing a #UNKNOWN! error.
ErrorCellValueType_Unknown ErrorCellValueType = 11 

// Represents the value of a cell containing a #TIMEOUT! error.
ErrorCellValueType_TimeOut ErrorCellValueType = 19 

// Represents the value of a cell containing an #EXTERNAL! error.
ErrorCellValueType_External ErrorCellValueType = 18 
)

func Int32ToErrorCellValueType(value int32)(ErrorCellValueType ,error){
	switch value {
		case 10:  return ErrorCellValueType_Blocked, nil  
		case 14:  return ErrorCellValueType_Busy, nil  
		case 13:  return ErrorCellValueType_Calc, nil  
		case 9:  return ErrorCellValueType_Connect, nil  
		case 4:  return ErrorCellValueType_Name, nil  
		case 12:  return ErrorCellValueType_Field, nil  
		case 8:  return ErrorCellValueType_Spill, nil  
		case 11:  return ErrorCellValueType_Unknown, nil  
		case 19:  return ErrorCellValueType_TimeOut, nil  
		case 18:  return ErrorCellValueType_External, nil  
		default:
			return 0 ,fmt.Errorf("invalid ErrorCellValueType value: %d", value)
	}
}

/**************Enum ErrorCheckType *****************/

// Represents all error check type.
type ErrorCheckType int32

const(
// Ignore errors when cells contain formulas that result in an error.
ErrorCheckType_EvaluationError ErrorCheckType = 1 

// Ignore errors when formulas refer to empty cells.
ErrorCheckType_EmptyCellRef ErrorCheckType = 2 

// Ignore errors when numbers are formatted as text or are preceded by an apostrophe
ErrorCheckType_NumberStoredAsText ErrorCheckType = 4 

// Ignore errors when formulas omit certain cells in a region.
ErrorCheckType_InconsistRange ErrorCheckType = 8 

// Ignore errors when a formula in a region of your worksheet differs from other formulas in the same region.
ErrorCheckType_InconsistFormula ErrorCheckType = 16 

// Ignore errors when formulas contain text formatted cells with years represented as 2 digits.
ErrorCheckType_TwoDigitTextYear ErrorCheckType = 32 

// Ignore errors when unlocked cells contain formulas.
ErrorCheckType_UnlockedFormula ErrorCheckType = 64 

// Ignore errors when a cell's value in a Table does not comply with the Data Validation rules specified.
ErrorCheckType_TableDataValidation ErrorCheckType = 128 

// Ignore errors when cells contain a value different from a calculated column formula.
ErrorCheckType_CalculatedColumn ErrorCheckType = 129 
)

func Int32ToErrorCheckType(value int32)(ErrorCheckType ,error){
	switch value {
		case 1:  return ErrorCheckType_EvaluationError, nil  
		case 2:  return ErrorCheckType_EmptyCellRef, nil  
		case 4:  return ErrorCheckType_NumberStoredAsText, nil  
		case 8:  return ErrorCheckType_InconsistRange, nil  
		case 16:  return ErrorCheckType_InconsistFormula, nil  
		case 32:  return ErrorCheckType_TwoDigitTextYear, nil  
		case 64:  return ErrorCheckType_UnlockedFormula, nil  
		case 128:  return ErrorCheckType_TableDataValidation, nil  
		case 129:  return ErrorCheckType_CalculatedColumn, nil  
		default:
			return 0 ,fmt.Errorf("invalid ErrorCheckType value: %d", value)
	}
}

/**************Enum ExceptionType *****************/

// Represents custom exception type code.
type ExceptionType int32

const(
// Invalid chart setting.
ExceptionType_Chart ExceptionType = 0 

// Invalid data type setting.
ExceptionType_DataType ExceptionType = 1 

// Invalid data validation setting.
ExceptionType_DataValidation ExceptionType = 2 

// Invalid data validation setting.
ExceptionType_ConditionalFormatting ExceptionType = 3 

// Invalid file format.
ExceptionType_FileFormat ExceptionType = 4 

// Invalid formula.
ExceptionType_Formula ExceptionType = 5 

// Invalid data.
ExceptionType_InvalidData ExceptionType = 6 

// Invalid operator.
ExceptionType_InvalidOperator ExceptionType = 7 

// Incorrect password.
ExceptionType_IncorrectPassword ExceptionType = 8 

// License related errors.
ExceptionType_License ExceptionType = 9 

// Out of MS Excel limitation error.
ExceptionType_Limitation ExceptionType = 10 

// Invalid page setup setting.
ExceptionType_PageSetup ExceptionType = 11 

// Invalid pivotTable setting.
ExceptionType_PivotTable ExceptionType = 12 

// Invalid drawing object setting.
ExceptionType_Shape ExceptionType = 13 

// Invalid sparkline object setting.
ExceptionType_Sparkline ExceptionType = 14 

// Invalid worksheet name.
ExceptionType_SheetName ExceptionType = 15 

// Invalid worksheet type.
ExceptionType_SheetType ExceptionType = 16 

// The process is interrupted.
ExceptionType_Interrupted ExceptionType = 17 

// The file is invalid.
ExceptionType_IO ExceptionType = 18 

// Permission is required to open this file.
ExceptionType_Permission ExceptionType = 19 

// Unsupported feature.
ExceptionType_UnsupportedFeature ExceptionType = 20 

// Unsupported stream to be opened.
ExceptionType_UnsupportedStream ExceptionType = 21 

// Files contains some undisclosed information.
ExceptionType_UndisclosedInformation ExceptionType = 22 

// File content is corrupted.
ExceptionType_FileCorrupted ExceptionType = 23 

// Internal exception.
ExceptionType_Internal ExceptionType = 24 

// Invalid defined name
ExceptionType_DefinedName ExceptionType = 25 

// Invalid font
ExceptionType_Font ExceptionType = 26 

// Invalid auto filter setting.
ExceptionType_AutoFilter ExceptionType = 27 

// Font substitution warning type
// when a font has not been found, this warning type can be get.
ExceptionType_FontSubstitution ExceptionType = 28 
)

func Int32ToExceptionType(value int32)(ExceptionType ,error){
	switch value {
		case 0:  return ExceptionType_Chart, nil  
		case 1:  return ExceptionType_DataType, nil  
		case 2:  return ExceptionType_DataValidation, nil  
		case 3:  return ExceptionType_ConditionalFormatting, nil  
		case 4:  return ExceptionType_FileFormat, nil  
		case 5:  return ExceptionType_Formula, nil  
		case 6:  return ExceptionType_InvalidData, nil  
		case 7:  return ExceptionType_InvalidOperator, nil  
		case 8:  return ExceptionType_IncorrectPassword, nil  
		case 9:  return ExceptionType_License, nil  
		case 10:  return ExceptionType_Limitation, nil  
		case 11:  return ExceptionType_PageSetup, nil  
		case 12:  return ExceptionType_PivotTable, nil  
		case 13:  return ExceptionType_Shape, nil  
		case 14:  return ExceptionType_Sparkline, nil  
		case 15:  return ExceptionType_SheetName, nil  
		case 16:  return ExceptionType_SheetType, nil  
		case 17:  return ExceptionType_Interrupted, nil  
		case 18:  return ExceptionType_IO, nil  
		case 19:  return ExceptionType_Permission, nil  
		case 20:  return ExceptionType_UnsupportedFeature, nil  
		case 21:  return ExceptionType_UnsupportedStream, nil  
		case 22:  return ExceptionType_UndisclosedInformation, nil  
		case 23:  return ExceptionType_FileCorrupted, nil  
		case 24:  return ExceptionType_Internal, nil  
		case 25:  return ExceptionType_DefinedName, nil  
		case 26:  return ExceptionType_Font, nil  
		case 27:  return ExceptionType_AutoFilter, nil  
		case 28:  return ExceptionType_FontSubstitution, nil  
		default:
			return 0 ,fmt.Errorf("invalid ExceptionType value: %d", value)
	}
}

/**************Enum ExternalLinkType *****************/

// Represents the type of external link.
type ExternalLinkType int32

const(
// Represents the DDE link.
ExternalLinkType_DDELink ExternalLinkType = 0 

// Represents external link.
ExternalLinkType_External ExternalLinkType = 1 
)

func Int32ToExternalLinkType(value int32)(ExternalLinkType ,error){
	switch value {
		case 0:  return ExternalLinkType_DDELink, nil  
		case 1:  return ExternalLinkType_External, nil  
		default:
			return 0 ,fmt.Errorf("invalid ExternalLinkType value: %d", value)
	}
}

/**************Enum FileFormatType *****************/

// Represents the file format types.
type FileFormatType int32

const(
// Comma-Separated Values(CSV) text file.
FileFormatType_Csv FileFormatType = 1 

// Office Open XML SpreadsheetML file (macro-free).
FileFormatType_Xlsx FileFormatType = 6 

// Office Open XML SpreadsheetML Macro-Enabled file.
FileFormatType_Xlsm FileFormatType = 7 

// Office Open XML SpreadsheetML Template (macro-free).
FileFormatType_Xltx FileFormatType = 8 

// Office Open XML SpreadsheetML Macro-Enabled Template.
FileFormatType_Xltm FileFormatType = 9 

// Office Open XML SpreadsheetML addinMacro-Enabled file.
FileFormatType_Xlam FileFormatType = 10 

// Tab-Separated Values(TSV) text file.
FileFormatType_Tsv FileFormatType = 11 

// HTML format.
FileFormatType_Html FileFormatType = 12 

// MHTML (Web archive) format.
FileFormatType_MHtml FileFormatType = 17 

// Open Document Sheet(ODS) file.
FileFormatType_Ods FileFormatType = 14 

// Excel97-2003 spreadsheet file.
FileFormatType_Excel97To2003 FileFormatType = 5 

// Excel 2003 XML Data file.
FileFormatType_SpreadsheetML FileFormatType = 15 

// The Excel Binary File Format (.xlsb)
FileFormatType_Xlsb FileFormatType = 16 

// Represents unrecognized format, cannot be loaded.
FileFormatType_Unknown FileFormatType = 255 

// PDF (Adobe Portable Document) format.
FileFormatType_Pdf FileFormatType = 13 

// XPS (XML Paper Specification) format.
FileFormatType_Xps FileFormatType = 20 

// Represents a TIFF file.
FileFormatType_Tiff FileFormatType = 21 

// SVG file.
FileFormatType_Svg FileFormatType = 28 

// Represents an Excel95 xls file.
FileFormatType_Excel95 FileFormatType = 22 

// Represents an Excel4.0 xls file.
FileFormatType_Excel4 FileFormatType = 23 

// Represents an Excel3.0 xls file.
FileFormatType_Excel3 FileFormatType = 24 

// Represents an Excel2.1 xls file.
FileFormatType_Excel2 FileFormatType = 25 

// Represents a pptx file.
FileFormatType_Pptx FileFormatType = 26 

// Represents a docx file.
FileFormatType_Docx FileFormatType = 27 

// Data Interchange Format.
FileFormatType_Dif FileFormatType = 30 

// Represents a doc file.
FileFormatType_Doc FileFormatType = 31 

// Represents a ppt file.
FileFormatType_Ppt FileFormatType = 32 

// Represents a email file.
FileFormatType_MapiMessage FileFormatType = 33 

// Represents the MS Equation 3.0 object.
FileFormatType_MsEquation FileFormatType = 34 

// Represents the embedded native object.
FileFormatType_Ole10Native FileFormatType = 35 

// Represents MS Visio VSD binary format.
FileFormatType_Vsd FileFormatType = 36 

// Represents MS Visio 2013 VSDX file format.
FileFormatType_Vsdx FileFormatType = 37 

// Represents a docm file.
FileFormatType_Docm FileFormatType = 38 

// Represents a dotx file.
FileFormatType_Dotx FileFormatType = 39 

// Represents a dotm file.
FileFormatType_Dotm FileFormatType = 40 

// Represents a pptm file.
FileFormatType_Pptm FileFormatType = 41 

// Represents a Potx file.
FileFormatType_Potx FileFormatType = 42 

// Represents a Potm file.
FileFormatType_Potm FileFormatType = 43 

// Represents a ppsx file.
FileFormatType_Ppsx FileFormatType = 44 

// Represents a ppsm file.
FileFormatType_Ppsm FileFormatType = 45 

// Represents office open xml file(such as xlsx, docx,pptx, etc).
FileFormatType_Ooxml FileFormatType = 46 

// Represents an ODT file.
FileFormatType_Odt FileFormatType = 47 

// Represents a ODP file.
FileFormatType_Odp FileFormatType = 48 

// Represents an ODF file.
FileFormatType_Odf FileFormatType = 49 

// Represents an ODG file.
FileFormatType_Odg FileFormatType = 50 

// Represents a simple xml file.
FileFormatType_Xml FileFormatType = 51 

// Excel97-2003 spreadsheet template.
FileFormatType_Xlt FileFormatType = 52 

// Represents an OTT file.
FileFormatType_Ott FileFormatType = 53 

// Represents a BMP file.
FileFormatType_Bmp FileFormatType = 54 

// Represents an ots file.
FileFormatType_Ots FileFormatType = 55 

// Represents Numbers 9.0 file format by Apple Inc.
FileFormatType_Numbers09 FileFormatType = 56 

// Represents markdown document.
FileFormatType_Markdown FileFormatType = 57 

// Represents embedded graph chart.
FileFormatType_GraphChart FileFormatType = 58 

// Represents OpenDocument Flat XML Spreadsheet (.fods) file format.
FileFormatType_Fods FileFormatType = 59 

// Represents StarOffice Calc Spreadsheet (.sxc) file format.
FileFormatType_Sxc FileFormatType = 60 

// Represents a OTP file.
FileFormatType_Otp FileFormatType = 61 

// Represents Numbers 3.5 file format since 2014 by Apple Inc
FileFormatType_Numbers35 FileFormatType = 62 

// Represents the embedded ole object.
FileFormatType_Ole FileFormatType = 64 

// Windows Enhanced Metafile.
FileFormatType_Emf FileFormatType = 258 

// Windows Metafile.
FileFormatType_Wmf FileFormatType = 259 

// JPEG JFIF.
FileFormatType_Jpg FileFormatType = 261 

// Portable Network Graphics.
FileFormatType_Png FileFormatType = 262 

// Gif
FileFormatType_Gif FileFormatType = 322 

// Webp
FileFormatType_WebP FileFormatType = 323 

// Json
FileFormatType_Json FileFormatType = 513 

// Sql
FileFormatType_SqlScript FileFormatType = 514 

// Xbase Data file
FileFormatType_Dbf FileFormatType = 515 

// Rrepesents XHtml file.
FileFormatType_XHtml FileFormatType = 771 

// Rrepesents One Note file.
FileFormatType_OneNote FileFormatType = 772 

// Rrepesents Microsoft Cabinet file.
FileFormatType_MicrosoftCabinet FileFormatType = 773 

// Rtf
FileFormatType_Rtf FileFormatType = 774 

// EPUB
FileFormatType_Epub FileFormatType = 775 

// AZW3
FileFormatType_Azw3 FileFormatType = 777 

// CHM
FileFormatType_Chm FileFormatType = 784 

// OXPS (Open XML Paper Specification) format.
FileFormatType_Oxps FileFormatType = 776 

// Rrepesents GZip file.
FileFormatType_GZip FileFormatType = 35615 
)

func Int32ToFileFormatType(value int32)(FileFormatType ,error){
	switch value {
		case 1:  return FileFormatType_Csv, nil  
		case 6:  return FileFormatType_Xlsx, nil  
		case 7:  return FileFormatType_Xlsm, nil  
		case 8:  return FileFormatType_Xltx, nil  
		case 9:  return FileFormatType_Xltm, nil  
		case 10:  return FileFormatType_Xlam, nil  
		case 11:  return FileFormatType_Tsv, nil  
		case 12:  return FileFormatType_Html, nil  
		case 17:  return FileFormatType_MHtml, nil  
		case 14:  return FileFormatType_Ods, nil  
		case 5:  return FileFormatType_Excel97To2003, nil  
		case 15:  return FileFormatType_SpreadsheetML, nil  
		case 16:  return FileFormatType_Xlsb, nil  
		case 255:  return FileFormatType_Unknown, nil  
		case 13:  return FileFormatType_Pdf, nil  
		case 20:  return FileFormatType_Xps, nil  
		case 21:  return FileFormatType_Tiff, nil  
		case 28:  return FileFormatType_Svg, nil  
		case 22:  return FileFormatType_Excel95, nil  
		case 23:  return FileFormatType_Excel4, nil  
		case 24:  return FileFormatType_Excel3, nil  
		case 25:  return FileFormatType_Excel2, nil  
		case 26:  return FileFormatType_Pptx, nil  
		case 27:  return FileFormatType_Docx, nil  
		case 30:  return FileFormatType_Dif, nil  
		case 31:  return FileFormatType_Doc, nil  
		case 32:  return FileFormatType_Ppt, nil  
		case 33:  return FileFormatType_MapiMessage, nil  
		case 34:  return FileFormatType_MsEquation, nil  
		case 35:  return FileFormatType_Ole10Native, nil  
		case 36:  return FileFormatType_Vsd, nil  
		case 37:  return FileFormatType_Vsdx, nil  
		case 38:  return FileFormatType_Docm, nil  
		case 39:  return FileFormatType_Dotx, nil  
		case 40:  return FileFormatType_Dotm, nil  
		case 41:  return FileFormatType_Pptm, nil  
		case 42:  return FileFormatType_Potx, nil  
		case 43:  return FileFormatType_Potm, nil  
		case 44:  return FileFormatType_Ppsx, nil  
		case 45:  return FileFormatType_Ppsm, nil  
		case 46:  return FileFormatType_Ooxml, nil  
		case 47:  return FileFormatType_Odt, nil  
		case 48:  return FileFormatType_Odp, nil  
		case 49:  return FileFormatType_Odf, nil  
		case 50:  return FileFormatType_Odg, nil  
		case 51:  return FileFormatType_Xml, nil  
		case 52:  return FileFormatType_Xlt, nil  
		case 53:  return FileFormatType_Ott, nil  
		case 54:  return FileFormatType_Bmp, nil  
		case 55:  return FileFormatType_Ots, nil  
		case 56:  return FileFormatType_Numbers09, nil  
		case 57:  return FileFormatType_Markdown, nil  
		case 58:  return FileFormatType_GraphChart, nil  
		case 59:  return FileFormatType_Fods, nil  
		case 60:  return FileFormatType_Sxc, nil  
		case 61:  return FileFormatType_Otp, nil  
		case 62:  return FileFormatType_Numbers35, nil  
		case 64:  return FileFormatType_Ole, nil  
		case 258:  return FileFormatType_Emf, nil  
		case 259:  return FileFormatType_Wmf, nil  
		case 261:  return FileFormatType_Jpg, nil  
		case 262:  return FileFormatType_Png, nil  
		case 322:  return FileFormatType_Gif, nil  
		case 323:  return FileFormatType_WebP, nil  
		case 513:  return FileFormatType_Json, nil  
		case 514:  return FileFormatType_SqlScript, nil  
		case 515:  return FileFormatType_Dbf, nil  
		case 771:  return FileFormatType_XHtml, nil  
		case 772:  return FileFormatType_OneNote, nil  
		case 773:  return FileFormatType_MicrosoftCabinet, nil  
		case 774:  return FileFormatType_Rtf, nil  
		case 775:  return FileFormatType_Epub, nil  
		case 777:  return FileFormatType_Azw3, nil  
		case 784:  return FileFormatType_Chm, nil  
		case 776:  return FileFormatType_Oxps, nil  
		case 35615:  return FileFormatType_GZip, nil  
		default:
			return 0 ,fmt.Errorf("invalid FileFormatType value: %d", value)
	}
}

/**************Enum FilterCategory *****************/

// Represents the category of the filter.
type FilterCategory int32

const(
// No Filter.
FilterCategory_None FilterCategory = 0 

// Caption Filter.
FilterCategory_Label FilterCategory = 1 

// Number Value Filter.
FilterCategory_NumberValue FilterCategory = 2 

// Date Value Filter.
FilterCategory_Date FilterCategory = 3 

// Top10 Value Filter.
FilterCategory_Top10 FilterCategory = 4 
)

func Int32ToFilterCategory(value int32)(FilterCategory ,error){
	switch value {
		case 0:  return FilterCategory_None, nil  
		case 1:  return FilterCategory_Label, nil  
		case 2:  return FilterCategory_NumberValue, nil  
		case 3:  return FilterCategory_Date, nil  
		case 4:  return FilterCategory_Top10, nil  
		default:
			return 0 ,fmt.Errorf("invalid FilterCategory value: %d", value)
	}
}

/**************Enum FilterOperatorType *****************/

// Custom Filter operator type.
type FilterOperatorType int32

const(
// Represents LessOrEqual operator.
FilterOperatorType_LessOrEqual FilterOperatorType = 0 

// Represents LessThan operator.
FilterOperatorType_LessThan FilterOperatorType = 1 

// Represents Equal operator.
FilterOperatorType_Equal FilterOperatorType = 2 

// Represents GreaterThan operator.
FilterOperatorType_GreaterThan FilterOperatorType = 3 

// Represents NotEqual operator.
FilterOperatorType_NotEqual FilterOperatorType = 4 

// Represents GreaterOrEqual operator.
FilterOperatorType_GreaterOrEqual FilterOperatorType = 5 

// Represents no comparison.
FilterOperatorType_None FilterOperatorType = 6 

// Begins with the text.
FilterOperatorType_BeginsWith FilterOperatorType = 7 

// Ends with the text.
FilterOperatorType_EndsWith FilterOperatorType = 8 

// Contains the text.
FilterOperatorType_Contains FilterOperatorType = 9 

// Not contains the text.
FilterOperatorType_NotContains FilterOperatorType = 10 

// Not begins with the text.
FilterOperatorType_NotBeginsWith FilterOperatorType = 11 

// Not ends with the text.
FilterOperatorType_NotEndsWith FilterOperatorType = 12 
)

func Int32ToFilterOperatorType(value int32)(FilterOperatorType ,error){
	switch value {
		case 0:  return FilterOperatorType_LessOrEqual, nil  
		case 1:  return FilterOperatorType_LessThan, nil  
		case 2:  return FilterOperatorType_Equal, nil  
		case 3:  return FilterOperatorType_GreaterThan, nil  
		case 4:  return FilterOperatorType_NotEqual, nil  
		case 5:  return FilterOperatorType_GreaterOrEqual, nil  
		case 6:  return FilterOperatorType_None, nil  
		case 7:  return FilterOperatorType_BeginsWith, nil  
		case 8:  return FilterOperatorType_EndsWith, nil  
		case 9:  return FilterOperatorType_Contains, nil  
		case 10:  return FilterOperatorType_NotContains, nil  
		case 11:  return FilterOperatorType_NotBeginsWith, nil  
		case 12:  return FilterOperatorType_NotEndsWith, nil  
		default:
			return 0 ,fmt.Errorf("invalid FilterOperatorType value: %d", value)
	}
}

/**************Enum FilterType *****************/

// The filter type.
type FilterType int32

const(
// Filter by fill color of the cell.
FilterType_ColorFilter FilterType = 0 

// Custom filter type.
FilterType_CustomFilters FilterType = 1 

// Dynamic filter type.
FilterType_DynamicFilter FilterType = 2 

// When multiple values are chosen to filter by, or when a group of date values are chosen to filter by,
// this element groups those criteria together.
FilterType_MultipleFilters FilterType = 3 

// Filter by icon of conditional formatting.
FilterType_IconFilter FilterType = 4 

// Top 10 filter.
FilterType_Top10 FilterType = 5 

// No filter.
FilterType_None FilterType = 6 
)

func Int32ToFilterType(value int32)(FilterType ,error){
	switch value {
		case 0:  return FilterType_ColorFilter, nil  
		case 1:  return FilterType_CustomFilters, nil  
		case 2:  return FilterType_DynamicFilter, nil  
		case 3:  return FilterType_MultipleFilters, nil  
		case 4:  return FilterType_IconFilter, nil  
		case 5:  return FilterType_Top10, nil  
		case 6:  return FilterType_None, nil  
		default:
			return 0 ,fmt.Errorf("invalid FilterType value: %d", value)
	}
}

/**************Enum FontFileFormatType *****************/

// Represents font format type.
type FontFileFormatType int32

const(
// Unknown font format type.
FontFileFormatType_Unknown FontFileFormatType = 0 

// TTF font format type.
FontFileFormatType_Ttf FontFileFormatType = 1 

// OTF font format type.
FontFileFormatType_Otf FontFileFormatType = 2 

// TTC font format type.
FontFileFormatType_Ttc FontFileFormatType = 3 
)

func Int32ToFontFileFormatType(value int32)(FontFileFormatType ,error){
	switch value {
		case 0:  return FontFileFormatType_Unknown, nil  
		case 1:  return FontFileFormatType_Ttf, nil  
		case 2:  return FontFileFormatType_Otf, nil  
		case 3:  return FontFileFormatType_Ttc, nil  
		default:
			return 0 ,fmt.Errorf("invalid FontFileFormatType value: %d", value)
	}
}

/**************Enum FontSchemeType *****************/

// Represents the scheme type of the font.
type FontSchemeType int32

const(
// None
FontSchemeType_None FontSchemeType = 0 

// Major scheme.
FontSchemeType_Major FontSchemeType = 1 

// Minor scheme.
FontSchemeType_Minor FontSchemeType = 2 
)

func Int32ToFontSchemeType(value int32)(FontSchemeType ,error){
	switch value {
		case 0:  return FontSchemeType_None, nil  
		case 1:  return FontSchemeType_Major, nil  
		case 2:  return FontSchemeType_Minor, nil  
		default:
			return 0 ,fmt.Errorf("invalid FontSchemeType value: %d", value)
	}
}

/**************Enum FontSourceType *****************/

// Specifies the type of a font source.
type FontSourceType int32

const(
// represents single font file.
FontSourceType_FontFile FontSourceType = 0 

// represents folder with font files.
FontSourceType_FontsFolder FontSourceType = 1 

// represents single font in memory.
FontSourceType_MemoryFont FontSourceType = 2 
)

func Int32ToFontSourceType(value int32)(FontSourceType ,error){
	switch value {
		case 0:  return FontSourceType_FontFile, nil  
		case 1:  return FontSourceType_FontsFolder, nil  
		case 2:  return FontSourceType_MemoryFont, nil  
		default:
			return 0 ,fmt.Errorf("invalid FontSourceType value: %d", value)
	}
}

/**************Enum FontUnderlineType *****************/

// Enumerates the font underline types.
type FontUnderlineType int32

const(
// Represents no underline.
FontUnderlineType_None FontUnderlineType = 0 

// Represents single underline.
FontUnderlineType_Single FontUnderlineType = 1 

// Represents double underline.
FontUnderlineType_Double FontUnderlineType = 2 

// Represents single accounting underline.
FontUnderlineType_Accounting FontUnderlineType = 3 

// Represents double accounting underline.
FontUnderlineType_DoubleAccounting FontUnderlineType = 4 

// Represents Dashed Underline
FontUnderlineType_Dash FontUnderlineType = 5 

// Represents Thick Dash-Dot-Dot Underline
FontUnderlineType_DashDotDotHeavy FontUnderlineType = 6 

// Represents Thick Dash-Dot Underline
FontUnderlineType_DashDotHeavy FontUnderlineType = 7 

// Represents Thick Dashed Underline
FontUnderlineType_DashedHeavy FontUnderlineType = 8 

// Represents Long Dashed Underline
FontUnderlineType_DashLong FontUnderlineType = 9 

// Represents Thick Long Dashed Underline
FontUnderlineType_DashLongHeavy FontUnderlineType = 10 

// Represents Dash-Dot Underline
FontUnderlineType_DotDash FontUnderlineType = 11 

// Represents Dash-Dot-Dot Underline
FontUnderlineType_DotDotDash FontUnderlineType = 12 

// Represents Dotted Underline
FontUnderlineType_Dotted FontUnderlineType = 13 

// Represents Thick Dotted Underline
FontUnderlineType_DottedHeavy FontUnderlineType = 14 

// Represents Thick Underline
FontUnderlineType_Heavy FontUnderlineType = 15 

// Represents Wave Underline
FontUnderlineType_Wave FontUnderlineType = 16 

// Represents Double Wave Underline
FontUnderlineType_WavyDouble FontUnderlineType = 17 

// Represents Heavy Wave Underline
FontUnderlineType_WavyHeavy FontUnderlineType = 18 

// Represents Underline Non-Space Characters Only
FontUnderlineType_Words FontUnderlineType = 19 
)

func Int32ToFontUnderlineType(value int32)(FontUnderlineType ,error){
	switch value {
		case 0:  return FontUnderlineType_None, nil  
		case 1:  return FontUnderlineType_Single, nil  
		case 2:  return FontUnderlineType_Double, nil  
		case 3:  return FontUnderlineType_Accounting, nil  
		case 4:  return FontUnderlineType_DoubleAccounting, nil  
		case 5:  return FontUnderlineType_Dash, nil  
		case 6:  return FontUnderlineType_DashDotDotHeavy, nil  
		case 7:  return FontUnderlineType_DashDotHeavy, nil  
		case 8:  return FontUnderlineType_DashedHeavy, nil  
		case 9:  return FontUnderlineType_DashLong, nil  
		case 10:  return FontUnderlineType_DashLongHeavy, nil  
		case 11:  return FontUnderlineType_DotDash, nil  
		case 12:  return FontUnderlineType_DotDotDash, nil  
		case 13:  return FontUnderlineType_Dotted, nil  
		case 14:  return FontUnderlineType_DottedHeavy, nil  
		case 15:  return FontUnderlineType_Heavy, nil  
		case 16:  return FontUnderlineType_Wave, nil  
		case 17:  return FontUnderlineType_WavyDouble, nil  
		case 18:  return FontUnderlineType_WavyHeavy, nil  
		case 19:  return FontUnderlineType_Words, nil  
		default:
			return 0 ,fmt.Errorf("invalid FontUnderlineType value: %d", value)
	}
}

/**************Enum FormatConditionType *****************/

// Conditional format rule type.
type FormatConditionType int32

const(
// This conditional formatting rule compares a cell value
// to a formula calculated result, using an operator.
FormatConditionType_CellValue FormatConditionType = 1 

// This conditional formatting rule contains a formula to
// evaluate. When the formula result is true, the cell is
// highlighted.
FormatConditionType_Expression FormatConditionType = 2 

// This conditional formatting rule highlights cells whose
// values fall in the top N or bottom N bracket, as
// specified.
FormatConditionType_Top10 FormatConditionType = 4 

// This conditional formatting rule highlights unique
// values in the range.
FormatConditionType_UniqueValues FormatConditionType = 8 

// This conditional formatting rule highlights duplicated
// values.
FormatConditionType_DuplicateValues FormatConditionType = 16 

// This conditional formatting rule highlights cells
// containing given text. Equivalent to using the SEARCH()
// sheet function to determine whether the cell contains
// the text.
FormatConditionType_ContainsText FormatConditionType = 32 

// This conditional formatting rule highlights cells that
// do not contain given text. Equivalent of using SEARCH()
// sheet function to determine whether the cell contains
// the text or not.
FormatConditionType_NotContainsText FormatConditionType = 64 

// This conditional formatting rule highlights cells in the
// range that begin with the given text. Equivalent to
// using the LEFT() sheet function and comparing values.
FormatConditionType_BeginsWith FormatConditionType = 128 

// This conditional formatting rule highlights cells ending
// with given text. Equivalent to using the RIGHT() sheet
// function and comparing values.
FormatConditionType_EndsWith FormatConditionType = 256 

// This conditional formatting rule highlights cells that
// are completely blank. Equivalent of using LEN(TRIM()).
// This means that if the cell contains only characters
// that TRIM() would remove, then it is considered blank.
// An empty cell is also considered blank.
FormatConditionType_ContainsBlanks FormatConditionType = 512 

// This conditional formatting rule highlights cells that
// are not blank. Equivalent of using LEN(TRIM()). This
// means that if the cell contains only characters that
// TRIM() would remove, then it is considered blank. An
// empty cell is also considered blank.
FormatConditionType_NotContainsBlanks FormatConditionType = 1024 

// This conditional formatting rule highlights cells with
// formula errors. Equivalent to using ISERROR() sheet
// function to determine if there is a formula error.
FormatConditionType_ContainsErrors FormatConditionType = 2048 

// This conditional formatting rule highlights cells
// without formula errors. Equivalent to using ISERROR()
// sheet function to determine if there is a formula error.
FormatConditionType_NotContainsErrors FormatConditionType = 4096 

// This conditional formatting rule highlights cells
// containing dates in the specified time period. The
// underlying value of the cell is evaluated, therefore the
// cell does not need to be formatted as a date to be
// evaluated. For example, with a cell containing the
// value 38913 the conditional format shall be applied if
// the rule requires a value of 7/14/2006.
FormatConditionType_TimePeriod FormatConditionType = 8192 

// This conditional formatting rule highlights cells that
// are above or below the average for all values in the
// range.
FormatConditionType_AboveAverage FormatConditionType = 16384 

// This conditional formatting rule creates a gradated
// color scale on the cells.
FormatConditionType_ColorScale FormatConditionType = 32768 

// This conditional formatting rule displays a gradated
// data bar in the range of cells.
FormatConditionType_DataBar FormatConditionType = 65536 

// This conditional formatting rule applies icons to cells
// according to their values.
FormatConditionType_IconSet FormatConditionType = 131072 
)

func Int32ToFormatConditionType(value int32)(FormatConditionType ,error){
	switch value {
		case 1:  return FormatConditionType_CellValue, nil  
		case 2:  return FormatConditionType_Expression, nil  
		case 4:  return FormatConditionType_Top10, nil  
		case 8:  return FormatConditionType_UniqueValues, nil  
		case 16:  return FormatConditionType_DuplicateValues, nil  
		case 32:  return FormatConditionType_ContainsText, nil  
		case 64:  return FormatConditionType_NotContainsText, nil  
		case 128:  return FormatConditionType_BeginsWith, nil  
		case 256:  return FormatConditionType_EndsWith, nil  
		case 512:  return FormatConditionType_ContainsBlanks, nil  
		case 1024:  return FormatConditionType_NotContainsBlanks, nil  
		case 2048:  return FormatConditionType_ContainsErrors, nil  
		case 4096:  return FormatConditionType_NotContainsErrors, nil  
		case 8192:  return FormatConditionType_TimePeriod, nil  
		case 16384:  return FormatConditionType_AboveAverage, nil  
		case 32768:  return FormatConditionType_ColorScale, nil  
		case 65536:  return FormatConditionType_DataBar, nil  
		case 131072:  return FormatConditionType_IconSet, nil  
		default:
			return 0 ,fmt.Errorf("invalid FormatConditionType value: %d", value)
	}
}

/**************Enum FormatConditionValueType *****************/

// Condition value type.
type FormatConditionValueType int32

const(
// The minimum/ midpoint / maximum value for the
// gradient is determined by a formula.
FormatConditionValueType_Formula FormatConditionValueType = 0 

// Indicates that the maximum value in the range shall be
// used as the maximum value for the gradient.
FormatConditionValueType_Max FormatConditionValueType = 1 

// Indicates that the minimum value in the range shall be
// used as the minimum value for the gradient.
FormatConditionValueType_Min FormatConditionValueType = 2 

// Indicates that the minimum / midpoint / maximum
// value for the gradient is specified by a constant
// numeric value.
FormatConditionValueType_Number FormatConditionValueType = 3 

// Value indicates a percentage between the minimum
// and maximum values in the range shall be used as the
// minimum / midpoint / maximum value for the gradient.
FormatConditionValueType_Percent FormatConditionValueType = 4 

// Value indicates a percentile ranking in the range shall
// be used as the minimum / midpoint / maximum value
// for the gradient.
FormatConditionValueType_Percentile FormatConditionValueType = 5 

// Indicates that the Automatic maximum value in the range shall be
// used as the Automatic maximum value for the gradient.
FormatConditionValueType_AutomaticMax FormatConditionValueType = 6 

// Indicates that the Automatic minimum value in the range shall be
// used as the Automatic minimum value for the gradient.
FormatConditionValueType_AutomaticMin FormatConditionValueType = 7 
)

func Int32ToFormatConditionValueType(value int32)(FormatConditionValueType ,error){
	switch value {
		case 0:  return FormatConditionValueType_Formula, nil  
		case 1:  return FormatConditionValueType_Max, nil  
		case 2:  return FormatConditionValueType_Min, nil  
		case 3:  return FormatConditionValueType_Number, nil  
		case 4:  return FormatConditionValueType_Percent, nil  
		case 5:  return FormatConditionValueType_Percentile, nil  
		case 6:  return FormatConditionValueType_AutomaticMax, nil  
		case 7:  return FormatConditionValueType_AutomaticMin, nil  
		default:
			return 0 ,fmt.Errorf("invalid FormatConditionValueType value: %d", value)
	}
}

/**************Enum GridlineType *****************/

// Enumerates grid line Type.
type GridlineType int32

const(
// Represents dotted line.
GridlineType_Dotted GridlineType = 0 

// Represents hair line.
GridlineType_Hair GridlineType = 1 
)

func Int32ToGridlineType(value int32)(GridlineType ,error){
	switch value {
		case 0:  return GridlineType_Dotted, nil  
		case 1:  return GridlineType_Hair, nil  
		default:
			return 0 ,fmt.Errorf("invalid GridlineType value: %d", value)
	}
}

/**************Enum HeaderFooterCommandType *****************/

// Represents the command type of header and footer.
type HeaderFooterCommandType int32

const(
// The text.
HeaderFooterCommandType_Text HeaderFooterCommandType = 0 

// Current page number
HeaderFooterCommandType_CurrentPage HeaderFooterCommandType = 1 

// Page count
HeaderFooterCommandType_Pagecount HeaderFooterCommandType = 2 

// Current date
HeaderFooterCommandType_CurrentDate HeaderFooterCommandType = 3 

// Current time
HeaderFooterCommandType_CurrentTime HeaderFooterCommandType = 4 

// Sheet name
HeaderFooterCommandType_SheetName HeaderFooterCommandType = 5 

// File name without path
HeaderFooterCommandType_FileName HeaderFooterCommandType = 6 

// File path without file name
HeaderFooterCommandType_FilePath HeaderFooterCommandType = 7 

// Picture
HeaderFooterCommandType_Picture HeaderFooterCommandType = 8 
)

func Int32ToHeaderFooterCommandType(value int32)(HeaderFooterCommandType ,error){
	switch value {
		case 0:  return HeaderFooterCommandType_Text, nil  
		case 1:  return HeaderFooterCommandType_CurrentPage, nil  
		case 2:  return HeaderFooterCommandType_Pagecount, nil  
		case 3:  return HeaderFooterCommandType_CurrentDate, nil  
		case 4:  return HeaderFooterCommandType_CurrentTime, nil  
		case 5:  return HeaderFooterCommandType_SheetName, nil  
		case 6:  return HeaderFooterCommandType_FileName, nil  
		case 7:  return HeaderFooterCommandType_FilePath, nil  
		case 8:  return HeaderFooterCommandType_Picture, nil  
		default:
			return 0 ,fmt.Errorf("invalid HeaderFooterCommandType value: %d", value)
	}
}

/**************Enum HtmlCrossType *****************/

// Represents five types of html cross string.
type HtmlCrossType int32

const(
// Display like MS Excel,depends on the next cell.
// If the next cell is null,the string will cross,or it will be truncated
HtmlCrossType_Default HtmlCrossType = 0 

// Display the string like MS Excel exporting html.
HtmlCrossType_MSExport HtmlCrossType = 1 

// Display HTML cross string, this performance for creating large html files will be more than ten times faster than setting the value to Default or FitToCell.
HtmlCrossType_Cross HtmlCrossType = 2 

// Display HTML cross string and hide the right string when the texts overlap.
HtmlCrossType_CrossHideRight HtmlCrossType = 3 

// Only displaying the string within the width of cell.
HtmlCrossType_FitToCell HtmlCrossType = 4 
)

func Int32ToHtmlCrossType(value int32)(HtmlCrossType ,error){
	switch value {
		case 0:  return HtmlCrossType_Default, nil  
		case 1:  return HtmlCrossType_MSExport, nil  
		case 2:  return HtmlCrossType_Cross, nil  
		case 3:  return HtmlCrossType_CrossHideRight, nil  
		case 4:  return HtmlCrossType_FitToCell, nil  
		default:
			return 0 ,fmt.Errorf("invalid HtmlCrossType value: %d", value)
	}
}

/**************Enum HtmlExportDataOptions *****************/

// Represents the options for exporting html data.
type HtmlExportDataOptions int32

const(
// Export file to html which only contains table part.
HtmlExportDataOptions_Table HtmlExportDataOptions = 1 

// Export all the data to html.
HtmlExportDataOptions_All HtmlExportDataOptions = 255 
)

func Int32ToHtmlExportDataOptions(value int32)(HtmlExportDataOptions ,error){
	switch value {
		case 1:  return HtmlExportDataOptions_Table, nil  
		case 255:  return HtmlExportDataOptions_All, nil  
		default:
			return 0 ,fmt.Errorf("invalid HtmlExportDataOptions value: %d", value)
	}
}

/**************Enum HtmlHiddenColDisplayType *****************/

// Represents two types of showing the hidden columns in html.
type HtmlHiddenColDisplayType int32

const(
// Hidden the hidden columns in html page.
HtmlHiddenColDisplayType_Hidden HtmlHiddenColDisplayType = 0 

// Remove the hidden columns in html page.
HtmlHiddenColDisplayType_Remove HtmlHiddenColDisplayType = 1 
)

func Int32ToHtmlHiddenColDisplayType(value int32)(HtmlHiddenColDisplayType ,error){
	switch value {
		case 0:  return HtmlHiddenColDisplayType_Hidden, nil  
		case 1:  return HtmlHiddenColDisplayType_Remove, nil  
		default:
			return 0 ,fmt.Errorf("invalid HtmlHiddenColDisplayType value: %d", value)
	}
}

/**************Enum HtmlHiddenRowDisplayType *****************/

// Represents two types of showing the hidden rows in html.
type HtmlHiddenRowDisplayType int32

const(
// Hidden the hidden rows in html page.
HtmlHiddenRowDisplayType_Hidden HtmlHiddenRowDisplayType = 0 

// Remove the hidden rows in html page.
HtmlHiddenRowDisplayType_Remove HtmlHiddenRowDisplayType = 1 
)

func Int32ToHtmlHiddenRowDisplayType(value int32)(HtmlHiddenRowDisplayType ,error){
	switch value {
		case 0:  return HtmlHiddenRowDisplayType_Hidden, nil  
		case 1:  return HtmlHiddenRowDisplayType_Remove, nil  
		default:
			return 0 ,fmt.Errorf("invalid HtmlHiddenRowDisplayType value: %d", value)
	}
}

/**************Enum HtmlLinkTargetType *****************/

// Represents the type of target attribute in HTML <a/> tag.
type HtmlLinkTargetType int32

const(
// Opens the linked document in a new window or tab
HtmlLinkTargetType_Blank HtmlLinkTargetType = 0 

// Opens the linked document in the parent frame
HtmlLinkTargetType_Parent HtmlLinkTargetType = 1 

// Opens the linked document in the same frame as it was clicked (this is default)
HtmlLinkTargetType_Self HtmlLinkTargetType = 2 

// Opens the linked document in the full body of the window
HtmlLinkTargetType_Top HtmlLinkTargetType = 3 
)

func Int32ToHtmlLinkTargetType(value int32)(HtmlLinkTargetType ,error){
	switch value {
		case 0:  return HtmlLinkTargetType_Blank, nil  
		case 1:  return HtmlLinkTargetType_Parent, nil  
		case 2:  return HtmlLinkTargetType_Self, nil  
		case 3:  return HtmlLinkTargetType_Top, nil  
		default:
			return 0 ,fmt.Errorf("invalid HtmlLinkTargetType value: %d", value)
	}
}

/**************Enum HtmlOfficeMathOutputType *****************/

// Represents how export OfficeMath to HTML.
type HtmlOfficeMathOutputType int32

const(
// Converts OfficeMath to HTML as image specified by &lt;img&gt; tag.
HtmlOfficeMathOutputType_Image HtmlOfficeMathOutputType = 0 

// Converts OfficeMath to HTML using MathML.
HtmlOfficeMathOutputType_MathML HtmlOfficeMathOutputType = 1 
)

func Int32ToHtmlOfficeMathOutputType(value int32)(HtmlOfficeMathOutputType ,error){
	switch value {
		case 0:  return HtmlOfficeMathOutputType_Image, nil  
		case 1:  return HtmlOfficeMathOutputType_MathML, nil  
		default:
			return 0 ,fmt.Errorf("invalid HtmlOfficeMathOutputType value: %d", value)
	}
}

/**************Enum HtmlVersion *****************/

// Indicates the version of HTML is used when saving to Html formats.
type HtmlVersion int32

const(
// Save the document in compliance with the MS Excel exporting HTML.
HtmlVersion_Default HtmlVersion = 0 

// Saves the document in compliance with the XHTML 1.0 Transitional standard.
HtmlVersion_XHtml HtmlVersion = 1 

// Saves the document in compliance with the HTML 5 standard.
HtmlVersion_Html5 HtmlVersion = 2 
)

func Int32ToHtmlVersion(value int32)(HtmlVersion ,error){
	switch value {
		case 0:  return HtmlVersion_Default, nil  
		case 1:  return HtmlVersion_XHtml, nil  
		case 2:  return HtmlVersion_Html5, nil  
		default:
			return 0 ,fmt.Errorf("invalid HtmlVersion value: %d", value)
	}
}

/**************Enum IconSetType *****************/

// Icon set type for conditional formatting.
// The threshold values for triggering the different icons within a set are
// configurable, and the icon order is reversible.
type IconSetType int32

const(
// 3 arrows icon set.
IconSetType_Arrows3 IconSetType = 0 

// 3 gray arrows icon set.
IconSetType_ArrowsGray3 IconSetType = 1 

// 3 flags icon set.
IconSetType_Flags3 IconSetType = 2 

// 3 signs icon set.
IconSetType_Signs3 IconSetType = 3 

// 3 symbols icon set (circled).
IconSetType_Symbols3 IconSetType = 4 

// 3 Symbols icon set (uncircled).
IconSetType_Symbols32 IconSetType = 5 

// 3 traffic lights icon set (unrimmed).
IconSetType_TrafficLights31 IconSetType = 6 

// 3 traffic lights icon set with thick black border.
IconSetType_TrafficLights32 IconSetType = 7 

// 4 arrows icon set.
IconSetType_Arrows4 IconSetType = 8 

// 4 gray arrows icon set.
IconSetType_ArrowsGray4 IconSetType = 9 

// 4 ratings icon set.
IconSetType_Rating4 IconSetType = 10 

// 4 'red to black' icon set.
IconSetType_RedToBlack4 IconSetType = 11 

// 4 traffic lights icon set.
IconSetType_TrafficLights4 IconSetType = 12 

// 5 arrows icon set.
IconSetType_Arrows5 IconSetType = 13 

// 5 gray arrows icon set.
IconSetType_ArrowsGray5 IconSetType = 14 

// 5 quarters icon set.
IconSetType_Quarters5 IconSetType = 15 

// 5 rating icon set.
IconSetType_Rating5 IconSetType = 16 

// 3 stars set
IconSetType_Stars3 IconSetType = 17 

// 5 boxes set
IconSetType_Boxes5 IconSetType = 18 

// 3 triangles set
IconSetType_Triangles3 IconSetType = 19 

// None
IconSetType_None IconSetType = 20 

// CustomSet.
// This element is read-only.
IconSetType_CustomSet IconSetType = 21 

// 3 smilies.
// Only for .ods.
IconSetType_Smilies3 IconSetType = 22 

// 3 color smilies.
// Only for .ods.
IconSetType_ColorSmilies3 IconSetType = 23 
)

func Int32ToIconSetType(value int32)(IconSetType ,error){
	switch value {
		case 0:  return IconSetType_Arrows3, nil  
		case 1:  return IconSetType_ArrowsGray3, nil  
		case 2:  return IconSetType_Flags3, nil  
		case 3:  return IconSetType_Signs3, nil  
		case 4:  return IconSetType_Symbols3, nil  
		case 5:  return IconSetType_Symbols32, nil  
		case 6:  return IconSetType_TrafficLights31, nil  
		case 7:  return IconSetType_TrafficLights32, nil  
		case 8:  return IconSetType_Arrows4, nil  
		case 9:  return IconSetType_ArrowsGray4, nil  
		case 10:  return IconSetType_Rating4, nil  
		case 11:  return IconSetType_RedToBlack4, nil  
		case 12:  return IconSetType_TrafficLights4, nil  
		case 13:  return IconSetType_Arrows5, nil  
		case 14:  return IconSetType_ArrowsGray5, nil  
		case 15:  return IconSetType_Quarters5, nil  
		case 16:  return IconSetType_Rating5, nil  
		case 17:  return IconSetType_Stars3, nil  
		case 18:  return IconSetType_Boxes5, nil  
		case 19:  return IconSetType_Triangles3, nil  
		case 20:  return IconSetType_None, nil  
		case 21:  return IconSetType_CustomSet, nil  
		case 22:  return IconSetType_Smilies3, nil  
		case 23:  return IconSetType_ColorSmilies3, nil  
		default:
			return 0 ,fmt.Errorf("invalid IconSetType value: %d", value)
	}
}

/**************Enum LoadDataFilterOptions *****************/

// Represents the options to filter data when loading workbook from template.
type LoadDataFilterOptions int32

const(
// Load all
LoadDataFilterOptions_All LoadDataFilterOptions = 2147483647 

// Load cells whose value is blank
LoadDataFilterOptions_CellBlank LoadDataFilterOptions = 1 

// Load cells whose value is string
LoadDataFilterOptions_CellString LoadDataFilterOptions = 2 

// Load cells whose value is numeric(including datetime)
LoadDataFilterOptions_CellNumeric LoadDataFilterOptions = 4 

// Load cells whose value is error
LoadDataFilterOptions_CellError LoadDataFilterOptions = 8 

// Load cells whose value is bool
LoadDataFilterOptions_CellBool LoadDataFilterOptions = 16 

// Load cells value(all value types) only
LoadDataFilterOptions_CellValue LoadDataFilterOptions = 31 

// Load cell formulas.
LoadDataFilterOptions_Formula LoadDataFilterOptions = 32 

// Load cells data including values, formulas and formatting
LoadDataFilterOptions_CellData LoadDataFilterOptions = 67108927 

// Load charts
LoadDataFilterOptions_Chart LoadDataFilterOptions = 256 

// Drawing objects(including Chart, Picture, OleObject and all other drawing objects)
LoadDataFilterOptions_Drawing LoadDataFilterOptions = 402653952 

// Load merged cells
LoadDataFilterOptions_MergedArea LoadDataFilterOptions = 1024 

// Load conditional formatting
LoadDataFilterOptions_ConditionalFormatting LoadDataFilterOptions = 2048 

// Load data validations
LoadDataFilterOptions_DataValidation LoadDataFilterOptions = 4096 

// Load pivot tables
LoadDataFilterOptions_PivotTable LoadDataFilterOptions = 8192 

// Load tables
LoadDataFilterOptions_Table LoadDataFilterOptions = 16384 

// Load hyperlinks
LoadDataFilterOptions_Hyperlinks LoadDataFilterOptions = 32768 

// Load settings for worksheet
LoadDataFilterOptions_SheetSettings LoadDataFilterOptions = 65536 

// Load all data of worksheet, such as cells data, settings, objects, ...etc.
LoadDataFilterOptions_SheetData LoadDataFilterOptions = 403701759 

// Load settings for workbook
LoadDataFilterOptions_BookSettings LoadDataFilterOptions = 1048576 

// Load settings for workbook and worksheet
LoadDataFilterOptions_Settings LoadDataFilterOptions = 1114112 

// Load XmlMap
LoadDataFilterOptions_XmlMap LoadDataFilterOptions = 2097152 

// Load structure of the workbook
LoadDataFilterOptions_Structure LoadDataFilterOptions = 4194304 

// Load document properties
LoadDataFilterOptions_Document_Properties LoadDataFilterOptions = 8388608 

// Load defined Name objects
LoadDataFilterOptions_DefinedNames LoadDataFilterOptions = 16777216 

// Load VBA projects
LoadDataFilterOptions_VBA LoadDataFilterOptions = 33554432 

// Load styles for cell formatting
LoadDataFilterOptions_Style LoadDataFilterOptions = 67108864 

// Load pictures
LoadDataFilterOptions_Picture LoadDataFilterOptions = 134217728 

// Load OleObjects
LoadDataFilterOptions_OleObject LoadDataFilterOptions = 268435456 

// Load revision logs
LoadDataFilterOptions_Revision LoadDataFilterOptions = 536870912 
)

func Int32ToLoadDataFilterOptions(value int32)(LoadDataFilterOptions ,error){
	switch value {
		case 2147483647:  return LoadDataFilterOptions_All, nil  
		case 1:  return LoadDataFilterOptions_CellBlank, nil  
		case 2:  return LoadDataFilterOptions_CellString, nil  
		case 4:  return LoadDataFilterOptions_CellNumeric, nil  
		case 8:  return LoadDataFilterOptions_CellError, nil  
		case 16:  return LoadDataFilterOptions_CellBool, nil  
		case 31:  return LoadDataFilterOptions_CellValue, nil  
		case 32:  return LoadDataFilterOptions_Formula, nil  
		case 67108927:  return LoadDataFilterOptions_CellData, nil  
		case 256:  return LoadDataFilterOptions_Chart, nil  
		case 402653952:  return LoadDataFilterOptions_Drawing, nil  
		case 1024:  return LoadDataFilterOptions_MergedArea, nil  
		case 2048:  return LoadDataFilterOptions_ConditionalFormatting, nil  
		case 4096:  return LoadDataFilterOptions_DataValidation, nil  
		case 8192:  return LoadDataFilterOptions_PivotTable, nil  
		case 16384:  return LoadDataFilterOptions_Table, nil  
		case 32768:  return LoadDataFilterOptions_Hyperlinks, nil  
		case 65536:  return LoadDataFilterOptions_SheetSettings, nil  
		case 403701759:  return LoadDataFilterOptions_SheetData, nil  
		case 1048576:  return LoadDataFilterOptions_BookSettings, nil  
		case 1114112:  return LoadDataFilterOptions_Settings, nil  
		case 2097152:  return LoadDataFilterOptions_XmlMap, nil  
		case 4194304:  return LoadDataFilterOptions_Structure, nil  
		case 8388608:  return LoadDataFilterOptions_Document_Properties, nil  
		case 16777216:  return LoadDataFilterOptions_DefinedNames, nil  
		case 33554432:  return LoadDataFilterOptions_VBA, nil  
		case 67108864:  return LoadDataFilterOptions_Style, nil  
		case 134217728:  return LoadDataFilterOptions_Picture, nil  
		case 268435456:  return LoadDataFilterOptions_OleObject, nil  
		case 536870912:  return LoadDataFilterOptions_Revision, nil  
		default:
			return 0 ,fmt.Errorf("invalid LoadDataFilterOptions value: %d", value)
	}
}

/**************Enum LoadFormat *****************/

// Represents the load file format.
type LoadFormat int32

const(
// Represents recognizing the format automatically.
LoadFormat_Auto LoadFormat = 0 

// Comma-Separated Values(CSV) text file.
LoadFormat_Csv LoadFormat = 1 

// Represents Office Open XML spreadsheetML workbook or template, with or without macros.
LoadFormat_Xlsx LoadFormat = 6 

// Tab-Separated Values(TSV) text file.
LoadFormat_Tsv LoadFormat = 11 

// Represents a html file.
LoadFormat_Html LoadFormat = 12 

// Represents a mhtml file.
LoadFormat_MHtml LoadFormat = 13 

// Open Document Sheet(ODS) file.
LoadFormat_Ods LoadFormat = 14 

// Represents an Excel97-2003 xls file.
LoadFormat_Excel97To2003 LoadFormat = 5 

// Represents an Excel 2003 xml file.
LoadFormat_SpreadsheetML LoadFormat = 15 

// Represents an xlsb file.
LoadFormat_Xlsb LoadFormat = 16 

// Open Document Template Sheet(OTS) file.
LoadFormat_Ots LoadFormat = 31 

// Represents a numbers file.
LoadFormat_Numbers LoadFormat = 56 

// Represents OpenDocument Flat XML Spreadsheet (.fods) file format.
LoadFormat_Fods LoadFormat = 59 

// Represents StarOffice Calc Spreadsheet (.sxc) file format.
LoadFormat_Sxc LoadFormat = 60 

// Represents a simple xml file.
LoadFormat_Xml LoadFormat = 51 

// Reprents an EPUB file.
LoadFormat_Epub LoadFormat = 52 

// Represents an AZW3 file.
LoadFormat_Azw3 LoadFormat = 53 

// Represents a CHM file.
LoadFormat_Chm LoadFormat = 54 

// Represents a Markdown file.
LoadFormat_Markdown LoadFormat = 55 

// Represents unrecognized format, cannot be loaded.
LoadFormat_Unknown LoadFormat = 255 

// Image
LoadFormat_Image LoadFormat = 254 

// Json
LoadFormat_Json LoadFormat = 513 

// Data Interchange Format.
LoadFormat_Dif LoadFormat = 30 

// Xbase Data file
LoadFormat_Dbf LoadFormat = 515 
)

func Int32ToLoadFormat(value int32)(LoadFormat ,error){
	switch value {
		case 0:  return LoadFormat_Auto, nil  
		case 1:  return LoadFormat_Csv, nil  
		case 6:  return LoadFormat_Xlsx, nil  
		case 11:  return LoadFormat_Tsv, nil  
		case 12:  return LoadFormat_Html, nil  
		case 13:  return LoadFormat_MHtml, nil  
		case 14:  return LoadFormat_Ods, nil  
		case 5:  return LoadFormat_Excel97To2003, nil  
		case 15:  return LoadFormat_SpreadsheetML, nil  
		case 16:  return LoadFormat_Xlsb, nil  
		case 31:  return LoadFormat_Ots, nil  
		case 56:  return LoadFormat_Numbers, nil  
		case 59:  return LoadFormat_Fods, nil  
		case 60:  return LoadFormat_Sxc, nil  
		case 51:  return LoadFormat_Xml, nil  
		case 52:  return LoadFormat_Epub, nil  
		case 53:  return LoadFormat_Azw3, nil  
		case 54:  return LoadFormat_Chm, nil  
		case 55:  return LoadFormat_Markdown, nil  
		case 255:  return LoadFormat_Unknown, nil  
		case 254:  return LoadFormat_Image, nil  
		case 513:  return LoadFormat_Json, nil  
		case 30:  return LoadFormat_Dif, nil  
		case 515:  return LoadFormat_Dbf, nil  
		default:
			return 0 ,fmt.Errorf("invalid LoadFormat value: %d", value)
	}
}

/**************Enum LookAtType *****************/

// Represents look at type.
type LookAtType int32

const(
// Cell value Contains the find object.
LookAtType_Contains LookAtType = 0 

// Cell value Starts with the find object.
LookAtType_StartWith LookAtType = 1 

// Cell value ends with the find object.
LookAtType_EndWith LookAtType = 2 

// Cell value is same as the find object.
LookAtType_EntireContent LookAtType = 3 
)

func Int32ToLookAtType(value int32)(LookAtType ,error){
	switch value {
		case 0:  return LookAtType_Contains, nil  
		case 1:  return LookAtType_StartWith, nil  
		case 2:  return LookAtType_EndWith, nil  
		case 3:  return LookAtType_EntireContent, nil  
		default:
			return 0 ,fmt.Errorf("invalid LookAtType value: %d", value)
	}
}

/**************Enum LookInType *****************/

// Represents look in type.
type LookInType int32

const(
// Finds the searched object from formula(<see cref="Cell.Formula"/>) if the cell is formula,
// otherwise finds from cell's original value(same with <see cref="OriginalValues"/>).
LookInType_Formulas LookInType = 0 

// Finds object from cell's original value(<see cref="Cell.Value"/>)
// and formatted value(<see cref="Cell.StringValue"/>).
LookInType_Values LookInType = 1 

// Ignores cells that are formula. For those cells that are not formula,
// it is same with <see cref="Values"/>.
LookInType_ValuesExcludeFormulaCell LookInType = 2 

// Finds object from cell's comment only. Ignores those cells that have no comment.
LookInType_Comments LookInType = 3 

// Ignores cells that are not formula. For those cells that are formula,
// finds the searched object from formula(<see cref="Cell.Formula"/>).
LookInType_OnlyFormulas LookInType = 4 

// Find object from cell's original value only.
LookInType_OriginalValues LookInType = 5 

// Find object from cell's formatted value(<see cref="Cell.StringValue"/>) only.
LookInType_FormattedValues LookInType = 6 
)

func Int32ToLookInType(value int32)(LookInType ,error){
	switch value {
		case 0:  return LookInType_Formulas, nil  
		case 1:  return LookInType_Values, nil  
		case 2:  return LookInType_ValuesExcludeFormulaCell, nil  
		case 3:  return LookInType_Comments, nil  
		case 4:  return LookInType_OnlyFormulas, nil  
		case 5:  return LookInType_OriginalValues, nil  
		case 6:  return LookInType_FormattedValues, nil  
		default:
			return 0 ,fmt.Errorf("invalid LookInType value: %d", value)
	}
}

/**************Enum MemorySetting *****************/

// Memory usage modes for cells data model.
type MemorySetting int32

const(
// Default mode for cells model.
MemorySetting_Normal MemorySetting = 0 

// Memory performance preferrable.
MemorySetting_MemoryPreference MemorySetting = 1 
)

func Int32ToMemorySetting(value int32)(MemorySetting ,error){
	switch value {
		case 0:  return MemorySetting_Normal, nil  
		case 1:  return MemorySetting_MemoryPreference, nil  
		default:
			return 0 ,fmt.Errorf("invalid MemorySetting value: %d", value)
	}
}

/**************Enum MergedCellsShrinkType *****************/

// Represents the strategy to shrink merged cells for operations such as deleting blank rows/column.
type MergedCellsShrinkType int32

const(
// Leaves the merged cells as it is without any modification.
MergedCellsShrinkType_None MergedCellsShrinkType = 0 

// Shrinks the merged area if needed, by removing rows from the bottom or columns from the right,
// while ensuring all content remains visible.
MergedCellsShrinkType_ShrinkToFit MergedCellsShrinkType = 1 

// Only keeps the header rows/columns of the merged area when the top-left cell of the merged area is not blank.
MergedCellsShrinkType_KeepHeaderOnly MergedCellsShrinkType = 2 
)

func Int32ToMergedCellsShrinkType(value int32)(MergedCellsShrinkType ,error){
	switch value {
		case 0:  return MergedCellsShrinkType_None, nil  
		case 1:  return MergedCellsShrinkType_ShrinkToFit, nil  
		case 2:  return MergedCellsShrinkType_KeepHeaderOnly, nil  
		default:
			return 0 ,fmt.Errorf("invalid MergedCellsShrinkType value: %d", value)
	}
}

/**************Enum MergeEmptyTdType *****************/

// Represents the merge type for empty TD element when exporting file to html.
type MergeEmptyTdType int32

const(
// Display like MS Excel.
MergeEmptyTdType_Default MergeEmptyTdType = 0 

// Empty TD elements will not be merged when exporting file to html.
// This will generate a significantly larger html file.
MergeEmptyTdType_None MergeEmptyTdType = 1 

// Merging empty TD element forcedly when exporting file to html.
// The size of html file will be reduced significantly after setting value to true.
// If you want to import the html file to excel or export perfect grid lines when saving file to html,
// please keep the default value.
MergeEmptyTdType_MergeForcely MergeEmptyTdType = 2 
)

func Int32ToMergeEmptyTdType(value int32)(MergeEmptyTdType ,error){
	switch value {
		case 0:  return MergeEmptyTdType_Default, nil  
		case 1:  return MergeEmptyTdType_None, nil  
		case 2:  return MergeEmptyTdType_MergeForcely, nil  
		default:
			return 0 ,fmt.Errorf("invalid MergeEmptyTdType value: %d", value)
	}
}

/**************Enum NameScopeType *****************/

// Represents the scope type of defined names.
type NameScopeType int32

const(
// All defined names.
NameScopeType_All NameScopeType = 0 

// The defined names in the workbook.
NameScopeType_Workbook NameScopeType = 1 

// The defined names in a worksheet or all worksheets.
NameScopeType_Worksheet NameScopeType = 2 
)

func Int32ToNameScopeType(value int32)(NameScopeType ,error){
	switch value {
		case 0:  return NameScopeType_All, nil  
		case 1:  return NameScopeType_Workbook, nil  
		case 2:  return NameScopeType_Worksheet, nil  
		default:
			return 0 ,fmt.Errorf("invalid NameScopeType value: %d", value)
	}
}

/**************Enum NumberCategoryType *****************/

// Represents category type of cell's number formatting.
type NumberCategoryType int32

const(
// General
NumberCategoryType_General NumberCategoryType = 0 

// Text
NumberCategoryType_Text NumberCategoryType = 1 

// Number
NumberCategoryType_Number NumberCategoryType = 2 

// Date or Date and Time
NumberCategoryType_Date NumberCategoryType = 3 

// Time
NumberCategoryType_Time NumberCategoryType = 4 

// Fraction
NumberCategoryType_Fraction NumberCategoryType = 5 

// Scientific
NumberCategoryType_Scientific NumberCategoryType = 6 
)

func Int32ToNumberCategoryType(value int32)(NumberCategoryType ,error){
	switch value {
		case 0:  return NumberCategoryType_General, nil  
		case 1:  return NumberCategoryType_Text, nil  
		case 2:  return NumberCategoryType_Number, nil  
		case 3:  return NumberCategoryType_Date, nil  
		case 4:  return NumberCategoryType_Time, nil  
		case 5:  return NumberCategoryType_Fraction, nil  
		case 6:  return NumberCategoryType_Scientific, nil  
		default:
			return 0 ,fmt.Errorf("invalid NumberCategoryType value: %d", value)
	}
}

/**************Enum ObjectType *****************/

// Represents the type of the number.
type ObjectType int32

const(
// The object is empty.
ObjectType_Null ObjectType = 0 

// The object is bool type.
ObjectType_Bool ObjectType = 1 

// The object is number type.
ObjectType_Number ObjectType = 2 

// The object is date type.
ObjectType_Date ObjectType = 3 

// The object is color type.
ObjectType_Color ObjectType = 4 

// The object is string type.
ObjectType_String ObjectType = 5 

// The object is ReferredArea type.
ObjectType_ReferredArea ObjectType = 6 

// The object is Range type.
ObjectType_Range ObjectType = 7 

// The object is a one-dimensional array.
ObjectType_Array1D ObjectType = 8 

// The object is a two-dimensional array.
ObjectType_Array2D ObjectType = 9 


ObjectType_Int8 ObjectType = 10 


ObjectType_UInt8 ObjectType = 11 


ObjectType_Int16 ObjectType = 12 


ObjectType_UInt16 ObjectType = 13 


ObjectType_Int32 ObjectType = 14 


ObjectType_UInt32 ObjectType = 15 


ObjectType_Int64 ObjectType = 16 


ObjectType_UInt64 ObjectType = 17 


ObjectType_Float ObjectType = 18 
)

func Int32ToObjectType(value int32)(ObjectType ,error){
	switch value {
		case 0:  return ObjectType_Null, nil  
		case 1:  return ObjectType_Bool, nil  
		case 2:  return ObjectType_Number, nil  
		case 3:  return ObjectType_Date, nil  
		case 4:  return ObjectType_Color, nil  
		case 5:  return ObjectType_String, nil  
		case 6:  return ObjectType_ReferredArea, nil  
		case 7:  return ObjectType_Range, nil  
		case 8:  return ObjectType_Array1D, nil  
		case 9:  return ObjectType_Array2D, nil  
		case 10:  return ObjectType_Int8, nil  
		case 11:  return ObjectType_UInt8, nil  
		case 12:  return ObjectType_Int16, nil  
		case 13:  return ObjectType_UInt16, nil  
		case 14:  return ObjectType_Int32, nil  
		case 15:  return ObjectType_UInt32, nil  
		case 16:  return ObjectType_Int64, nil  
		case 17:  return ObjectType_UInt64, nil  
		case 18:  return ObjectType_Float, nil  
		default:
			return 0 ,fmt.Errorf("invalid ObjectType value: %d", value)
	}
}

/**************Enum OoxmlCompliance *****************/

// Allows to specify which OOXML specification will be used when saving in the Xlsx format.
type OoxmlCompliance int32

const(
// ECMA-376 1st Edition, 2006.
OoxmlCompliance_Ecma376_2006 OoxmlCompliance = 0 

// ISO/IEC 29500:2008 Strict compliance level.
OoxmlCompliance_Iso29500_2008_Strict OoxmlCompliance = 1 
)

func Int32ToOoxmlCompliance(value int32)(OoxmlCompliance ,error){
	switch value {
		case 0:  return OoxmlCompliance_Ecma376_2006, nil  
		case 1:  return OoxmlCompliance_Iso29500_2008_Strict, nil  
		default:
			return 0 ,fmt.Errorf("invalid OoxmlCompliance value: %d", value)
	}
}

/**************Enum OoxmlCompressionType *****************/

// The Ooxml compression type
type OoxmlCompressionType int32

const(
// The fastest but least effective compression.
OoxmlCompressionType_Level1 OoxmlCompressionType = 1 

// A little slower, but better, than level 1.
OoxmlCompressionType_Level2 OoxmlCompressionType = 2 

// A little slower, but better, than level 2.
OoxmlCompressionType_Level3 OoxmlCompressionType = 3 

// A little slower, but better, than level 3.
OoxmlCompressionType_Level4 OoxmlCompressionType = 4 

// A little slower than level 4, but with better compression.
OoxmlCompressionType_Level5 OoxmlCompressionType = 5 

// A good balance of speed and compression efficiency.
OoxmlCompressionType_Level6 OoxmlCompressionType = 6 

// Pretty good compression!
OoxmlCompressionType_Level7 OoxmlCompressionType = 7 

// Better compression than Level7!
OoxmlCompressionType_Level8 OoxmlCompressionType = 8 

// The "best" compression, where best means greatest reduction in size of the input data stream.
// This is also the slowest compression.
OoxmlCompressionType_Level9 OoxmlCompressionType = 9 
)

func Int32ToOoxmlCompressionType(value int32)(OoxmlCompressionType ,error){
	switch value {
		case 1:  return OoxmlCompressionType_Level1, nil  
		case 2:  return OoxmlCompressionType_Level2, nil  
		case 3:  return OoxmlCompressionType_Level3, nil  
		case 4:  return OoxmlCompressionType_Level4, nil  
		case 5:  return OoxmlCompressionType_Level5, nil  
		case 6:  return OoxmlCompressionType_Level6, nil  
		case 7:  return OoxmlCompressionType_Level7, nil  
		case 8:  return OoxmlCompressionType_Level8, nil  
		case 9:  return OoxmlCompressionType_Level9, nil  
		default:
			return 0 ,fmt.Errorf("invalid OoxmlCompressionType value: %d", value)
	}
}

/**************Enum OperatorType *****************/

// Represents the operator type of conditional format and data validation.
type OperatorType int32

const(
// Represents Between operator of conditional format and data validation.
OperatorType_Between OperatorType = 0 

// Represents Equal operator of conditional format and data validation.
OperatorType_Equal OperatorType = 1 

// Represents GreaterThan operator of conditional format and data validation.
OperatorType_GreaterThan OperatorType = 2 

// Represents GreaterOrEqual operator of conditional format and data validation.
OperatorType_GreaterOrEqual OperatorType = 3 

// Represents LessThan operator of conditional format and data validation.
OperatorType_LessThan OperatorType = 4 

// Represents LessOrEqual operator of conditional format and data validation.
OperatorType_LessOrEqual OperatorType = 5 

// Represents no comparison.
OperatorType_None OperatorType = 6 

// Represents NotBetween operator of conditional format and data validation.
OperatorType_NotBetween OperatorType = 7 

// Represents NotEqual operator of conditional format and data validation.
OperatorType_NotEqual OperatorType = 8 
)

func Int32ToOperatorType(value int32)(OperatorType ,error){
	switch value {
		case 0:  return OperatorType_Between, nil  
		case 1:  return OperatorType_Equal, nil  
		case 2:  return OperatorType_GreaterThan, nil  
		case 3:  return OperatorType_GreaterOrEqual, nil  
		case 4:  return OperatorType_LessThan, nil  
		case 5:  return OperatorType_LessOrEqual, nil  
		case 6:  return OperatorType_None, nil  
		case 7:  return OperatorType_NotBetween, nil  
		case 8:  return OperatorType_NotEqual, nil  
		default:
			return 0 ,fmt.Errorf("invalid OperatorType value: %d", value)
	}
}

/**************Enum PageLayoutAlignmentType *****************/

// Enumerates page layout alignment types.
type PageLayoutAlignmentType int32

const(
// Represents bottom page layout alignment.
PageLayoutAlignmentType_Bottom PageLayoutAlignmentType = 0 

// Represents center page layout alignment.
PageLayoutAlignmentType_Center PageLayoutAlignmentType = 1 

// Represents left page layout alignment.
PageLayoutAlignmentType_Left PageLayoutAlignmentType = 2 

// Represents right page layout alignment.
PageLayoutAlignmentType_Right PageLayoutAlignmentType = 3 

// Represents top page layout alignment.
PageLayoutAlignmentType_Top PageLayoutAlignmentType = 4 
)

func Int32ToPageLayoutAlignmentType(value int32)(PageLayoutAlignmentType ,error){
	switch value {
		case 0:  return PageLayoutAlignmentType_Bottom, nil  
		case 1:  return PageLayoutAlignmentType_Center, nil  
		case 2:  return PageLayoutAlignmentType_Left, nil  
		case 3:  return PageLayoutAlignmentType_Right, nil  
		case 4:  return PageLayoutAlignmentType_Top, nil  
		default:
			return 0 ,fmt.Errorf("invalid PageLayoutAlignmentType value: %d", value)
	}
}

/**************Enum PageOrientationType *****************/

// Represents print orientation constants.
type PageOrientationType int32

const(
// Landscape orientation
PageOrientationType_Landscape PageOrientationType = 0 

// Portrait orientation
PageOrientationType_Portrait PageOrientationType = 1 
)

func Int32ToPageOrientationType(value int32)(PageOrientationType ,error){
	switch value {
		case 0:  return PageOrientationType_Landscape, nil  
		case 1:  return PageOrientationType_Portrait, nil  
		default:
			return 0 ,fmt.Errorf("invalid PageOrientationType value: %d", value)
	}
}

/**************Enum PaneStateType *****************/

// Represents state of the sheet's pane.
type PaneStateType int32

const(
// Panes are frozen, but were not before being frozen.
PaneStateType_Frozen PaneStateType = 0 

// Panes are frozen and were split before being frozen.
PaneStateType_FrozenSplit PaneStateType = 1 

// Panes are split, but not frozen.
PaneStateType_Split PaneStateType = 2 

// Panes are not frozen and not split.
PaneStateType_Normal PaneStateType = 3 
)

func Int32ToPaneStateType(value int32)(PaneStateType ,error){
	switch value {
		case 0:  return PaneStateType_Frozen, nil  
		case 1:  return PaneStateType_FrozenSplit, nil  
		case 2:  return PaneStateType_Split, nil  
		case 3:  return PaneStateType_Normal, nil  
		default:
			return 0 ,fmt.Errorf("invalid PaneStateType value: %d", value)
	}
}

/**************Enum PaperSizeType *****************/

// Represents paper size constants.
type PaperSizeType int32

const(
// Letter (8-1/2 in. x 11 in.)
PaperSizeType_PaperLetter PaperSizeType = 1 

// Letter Small (8-1/2 in. x 11 in.)
PaperSizeType_PaperLetterSmall PaperSizeType = 2 

// Tabloid (11 in. x 17 in.)
PaperSizeType_PaperTabloid PaperSizeType = 3 

// Ledger (17 in. x 11 in.)
PaperSizeType_PaperLedger PaperSizeType = 4 

// Legal (8-1/2 in. x 14 in.)
PaperSizeType_PaperLegal PaperSizeType = 5 

// Statement (5-1/2 in. x 8-1/2 in.)
PaperSizeType_PaperStatement PaperSizeType = 6 

// Executive (7-1/4 in. x 10-1/2 in.)
PaperSizeType_PaperExecutive PaperSizeType = 7 

// A3 (297 mm x 420 mm)
PaperSizeType_PaperA3 PaperSizeType = 8 

// A4 (210 mm x 297 mm)
PaperSizeType_PaperA4 PaperSizeType = 9 

// A4 Small (210 mm x 297 mm)
PaperSizeType_PaperA4Small PaperSizeType = 10 

// A5 (148 mm x 210 mm)
PaperSizeType_PaperA5 PaperSizeType = 11 

// JIS B4 (257 mm x 364 mm)
PaperSizeType_PaperB4 PaperSizeType = 12 

// JIS B5 (182 mm x 257 mm)
PaperSizeType_PaperB5 PaperSizeType = 13 

// Folio (8-1/2 in. x 13 in.)
PaperSizeType_PaperFolio PaperSizeType = 14 

// Quarto (215 mm x 275 mm)
PaperSizeType_PaperQuarto PaperSizeType = 15 

// 10 in. x 14 in.
PaperSizeType_Paper10x14 PaperSizeType = 16 

// 11 in. x 17 in.
PaperSizeType_Paper11x17 PaperSizeType = 17 

// Note (8-1/2 in. x 11 in.)
PaperSizeType_PaperNote PaperSizeType = 18 

// Envelope #9 (3-7/8 in. x 8-7/8 in.)
PaperSizeType_PaperEnvelope9 PaperSizeType = 19 

// Envelope #10 (4-1/8 in. x 9-1/2 in.)
PaperSizeType_PaperEnvelope10 PaperSizeType = 20 

// Envelope #11 (4-1/2 in. x 10-3/8 in.)
PaperSizeType_PaperEnvelope11 PaperSizeType = 21 

// Envelope #12 (4-1/2 in. x 11 in.)
PaperSizeType_PaperEnvelope12 PaperSizeType = 22 

// Envelope #14 (5 in. x 11-1/2 in.)
PaperSizeType_PaperEnvelope14 PaperSizeType = 23 

// C size sheet
PaperSizeType_PaperCSheet PaperSizeType = 24 

// D size sheet
PaperSizeType_PaperDSheet PaperSizeType = 25 

// E size sheet
PaperSizeType_PaperESheet PaperSizeType = 26 

// Envelope DL (110 mm x 220 mm)
PaperSizeType_PaperEnvelopeDL PaperSizeType = 27 

// Envelope C5 (162 mm x 229 mm)
PaperSizeType_PaperEnvelopeC5 PaperSizeType = 28 

// Envelope C3 (324 mm x 458 mm)
PaperSizeType_PaperEnvelopeC3 PaperSizeType = 29 

// Envelope C4 (229 mm x 324 mm)
PaperSizeType_PaperEnvelopeC4 PaperSizeType = 30 

// Envelope C6 (114 mm x 162 mm)
PaperSizeType_PaperEnvelopeC6 PaperSizeType = 31 

// Envelope C65 (114 mm x 229 mm)
PaperSizeType_PaperEnvelopeC65 PaperSizeType = 32 

// Envelope B4 (250 mm x 353 mm)
PaperSizeType_PaperEnvelopeB4 PaperSizeType = 33 

// Envelope B5 (176 mm x 250 mm)
PaperSizeType_PaperEnvelopeB5 PaperSizeType = 34 

// Envelope B6 (176 mm x 125 mm)
PaperSizeType_PaperEnvelopeB6 PaperSizeType = 35 

// Envelope Italy (110 mm x 230 mm)
PaperSizeType_PaperEnvelopeItaly PaperSizeType = 36 

// Envelope Monarch (3-7/8 in. x 7-1/2 in.)
PaperSizeType_PaperEnvelopeMonarch PaperSizeType = 37 

// Envelope (3-5/8 in. x 6-1/2 in.)
PaperSizeType_PaperEnvelopePersonal PaperSizeType = 38 

// U.S. Standard Fanfold (14-7/8 in. x 11 in.)
PaperSizeType_PaperFanfoldUS PaperSizeType = 39 

// German Standard Fanfold (8-1/2 in. x 12 in.)
PaperSizeType_PaperFanfoldStdGerman PaperSizeType = 40 

// German Legal Fanfold (8-1/2 in. x 13 in.)
PaperSizeType_PaperFanfoldLegalGerman PaperSizeType = 41 

// B4 (ISO) 250 x 353 mm
PaperSizeType_PaperISOB4 PaperSizeType = 42 

// Japanese Postcard (100mm  148mm)
PaperSizeType_PaperJapanesePostcard PaperSizeType = 43 

// 9?  11?
PaperSizeType_Paper9x11 PaperSizeType = 44 

// 10?  11?
PaperSizeType_Paper10x11 PaperSizeType = 45 

// 15?  11?
PaperSizeType_Paper15x11 PaperSizeType = 46 

// Envelope Invite(220mm  220mm)
PaperSizeType_PaperEnvelopeInvite PaperSizeType = 47 

// US Letter Extra 9 \275 x 12 in
PaperSizeType_PaperLetterExtra PaperSizeType = 50 

// US Legal Extra 9 \275 x 15 in
PaperSizeType_PaperLegalExtra PaperSizeType = 51 

// US Tabloid Extra 11.69 x 18 in
PaperSizeType_PaperTabloidExtra PaperSizeType = 52 

// A4 Extra 9.27 x 12.69 in
PaperSizeType_PaperA4Extra PaperSizeType = 53 

// Letter Transverse 8 \275 x 11 in
PaperSizeType_PaperLetterTransverse PaperSizeType = 54 

// A4 Transverse 210 x 297 mm
PaperSizeType_PaperA4Transverse PaperSizeType = 55 

// Letter Extra Transverse 9\275 x 12 in
PaperSizeType_PaperLetterExtraTransverse PaperSizeType = 56 

// SuperA/SuperA/A4 227 x 356 mm
PaperSizeType_PaperSuperA PaperSizeType = 57 

// SuperB/SuperB/A3 305 x 487 mm
PaperSizeType_PaperSuperB PaperSizeType = 58 

// US Letter Plus 8.5 x 12.69 in
PaperSizeType_PaperLetterPlus PaperSizeType = 59 

// A4 Plus 210 x 330 mm
PaperSizeType_PaperA4Plus PaperSizeType = 60 

// A5 Transverse 148 x 210 mm
PaperSizeType_PaperA5Transverse PaperSizeType = 61 

// B5 (JIS) Transverse 182 x 257 mm
PaperSizeType_PaperJISB5Transverse PaperSizeType = 62 

// A3 Extra 322 x 445 mm
PaperSizeType_PaperA3Extra PaperSizeType = 63 

// A5 Extra 174 x 235 mm
PaperSizeType_PaperA5Extra PaperSizeType = 64 

// B5 (ISO) Extra 201 x 276 mm
PaperSizeType_PaperISOB5Extra PaperSizeType = 65 

// A2 420 x 594 mm
PaperSizeType_PaperA2 PaperSizeType = 66 

// A3 Transverse 297 x 420 mm
PaperSizeType_PaperA3Transverse PaperSizeType = 67 

// A3 Extra Transverse 322 x 445 mm
PaperSizeType_PaperA3ExtraTransverse PaperSizeType = 68 

// Japanese Double Postcard 200 x 148 mm
PaperSizeType_PaperJapaneseDoublePostcard PaperSizeType = 69 

// A6 105 x 148 mm
PaperSizeType_PaperA6 PaperSizeType = 70 

// Japanese Envelope Kaku #2
PaperSizeType_PaperJapaneseEnvelopeKaku2 PaperSizeType = 71 

// Japanese Envelope Kaku #3
PaperSizeType_PaperJapaneseEnvelopeKaku3 PaperSizeType = 72 

// Japanese Envelope Chou #3
PaperSizeType_PaperJapaneseEnvelopeChou3 PaperSizeType = 73 

// Japanese Envelope Chou #4
PaperSizeType_PaperJapaneseEnvelopeChou4 PaperSizeType = 74 

// 11in  8.5in
PaperSizeType_PaperLetterRotated PaperSizeType = 75 

// 420mm  297mm
PaperSizeType_PaperA3Rotated PaperSizeType = 76 

// 297mm  210mm
PaperSizeType_PaperA4Rotated PaperSizeType = 77 

// 210mm  148mm
PaperSizeType_PaperA5Rotated PaperSizeType = 78 

// B4 (JIS) Rotated 364 x 257 mm
PaperSizeType_PaperJISB4Rotated PaperSizeType = 79 

// B5 (JIS) Rotated 257 x 182 mm
PaperSizeType_PaperJISB5Rotated PaperSizeType = 80 

// Japanese Postcard Rotated 148 x 100 mm
PaperSizeType_PaperJapanesePostcardRotated PaperSizeType = 81 

// Double Japanese Postcard Rotated 148 x 200 mm
PaperSizeType_PaperJapaneseDoublePostcardRotated PaperSizeType = 82 

// A6 Rotated 148 x 105 mm
PaperSizeType_PaperA6Rotated PaperSizeType = 83 

// Japanese Envelope Kaku #2 Rotated
PaperSizeType_PaperJapaneseEnvelopeKaku2Rotated PaperSizeType = 84 

// Japanese Envelope Kaku #3 Rotated
PaperSizeType_PaperJapaneseEnvelopeKaku3Rotated PaperSizeType = 85 

// Japanese Envelope Chou #3 Rotated
PaperSizeType_PaperJapaneseEnvelopeChou3Rotated PaperSizeType = 86 

// Japanese Envelope Chou #4 Rotated
PaperSizeType_PaperJapaneseEnvelopeChou4Rotated PaperSizeType = 87 

// B6 (JIS) 128 x 182 mm
PaperSizeType_PaperJISB6 PaperSizeType = 88 

// B6 (JIS) Rotated 182 x 128 mm
PaperSizeType_PaperJISB6Rotated PaperSizeType = 89 

// 12 x 11 in
PaperSizeType_Paper12x11 PaperSizeType = 90 

// Japanese Envelope You #4
PaperSizeType_PaperJapaneseEnvelopeYou4 PaperSizeType = 91 

// Japanese Envelope You #4 Rotated
PaperSizeType_PaperJapaneseEnvelopeYou4Rotated PaperSizeType = 92 

// PRC 16K 146 x 215 mm
PaperSizeType_PaperPRC16K PaperSizeType = 93 

// PRC 32K 97 x 151 mm
PaperSizeType_PaperPRC32K PaperSizeType = 94 

// PRC 32K(Big) 97 x 151 mm
PaperSizeType_PaperPRCBig32K PaperSizeType = 95 

// PRC Envelope #1 102 x 165 mm
PaperSizeType_PaperPRCEnvelope1 PaperSizeType = 96 

// PRC Envelope #2 102 x 176 mm
PaperSizeType_PaperPRCEnvelope2 PaperSizeType = 97 

// PRC Envelope #3 125 x 176 mm
PaperSizeType_PaperPRCEnvelope3 PaperSizeType = 98 

// PRC Envelope #4 110 x 208 mm
PaperSizeType_PaperPRCEnvelope4 PaperSizeType = 99 

// PRC Envelope #5 110 x 220 mm
PaperSizeType_PaperPRCEnvelope5 PaperSizeType = 100 

// PRC Envelope #6 120 x 230 mm
PaperSizeType_PaperPRCEnvelope6 PaperSizeType = 101 

// PRC Envelope #7 160 x 230 mm
PaperSizeType_PaperPRCEnvelope7 PaperSizeType = 102 

// PRC Envelope #8 120 x 309 mm
PaperSizeType_PaperPRCEnvelope8 PaperSizeType = 103 

// PRC Envelope #9 229 x 324 mm
PaperSizeType_PaperPRCEnvelope9 PaperSizeType = 104 

// PRC Envelope #10 324 x 458 mm
PaperSizeType_PaperPRCEnvelope10 PaperSizeType = 105 

// PRC 16K Rotated
PaperSizeType_PaperPRC16KRotated PaperSizeType = 106 

// PRC 32K Rotated
PaperSizeType_PaperPRC32KRotated PaperSizeType = 107 

// PRC 32K(Big) Rotated
PaperSizeType_PaperPRCBig32KRotated PaperSizeType = 108 

// PRC Envelope #1 Rotated 165 x 102 mm
PaperSizeType_PaperPRCEnvelope1Rotated PaperSizeType = 109 

// PRC Envelope #2 Rotated 176 x 102 mm
PaperSizeType_PaperPRCEnvelope2Rotated PaperSizeType = 110 

// PRC Envelope #3 Rotated 176 x 125 mm
PaperSizeType_PaperPRCEnvelope3Rotated PaperSizeType = 111 

// PRC Envelope #4 Rotated 208 x 110 mm
PaperSizeType_PaperPRCEnvelope4Rotated PaperSizeType = 112 

// PRC Envelope #5 Rotated 220 x 110 mm
PaperSizeType_PaperPRCEnvelope5Rotated PaperSizeType = 113 

// PRC Envelope #6 Rotated 230 x 120 mm
PaperSizeType_PaperPRCEnvelope6Rotated PaperSizeType = 114 

// PRC Envelope #7 Rotated 230 x 160 mm
PaperSizeType_PaperPRCEnvelope7Rotated PaperSizeType = 115 

// PRC Envelope #8 Rotated 309 x 120 mm
PaperSizeType_PaperPRCEnvelope8Rotated PaperSizeType = 116 

// PRC Envelope #9 Rotated 324 x 229 mm
PaperSizeType_PaperPRCEnvelope9Rotated PaperSizeType = 117 

// PRC Envelope #10 Rotated 458 x 324 mm
PaperSizeType_PaperPRCEnvelope10Rotated PaperSizeType = 118 

// usual B3(13.9 x 19.7 in)
PaperSizeType_PaperB3 PaperSizeType = 300 

// Business Card(90mm x 55 mm)
PaperSizeType_PaperBusinessCard PaperSizeType = 301 

// Thermal(3 x 11 in)
PaperSizeType_PaperThermal PaperSizeType = 302 

// Represents the custom paper size.
PaperSizeType_Custom PaperSizeType = 0 
)

func Int32ToPaperSizeType(value int32)(PaperSizeType ,error){
	switch value {
		case 1:  return PaperSizeType_PaperLetter, nil  
		case 2:  return PaperSizeType_PaperLetterSmall, nil  
		case 3:  return PaperSizeType_PaperTabloid, nil  
		case 4:  return PaperSizeType_PaperLedger, nil  
		case 5:  return PaperSizeType_PaperLegal, nil  
		case 6:  return PaperSizeType_PaperStatement, nil  
		case 7:  return PaperSizeType_PaperExecutive, nil  
		case 8:  return PaperSizeType_PaperA3, nil  
		case 9:  return PaperSizeType_PaperA4, nil  
		case 10:  return PaperSizeType_PaperA4Small, nil  
		case 11:  return PaperSizeType_PaperA5, nil  
		case 12:  return PaperSizeType_PaperB4, nil  
		case 13:  return PaperSizeType_PaperB5, nil  
		case 14:  return PaperSizeType_PaperFolio, nil  
		case 15:  return PaperSizeType_PaperQuarto, nil  
		case 16:  return PaperSizeType_Paper10x14, nil  
		case 17:  return PaperSizeType_Paper11x17, nil  
		case 18:  return PaperSizeType_PaperNote, nil  
		case 19:  return PaperSizeType_PaperEnvelope9, nil  
		case 20:  return PaperSizeType_PaperEnvelope10, nil  
		case 21:  return PaperSizeType_PaperEnvelope11, nil  
		case 22:  return PaperSizeType_PaperEnvelope12, nil  
		case 23:  return PaperSizeType_PaperEnvelope14, nil  
		case 24:  return PaperSizeType_PaperCSheet, nil  
		case 25:  return PaperSizeType_PaperDSheet, nil  
		case 26:  return PaperSizeType_PaperESheet, nil  
		case 27:  return PaperSizeType_PaperEnvelopeDL, nil  
		case 28:  return PaperSizeType_PaperEnvelopeC5, nil  
		case 29:  return PaperSizeType_PaperEnvelopeC3, nil  
		case 30:  return PaperSizeType_PaperEnvelopeC4, nil  
		case 31:  return PaperSizeType_PaperEnvelopeC6, nil  
		case 32:  return PaperSizeType_PaperEnvelopeC65, nil  
		case 33:  return PaperSizeType_PaperEnvelopeB4, nil  
		case 34:  return PaperSizeType_PaperEnvelopeB5, nil  
		case 35:  return PaperSizeType_PaperEnvelopeB6, nil  
		case 36:  return PaperSizeType_PaperEnvelopeItaly, nil  
		case 37:  return PaperSizeType_PaperEnvelopeMonarch, nil  
		case 38:  return PaperSizeType_PaperEnvelopePersonal, nil  
		case 39:  return PaperSizeType_PaperFanfoldUS, nil  
		case 40:  return PaperSizeType_PaperFanfoldStdGerman, nil  
		case 41:  return PaperSizeType_PaperFanfoldLegalGerman, nil  
		case 42:  return PaperSizeType_PaperISOB4, nil  
		case 43:  return PaperSizeType_PaperJapanesePostcard, nil  
		case 44:  return PaperSizeType_Paper9x11, nil  
		case 45:  return PaperSizeType_Paper10x11, nil  
		case 46:  return PaperSizeType_Paper15x11, nil  
		case 47:  return PaperSizeType_PaperEnvelopeInvite, nil  
		case 50:  return PaperSizeType_PaperLetterExtra, nil  
		case 51:  return PaperSizeType_PaperLegalExtra, nil  
		case 52:  return PaperSizeType_PaperTabloidExtra, nil  
		case 53:  return PaperSizeType_PaperA4Extra, nil  
		case 54:  return PaperSizeType_PaperLetterTransverse, nil  
		case 55:  return PaperSizeType_PaperA4Transverse, nil  
		case 56:  return PaperSizeType_PaperLetterExtraTransverse, nil  
		case 57:  return PaperSizeType_PaperSuperA, nil  
		case 58:  return PaperSizeType_PaperSuperB, nil  
		case 59:  return PaperSizeType_PaperLetterPlus, nil  
		case 60:  return PaperSizeType_PaperA4Plus, nil  
		case 61:  return PaperSizeType_PaperA5Transverse, nil  
		case 62:  return PaperSizeType_PaperJISB5Transverse, nil  
		case 63:  return PaperSizeType_PaperA3Extra, nil  
		case 64:  return PaperSizeType_PaperA5Extra, nil  
		case 65:  return PaperSizeType_PaperISOB5Extra, nil  
		case 66:  return PaperSizeType_PaperA2, nil  
		case 67:  return PaperSizeType_PaperA3Transverse, nil  
		case 68:  return PaperSizeType_PaperA3ExtraTransverse, nil  
		case 69:  return PaperSizeType_PaperJapaneseDoublePostcard, nil  
		case 70:  return PaperSizeType_PaperA6, nil  
		case 71:  return PaperSizeType_PaperJapaneseEnvelopeKaku2, nil  
		case 72:  return PaperSizeType_PaperJapaneseEnvelopeKaku3, nil  
		case 73:  return PaperSizeType_PaperJapaneseEnvelopeChou3, nil  
		case 74:  return PaperSizeType_PaperJapaneseEnvelopeChou4, nil  
		case 75:  return PaperSizeType_PaperLetterRotated, nil  
		case 76:  return PaperSizeType_PaperA3Rotated, nil  
		case 77:  return PaperSizeType_PaperA4Rotated, nil  
		case 78:  return PaperSizeType_PaperA5Rotated, nil  
		case 79:  return PaperSizeType_PaperJISB4Rotated, nil  
		case 80:  return PaperSizeType_PaperJISB5Rotated, nil  
		case 81:  return PaperSizeType_PaperJapanesePostcardRotated, nil  
		case 82:  return PaperSizeType_PaperJapaneseDoublePostcardRotated, nil  
		case 83:  return PaperSizeType_PaperA6Rotated, nil  
		case 84:  return PaperSizeType_PaperJapaneseEnvelopeKaku2Rotated, nil  
		case 85:  return PaperSizeType_PaperJapaneseEnvelopeKaku3Rotated, nil  
		case 86:  return PaperSizeType_PaperJapaneseEnvelopeChou3Rotated, nil  
		case 87:  return PaperSizeType_PaperJapaneseEnvelopeChou4Rotated, nil  
		case 88:  return PaperSizeType_PaperJISB6, nil  
		case 89:  return PaperSizeType_PaperJISB6Rotated, nil  
		case 90:  return PaperSizeType_Paper12x11, nil  
		case 91:  return PaperSizeType_PaperJapaneseEnvelopeYou4, nil  
		case 92:  return PaperSizeType_PaperJapaneseEnvelopeYou4Rotated, nil  
		case 93:  return PaperSizeType_PaperPRC16K, nil  
		case 94:  return PaperSizeType_PaperPRC32K, nil  
		case 95:  return PaperSizeType_PaperPRCBig32K, nil  
		case 96:  return PaperSizeType_PaperPRCEnvelope1, nil  
		case 97:  return PaperSizeType_PaperPRCEnvelope2, nil  
		case 98:  return PaperSizeType_PaperPRCEnvelope3, nil  
		case 99:  return PaperSizeType_PaperPRCEnvelope4, nil  
		case 100:  return PaperSizeType_PaperPRCEnvelope5, nil  
		case 101:  return PaperSizeType_PaperPRCEnvelope6, nil  
		case 102:  return PaperSizeType_PaperPRCEnvelope7, nil  
		case 103:  return PaperSizeType_PaperPRCEnvelope8, nil  
		case 104:  return PaperSizeType_PaperPRCEnvelope9, nil  
		case 105:  return PaperSizeType_PaperPRCEnvelope10, nil  
		case 106:  return PaperSizeType_PaperPRC16KRotated, nil  
		case 107:  return PaperSizeType_PaperPRC32KRotated, nil  
		case 108:  return PaperSizeType_PaperPRCBig32KRotated, nil  
		case 109:  return PaperSizeType_PaperPRCEnvelope1Rotated, nil  
		case 110:  return PaperSizeType_PaperPRCEnvelope2Rotated, nil  
		case 111:  return PaperSizeType_PaperPRCEnvelope3Rotated, nil  
		case 112:  return PaperSizeType_PaperPRCEnvelope4Rotated, nil  
		case 113:  return PaperSizeType_PaperPRCEnvelope5Rotated, nil  
		case 114:  return PaperSizeType_PaperPRCEnvelope6Rotated, nil  
		case 115:  return PaperSizeType_PaperPRCEnvelope7Rotated, nil  
		case 116:  return PaperSizeType_PaperPRCEnvelope8Rotated, nil  
		case 117:  return PaperSizeType_PaperPRCEnvelope9Rotated, nil  
		case 118:  return PaperSizeType_PaperPRCEnvelope10Rotated, nil  
		case 300:  return PaperSizeType_PaperB3, nil  
		case 301:  return PaperSizeType_PaperBusinessCard, nil  
		case 302:  return PaperSizeType_PaperThermal, nil  
		case 0:  return PaperSizeType_Custom, nil  
		default:
			return 0 ,fmt.Errorf("invalid PaperSizeType value: %d", value)
	}
}

/**************Enum ParameterType *****************/

// Represents all parameters' type or return value type of function.
type ParameterType int32

const(
ParameterType_Reference ParameterType = 0 


ParameterType_Value ParameterType = 1 


ParameterType_Array ParameterType = 2 
)

func Int32ToParameterType(value int32)(ParameterType ,error){
	switch value {
		case 0:  return ParameterType_Reference, nil  
		case 1:  return ParameterType_Value, nil  
		case 2:  return ParameterType_Array, nil  
		default:
			return 0 ,fmt.Errorf("invalid ParameterType value: %d", value)
	}
}

/**************Enum PasteOperationType *****************/

// Represents operation type when pasting range.
type PasteOperationType int32

const(
// No operation.
PasteOperationType_None PasteOperationType = 0 

// Add
PasteOperationType_Add PasteOperationType = 1 

// Subtract
PasteOperationType_Subtract PasteOperationType = 2 

// Multiply
PasteOperationType_Multiply PasteOperationType = 3 

// Divide
PasteOperationType_Divide PasteOperationType = 4 
)

func Int32ToPasteOperationType(value int32)(PasteOperationType ,error){
	switch value {
		case 0:  return PasteOperationType_None, nil  
		case 1:  return PasteOperationType_Add, nil  
		case 2:  return PasteOperationType_Subtract, nil  
		case 3:  return PasteOperationType_Multiply, nil  
		case 4:  return PasteOperationType_Divide, nil  
		default:
			return 0 ,fmt.Errorf("invalid PasteOperationType value: %d", value)
	}
}

/**************Enum PasteType *****************/

// Represents the paste special type.
type PasteType int32

const(
// Copies all data of the range.
PasteType_All PasteType = 0 

// It works as "All" behavior of MS Excel.
PasteType_Default PasteType = 1 

// Copies all data of the range without the range.
PasteType_AllExceptBorders PasteType = 2 

// It works as "All except borders" behavior of MS Excel.
PasteType_DefaultExceptBorders PasteType = 3 

// Only copies the widths of the range.
PasteType_ColumnWidths PasteType = 4 

// Only copies the heights of the range.
PasteType_RowHeights PasteType = 5 


PasteType_Comments PasteType = 6 


PasteType_Formats PasteType = 7 


PasteType_Formulas PasteType = 8 


PasteType_FormulasAndNumberFormats PasteType = 9 


PasteType_Validation PasteType = 10 


PasteType_Values PasteType = 11 


PasteType_ValuesAndFormats PasteType = 12 


PasteType_ValuesAndNumberFormats PasteType = 13 
)

func Int32ToPasteType(value int32)(PasteType ,error){
	switch value {
		case 0:  return PasteType_All, nil  
		case 1:  return PasteType_Default, nil  
		case 2:  return PasteType_AllExceptBorders, nil  
		case 3:  return PasteType_DefaultExceptBorders, nil  
		case 4:  return PasteType_ColumnWidths, nil  
		case 5:  return PasteType_RowHeights, nil  
		case 6:  return PasteType_Comments, nil  
		case 7:  return PasteType_Formats, nil  
		case 8:  return PasteType_Formulas, nil  
		case 9:  return PasteType_FormulasAndNumberFormats, nil  
		case 10:  return PasteType_Validation, nil  
		case 11:  return PasteType_Values, nil  
		case 12:  return PasteType_ValuesAndFormats, nil  
		case 13:  return PasteType_ValuesAndNumberFormats, nil  
		default:
			return 0 ,fmt.Errorf("invalid PasteType value: %d", value)
	}
}

/**************Enum PrintCommentsType *****************/

// Represents the way comments are printed with the sheet.
type PrintCommentsType int32

const(
// Represents to print comments as displayed on sheet.
PrintCommentsType_PrintInPlace PrintCommentsType = 0 

// Represents not to print comments.
PrintCommentsType_PrintNoComments PrintCommentsType = 1 

// Represents to print comments at end of sheet.
PrintCommentsType_PrintSheetEnd PrintCommentsType = 2 

// Represents to print comments as displayed on sheet include threaded comments.
PrintCommentsType_PrintWithThreadedComments PrintCommentsType = 3 
)

func Int32ToPrintCommentsType(value int32)(PrintCommentsType ,error){
	switch value {
		case 0:  return PrintCommentsType_PrintInPlace, nil  
		case 1:  return PrintCommentsType_PrintNoComments, nil  
		case 2:  return PrintCommentsType_PrintSheetEnd, nil  
		case 3:  return PrintCommentsType_PrintWithThreadedComments, nil  
		default:
			return 0 ,fmt.Errorf("invalid PrintCommentsType value: %d", value)
	}
}

/**************Enum PrintErrorsType *****************/

// Represents print errors constants.
type PrintErrorsType int32

const(
// Represents not to print errors.
PrintErrorsType_PrintErrorsBlank PrintErrorsType = 0 

// Represents to print errors as "--".
PrintErrorsType_PrintErrorsDash PrintErrorsType = 1 

// Represents to print errors as displayed.
PrintErrorsType_PrintErrorsDisplayed PrintErrorsType = 2 

// Represents to print errors as "#N/A".
PrintErrorsType_PrintErrorsNA PrintErrorsType = 3 
)

func Int32ToPrintErrorsType(value int32)(PrintErrorsType ,error){
	switch value {
		case 0:  return PrintErrorsType_PrintErrorsBlank, nil  
		case 1:  return PrintErrorsType_PrintErrorsDash, nil  
		case 2:  return PrintErrorsType_PrintErrorsDisplayed, nil  
		case 3:  return PrintErrorsType_PrintErrorsNA, nil  
		default:
			return 0 ,fmt.Errorf("invalid PrintErrorsType value: %d", value)
	}
}

/**************Enum PrintingPageType *****************/

// Indicates which pages will not be printed.
type PrintingPageType int32

const(
// Prints all pages.
PrintingPageType_Default PrintingPageType = 0 

// Don't print the pages which the cells are blank.
PrintingPageType_IgnoreBlank PrintingPageType = 1 

// Don't print the pages which cells only contain styles.
PrintingPageType_IgnoreStyle PrintingPageType = 2 
)

func Int32ToPrintingPageType(value int32)(PrintingPageType ,error){
	switch value {
		case 0:  return PrintingPageType_Default, nil  
		case 1:  return PrintingPageType_IgnoreBlank, nil  
		case 2:  return PrintingPageType_IgnoreStyle, nil  
		default:
			return 0 ,fmt.Errorf("invalid PrintingPageType value: %d", value)
	}
}

/**************Enum PrintOrderType *****************/

// Represent print order constants.
type PrintOrderType int32

const(
// Down, then over
PrintOrderType_DownThenOver PrintOrderType = 0 

// Over, then down
PrintOrderType_OverThenDown PrintOrderType = 1 
)

func Int32ToPrintOrderType(value int32)(PrintOrderType ,error){
	switch value {
		case 0:  return PrintOrderType_DownThenOver, nil  
		case 1:  return PrintOrderType_OverThenDown, nil  
		default:
			return 0 ,fmt.Errorf("invalid PrintOrderType value: %d", value)
	}
}

/**************Enum PrintSizeType *****************/

// Represents the printed chart size.
type PrintSizeType int32

const(
// Use full page.
PrintSizeType_Full PrintSizeType = 0 

// Scale to fit page.
PrintSizeType_Fit PrintSizeType = 1 

// Custom.
PrintSizeType_Custom PrintSizeType = 2 
)

func Int32ToPrintSizeType(value int32)(PrintSizeType ,error){
	switch value {
		case 0:  return PrintSizeType_Full, nil  
		case 1:  return PrintSizeType_Fit, nil  
		case 2:  return PrintSizeType_Custom, nil  
		default:
			return 0 ,fmt.Errorf("invalid PrintSizeType value: %d", value)
	}
}

/**************Enum ProtectionType *****************/

// Represents workbook/worksheet protection type.
type ProtectionType int32

const(
// Represents to protect all.
ProtectionType_All ProtectionType = 0 

// Represents to protect contents, used in Worksheet protection.
ProtectionType_Contents ProtectionType = 1 

// Represents to protect objects, used in Worksheet protection.
ProtectionType_Objects ProtectionType = 2 

// Represents to protect scenarios, used in Worksheet protection.
ProtectionType_Scenarios ProtectionType = 3 

// Represents to protect structure, used in Workbook protection.
ProtectionType_Structure ProtectionType = 4 

// Represents to protect window, used in Workbook protection.
ProtectionType_Windows ProtectionType = 5 

// Represents no protection. Only for Reading property.
ProtectionType_None ProtectionType = 6 
)

func Int32ToProtectionType(value int32)(ProtectionType ,error){
	switch value {
		case 0:  return ProtectionType_All, nil  
		case 1:  return ProtectionType_Contents, nil  
		case 2:  return ProtectionType_Objects, nil  
		case 3:  return ProtectionType_Scenarios, nil  
		case 4:  return ProtectionType_Structure, nil  
		case 5:  return ProtectionType_Windows, nil  
		case 6:  return ProtectionType_None, nil  
		default:
			return 0 ,fmt.Errorf("invalid ProtectionType value: %d", value)
	}
}

/**************Enum RenameStrategy *****************/

// Strategy option for duplicate names of columns.
type RenameStrategy int32

const(
// Throws exception.
RenameStrategy_Exception RenameStrategy = 0 

// Named with digit. Duplicated names will become ...1, ...2, etc.
RenameStrategy_Digit RenameStrategy = 1 

// Named with letter.. Duplicated names will become ...A, ...B, etc.
RenameStrategy_Letter RenameStrategy = 2 
)

func Int32ToRenameStrategy(value int32)(RenameStrategy ,error){
	switch value {
		case 0:  return RenameStrategy_Exception, nil  
		case 1:  return RenameStrategy_Digit, nil  
		case 2:  return RenameStrategy_Letter, nil  
		default:
			return 0 ,fmt.Errorf("invalid RenameStrategy value: %d", value)
	}
}

/**************Enum ResourceLoadingType *****************/

// Represents how to loading the linked resource.
type ResourceLoadingType int32

const(
// Loads this resource as usual.
ResourceLoadingType_Default ResourceLoadingType = 0 

// Skips loading of this resource.
ResourceLoadingType_Skip ResourceLoadingType = 1 

// Use stream provided by user
ResourceLoadingType_UserProvided ResourceLoadingType = 2 
)

func Int32ToResourceLoadingType(value int32)(ResourceLoadingType ,error){
	switch value {
		case 0:  return ResourceLoadingType_Default, nil  
		case 1:  return ResourceLoadingType_Skip, nil  
		case 2:  return ResourceLoadingType_UserProvided, nil  
		default:
			return 0 ,fmt.Errorf("invalid ResourceLoadingType value: %d", value)
	}
}

/**************Enum SaveFormat *****************/

// Represents the format in which the workbook is saved.
type SaveFormat int32

const(
// Comma-Separated Values(CSV) text file.
SaveFormat_Csv SaveFormat = 1 

// Represents an xlsx file.
SaveFormat_Xlsx SaveFormat = 6 

// Represents an xlsm file which enable macros.
SaveFormat_Xlsm SaveFormat = 7 

// Represents an xltx file.
SaveFormat_Xltx SaveFormat = 8 

// Represents an xltm file which enable macros.
SaveFormat_Xltm SaveFormat = 9 

// Represents an xltm file which enable addin macros.
SaveFormat_Xlam SaveFormat = 10 

// Tab-Separated Values(TSV) text file.
SaveFormat_Tsv SaveFormat = 11 

// Represents a html file.
SaveFormat_Html SaveFormat = 12 

// Represents a mhtml file.
SaveFormat_MHtml SaveFormat = 17 

// Open Document Sheet(ODS) file.
SaveFormat_Ods SaveFormat = 14 

// Represents an Excel97-2003 xls file.
SaveFormat_Excel97To2003 SaveFormat = 5 

// Represents an Excel 2003 xml file.
SaveFormat_SpreadsheetML SaveFormat = 15 

// Represents an xlsb file.
SaveFormat_Xlsb SaveFormat = 16 

// If saving the file to the disk,the file format accords to the extension of the file name.
// If saving the file to the stream, the file format is xlsx.
SaveFormat_Auto SaveFormat = 0 

// Represents unrecognized format, cannot be saved.
SaveFormat_Unknown SaveFormat = 255 

// Represents a Pdf file.
SaveFormat_Pdf SaveFormat = 13 

// XPS (XML Paper Specification) format.
SaveFormat_Xps SaveFormat = 20 

// Represents a TIFF file.
SaveFormat_Tiff SaveFormat = 21 

// SVG file.
SaveFormat_Svg SaveFormat = 28 

// Data Interchange Format.
SaveFormat_Dif SaveFormat = 30 

// Open Document Template Sheet(OTS) file.
SaveFormat_Ots SaveFormat = 31 

// Excel 97-2003 template file.
SaveFormat_Xlt SaveFormat = 32 

// Represents a simple xml file.
SaveFormat_Xml SaveFormat = 51 

// Represents a numbers file.
SaveFormat_Numbers SaveFormat = 56 

// Represents markdown document.
SaveFormat_Markdown SaveFormat = 57 

// Represents OpenDocument Flat XML Spreadsheet (.fods) file format.
SaveFormat_Fods SaveFormat = 59 

// Represents StarOffice Calc Spreadsheet (.sxc) file format.
SaveFormat_Sxc SaveFormat = 60 

// Represents .pptx file.
SaveFormat_Pptx SaveFormat = 61 

// Represents .docx file.
SaveFormat_Docx SaveFormat = 62 

// Windows Enhanced Metafile.
SaveFormat_Emf SaveFormat = 258 

// JPEG JFIF.
SaveFormat_Jpg SaveFormat = 261 

// Portable Network Graphics.
SaveFormat_Png SaveFormat = 262 

// Windows Bitmap
SaveFormat_Bmp SaveFormat = 263 

// Gif
SaveFormat_Gif SaveFormat = 322 

// Json
SaveFormat_Json SaveFormat = 513 

// Sql
SaveFormat_SqlScript SaveFormat = 514 

// Represents Epub file.
SaveFormat_Epub SaveFormat = 772 

// Represents Azw3 file.
SaveFormat_Azw3 SaveFormat = 773 

// PCL (Printer Command Language)
SaveFormat_Pcl SaveFormat = 1025 

// Xbase Data file
SaveFormat_Dbf SaveFormat = 515 
)

func Int32ToSaveFormat(value int32)(SaveFormat ,error){
	switch value {
		case 1:  return SaveFormat_Csv, nil  
		case 6:  return SaveFormat_Xlsx, nil  
		case 7:  return SaveFormat_Xlsm, nil  
		case 8:  return SaveFormat_Xltx, nil  
		case 9:  return SaveFormat_Xltm, nil  
		case 10:  return SaveFormat_Xlam, nil  
		case 11:  return SaveFormat_Tsv, nil  
		case 12:  return SaveFormat_Html, nil  
		case 17:  return SaveFormat_MHtml, nil  
		case 14:  return SaveFormat_Ods, nil  
		case 5:  return SaveFormat_Excel97To2003, nil  
		case 15:  return SaveFormat_SpreadsheetML, nil  
		case 16:  return SaveFormat_Xlsb, nil  
		case 0:  return SaveFormat_Auto, nil  
		case 255:  return SaveFormat_Unknown, nil  
		case 13:  return SaveFormat_Pdf, nil  
		case 20:  return SaveFormat_Xps, nil  
		case 21:  return SaveFormat_Tiff, nil  
		case 28:  return SaveFormat_Svg, nil  
		case 30:  return SaveFormat_Dif, nil  
		case 31:  return SaveFormat_Ots, nil  
		case 32:  return SaveFormat_Xlt, nil  
		case 51:  return SaveFormat_Xml, nil  
		case 56:  return SaveFormat_Numbers, nil  
		case 57:  return SaveFormat_Markdown, nil  
		case 59:  return SaveFormat_Fods, nil  
		case 60:  return SaveFormat_Sxc, nil  
		case 61:  return SaveFormat_Pptx, nil  
		case 62:  return SaveFormat_Docx, nil  
		case 258:  return SaveFormat_Emf, nil  
		case 261:  return SaveFormat_Jpg, nil  
		case 262:  return SaveFormat_Png, nil  
		case 263:  return SaveFormat_Bmp, nil  
		case 322:  return SaveFormat_Gif, nil  
		case 513:  return SaveFormat_Json, nil  
		case 514:  return SaveFormat_SqlScript, nil  
		case 772:  return SaveFormat_Epub, nil  
		case 773:  return SaveFormat_Azw3, nil  
		case 1025:  return SaveFormat_Pcl, nil  
		case 515:  return SaveFormat_Dbf, nil  
		default:
			return 0 ,fmt.Errorf("invalid SaveFormat value: %d", value)
	}
}

/**************Enum SheetType *****************/

// Specifies the worksheet type.
type SheetType int32

const(
// Visual Basic module
SheetType_VB SheetType = 0 


SheetType_Worksheet SheetType = 1 

// Chart
SheetType_Chart SheetType = 2 

// BIFF4 Macro sheet
SheetType_BIFF4Macro SheetType = 3 

// International Macro sheet
SheetType_InternationalMacro SheetType = 4 


SheetType_Other SheetType = 5 

// Dialog worksheet
SheetType_Dialog SheetType = 6 
)

func Int32ToSheetType(value int32)(SheetType ,error){
	switch value {
		case 0:  return SheetType_VB, nil  
		case 1:  return SheetType_Worksheet, nil  
		case 2:  return SheetType_Chart, nil  
		case 3:  return SheetType_BIFF4Macro, nil  
		case 4:  return SheetType_InternationalMacro, nil  
		case 5:  return SheetType_Other, nil  
		case 6:  return SheetType_Dialog, nil  
		default:
			return 0 ,fmt.Errorf("invalid SheetType value: %d", value)
	}
}

/**************Enum ShiftType *****************/

// Represent the shift options when deleting a range of cells.
type ShiftType int32

const(
// Shift cells down.
ShiftType_Down ShiftType = 0 

// Shift cells left.
ShiftType_Left ShiftType = 1 

// Do not shift cells.
ShiftType_None ShiftType = 2 

// Shift cells right.
ShiftType_Right ShiftType = 3 

// Shift cells up.
ShiftType_Up ShiftType = 4 
)

func Int32ToShiftType(value int32)(ShiftType ,error){
	switch value {
		case 0:  return ShiftType_Down, nil  
		case 1:  return ShiftType_Left, nil  
		case 2:  return ShiftType_None, nil  
		case 3:  return ShiftType_Right, nil  
		case 4:  return ShiftType_Up, nil  
		default:
			return 0 ,fmt.Errorf("invalid ShiftType value: %d", value)
	}
}

/**************Enum SortOnType *****************/

// Sorted value type.
type SortOnType int32

const(
// Sorts by cells' value.
SortOnType_Value SortOnType = 0 

// Sorts by cells' color.
SortOnType_CellColor SortOnType = 1 

// Sorts by cells' font color.
SortOnType_FontColor SortOnType = 2 

// Sorts by conditional icon.
SortOnType_Icon SortOnType = 3 
)

func Int32ToSortOnType(value int32)(SortOnType ,error){
	switch value {
		case 0:  return SortOnType_Value, nil  
		case 1:  return SortOnType_CellColor, nil  
		case 2:  return SortOnType_FontColor, nil  
		case 3:  return SortOnType_Icon, nil  
		default:
			return 0 ,fmt.Errorf("invalid SortOnType value: %d", value)
	}
}

/**************Enum SortOrder *****************/

// Represents sort order for the data range.
type SortOrder int32

const(
// Sorts data in ascending order
SortOrder_Ascending SortOrder = 0 

// Sorts data in descending order
SortOrder_Descending SortOrder = 1 

// Keeps original data order without sorting. Only applies to some special scenarios such as PivotTable.
SortOrder_Natural SortOrder = 2 
)

func Int32ToSortOrder(value int32)(SortOrder ,error){
	switch value {
		case 0:  return SortOrder_Ascending, nil  
		case 1:  return SortOrder_Descending, nil  
		case 2:  return SortOrder_Natural, nil  
		default:
			return 0 ,fmt.Errorf("invalid SortOrder value: %d", value)
	}
}

/**************Enum StyleModifyFlag *****************/

// The style modified flags.
type StyleModifyFlag int32

const(
// Indicates whether left border has been modified for the style.
StyleModifyFlag_LeftBorder StyleModifyFlag = 256 

// Indicates whether right border has been modified for the style.
StyleModifyFlag_RightBorder StyleModifyFlag = 512 

// Indicates whether top border has been modified for the style.
StyleModifyFlag_TopBorder StyleModifyFlag = 1024 

// Indicates whether bottom border has been modified for the style.
StyleModifyFlag_BottomBorder StyleModifyFlag = 2048 

// Indicates whether diagonal-down border has been modified for the style.
StyleModifyFlag_DiagonalDownBorder StyleModifyFlag = 4096 

// Indicates whether diagonal-up border has been modified for the style.
StyleModifyFlag_DiagonalUpBorder StyleModifyFlag = 8192 

// Indicates whether horizontal border has been modified for the style.
// Only for dynamic style, such as conditional formatting.
StyleModifyFlag_HorizontalBorder StyleModifyFlag = 32 

// Indicates whether vertical border has been modified for the style.
// Only for dynamic style, such as conditional formatting.
StyleModifyFlag_VerticalBorder StyleModifyFlag = 64 

// Indicates the four side borders: <see cref="LeftBorder"/>,
// <see cref="RightBorder"/>, <see cref="TopBorder"/> and <see cref="BottomBorder"/>.
StyleModifyFlag_SideBorders StyleModifyFlag = 3840 

// Indicates diagonal borders: <see cref="DiagonalDownBorder"/> and <see cref="DiagonalUpBorder"/>.
StyleModifyFlag_Diagonal StyleModifyFlag = 12288 

// Indicates borders of dynamic style: <see cref="HorizontalBorder"/> and <see cref="VerticalBorder"/>.
StyleModifyFlag_DynamicStyleBorders StyleModifyFlag = 96 

// Indicates whether one or more borders(<see cref="LeftBorder"/>,
// <see cref="RightBorder"/>, <see cref="TopBorder"/>, <see cref="BottomBorder"/>,
// <see cref="Diagonal"/>, <see cref="HorizontalBorder"/>, <see cref="VerticalBorder"/>)
// have been modified for the style.
StyleModifyFlag_Borders StyleModifyFlag = 16224 

// Indicates whether numberformat has been modified.
StyleModifyFlag_NumberFormat StyleModifyFlag = 16384 

// Indicates whether horizontal alignment has been modified.
StyleModifyFlag_HorizontalAlignment StyleModifyFlag = 32768 

// Indicates whether vertical alignment has been modified.
StyleModifyFlag_VerticalAlignment StyleModifyFlag = 65536 

// Indicates whether indent property has been modified.
StyleModifyFlag_Indent StyleModifyFlag = 131072 

// Indicates whether rotation property has been modified.
StyleModifyFlag_Rotation StyleModifyFlag = 262144 

// Indicates whether wrap text property has been modified.
StyleModifyFlag_WrapText StyleModifyFlag = 524288 

// Indicates whether shrink to fit property has been modified.
StyleModifyFlag_ShrinkToFit StyleModifyFlag = 1048576 

// Indicates whether text direction property has been modified.
StyleModifyFlag_TextDirection StyleModifyFlag = 2097152 

// Indicates whether relative indent property has been modified for the style.
// Only for dynamic style, such as conditional formatting.
StyleModifyFlag_RelativeIndent StyleModifyFlag = 128 

// Indicates whether one or more alignment-related properties(<see cref="HorizontalAlignment"/>,
// <see cref="VerticalAlignment"/>, <see cref="Rotation"/>, <see cref="WrapText"/>,
// <see cref="WrapText"/>, <see cref="Indent"/>, <see cref="ShrinkToFit"/>, <see cref="TextDirection"/>,
// <see cref="RelativeIndent"/>) have been modified.
StyleModifyFlag_AlignmentSettings StyleModifyFlag = 4161664 

// Indicates whether pattern of the shading has been modified.
StyleModifyFlag_Pattern StyleModifyFlag = 4194304 

// Indicates whether foreground color has been modified.
StyleModifyFlag_ForegroundColor StyleModifyFlag = 8388608 

// Indicates whether background color has been modified.
StyleModifyFlag_BackgroundColor StyleModifyFlag = 16777216 

// Indicates whether one or more shading-related properties(<see cref="Pattern"/>,
// <see cref="ForegroundColor"/>, <see cref="BackgroundColor"/>) have been modified.
StyleModifyFlag_CellShading StyleModifyFlag = 29360128 

// Indicates whether locked property has been modified.
StyleModifyFlag_Locked StyleModifyFlag = 67108864 

// Indicates whether hide formula has been modified.
StyleModifyFlag_HideFormula StyleModifyFlag = 134217728 

// Indicates whether one or more protection-related properties(<see cref="Locked"/>,
// <see cref="HideFormula"/>) have been modified.
StyleModifyFlag_ProtectionSettings StyleModifyFlag = 201326592 

// Indicates whether font size has been modified.
StyleModifyFlag_FontSize StyleModifyFlag = 1 

// Indicates whether font name has been modified.
StyleModifyFlag_FontName StyleModifyFlag = 2 

// Indicates whether font color has been modified.
StyleModifyFlag_FontColor StyleModifyFlag = 3 

// Indicates whether font weight has been modified.
StyleModifyFlag_FontWeight StyleModifyFlag = 4 

// Indicates whether italic property of font has been modified.
StyleModifyFlag_FontItalic StyleModifyFlag = 5 

// Indicates whether underline property of font has been modified.
StyleModifyFlag_FontUnderline StyleModifyFlag = 6 

// Indicates whether strike property font has been modified.
StyleModifyFlag_FontStrike StyleModifyFlag = 7 

// Indicates whether subscript or superscript property of font has been modified.
StyleModifyFlag_FontScript StyleModifyFlag = 8 

// Indicates whether font family has been modified.
StyleModifyFlag_FontFamily StyleModifyFlag = 9 

// Indicates whether charset of the font has been modified.
StyleModifyFlag_FontCharset StyleModifyFlag = 10 

// unused.
StyleModifyFlag_FontScheme StyleModifyFlag = 11 

// unused.
StyleModifyFlag_FontDirty StyleModifyFlag = 12 

// unused.
StyleModifyFlag_FontSpellingError StyleModifyFlag = 13 

// unused.
StyleModifyFlag_FontUFillTx StyleModifyFlag = 14 

// unused.
StyleModifyFlag_FontSpacing StyleModifyFlag = 15 

// unused.
StyleModifyFlag_FontKerning StyleModifyFlag = 16 

// unused.
StyleModifyFlag_FontEqualize StyleModifyFlag = 17 

// unused.
StyleModifyFlag_FontCap StyleModifyFlag = 18 


StyleModifyFlag_FontVerticalText StyleModifyFlag = 19 

// Indicates whether one or more properties have been modified for the font of the style.
StyleModifyFlag_Font StyleModifyFlag = 31 

// All properties that can be modified for the style.
StyleModifyFlag_All StyleModifyFlag = 234881023 

// No property has been specified.
StyleModifyFlag_None StyleModifyFlag = 0 
)

func Int32ToStyleModifyFlag(value int32)(StyleModifyFlag ,error){
	switch value {
		case 256:  return StyleModifyFlag_LeftBorder, nil  
		case 512:  return StyleModifyFlag_RightBorder, nil  
		case 1024:  return StyleModifyFlag_TopBorder, nil  
		case 2048:  return StyleModifyFlag_BottomBorder, nil  
		case 4096:  return StyleModifyFlag_DiagonalDownBorder, nil  
		case 8192:  return StyleModifyFlag_DiagonalUpBorder, nil  
		case 32:  return StyleModifyFlag_HorizontalBorder, nil  
		case 64:  return StyleModifyFlag_VerticalBorder, nil  
		case 3840:  return StyleModifyFlag_SideBorders, nil  
		case 12288:  return StyleModifyFlag_Diagonal, nil  
		case 96:  return StyleModifyFlag_DynamicStyleBorders, nil  
		case 16224:  return StyleModifyFlag_Borders, nil  
		case 16384:  return StyleModifyFlag_NumberFormat, nil  
		case 32768:  return StyleModifyFlag_HorizontalAlignment, nil  
		case 65536:  return StyleModifyFlag_VerticalAlignment, nil  
		case 131072:  return StyleModifyFlag_Indent, nil  
		case 262144:  return StyleModifyFlag_Rotation, nil  
		case 524288:  return StyleModifyFlag_WrapText, nil  
		case 1048576:  return StyleModifyFlag_ShrinkToFit, nil  
		case 2097152:  return StyleModifyFlag_TextDirection, nil  
		case 128:  return StyleModifyFlag_RelativeIndent, nil  
		case 4161664:  return StyleModifyFlag_AlignmentSettings, nil  
		case 4194304:  return StyleModifyFlag_Pattern, nil  
		case 8388608:  return StyleModifyFlag_ForegroundColor, nil  
		case 16777216:  return StyleModifyFlag_BackgroundColor, nil  
		case 29360128:  return StyleModifyFlag_CellShading, nil  
		case 67108864:  return StyleModifyFlag_Locked, nil  
		case 134217728:  return StyleModifyFlag_HideFormula, nil  
		case 201326592:  return StyleModifyFlag_ProtectionSettings, nil  
		case 1:  return StyleModifyFlag_FontSize, nil  
		case 2:  return StyleModifyFlag_FontName, nil  
		case 3:  return StyleModifyFlag_FontColor, nil  
		case 4:  return StyleModifyFlag_FontWeight, nil  
		case 5:  return StyleModifyFlag_FontItalic, nil  
		case 6:  return StyleModifyFlag_FontUnderline, nil  
		case 7:  return StyleModifyFlag_FontStrike, nil  
		case 8:  return StyleModifyFlag_FontScript, nil  
		case 9:  return StyleModifyFlag_FontFamily, nil  
		case 10:  return StyleModifyFlag_FontCharset, nil  
		case 11:  return StyleModifyFlag_FontScheme, nil  
		case 12:  return StyleModifyFlag_FontDirty, nil  
		case 13:  return StyleModifyFlag_FontSpellingError, nil  
		case 14:  return StyleModifyFlag_FontUFillTx, nil  
		case 15:  return StyleModifyFlag_FontSpacing, nil  
		case 16:  return StyleModifyFlag_FontKerning, nil  
		case 17:  return StyleModifyFlag_FontEqualize, nil  
		case 18:  return StyleModifyFlag_FontCap, nil  
		case 19:  return StyleModifyFlag_FontVerticalText, nil  
		case 31:  return StyleModifyFlag_Font, nil  
		case 234881023:  return StyleModifyFlag_All, nil  
		case 0:  return StyleModifyFlag_None, nil  
		default:
			return 0 ,fmt.Errorf("invalid StyleModifyFlag value: %d", value)
	}
}

/**************Enum TargetModeType *****************/

// Represents the type of target mode.
type TargetModeType int32

const(
// External link
TargetModeType_External TargetModeType = 0 

// Local and full paths to files or folders.
TargetModeType_FilePath TargetModeType = 1 

// Email.
TargetModeType_Email TargetModeType = 2 

// Link on cell or named range.
TargetModeType_CellReference TargetModeType = 3 
)

func Int32ToTargetModeType(value int32)(TargetModeType ,error){
	switch value {
		case 0:  return TargetModeType_External, nil  
		case 1:  return TargetModeType_FilePath, nil  
		case 2:  return TargetModeType_Email, nil  
		case 3:  return TargetModeType_CellReference, nil  
		default:
			return 0 ,fmt.Errorf("invalid TargetModeType value: %d", value)
	}
}

/**************Enum TextAlignmentType *****************/

// Enumerates text alignment types.
type TextAlignmentType int32

const(
// Represents general text alignment.
TextAlignmentType_General TextAlignmentType = 1792 

// Represents bottom text alignment.
TextAlignmentType_Bottom TextAlignmentType = 528 

// Represents center text alignment.
TextAlignmentType_Center TextAlignmentType = 1802 

// Represents center across text alignment.
TextAlignmentType_CenterAcross TextAlignmentType = 1286 

// Represents distributed text alignment.
TextAlignmentType_Distributed TextAlignmentType = 807 

// Represents fill text alignment.
TextAlignmentType_Fill TextAlignmentType = 1284 

// Represents justify text alignment.
TextAlignmentType_Justify TextAlignmentType = 1821 

// Represents left text alignment.
TextAlignmentType_Left TextAlignmentType = 257 

// Represents right text alignment.
TextAlignmentType_Right TextAlignmentType = 259 

// Represents top text alignment.
TextAlignmentType_Top TextAlignmentType = 512 

// Aligns the text with an adjusted kashida length for Arabic text.
TextAlignmentType_JustifiedLow TextAlignmentType = 832 

// Distributes Thai text specially, because each character is treated as a word.
TextAlignmentType_ThaiDistributed TextAlignmentType = 896 
)

func Int32ToTextAlignmentType(value int32)(TextAlignmentType ,error){
	switch value {
		case 1792:  return TextAlignmentType_General, nil  
		case 528:  return TextAlignmentType_Bottom, nil  
		case 1802:  return TextAlignmentType_Center, nil  
		case 1286:  return TextAlignmentType_CenterAcross, nil  
		case 807:  return TextAlignmentType_Distributed, nil  
		case 1284:  return TextAlignmentType_Fill, nil  
		case 1821:  return TextAlignmentType_Justify, nil  
		case 257:  return TextAlignmentType_Left, nil  
		case 259:  return TextAlignmentType_Right, nil  
		case 512:  return TextAlignmentType_Top, nil  
		case 832:  return TextAlignmentType_JustifiedLow, nil  
		case 896:  return TextAlignmentType_ThaiDistributed, nil  
		default:
			return 0 ,fmt.Errorf("invalid TextAlignmentType value: %d", value)
	}
}

/**************Enum TextCapsType *****************/

// This type specifies the cap types of the text.
type TextCapsType int32

const(
// None caps
TextCapsType_None TextCapsType = 0 

// Apply all caps on the text.
TextCapsType_All TextCapsType = 1 

// Apply small caps to the text.
TextCapsType_Small TextCapsType = 2 
)

func Int32ToTextCapsType(value int32)(TextCapsType ,error){
	switch value {
		case 0:  return TextCapsType_None, nil  
		case 1:  return TextCapsType_All, nil  
		case 2:  return TextCapsType_Small, nil  
		default:
			return 0 ,fmt.Errorf("invalid TextCapsType value: %d", value)
	}
}

/**************Enum TextCrossType *****************/

// Enumerates displaying text type when the text width is larger than cell width.
type TextCrossType int32

const(
// Display text like in Microsoft Excel.
TextCrossType_Default TextCrossType = 1 

// Display all the text by crossing other cells and keep text of crossed cells.
TextCrossType_CrossKeep TextCrossType = 2 

// Display all the text by crossing other cells and override text of crossed cells.
TextCrossType_CrossOverride TextCrossType = 3 

// Only display the text within the width of cell.
TextCrossType_StrictInCell TextCrossType = 4 
)

func Int32ToTextCrossType(value int32)(TextCrossType ,error){
	switch value {
		case 1:  return TextCrossType_Default, nil  
		case 2:  return TextCrossType_CrossKeep, nil  
		case 3:  return TextCrossType_CrossOverride, nil  
		case 4:  return TextCrossType_StrictInCell, nil  
		default:
			return 0 ,fmt.Errorf("invalid TextCrossType value: %d", value)
	}
}

/**************Enum TextDirectionType *****************/

// Represents the direction of the text flow for this paragraph.
type TextDirectionType int32

const(
TextDirectionType_Context TextDirectionType = 0 


TextDirectionType_LeftToRight TextDirectionType = 1 


TextDirectionType_RightToLeft TextDirectionType = 2 
)

func Int32ToTextDirectionType(value int32)(TextDirectionType ,error){
	switch value {
		case 0:  return TextDirectionType_Context, nil  
		case 1:  return TextDirectionType_LeftToRight, nil  
		case 2:  return TextDirectionType_RightToLeft, nil  
		default:
			return 0 ,fmt.Errorf("invalid TextDirectionType value: %d", value)
	}
}

/**************Enum TextOrientationType *****************/

// Enumerates text orientation types.
type TextOrientationType int32

const(
// Rotates text with 90 degrees clockwise.
TextOrientationType_ClockWise TextOrientationType = 0 

// Rotates text with 90 degrees counterclockwise.
TextOrientationType_CounterClockWise TextOrientationType = 1 

// Represents the default value.
TextOrientationType_NoRotation TextOrientationType = 2 

// Displays text from top to bottom of the cell. Stacked text.
TextOrientationType_TopToBottom TextOrientationType = 3 
)

func Int32ToTextOrientationType(value int32)(TextOrientationType ,error){
	switch value {
		case 0:  return TextOrientationType_ClockWise, nil  
		case 1:  return TextOrientationType_CounterClockWise, nil  
		case 2:  return TextOrientationType_NoRotation, nil  
		case 3:  return TextOrientationType_TopToBottom, nil  
		default:
			return 0 ,fmt.Errorf("invalid TextOrientationType value: %d", value)
	}
}

/**************Enum TextStrikeType *****************/

// This type specifies the strike type.
type TextStrikeType int32

const(
// A single strikethrough applied on the text.
TextStrikeType_Single TextStrikeType = 0 

// A double strikethrough applied on the text.
// Only works for the text of the shapes or charts.
TextStrikeType_Double TextStrikeType = 1 

// No strike is applied to the text.
TextStrikeType_None TextStrikeType = 2 
)

func Int32ToTextStrikeType(value int32)(TextStrikeType ,error){
	switch value {
		case 0:  return TextStrikeType_Single, nil  
		case 1:  return TextStrikeType_Double, nil  
		case 2:  return TextStrikeType_None, nil  
		default:
			return 0 ,fmt.Errorf("invalid TextStrikeType value: %d", value)
	}
}

/**************Enum ThemeColorType *****************/

// Enumerates  the theme color types.
type ThemeColorType int32

const(
ThemeColorType_Background1 ThemeColorType = 0 


ThemeColorType_Text1 ThemeColorType = 1 


ThemeColorType_Background2 ThemeColorType = 2 


ThemeColorType_Text2 ThemeColorType = 3 


ThemeColorType_Accent1 ThemeColorType = 4 


ThemeColorType_Accent2 ThemeColorType = 5 


ThemeColorType_Accent3 ThemeColorType = 6 


ThemeColorType_Accent4 ThemeColorType = 7 


ThemeColorType_Accent5 ThemeColorType = 8 


ThemeColorType_Accent6 ThemeColorType = 9 


ThemeColorType_Hyperlink ThemeColorType = 10 


ThemeColorType_FollowedHyperlink ThemeColorType = 11 

// Inner used.
// A color used in theme definitions which means to use the color of the style.
ThemeColorType_StyleColor ThemeColorType = 12 
)

func Int32ToThemeColorType(value int32)(ThemeColorType ,error){
	switch value {
		case 0:  return ThemeColorType_Background1, nil  
		case 1:  return ThemeColorType_Text1, nil  
		case 2:  return ThemeColorType_Background2, nil  
		case 3:  return ThemeColorType_Text2, nil  
		case 4:  return ThemeColorType_Accent1, nil  
		case 5:  return ThemeColorType_Accent2, nil  
		case 6:  return ThemeColorType_Accent3, nil  
		case 7:  return ThemeColorType_Accent4, nil  
		case 8:  return ThemeColorType_Accent5, nil  
		case 9:  return ThemeColorType_Accent6, nil  
		case 10:  return ThemeColorType_Hyperlink, nil  
		case 11:  return ThemeColorType_FollowedHyperlink, nil  
		case 12:  return ThemeColorType_StyleColor, nil  
		default:
			return 0 ,fmt.Errorf("invalid ThemeColorType value: %d", value)
	}
}

/**************Enum TimePeriodType *****************/

// Used in a FormatConditionType.TimePeriod conditional formatting rule.
// These are dynamic time periods, which change based on
// the date the conditional formatting is refreshed / applied.
type TimePeriodType int32

const(
// Today's date.
TimePeriodType_Today TimePeriodType = 0 

// Yesterday's date.
TimePeriodType_Yesterday TimePeriodType = 1 

// Tomorrow's date.
TimePeriodType_Tomorrow TimePeriodType = 2 

// A date in the last seven days.
TimePeriodType_Last7Days TimePeriodType = 3 

// A date occurring in this calendar month.
TimePeriodType_ThisMonth TimePeriodType = 4 

// A date occurring in the last calendar month.
TimePeriodType_LastMonth TimePeriodType = 5 

// A date occurring in the next calendar month.
TimePeriodType_NextMonth TimePeriodType = 6 

// A date occurring this week.
TimePeriodType_ThisWeek TimePeriodType = 7 

// A date occurring last week.
TimePeriodType_LastWeek TimePeriodType = 8 

// A date occurring next week.
TimePeriodType_NextWeek TimePeriodType = 9 

// A date occurring this year.
// Only for .ods.
TimePeriodType_ThisYear TimePeriodType = 10 

// A date occurring last year.
// Only for .ods.
TimePeriodType_LastYear TimePeriodType = 11 

// A date occurring next year.
// Only for .ods.
TimePeriodType_NextYear TimePeriodType = 12 
)

func Int32ToTimePeriodType(value int32)(TimePeriodType ,error){
	switch value {
		case 0:  return TimePeriodType_Today, nil  
		case 1:  return TimePeriodType_Yesterday, nil  
		case 2:  return TimePeriodType_Tomorrow, nil  
		case 3:  return TimePeriodType_Last7Days, nil  
		case 4:  return TimePeriodType_ThisMonth, nil  
		case 5:  return TimePeriodType_LastMonth, nil  
		case 6:  return TimePeriodType_NextMonth, nil  
		case 7:  return TimePeriodType_ThisWeek, nil  
		case 8:  return TimePeriodType_LastWeek, nil  
		case 9:  return TimePeriodType_NextWeek, nil  
		case 10:  return TimePeriodType_ThisYear, nil  
		case 11:  return TimePeriodType_LastYear, nil  
		case 12:  return TimePeriodType_NextYear, nil  
		default:
			return 0 ,fmt.Errorf("invalid TimePeriodType value: %d", value)
	}
}

/**************Enum TxtLoadStyleStrategy *****************/

// Specifies how to apply style for parsed values when converting string value to number or datetime.
type TxtLoadStyleStrategy int32

const(
// Does not set style for the parsed value.
TxtLoadStyleStrategy_None TxtLoadStyleStrategy = 0 

// Set the style as built-in number/datetime when the parsed value are plain numeric/datetime values.
TxtLoadStyleStrategy_BuiltIn TxtLoadStyleStrategy = 1 

// Set the exact custom format for the parsed value to make the formatted value be same with the original input one.
TxtLoadStyleStrategy_ExactFormat TxtLoadStyleStrategy = 2 
)

func Int32ToTxtLoadStyleStrategy(value int32)(TxtLoadStyleStrategy ,error){
	switch value {
		case 0:  return TxtLoadStyleStrategy_None, nil  
		case 1:  return TxtLoadStyleStrategy_BuiltIn, nil  
		case 2:  return TxtLoadStyleStrategy_ExactFormat, nil  
		default:
			return 0 ,fmt.Errorf("invalid TxtLoadStyleStrategy value: %d", value)
	}
}

/**************Enum TxtValueQuoteType *****************/

// Specifies the type of using quotation marks for values in text format files.
type TxtValueQuoteType int32

const(
// All values that contain special characters such as quotation mark, separator character will be quoted.
// Same with the behavior of ms excel for exporting text file.
TxtValueQuoteType_Normal TxtValueQuoteType = 0 

// All values will be quoted always.
TxtValueQuoteType_Always TxtValueQuoteType = 1 

// Only quote values when needed. Such as, if one value contains quotation mark but the quotation mark is not at the begin of this value, this value will not be quoted.
TxtValueQuoteType_Minimum TxtValueQuoteType = 2 

// All values will not be quoted. The exported text file with this type may not be read back correctly because the needed quotation marks being absent.
TxtValueQuoteType_Never TxtValueQuoteType = 3 
)

func Int32ToTxtValueQuoteType(value int32)(TxtValueQuoteType ,error){
	switch value {
		case 0:  return TxtValueQuoteType_Normal, nil  
		case 1:  return TxtValueQuoteType_Always, nil  
		case 2:  return TxtValueQuoteType_Minimum, nil  
		case 3:  return TxtValueQuoteType_Never, nil  
		default:
			return 0 ,fmt.Errorf("invalid TxtValueQuoteType value: %d", value)
	}
}

/**************Enum UpdateLinksType *****************/

// Represents how to update links to other workbooks when the workbook is opened.
type UpdateLinksType int32

const(
// Prompt user to update.
UpdateLinksType_UserSet UpdateLinksType = 0 

// Do not update, and do not prompt user.
UpdateLinksType_Never UpdateLinksType = 1 

// Always update.
UpdateLinksType_Always UpdateLinksType = 2 
)

func Int32ToUpdateLinksType(value int32)(UpdateLinksType ,error){
	switch value {
		case 0:  return UpdateLinksType_UserSet, nil  
		case 1:  return UpdateLinksType_Never, nil  
		case 2:  return UpdateLinksType_Always, nil  
		default:
			return 0 ,fmt.Errorf("invalid UpdateLinksType value: %d", value)
	}
}

/**************Enum ValidationAlertType *****************/

// Represents the data validation alert style.
type ValidationAlertType int32

const(
// Information alert style.
ValidationAlertType_Information ValidationAlertType = 0 

// Stop alert style.
ValidationAlertType_Stop ValidationAlertType = 1 

// Warning alert style.
ValidationAlertType_Warning ValidationAlertType = 2 
)

func Int32ToValidationAlertType(value int32)(ValidationAlertType ,error){
	switch value {
		case 0:  return ValidationAlertType_Information, nil  
		case 1:  return ValidationAlertType_Stop, nil  
		case 2:  return ValidationAlertType_Warning, nil  
		default:
			return 0 ,fmt.Errorf("invalid ValidationAlertType value: %d", value)
	}
}

/**************Enum ValidationType *****************/

// Represents data validation type.
type ValidationType int32

const(
// Any value validation type.
ValidationType_AnyValue ValidationType = 0 

// Whole number validation type.
ValidationType_WholeNumber ValidationType = 1 

// Decimal validation type.
ValidationType_Decimal ValidationType = 2 

// List validation type.
ValidationType_List ValidationType = 3 

// Date validation type.
ValidationType_Date ValidationType = 4 

// Time validation type.
ValidationType_Time ValidationType = 5 

// Text length validation type.
ValidationType_TextLength ValidationType = 6 

// Custom validation type.
ValidationType_Custom ValidationType = 7 
)

func Int32ToValidationType(value int32)(ValidationType ,error){
	switch value {
		case 0:  return ValidationType_AnyValue, nil  
		case 1:  return ValidationType_WholeNumber, nil  
		case 2:  return ValidationType_Decimal, nil  
		case 3:  return ValidationType_List, nil  
		case 4:  return ValidationType_Date, nil  
		case 5:  return ValidationType_Time, nil  
		case 6:  return ValidationType_TextLength, nil  
		case 7:  return ValidationType_Custom, nil  
		default:
			return 0 ,fmt.Errorf("invalid ValidationType value: %d", value)
	}
}

/**************Enum ViewType *****************/

// Represents the view type of the worksheet.
type ViewType int32

const(
ViewType_NormalView ViewType = 0 


ViewType_PageBreakPreview ViewType = 1 


ViewType_PageLayoutView ViewType = 2 
)

func Int32ToViewType(value int32)(ViewType ,error){
	switch value {
		case 0:  return ViewType_NormalView, nil  
		case 1:  return ViewType_PageBreakPreview, nil  
		case 2:  return ViewType_PageLayoutView, nil  
		default:
			return 0 ,fmt.Errorf("invalid ViewType value: %d", value)
	}
}

/**************Enum VisibilityType *****************/

// Represents the states for sheet visibility.
type VisibilityType int32

const(
// Indicates the sheet is visible.
VisibilityType_Visible VisibilityType = 0 

// Indicates the sheet is hidden, but can be shown by the user via the user interface.
VisibilityType_Hidden VisibilityType = 1 

// Indicates the sheet is hidden and cannot be shown in the user interface (UI).
// This state is only available programmatically.
VisibilityType_VeryHidden VisibilityType = 2 
)

func Int32ToVisibilityType(value int32)(VisibilityType ,error){
	switch value {
		case 0:  return VisibilityType_Visible, nil  
		case 1:  return VisibilityType_Hidden, nil  
		case 2:  return VisibilityType_VeryHidden, nil  
		default:
			return 0 ,fmt.Errorf("invalid VisibilityType value: %d", value)
	}
}

/**************Enum WarningType *****************/

// WaringType
type WarningType int32

const(
// Font substitution warning type
// when a font has not been found, this warning type can be get.
WarningType_FontSubstitution WarningType = 0 

// Duplicate defined name is found in the file.
WarningType_DuplicateDefinedName WarningType = 1 

// Unsupported file format.
WarningType_UnsupportedFileFormat WarningType = 2 

// Invalid text of the defined name.
WarningType_InvalidTextOfDefinedName WarningType = 3 

// Invalid the font name.
WarningType_InvalidFontName WarningType = 4 

// Invalid autofilter range.
WarningType_InvalidAutoFilterRange WarningType = 5 

// The file is corrupted.
WarningType_IO WarningType = 6 

// Out of MS Excel limitation error.
WarningType_Limitation WarningType = 7 

// Invalid data.
WarningType_InvalidData WarningType = 8 

// Invalid formula.
WarningType_Formula WarningType = 9 

// Invalid operator.
WarningType_InvalidOperator WarningType = 10 
)

func Int32ToWarningType(value int32)(WarningType ,error){
	switch value {
		case 0:  return WarningType_FontSubstitution, nil  
		case 1:  return WarningType_DuplicateDefinedName, nil  
		case 2:  return WarningType_UnsupportedFileFormat, nil  
		case 3:  return WarningType_InvalidTextOfDefinedName, nil  
		case 4:  return WarningType_InvalidFontName, nil  
		case 5:  return WarningType_InvalidAutoFilterRange, nil  
		case 6:  return WarningType_IO, nil  
		case 7:  return WarningType_Limitation, nil  
		case 8:  return WarningType_InvalidData, nil  
		case 9:  return WarningType_Formula, nil  
		case 10:  return WarningType_InvalidOperator, nil  
		default:
			return 0 ,fmt.Errorf("invalid WarningType value: %d", value)
	}
}
// Struct Color 
// Represents an ARGB (alpha, red, green, blue) color.
type Color struct {
	ptr unsafe.Pointer
}

func NewColor() ( *Color, error) {
	color := &Color{}
	CGoReturnPtr := C.New_Color()
	if CGoReturnPtr.error_no == 0 {
		color.ptr = CGoReturnPtr.return_value
		return color, nil
	} else {
		color.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return color, err
	}	
}

func (color *Color) Set_Color_A(value byte ) {
	C.Color_Set_a(color.ptr, C.uint8_t( value ))
}

func (color *Color) Get_Color_A() (byte , error) {
	CGoReturnPtr := C.Color_Get_a(color.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return 0, err
	}
	result := byte(CGoReturnPtr.return_value)
	return result, nil 
}


func (color *Color) Set_Color_R(value byte ) {
	C.Color_Set_r(color.ptr, C.uint8_t( value ))
}

func (color *Color) Get_Color_R() (byte , error) {
	CGoReturnPtr := C.Color_Get_r(color.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return 0, err
	}
	result := byte(CGoReturnPtr.return_value)
	return result, nil 
}


func (color *Color) Set_Color_G(value byte ) {
	C.Color_Set_g(color.ptr, C.uint8_t( value ))
}

func (color *Color) Get_Color_G() (byte , error) {
	CGoReturnPtr := C.Color_Get_g(color.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return 0, err
	}
	result := byte(CGoReturnPtr.return_value)
	return result, nil 
}


func (color *Color) Set_Color_B(value byte ) {
	C.Color_Set_b(color.ptr, C.uint8_t( value ))
}

func (color *Color) Get_Color_B() (byte , error) {
	CGoReturnPtr := C.Color_Get_b(color.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return 0, err
	}
	result := byte(CGoReturnPtr.return_value)
	return result, nil 
}

// Returns:
//   Color  
func Color_Black()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_Black()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_Navy()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_Navy()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_DarkBlue()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_DarkBlue()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_MediumBlue()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_MediumBlue()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_Blue()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_Blue()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_DarkGreen()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_DarkGreen()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_Green()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_Green()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_Teal()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_Teal()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_DarkCyan()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_DarkCyan()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_DeepSkyBlue()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_DeepSkyBlue()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_DarkTurquoise()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_DarkTurquoise()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_MediumSpringGreen()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_MediumSpringGreen()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_Lime()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_Lime()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_SpringGreen()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_SpringGreen()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_Aqua()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_Aqua()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_Cyan()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_Cyan()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_MidnightBlue()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_MidnightBlue()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_DodgerBlue()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_DodgerBlue()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_LightSeaGreen()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_LightSeaGreen()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_ForestGreen()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_ForestGreen()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_SeaGreen()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_SeaGreen()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_DarkSlateGray()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_DarkSlateGray()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_LimeGreen()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_LimeGreen()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_MediumSeaGreen()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_MediumSeaGreen()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_Turquoise()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_Turquoise()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_RoyalBlue()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_RoyalBlue()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_SteelBlue()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_SteelBlue()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_DarkSlateBlue()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_DarkSlateBlue()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_MediumTurquoise()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_MediumTurquoise()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_Indigo()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_Indigo()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_DarkOliveGreen()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_DarkOliveGreen()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_CadetBlue()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_CadetBlue()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_CornflowerBlue()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_CornflowerBlue()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_MediumAquaMarine()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_MediumAquaMarine()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_DimGray()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_DimGray()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_SlateBlue()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_SlateBlue()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_OliveDrab()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_OliveDrab()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_SlateGray()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_SlateGray()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_LightSlateGray()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_LightSlateGray()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_MediumSlateBlue()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_MediumSlateBlue()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_LawnGreen()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_LawnGreen()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_Chartreuse()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_Chartreuse()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_Aquamarine()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_Aquamarine()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_Maroon()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_Maroon()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_Purple()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_Purple()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_Olive()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_Olive()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_Gray()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_Gray()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_SkyBlue()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_SkyBlue()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_LightSkyBlue()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_LightSkyBlue()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_BlueViolet()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_BlueViolet()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_DarkRed()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_DarkRed()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_DarkMagenta()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_DarkMagenta()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_SaddleBrown()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_SaddleBrown()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_DarkSeaGreen()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_DarkSeaGreen()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_LightGreen()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_LightGreen()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_MediumPurple()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_MediumPurple()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_DarkViolet()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_DarkViolet()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_PaleGreen()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_PaleGreen()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_DarkOrchid()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_DarkOrchid()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_YellowGreen()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_YellowGreen()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_Sienna()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_Sienna()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_Brown()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_Brown()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_DarkGray()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_DarkGray()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_LightBlue()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_LightBlue()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_GreenYellow()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_GreenYellow()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_PaleTurquoise()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_PaleTurquoise()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_LightSteelBlue()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_LightSteelBlue()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_PowderBlue()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_PowderBlue()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_FireBrick()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_FireBrick()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_DarkGoldenRod()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_DarkGoldenRod()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_MediumOrchid()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_MediumOrchid()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_RosyBrown()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_RosyBrown()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_DarkKhaki()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_DarkKhaki()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_Silver()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_Silver()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_MediumVioletRed()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_MediumVioletRed()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_IndianRed()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_IndianRed()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_Peru()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_Peru()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_Chocolate()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_Chocolate()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_Tan()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_Tan()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_LightGray()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_LightGray()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_Thistle()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_Thistle()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_Orchid()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_Orchid()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_GoldenRod()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_GoldenRod()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_PaleVioletRed()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_PaleVioletRed()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_Crimson()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_Crimson()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_Gainsboro()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_Gainsboro()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_Plum()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_Plum()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_BurlyWood()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_BurlyWood()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_LightCyan()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_LightCyan()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_Lavender()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_Lavender()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_DarkSalmon()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_DarkSalmon()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_Violet()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_Violet()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_PaleGoldenRod()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_PaleGoldenRod()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_LightCoral()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_LightCoral()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_Khaki()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_Khaki()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_AliceBlue()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_AliceBlue()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_HoneyDew()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_HoneyDew()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_Azure()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_Azure()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_SandyBrown()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_SandyBrown()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_Wheat()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_Wheat()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_Beige()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_Beige()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_WhiteSmoke()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_WhiteSmoke()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_MintCream()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_MintCream()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_GhostWhite()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_GhostWhite()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_Salmon()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_Salmon()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_AntiqueWhite()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_AntiqueWhite()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_Linen()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_Linen()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_LightGoldenRodYellow()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_LightGoldenRodYellow()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_OldLace()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_OldLace()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_Red()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_Red()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_Fuchsia()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_Fuchsia()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_Magenta()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_Magenta()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_DeepPink()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_DeepPink()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_OrangeRed()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_OrangeRed()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_Tomato()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_Tomato()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_HotPink()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_HotPink()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_Coral()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_Coral()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_DarkOrange()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_DarkOrange()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_LightSalmon()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_LightSalmon()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_Orange()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_Orange()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_LightPink()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_LightPink()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_Pink()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_Pink()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_Gold()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_Gold()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_PeachPuff()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_PeachPuff()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_NavajoWhite()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_NavajoWhite()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_Moccasin()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_Moccasin()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_Bisque()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_Bisque()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_MistyRose()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_MistyRose()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_BlanchedAlmond()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_BlanchedAlmond()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_PapayaWhip()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_PapayaWhip()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_LavenderBlush()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_LavenderBlush()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_SeaShell()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_SeaShell()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_Cornsilk()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_Cornsilk()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_LemonChiffon()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_LemonChiffon()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_FloralWhite()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_FloralWhite()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_Snow()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_Snow()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_Yellow()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_Yellow()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_LightYellow()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_LightYellow()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_Ivory()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_Ivory()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Returns:
//   Color  
func Color_White()  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_White()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Creates a Color from its 32-bit component (alpha, red, green, and blue) values.
// Parameters:
//   value - int32 
// Returns:
//   Color  
func Color_FromArgb(value int32)  (*Color,  error)  {
	
	CGoReturnPtr := C.Color_FromArgb(C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}

func DeleteColor(color *Color){
	C.Delete_Color(color.ptr)
}
// Class AboveAverage 

// Describe the AboveAverage conditional formatting rule.
// This conditional formatting rule highlights cells that
// are above or below the average for all values in the range.
type AboveAverage struct {
	ptr unsafe.Pointer
}

// Default constructor.
func NewAboveAverage() ( *AboveAverage, error) {
	aboveaverage := &AboveAverage{}
	CGoReturnPtr := C.New_AboveAverage()
	if CGoReturnPtr.error_no == 0 {
		aboveaverage.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(aboveaverage, DeleteAboveAverage)
		return aboveaverage, nil
	} else {
		aboveaverage.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return aboveaverage, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *AboveAverage) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.AboveAverage_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Get or set the flag indicating whether the rule is an "above average" rule.
// 'true' indicates 'above average'.
// Default value is true.
// Returns:
//   bool  
func (instance *AboveAverage) IsAboveAverage()  (bool,  error)  {
	
	CGoReturnPtr := C.AboveAverage_IsAboveAverage( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Get or set the flag indicating whether the rule is an "above average" rule.
// 'true' indicates 'above average'.
// Default value is true.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *AboveAverage) SetIsAboveAverage(value bool)  error {
	
	CGoReturnPtr := C.AboveAverage_SetIsAboveAverage( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Get or set the flag indicating whether the 'aboveAverage' and 'belowAverage' criteria
// is inclusive of the average itself, or exclusive of that value.
// 'true' indicates to include the average value in the criteria.
// Default value is false.
// Returns:
//   bool  
func (instance *AboveAverage) IsEqualAverage()  (bool,  error)  {
	
	CGoReturnPtr := C.AboveAverage_IsEqualAverage( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Get or set the flag indicating whether the 'aboveAverage' and 'belowAverage' criteria
// is inclusive of the average itself, or exclusive of that value.
// 'true' indicates to include the average value in the criteria.
// Default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *AboveAverage) SetIsEqualAverage(value bool)  error {
	
	CGoReturnPtr := C.AboveAverage_SetIsEqualAverage( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Get or set the number of standard deviations to include above or below the average in the
// conditional formatting rule.
// The input value must between 0 and 3 (include 0 and 3).
// Setting this value to 0 means stdDev is not set.
// The default value is 0.
// Returns:
//   int32  
func (instance *AboveAverage) GetStdDev()  (int32,  error)  {
	
	CGoReturnPtr := C.AboveAverage_GetStdDev( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Get or set the number of standard deviations to include above or below the average in the
// conditional formatting rule.
// The input value must between 0 and 3 (include 0 and 3).
// Setting this value to 0 means stdDev is not set.
// The default value is 0.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *AboveAverage) SetStdDev(value int32)  error {
	
	CGoReturnPtr := C.AboveAverage_SetStdDev( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}



func DeleteAboveAverage(aboveaverage *AboveAverage){
	runtime.SetFinalizer(aboveaverage, nil)
	C.Delete_AboveAverage(aboveaverage.ptr)
	aboveaverage.ptr = nil
}

// Class AbstractCalculationEngine 

// Represents user's custom calculation engine to extend the default calculation engine of Aspose.Cells.
type AbstractCalculationEngine struct {
	ptr unsafe.Pointer
}


// Indicates whether this engine needs the literal text of parameter while doing calculation. Default value is false.
// Returns:
//   bool  
func (instance *AbstractCalculationEngine) IsParamLiteralRequired()  (bool,  error)  {
	
	CGoReturnPtr := C.AbstractCalculationEngine_IsParamLiteralRequired( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether this engine needs the parameter to be calculated in array mode. Default value is false.
// If <see cref="CalculationData.GetParamValueInArrayMode(int, int, int)"/> is required when calculating custom
// functions and user has not updated the definition for them
// (by <see cref="Workbook.UpdateCustomFunctionDefinition(CustomFunctionDefinition)"/>),
// this property needs to be set as true.
// Returns:
//   bool  
func (instance *AbstractCalculationEngine) IsParamArrayModeRequired()  (bool,  error)  {
	
	CGoReturnPtr := C.AbstractCalculationEngine_IsParamArrayModeRequired( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Whether built-in functions that have been supported by the built-in engine
// should be checked and processed by this implementation.
// Default is false.
// Returns:
//   bool  
func (instance *AbstractCalculationEngine) GetProcessBuiltInFunctions()  (bool,  error)  {
	
	CGoReturnPtr := C.AbstractCalculationEngine_GetProcessBuiltInFunctions( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Whether force given function to be recalculated always when calculating shared formulas.
// Parameters:
//   functionName - string 
// Returns:
//   bool  
func (instance *AbstractCalculationEngine) ForceRecalculate(functionname string)  (bool,  error)  {
	
	CGoReturnPtr := C.AbstractCalculationEngine_ForceRecalculate( instance.ptr, C.CString(functionname))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}



func DeleteAbstractCalculationEngine(abstractcalculationengine *AbstractCalculationEngine){
	runtime.SetFinalizer(abstractcalculationengine, nil)
	C.Delete_AbstractCalculationEngine(abstractcalculationengine.ptr)
	abstractcalculationengine.ptr = nil
}

// Class AbstractFormulaChangeMonitor 

// Monitor for user to track the change of formulas during certain operations.
type AbstractFormulaChangeMonitor struct {
	ptr unsafe.Pointer
}


// The event that will be triggered when the formula in a cell is changed.
// Parameters:
//   sheetIndex - int32 
//   rowIndex - int32 
//   columnIndex - int32 
// Returns:
//   void  
func (instance *AbstractFormulaChangeMonitor) OnCellFormulaChanged(sheetindex int32, rowindex int32, columnindex int32)  error {
	
	CGoReturnPtr := C.AbstractFormulaChangeMonitor_OnCellFormulaChanged( instance.ptr, C.int(sheetindex), C.int(rowindex), C.int(columnindex))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// The event that will be triggered when the formula of FormatCondition is changed.
// Parameters:
//   fc - FormatCondition 
// Returns:
//   void  
func (instance *AbstractFormulaChangeMonitor) OnFormatConditionFormulaChanged(fc *FormatCondition)  error {
	
	var fc_ptr unsafe.Pointer = nil
	if fc != nil {
	  fc_ptr =fc.ptr
	}

	CGoReturnPtr := C.AbstractFormulaChangeMonitor_OnFormatConditionFormulaChanged( instance.ptr, fc_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}



func DeleteAbstractFormulaChangeMonitor(abstractformulachangemonitor *AbstractFormulaChangeMonitor){
	runtime.SetFinalizer(abstractformulachangemonitor, nil)
	C.Delete_AbstractFormulaChangeMonitor(abstractformulachangemonitor.ptr)
	abstractformulachangemonitor.ptr = nil
}

// Class AbstractInterruptMonitor 

// Monitor for interruption requests in all time-consuming operations.
type AbstractInterruptMonitor struct {
	ptr unsafe.Pointer
}


// When procedure is interrupted, whether terminate the procedure quietly or throw an Exception.
// Default is false, that is, when <see cref="IsInterruptionRequested"/> is true,
// a <see cref="CellsException"/> with code <see cref="ExceptionType.Interrupted"/> will be thrown.
// Returns:
//   bool  
func (instance *AbstractInterruptMonitor) GetTerminateWithoutException()  (bool,  error)  {
	
	CGoReturnPtr := C.AbstractInterruptMonitor_GetTerminateWithoutException( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}



func DeleteAbstractInterruptMonitor(abstractinterruptmonitor *AbstractInterruptMonitor){
	runtime.SetFinalizer(abstractinterruptmonitor, nil)
	C.Delete_AbstractInterruptMonitor(abstractinterruptmonitor.ptr)
	abstractinterruptmonitor.ptr = nil
}

// Class AbstractTextLoadOptions 

// Common options for loading text values
type AbstractTextLoadOptions struct {
	ptr unsafe.Pointer
}

// Constructs from a parent object.
// Parameters:
//   src - LoadOptions 
func NewAbstractTextLoadOptions(src *LoadOptions) ( *AbstractTextLoadOptions, error) {
	abstracttextloadoptions := &AbstractTextLoadOptions{}
	var src_ptr unsafe.Pointer = nil
	if src != nil {
	  src_ptr =src.ptr
	}

	CGoReturnPtr := C.New_AbstractTextLoadOptions(src_ptr)
	if CGoReturnPtr.error_no == 0 {
		abstracttextloadoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(abstracttextloadoptions, DeleteAbstractTextLoadOptions)
		return abstracttextloadoptions, nil
	} else {
		abstracttextloadoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return abstracttextloadoptions, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *AbstractTextLoadOptions) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.AbstractTextLoadOptions_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the default encoding. Only applies for csv file.
// Returns:
//   int32  
func (instance *AbstractTextLoadOptions) GetEncoding()  (EncodingType,  error)  {
	
	CGoReturnPtr := C.AbstractTextLoadOptions_GetEncoding( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToEncodingType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets and sets the default encoding. Only applies for csv file.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *AbstractTextLoadOptions) SetEncoding(value EncodingType)  error {
	
	CGoReturnPtr := C.AbstractTextLoadOptions_SetEncoding( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates the strategy to apply style for parsed values when converting string value to number or datetime.
// Returns:
//   int32  
func (instance *AbstractTextLoadOptions) GetLoadStyleStrategy()  (TxtLoadStyleStrategy,  error)  {
	
	CGoReturnPtr := C.AbstractTextLoadOptions_GetLoadStyleStrategy( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToTxtLoadStyleStrategy(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Indicates the strategy to apply style for parsed values when converting string value to number or datetime.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *AbstractTextLoadOptions) SetLoadStyleStrategy(value TxtLoadStyleStrategy)  error {
	
	CGoReturnPtr := C.AbstractTextLoadOptions_SetLoadStyleStrategy( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets a value that indicates whether the string in text file is converted to numeric data.
// Returns:
//   bool  
func (instance *AbstractTextLoadOptions) GetConvertNumericData()  (bool,  error)  {
	
	CGoReturnPtr := C.AbstractTextLoadOptions_GetConvertNumericData( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets a value that indicates whether the string in text file is converted to numeric data.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *AbstractTextLoadOptions) SetConvertNumericData(value bool)  error {
	
	CGoReturnPtr := C.AbstractTextLoadOptions_SetConvertNumericData( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets a value that indicates whether the string in text file is converted to date data.
// Returns:
//   bool  
func (instance *AbstractTextLoadOptions) GetConvertDateTimeData()  (bool,  error)  {
	
	CGoReturnPtr := C.AbstractTextLoadOptions_GetConvertDateTimeData( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets a value that indicates whether the string in text file is converted to date data.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *AbstractTextLoadOptions) SetConvertDateTimeData(value bool)  error {
	
	CGoReturnPtr := C.AbstractTextLoadOptions_SetConvertDateTimeData( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether not parsing a string value if the length is 15.
// Returns:
//   bool  
func (instance *AbstractTextLoadOptions) GetKeepPrecision()  (bool,  error)  {
	
	CGoReturnPtr := C.AbstractTextLoadOptions_GetKeepPrecision( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether not parsing a string value if the length is 15.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *AbstractTextLoadOptions) SetKeepPrecision(value bool)  error {
	
	CGoReturnPtr := C.AbstractTextLoadOptions_SetKeepPrecision( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the load format.
// Returns:
//   int32  
func (instance *AbstractTextLoadOptions) GetLoadFormat()  (LoadFormat,  error)  {
	
	CGoReturnPtr := C.AbstractTextLoadOptions_GetLoadFormat( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToLoadFormat(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets and set the password of the workbook.
// Returns:
//   string  
func (instance *AbstractTextLoadOptions) GetPassword()  (string,  error)  {
	
	CGoReturnPtr := C.AbstractTextLoadOptions_GetPassword( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and set the password of the workbook.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *AbstractTextLoadOptions) SetPassword(value string)  error {
	
	CGoReturnPtr := C.AbstractTextLoadOptions_SetPassword( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether parsing the formula when reading the file.
// Returns:
//   bool  
func (instance *AbstractTextLoadOptions) GetParsingFormulaOnOpen()  (bool,  error)  {
	
	CGoReturnPtr := C.AbstractTextLoadOptions_GetParsingFormulaOnOpen( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether parsing the formula when reading the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *AbstractTextLoadOptions) SetParsingFormulaOnOpen(value bool)  error {
	
	CGoReturnPtr := C.AbstractTextLoadOptions_SetParsingFormulaOnOpen( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether parsing pivot cached records when loading the file.
// The default value is false.
// Returns:
//   bool  
func (instance *AbstractTextLoadOptions) GetParsingPivotCachedRecords()  (bool,  error)  {
	
	CGoReturnPtr := C.AbstractTextLoadOptions_GetParsingPivotCachedRecords( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether parsing pivot cached records when loading the file.
// The default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *AbstractTextLoadOptions) SetParsingPivotCachedRecords(value bool)  error {
	
	CGoReturnPtr := C.AbstractTextLoadOptions_SetParsingPivotCachedRecords( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Sets the default print paper size from default printer's setting.
// Parameters:
//   type - int32 
// Returns:
//   void  
func (instance *AbstractTextLoadOptions) SetPaperSize(type_ PaperSizeType)  error {
	
	CGoReturnPtr := C.AbstractTextLoadOptions_SetPaperSize( instance.ptr, C.int( int32(type_)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the user interface language of the Workbook version based on CountryCode that has saved the file.
// Returns:
//   int32  
func (instance *AbstractTextLoadOptions) GetLanguageCode()  (CountryCode,  error)  {
	
	CGoReturnPtr := C.AbstractTextLoadOptions_GetLanguageCode( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToCountryCode(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets or sets the user interface language of the Workbook version based on CountryCode that has saved the file.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *AbstractTextLoadOptions) SetLanguageCode(value CountryCode)  error {
	
	CGoReturnPtr := C.AbstractTextLoadOptions_SetLanguageCode( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the regional settings used for the Workbook that will be loaded.
// Returns:
//   int32  
func (instance *AbstractTextLoadOptions) GetRegion()  (CountryCode,  error)  {
	
	CGoReturnPtr := C.AbstractTextLoadOptions_GetRegion( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToCountryCode(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets or sets the regional settings used for the Workbook that will be loaded.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *AbstractTextLoadOptions) SetRegion(value CountryCode)  error {
	
	CGoReturnPtr := C.AbstractTextLoadOptions_SetRegion( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the default style settings for initializing styles of the workbook
// Returns:
//   DefaultStyleSettings  
func (instance *AbstractTextLoadOptions) GetDefaultStyleSettings()  (*DefaultStyleSettings,  error)  {
	
	CGoReturnPtr := C.AbstractTextLoadOptions_GetDefaultStyleSettings( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &DefaultStyleSettings{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteDefaultStyleSettings) 

	return result, nil 
}
// Gets and sets the interrupt monitor.
// Returns:
//   AbstractInterruptMonitor  
func (instance *AbstractTextLoadOptions) GetInterruptMonitor()  (*AbstractInterruptMonitor,  error)  {
	
	CGoReturnPtr := C.AbstractTextLoadOptions_GetInterruptMonitor( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &AbstractInterruptMonitor{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteAbstractInterruptMonitor) 

	return result, nil 
}
// Gets and sets the interrupt monitor.
// Parameters:
//   value - AbstractInterruptMonitor 
// Returns:
//   void  
func (instance *AbstractTextLoadOptions) SetInterruptMonitor(value *AbstractInterruptMonitor)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.AbstractTextLoadOptions_SetInterruptMonitor( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Ignore the data which are not printed if directly printing the file
// Returns:
//   bool  
func (instance *AbstractTextLoadOptions) GetIgnoreNotPrinted()  (bool,  error)  {
	
	CGoReturnPtr := C.AbstractTextLoadOptions_GetIgnoreNotPrinted( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Ignore the data which are not printed if directly printing the file
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *AbstractTextLoadOptions) SetIgnoreNotPrinted(value bool)  error {
	
	CGoReturnPtr := C.AbstractTextLoadOptions_SetIgnoreNotPrinted( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Check whether data is valid in the template file.
// Returns:
//   bool  
func (instance *AbstractTextLoadOptions) GetCheckDataValid()  (bool,  error)  {
	
	CGoReturnPtr := C.AbstractTextLoadOptions_GetCheckDataValid( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Check whether data is valid in the template file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *AbstractTextLoadOptions) SetCheckDataValid(value bool)  error {
	
	CGoReturnPtr := C.AbstractTextLoadOptions_SetCheckDataValid( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Whether check restriction of excel file when user modify cells related objects.
// For example, excel does not allow inputting string value longer than 32K.
// When you input a value longer than 32K such as by Cell.PutValue(string), if this property is true, you will get an Exception.
// If this property is false, we will accept your input string value as the cell's value so that later
// you can output the complete string value for other file formats such as CSV.
// However, if you have set such kind of value that is invalid for excel file format,
// you should not save the workbook as excel file format later. Otherwise there may be unexpected error for the generated excel file.
// Returns:
//   bool  
func (instance *AbstractTextLoadOptions) GetCheckExcelRestriction()  (bool,  error)  {
	
	CGoReturnPtr := C.AbstractTextLoadOptions_GetCheckExcelRestriction( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Whether check restriction of excel file when user modify cells related objects.
// For example, excel does not allow inputting string value longer than 32K.
// When you input a value longer than 32K such as by Cell.PutValue(string), if this property is true, you will get an Exception.
// If this property is false, we will accept your input string value as the cell's value so that later
// you can output the complete string value for other file formats such as CSV.
// However, if you have set such kind of value that is invalid for excel file format,
// you should not save the workbook as excel file format later. Otherwise there may be unexpected error for the generated excel file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *AbstractTextLoadOptions) SetCheckExcelRestriction(value bool)  error {
	
	CGoReturnPtr := C.AbstractTextLoadOptions_SetCheckExcelRestriction( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Whether keep the unparsed data in memory for the Workbook when it is loaded from template file. Default is true.
// Returns:
//   bool  
func (instance *AbstractTextLoadOptions) GetKeepUnparsedData()  (bool,  error)  {
	
	CGoReturnPtr := C.AbstractTextLoadOptions_GetKeepUnparsedData( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Whether keep the unparsed data in memory for the Workbook when it is loaded from template file. Default is true.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *AbstractTextLoadOptions) SetKeepUnparsedData(value bool)  error {
	
	CGoReturnPtr := C.AbstractTextLoadOptions_SetKeepUnparsedData( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// The filter to denote how to load data.
// Returns:
//   LoadFilter  
func (instance *AbstractTextLoadOptions) GetLoadFilter()  (*LoadFilter,  error)  {
	
	CGoReturnPtr := C.AbstractTextLoadOptions_GetLoadFilter( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &LoadFilter{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteLoadFilter) 

	return result, nil 
}
// The filter to denote how to load data.
// Parameters:
//   value - LoadFilter 
// Returns:
//   void  
func (instance *AbstractTextLoadOptions) SetLoadFilter(value *LoadFilter)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.AbstractTextLoadOptions_SetLoadFilter( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the memory usage options.
// Returns:
//   int32  
func (instance *AbstractTextLoadOptions) GetMemorySetting()  (MemorySetting,  error)  {
	
	CGoReturnPtr := C.AbstractTextLoadOptions_GetMemorySetting( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToMemorySetting(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets or sets the memory usage options.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *AbstractTextLoadOptions) SetMemorySetting(value MemorySetting)  error {
	
	CGoReturnPtr := C.AbstractTextLoadOptions_SetMemorySetting( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the auto fitter options
// Returns:
//   AutoFitterOptions  
func (instance *AbstractTextLoadOptions) GetAutoFitterOptions()  (*AutoFitterOptions,  error)  {
	
	CGoReturnPtr := C.AbstractTextLoadOptions_GetAutoFitterOptions( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &AutoFitterOptions{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteAutoFitterOptions) 

	return result, nil 
}
// Gets and sets the auto fitter options
// Parameters:
//   value - AutoFitterOptions 
// Returns:
//   void  
func (instance *AbstractTextLoadOptions) SetAutoFitterOptions(value *AutoFitterOptions)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.AbstractTextLoadOptions_SetAutoFitterOptions( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether auto filtering the data when loading the files.
// Returns:
//   bool  
func (instance *AbstractTextLoadOptions) GetAutoFilter()  (bool,  error)  {
	
	CGoReturnPtr := C.AbstractTextLoadOptions_GetAutoFilter( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether auto filtering the data when loading the files.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *AbstractTextLoadOptions) SetAutoFilter(value bool)  error {
	
	CGoReturnPtr := C.AbstractTextLoadOptions_SetAutoFilter( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets individual font configs.
// Only works for the <see cref="Workbook"/> which uses this <see cref="LoadOptions"/> to load.
// Returns:
//   IndividualFontConfigs  
func (instance *AbstractTextLoadOptions) GetFontConfigs()  (*IndividualFontConfigs,  error)  {
	
	CGoReturnPtr := C.AbstractTextLoadOptions_GetFontConfigs( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &IndividualFontConfigs{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteIndividualFontConfigs) 

	return result, nil 
}
// Gets and sets individual font configs.
// Only works for the <see cref="Workbook"/> which uses this <see cref="LoadOptions"/> to load.
// Parameters:
//   value - IndividualFontConfigs 
// Returns:
//   void  
func (instance *AbstractTextLoadOptions) SetFontConfigs(value *IndividualFontConfigs)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.AbstractTextLoadOptions_SetFontConfigs( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether ignoring useless shapes.
// Returns:
//   bool  
func (instance *AbstractTextLoadOptions) GetIgnoreUselessShapes()  (bool,  error)  {
	
	CGoReturnPtr := C.AbstractTextLoadOptions_GetIgnoreUselessShapes( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether ignoring useless shapes.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *AbstractTextLoadOptions) SetIgnoreUselessShapes(value bool)  error {
	
	CGoReturnPtr := C.AbstractTextLoadOptions_SetIgnoreUselessShapes( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether preserve those spaces and line breaks that are padded between formula tokens
// while getting and setting formulas.
// Default value is false.
// Returns:
//   bool  
func (instance *AbstractTextLoadOptions) GetPreservePaddingSpacesInFormula()  (bool,  error)  {
	
	CGoReturnPtr := C.AbstractTextLoadOptions_GetPreservePaddingSpacesInFormula( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether preserve those spaces and line breaks that are padded between formula tokens
// while getting and setting formulas.
// Default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *AbstractTextLoadOptions) SetPreservePaddingSpacesInFormula(value bool)  error {
	
	CGoReturnPtr := C.AbstractTextLoadOptions_SetPreservePaddingSpacesInFormula( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}


func (instance *AbstractTextLoadOptions) ToLoadOptions() *LoadOptions {
	parentClass := &LoadOptions{}
	parentClass.ptr = instance.ptr
	return parentClass
}

func DeleteAbstractTextLoadOptions(abstracttextloadoptions *AbstractTextLoadOptions){
	runtime.SetFinalizer(abstracttextloadoptions, nil)
	C.Delete_AbstractTextLoadOptions(abstracttextloadoptions.ptr)
	abstracttextloadoptions.ptr = nil
}

// Class AdvancedFilter 

// Represents the settings of advanced filter.
type AdvancedFilter struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *AdvancedFilter) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.AdvancedFilter_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the list range of this advanced filter.
// Returns:
//   string  
func (instance *AdvancedFilter) GetListRange()  (string,  error)  {
	
	CGoReturnPtr := C.AdvancedFilter_GetListRange( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the criteria range of this advanced filter.
// Returns:
//   string  
func (instance *AdvancedFilter) GetCriteriaRange()  (string,  error)  {
	
	CGoReturnPtr := C.AdvancedFilter_GetCriteriaRange( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the range where copying the resut of this advanced filter to.
// Returns:
//   string  
func (instance *AdvancedFilter) GetCopyToRange()  (string,  error)  {
	
	CGoReturnPtr := C.AdvancedFilter_GetCopyToRange( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}



func DeleteAdvancedFilter(advancedfilter *AdvancedFilter){
	runtime.SetFinalizer(advancedfilter, nil)
	C.Delete_AdvancedFilter(advancedfilter.ptr)
	advancedfilter.ptr = nil
}

// Class AutoFilter 

// Represents autofiltering for the specified worksheet.
type AutoFilter struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *AutoFilter) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.AutoFilter_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the data sorter.
// Returns:
//   DataSorter  
func (instance *AutoFilter) GetSorter()  (*DataSorter,  error)  {
	
	CGoReturnPtr := C.AutoFilter_GetSorter( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &DataSorter{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteDataSorter) 

	return result, nil 
}
// Sets the range to which the specified AutoFilter applies.
// Parameters:
//   row - int32 
//   startColumn - int32 
//   endColumn - int32 
// Returns:
//   void  
func (instance *AutoFilter) SetRange_Int_Int_Int(row int32, startcolumn int32, endcolumn int32)  error {
	
	CGoReturnPtr := C.AutoFilter_SetRange_Integer_Integer_Integer( instance.ptr, C.int(row), C.int(startcolumn), C.int(endcolumn))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the <see cref="CellArea"/> where the this AutoFilter applies to.
// Returns:
//   CellArea  
func (instance *AutoFilter) GetCellArea()  (*CellArea,  error)  {
	
	CGoReturnPtr := C.AutoFilter_GetCellArea( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &CellArea{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteCellArea) 

	return result, nil 
}
// Gets the <see cref="CellArea"/> where the specified AutoFilter applies to.
// Parameters:
//   refreshAppliedRange - bool 
// Returns:
//   CellArea  
func (instance *AutoFilter) GetCellArea_Bool(refreshappliedrange bool)  (*CellArea,  error)  {
	
	CGoReturnPtr := C.AutoFilter_GetCellArea_Boolean( instance.ptr, C.bool(refreshappliedrange))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &CellArea{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteCellArea) 

	return result, nil 
}
// Represents the range to which the specified AutoFilter applies.
// Returns:
//   string  
func (instance *AutoFilter) GetRange()  (string,  error)  {
	
	CGoReturnPtr := C.AutoFilter_GetRange( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents the range to which the specified AutoFilter applies.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *AutoFilter) SetRange_String(value string)  error {
	
	CGoReturnPtr := C.AutoFilter_SetRange_String( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Adds a filter for a filter column.
// Parameters:
//   fieldIndex - int32 
//   criteria - string 
// Returns:
//   void  
func (instance *AutoFilter) AddFilter(fieldindex int32, criteria string)  error {
	
	CGoReturnPtr := C.AutoFilter_AddFilter( instance.ptr, C.int(fieldindex), C.CString(criteria))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Adds a date filter.
// Parameters:
//   fieldIndex - int32 
//   dateTimeGroupingType - int32 
//   year - int32 
//   month - int32 
//   day - int32 
//   hour - int32 
//   minute - int32 
//   second - int32 
// Returns:
//   void  
func (instance *AutoFilter) AddDateFilter(fieldindex int32, datetimegroupingtype DateTimeGroupingType, year int32, month int32, day int32, hour int32, minute int32, second int32)  error {
	
	CGoReturnPtr := C.AutoFilter_AddDateFilter( instance.ptr, C.int(fieldindex), C.int( int32(datetimegroupingtype)), C.int(year), C.int(month), C.int(day), C.int(hour), C.int(minute), C.int(second))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Removes a date filter.
// Parameters:
//   fieldIndex - int32 
//   dateTimeGroupingType - int32 
//   year - int32 
//   month - int32 
//   day - int32 
//   hour - int32 
//   minute - int32 
//   second - int32 
// Returns:
//   void  
func (instance *AutoFilter) RemoveDateFilter(fieldindex int32, datetimegroupingtype DateTimeGroupingType, year int32, month int32, day int32, hour int32, minute int32, second int32)  error {
	
	CGoReturnPtr := C.AutoFilter_RemoveDateFilter( instance.ptr, C.int(fieldindex), C.int( int32(datetimegroupingtype)), C.int(year), C.int(month), C.int(day), C.int(hour), C.int(minute), C.int(second))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Removes a filter for a filter column.
// Parameters:
//   fieldIndex - int32 
//   criteria - string 
// Returns:
//   void  
func (instance *AutoFilter) RemoveFilter_Int_String(fieldindex int32, criteria string)  error {
	
	CGoReturnPtr := C.AutoFilter_RemoveFilter_Integer_String( instance.ptr, C.int(fieldindex), C.CString(criteria))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Filters a list with specified criteria.
// Parameters:
//   fieldIndex - int32 
//   criteria - string 
// Returns:
//   void  
func (instance *AutoFilter) Filter(fieldindex int32, criteria string)  error {
	
	CGoReturnPtr := C.AutoFilter_Filter( instance.ptr, C.int(fieldindex), C.CString(criteria))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Filter the top 10 item in the list
// Parameters:
//   fieldIndex - int32 
//   isTop - bool 
//   isPercent - bool 
//   itemCount - int32 
// Returns:
//   void  
func (instance *AutoFilter) FilterTop10(fieldindex int32, istop bool, ispercent bool, itemcount int32)  error {
	
	CGoReturnPtr := C.AutoFilter_FilterTop10( instance.ptr, C.int(fieldindex), C.bool(istop), C.bool(ispercent), C.int(itemcount))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Adds a dynamic filter.
// Parameters:
//   fieldIndex - int32 
//   dynamicFilterType - int32 
// Returns:
//   void  
func (instance *AutoFilter) Dynamic_Filter(fieldindex int32, dynamicfiltertype DynamicFilterType)  error {
	
	CGoReturnPtr := C.AutoFilter_Dynamic_Filter( instance.ptr, C.int(fieldindex), C.int( int32(dynamicfiltertype)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Adds a font color filter.
// Parameters:
//   fieldIndex - int32 
//   color - CellsColor 
// Returns:
//   void  
func (instance *AutoFilter) AddFontColorFilter(fieldindex int32, color *CellsColor)  error {
	
	var color_ptr unsafe.Pointer = nil
	if color != nil {
	  color_ptr =color.ptr
	}

	CGoReturnPtr := C.AutoFilter_AddFontColorFilter( instance.ptr, C.int(fieldindex), color_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Adds a fill color filter.
// Parameters:
//   fieldIndex - int32 
//   pattern - int32 
//   foregroundColor - CellsColor 
//   backgroundColor - CellsColor 
// Returns:
//   void  
func (instance *AutoFilter) AddFillColorFilter(fieldindex int32, pattern BackgroundType, foregroundcolor *CellsColor, backgroundcolor *CellsColor)  error {
	
	var foregroundcolor_ptr unsafe.Pointer = nil
	if foregroundcolor != nil {
	  foregroundcolor_ptr =foregroundcolor.ptr
	}
	var backgroundcolor_ptr unsafe.Pointer = nil
	if backgroundcolor != nil {
	  backgroundcolor_ptr =backgroundcolor.ptr
	}

	CGoReturnPtr := C.AutoFilter_AddFillColorFilter( instance.ptr, C.int(fieldindex), C.int( int32(pattern)), foregroundcolor_ptr, backgroundcolor_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Adds an icon filter.
// Parameters:
//   fieldIndex - int32 
//   iconSetType - int32 
//   iconId - int32 
// Returns:
//   void  
func (instance *AutoFilter) AddIconFilter(fieldindex int32, iconsettype IconSetType, iconid int32)  error {
	
	CGoReturnPtr := C.AutoFilter_AddIconFilter( instance.ptr, C.int(fieldindex), C.int( int32(iconsettype)), C.int(iconid))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Match all blank cell in the list.
// Parameters:
//   fieldIndex - int32 
// Returns:
//   void  
func (instance *AutoFilter) MatchBlanks(fieldindex int32)  error {
	
	CGoReturnPtr := C.AutoFilter_MatchBlanks( instance.ptr, C.int(fieldindex))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Match all not blank cell in the list.
// Parameters:
//   fieldIndex - int32 
// Returns:
//   void  
func (instance *AutoFilter) MatchNonBlanks(fieldindex int32)  error {
	
	CGoReturnPtr := C.AutoFilter_MatchNonBlanks( instance.ptr, C.int(fieldindex))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Filters a list with a custom criteria.
// Parameters:
//   fieldIndex - int32 
//   operatorType1 - int32 
//   criteria1 - Object 
// Returns:
//   void  
func (instance *AutoFilter) Custom_Int_FilterOperatorType_Object(fieldindex int32, operatortype1 FilterOperatorType, criteria1 *Object)  error {
	
	var criteria1_ptr unsafe.Pointer = nil
	if criteria1 != nil {
	  criteria1_ptr =criteria1.ptr
	}

	CGoReturnPtr := C.AutoFilter_Custom_Integer_FilterOperatorType_Object( instance.ptr, C.int(fieldindex), C.int( int32(operatortype1)), criteria1_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Filters a list with custom criteria.
// Parameters:
//   fieldIndex - int32 
//   operatorType1 - int32 
//   criteria1 - Object 
//   isAnd - bool 
//   operatorType2 - int32 
//   criteria2 - Object 
// Returns:
//   void  
func (instance *AutoFilter) Custom_Int_FilterOperatorType_Object_Bool_FilterOperatorType_Object(fieldindex int32, operatortype1 FilterOperatorType, criteria1 *Object, isand bool, operatortype2 FilterOperatorType, criteria2 *Object)  error {
	
	var criteria1_ptr unsafe.Pointer = nil
	if criteria1 != nil {
	  criteria1_ptr =criteria1.ptr
	}
	var criteria2_ptr unsafe.Pointer = nil
	if criteria2 != nil {
	  criteria2_ptr =criteria2.ptr
	}

	CGoReturnPtr := C.AutoFilter_Custom_Integer_FilterOperatorType_Object_Boolean_FilterOperatorType_Object( instance.ptr, C.int(fieldindex), C.int( int32(operatortype1)), criteria1_ptr, C.bool(isand), C.int( int32(operatortype2)), criteria2_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Unhide all rows.
// Returns:
//   void  
func (instance *AutoFilter) ShowAll()  error {
	
	CGoReturnPtr := C.AutoFilter_ShowAll( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Remove the specific filter.
// Parameters:
//   fieldIndex - int32 
// Returns:
//   void  
func (instance *AutoFilter) RemoveFilter_Int(fieldindex int32)  error {
	
	CGoReturnPtr := C.AutoFilter_RemoveFilter_Integer( instance.ptr, C.int(fieldindex))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Refresh auto filters to hide or unhide the rows.
// Returns:
//   []int32_t  
func (instance *AutoFilter) Refresh()  ([]int32,  error)  {
	
	CGoReturnPtr := C.AutoFilter_Refresh( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result:= make([]int32, CGoReturnPtr.column_length)
	for i := 0; i < int(CGoReturnPtr.column_length); i++ {
	   offset := uintptr(C.size_t(i)) * uintptr(CGoReturnPtr.size)
	   cObject := *(*C.int)(unsafe.Pointer( uintptr( unsafe.Pointer(CGoReturnPtr.return_value)) + offset))
	   goObject :=int32(cObject)
	   result[i] = goObject
	}
	 

	return result, nil 
}
// Gets all hidden rows' indexes.
// Parameters:
//   hideRows - bool 
// Returns:
//   []int32_t  
func (instance *AutoFilter) Refresh_Bool(hiderows bool)  ([]int32,  error)  {
	
	CGoReturnPtr := C.AutoFilter_Refresh_Boolean( instance.ptr, C.bool(hiderows))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result:= make([]int32, CGoReturnPtr.column_length)
	for i := 0; i < int(CGoReturnPtr.column_length); i++ {
	   offset := uintptr(C.size_t(i)) * uintptr(CGoReturnPtr.size)
	   cObject := *(*C.int)(unsafe.Pointer( uintptr( unsafe.Pointer(CGoReturnPtr.return_value)) + offset))
	   goObject :=int32(cObject)
	   result[i] = goObject
	}
	 

	return result, nil 
}
// Indicates whether the AutoFilter button for this column is visible.
// Returns:
//   bool  
func (instance *AutoFilter) GetShowFilterButton()  (bool,  error)  {
	
	CGoReturnPtr := C.AutoFilter_GetShowFilterButton( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether the AutoFilter button for this column is visible.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *AutoFilter) SetShowFilterButton(value bool)  error {
	
	CGoReturnPtr := C.AutoFilter_SetShowFilterButton( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the collection of the filter columns.
// Returns:
//   FilterColumnCollection  
func (instance *AutoFilter) GetFilterColumns()  (*FilterColumnCollection,  error)  {
	
	CGoReturnPtr := C.AutoFilter_GetFilterColumns( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &FilterColumnCollection{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteFilterColumnCollection) 

	return result, nil 
}



func DeleteAutoFilter(autofilter *AutoFilter){
	runtime.SetFinalizer(autofilter, nil)
	C.Delete_AutoFilter(autofilter.ptr)
	autofilter.ptr = nil
}

// Class AutoFitterOptions 

// Represents all auto fitter options.
type AutoFitterOptions struct {
	ptr unsafe.Pointer
}

// Default constructor.
func NewAutoFitterOptions() ( *AutoFitterOptions, error) {
	autofitteroptions := &AutoFitterOptions{}
	CGoReturnPtr := C.New_AutoFitterOptions()
	if CGoReturnPtr.error_no == 0 {
		autofitteroptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(autofitteroptions, DeleteAutoFitterOptions)
		return autofitteroptions, nil
	} else {
		autofitteroptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return autofitteroptions, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *AutoFitterOptions) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.AutoFitterOptions_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets default edit language.
// Returns:
//   int32  
func (instance *AutoFitterOptions) GetDefaultEditLanguage()  (DefaultEditLanguage,  error)  {
	
	CGoReturnPtr := C.AutoFitterOptions_GetDefaultEditLanguage( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToDefaultEditLanguage(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets or sets default edit language.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *AutoFitterOptions) SetDefaultEditLanguage(value DefaultEditLanguage)  error {
	
	CGoReturnPtr := C.AutoFitterOptions_SetDefaultEditLanguage( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and set the type of auto fitting row height of merged cells.
// Returns:
//   int32  
func (instance *AutoFitterOptions) GetAutoFitMergedCellsType()  (AutoFitMergedCellsType,  error)  {
	
	CGoReturnPtr := C.AutoFitterOptions_GetAutoFitMergedCellsType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToAutoFitMergedCellsType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets and set the type of auto fitting row height of merged cells.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *AutoFitterOptions) SetAutoFitMergedCellsType(value AutoFitMergedCellsType)  error {
	
	CGoReturnPtr := C.AutoFitterOptions_SetAutoFitMergedCellsType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether only fit the rows which height are not customed.
// Returns:
//   bool  
func (instance *AutoFitterOptions) GetOnlyAuto()  (bool,  error)  {
	
	CGoReturnPtr := C.AutoFitterOptions_GetOnlyAuto( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether only fit the rows which height are not customed.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *AutoFitterOptions) SetOnlyAuto(value bool)  error {
	
	CGoReturnPtr := C.AutoFitterOptions_SetOnlyAuto( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Ignores the hidden rows/columns.
// Returns:
//   bool  
func (instance *AutoFitterOptions) GetIgnoreHidden()  (bool,  error)  {
	
	CGoReturnPtr := C.AutoFitterOptions_GetIgnoreHidden( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Ignores the hidden rows/columns.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *AutoFitterOptions) SetIgnoreHidden(value bool)  error {
	
	CGoReturnPtr := C.AutoFitterOptions_SetIgnoreHidden( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the max row height(in unit of Point) when autofitting rows.
// Returns:
//   float64  
func (instance *AutoFitterOptions) GetMaxRowHeight()  (float64,  error)  {
	
	CGoReturnPtr := C.AutoFitterOptions_GetMaxRowHeight( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := float64(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the max row height(in unit of Point) when autofitting rows.
// Parameters:
//   value - float64 
// Returns:
//   void  
func (instance *AutoFitterOptions) SetMaxRowHeight(value float64)  error {
	
	CGoReturnPtr := C.AutoFitterOptions_SetMaxRowHeight( instance.ptr, C.double(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the type of auto fitting wrapped text.
// Returns:
//   int32  
func (instance *AutoFitterOptions) GetAutoFitWrappedTextType()  (AutoFitWrappedTextType,  error)  {
	
	CGoReturnPtr := C.AutoFitterOptions_GetAutoFitWrappedTextType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToAutoFitWrappedTextType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets and sets the type of auto fitting wrapped text.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *AutoFitterOptions) SetAutoFitWrappedTextType(value AutoFitWrappedTextType)  error {
	
	CGoReturnPtr := C.AutoFitterOptions_SetAutoFitWrappedTextType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the formatted strategy.
// Returns:
//   int32  
func (instance *AutoFitterOptions) GetFormatStrategy()  (CellValueFormatStrategy,  error)  {
	
	CGoReturnPtr := C.AutoFitterOptions_GetFormatStrategy( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToCellValueFormatStrategy(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets and sets the formatted strategy.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *AutoFitterOptions) SetFormatStrategy(value CellValueFormatStrategy)  error {
	
	CGoReturnPtr := C.AutoFitterOptions_SetFormatStrategy( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether fit for rendering purpose.
// Returns:
//   bool  
func (instance *AutoFitterOptions) GetForRendering()  (bool,  error)  {
	
	CGoReturnPtr := C.AutoFitterOptions_GetForRendering( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether fit for rendering purpose.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *AutoFitterOptions) SetForRendering(value bool)  error {
	
	CGoReturnPtr := C.AutoFitterOptions_SetForRendering( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}



func DeleteAutoFitterOptions(autofitteroptions *AutoFitterOptions){
	runtime.SetFinalizer(autofitteroptions, nil)
	C.Delete_AutoFitterOptions(autofitteroptions.ptr)
	autofitteroptions.ptr = nil
}

// Class Border 

// Encapsulates the object that represents the cell border.
type Border struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *Border) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.Border_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the theme color of the border.
// Returns:
//   ThemeColor  
func (instance *Border) GetThemeColor()  (*ThemeColor,  error)  {
	
	CGoReturnPtr := C.Border_GetThemeColor( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &ThemeColor{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteThemeColor) 

	return result, nil 
}
// Gets and sets the theme color of the border.
// Parameters:
//   value - ThemeColor 
// Returns:
//   void  
func (instance *Border) SetThemeColor(value *ThemeColor)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.Border_SetThemeColor( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the <see cref="Color"/> of the border.
// Returns:
//   Color  
func (instance *Border) GetColor()  (*Color,  error)  {
	
	CGoReturnPtr := C.Border_GetColor( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Gets or sets the <see cref="Color"/> of the border.
// Parameters:
//   value - Color 
// Returns:
//   void  
func (instance *Border) SetColor(value *Color)  error {
	
	CGoReturnPtr := C.Border_SetColor( instance.ptr, value.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the color with a 32-bit ARGB value.
// Returns:
//   int32  
func (instance *Border) GetArgbColor()  (int32,  error)  {
	
	CGoReturnPtr := C.Border_GetArgbColor( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the color with a 32-bit ARGB value.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *Border) SetArgbColor(value int32)  error {
	
	CGoReturnPtr := C.Border_SetArgbColor( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the cell border type.
// Returns:
//   int32  
func (instance *Border) GetLineStyle()  (CellBorderType,  error)  {
	
	CGoReturnPtr := C.Border_GetLineStyle( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToCellBorderType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets or sets the cell border type.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *Border) SetLineStyle(value CellBorderType)  error {
	
	CGoReturnPtr := C.Border_SetLineStyle( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}



func DeleteBorder(border *Border){
	runtime.SetFinalizer(border, nil)
	C.Delete_Border(border.ptr)
	border.ptr = nil
}

// Class BorderCollection 

// Encapsulates a collection of <see cref="Border"/> objects.
type BorderCollection struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *BorderCollection) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.BorderCollection_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the <see cref="Border"/> element at the specified index.
// Parameters:
//   borderType - int32 
// Returns:
//   Border  
func (instance *BorderCollection) Get(bordertype BorderType)  (*Border,  error)  {
	
	CGoReturnPtr := C.BorderCollection_Get( instance.ptr, C.int( int32(bordertype)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Border{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteBorder) 

	return result, nil 
}
// Sets the <see cref="Color"/> of all borders in the collection.
// Parameters:
//   color - Color 
// Returns:
//   void  
func (instance *BorderCollection) SetColor(color *Color)  error {
	
	CGoReturnPtr := C.BorderCollection_SetColor( instance.ptr, color.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Sets the style of all borders of the collection.
// Parameters:
//   style - int32 
// Returns:
//   void  
func (instance *BorderCollection) SetStyle(style CellBorderType)  error {
	
	CGoReturnPtr := C.BorderCollection_SetStyle( instance.ptr, C.int( int32(style)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the <see cref="Color"/> of Diagonal lines.
// Returns:
//   Color  
func (instance *BorderCollection) GetDiagonalColor()  (*Color,  error)  {
	
	CGoReturnPtr := C.BorderCollection_GetDiagonalColor( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Gets or sets the <see cref="Color"/> of Diagonal lines.
// Parameters:
//   value - Color 
// Returns:
//   void  
func (instance *BorderCollection) SetDiagonalColor(value *Color)  error {
	
	CGoReturnPtr := C.BorderCollection_SetDiagonalColor( instance.ptr, value.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the style of Diagonal lines.
// Returns:
//   int32  
func (instance *BorderCollection) GetDiagonalStyle()  (CellBorderType,  error)  {
	
	CGoReturnPtr := C.BorderCollection_GetDiagonalStyle( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToCellBorderType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets or sets the style of Diagonal lines.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *BorderCollection) SetDiagonalStyle(value CellBorderType)  error {
	
	CGoReturnPtr := C.BorderCollection_SetDiagonalStyle( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}



func DeleteBorderCollection(bordercollection *BorderCollection){
	runtime.SetFinalizer(bordercollection, nil)
	C.Delete_BorderCollection(bordercollection.ptr)
	bordercollection.ptr = nil
}

// Class CalculationCell 

// Represents the calculation relevant data about one cell which is being calculated.
type CalculationCell struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *CalculationCell) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.CalculationCell_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Sets the calculated value for the cell.
// Parameters:
//   v - Object 
// Returns:
//   void  
func (instance *CalculationCell) SetCalculatedValue(v *Object)  error {
	
	var v_ptr unsafe.Pointer = nil
	if v != nil {
	  v_ptr =v.ptr
	}

	CGoReturnPtr := C.CalculationCell_SetCalculatedValue( instance.ptr, v_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the Workbook object.
// Returns:
//   Workbook  
func (instance *CalculationCell) GetWorkbook()  (*Workbook,  error)  {
	
	CGoReturnPtr := C.CalculationCell_GetWorkbook( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Workbook{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteWorkbook) 

	return result, nil 
}
// Gets the Worksheet object where the cell is in.
// Returns:
//   Worksheet  
func (instance *CalculationCell) GetWorksheet()  (*Worksheet,  error)  {
	
	CGoReturnPtr := C.CalculationCell_GetWorksheet( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Worksheet{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteWorksheet) 

	return result, nil 
}
// Gets the row index of the cell.
// Returns:
//   int32  
func (instance *CalculationCell) GetCellRow()  (int32,  error)  {
	
	CGoReturnPtr := C.CalculationCell_GetCellRow( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the column index of the cell.
// Returns:
//   int32  
func (instance *CalculationCell) GetCellColumn()  (int32,  error)  {
	
	CGoReturnPtr := C.CalculationCell_GetCellColumn( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the Cell object which is being calculated.
// Returns:
//   Cell  
func (instance *CalculationCell) GetCell()  (*Cell,  error)  {
	
	CGoReturnPtr := C.CalculationCell_GetCell( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Cell{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteCell) 

	return result, nil 
}



func DeleteCalculationCell(calculationcell *CalculationCell){
	runtime.SetFinalizer(calculationcell, nil)
	C.Delete_CalculationCell(calculationcell.ptr)
	calculationcell.ptr = nil
}

// Class CalculationData 

// Represents the required data when calculating one function, such as function name, parameters, ...etc.
type CalculationData struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *CalculationData) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.CalculationData_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets the calculated value for this function.
// Returns:
//   Object  
func (instance *CalculationData) GetCalculatedValue()  (*Object,  error)  {
	
	CGoReturnPtr := C.CalculationData_GetCalculatedValue( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Object{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteObject) 

	return result, nil 
}
// Gets or sets the calculated value for this function.
// Parameters:
//   value - Object 
// Returns:
//   void  
func (instance *CalculationData) SetCalculatedValue(value *Object)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.CalculationData_SetCalculatedValue( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the Workbook object where the function is in.
// Returns:
//   Workbook  
func (instance *CalculationData) GetWorkbook()  (*Workbook,  error)  {
	
	CGoReturnPtr := C.CalculationData_GetWorkbook( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Workbook{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteWorkbook) 

	return result, nil 
}
// Gets the Worksheet object where the function is in.
// Returns:
//   Worksheet  
func (instance *CalculationData) GetWorksheet()  (*Worksheet,  error)  {
	
	CGoReturnPtr := C.CalculationData_GetWorksheet( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Worksheet{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteWorksheet) 

	return result, nil 
}
// Gets the row index of the cell where the function is in.
// Returns:
//   int32  
func (instance *CalculationData) GetCellRow()  (int32,  error)  {
	
	CGoReturnPtr := C.CalculationData_GetCellRow( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the column index of the cell where the function is in.
// Returns:
//   int32  
func (instance *CalculationData) GetCellColumn()  (int32,  error)  {
	
	CGoReturnPtr := C.CalculationData_GetCellColumn( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the Cell object where the function is in.
// Returns:
//   Cell  
func (instance *CalculationData) GetCell()  (*Cell,  error)  {
	
	CGoReturnPtr := C.CalculationData_GetCell( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Cell{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteCell) 

	return result, nil 
}
// Gets the function name to be calculated.
// Returns:
//   string  
func (instance *CalculationData) GetFunctionName()  (string,  error)  {
	
	CGoReturnPtr := C.CalculationData_GetFunctionName( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the count of parameters
// Returns:
//   int32  
func (instance *CalculationData) GetParamCount()  (int32,  error)  {
	
	CGoReturnPtr := C.CalculationData_GetParamCount( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the represented value object of the parameter at given index.
// Parameters:
//   index - int32 
// Returns:
//   Object  
func (instance *CalculationData) GetParamValue(index int32)  (*Object,  error)  {
	
	CGoReturnPtr := C.CalculationData_GetParamValue( instance.ptr, C.int(index))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Object{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteObject) 

	return result, nil 
}
// Gets the value(s) of the parameter at given index.
// If the parameter is some kind of expression that needs to be calculated,
// then it will be calculated in array mode.
// Parameters:
//   index - int32 
//   maxRowCount - int32 
//   maxColumnCount - int32 
// Returns:
//   []Vector<Object>  
func (instance *CalculationData) GetParamValueInArrayMode(index int32, maxrowcount int32, maxcolumncount int32)  ([][]Object,  error)  {
	
	CGoReturnPtr := C.CalculationData_GetParamValueInArrayMode( instance.ptr, C.int(index), C.int(maxrowcount), C.int(maxcolumncount))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result:= make([][]Object, CGoReturnPtr.row_length)
	for i := 0; i < int(CGoReturnPtr.row_length); i++ {
	result[i] = make([]Object, int(CGoReturnPtr.column_length))
	}
	for i := 0; i < int(CGoReturnPtr.row_length); i++ {
	for j := 0; j < int(CGoReturnPtr.column_length); j++ {
	   offset := uintptr(C.size_t(i) * C.size_t(int(CGoReturnPtr.column_length))  +  C.size_t(j)  ) * uintptr(CGoReturnPtr.size) 
	   goObject := &Object{}
	   goObject.ptr =unsafe.Pointer(uintptr( unsafe.Pointer(CGoReturnPtr.return_value)) + offset)
	   result[i][j] = *goObject
	}
	}
	 

	return result, nil 
}
// Gets the literal text of the parameter at given index.
// Parameters:
//   index - int32 
// Returns:
//   string  
func (instance *CalculationData) GetParamText(index int32)  (string,  error)  {
	
	CGoReturnPtr := C.CalculationData_GetParamText( instance.ptr, C.int(index))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}



func DeleteCalculationData(calculationdata *CalculationData){
	runtime.SetFinalizer(calculationdata, nil)
	C.Delete_CalculationData(calculationdata.ptr)
	calculationdata.ptr = nil
}

// Class CalculationOptions 

// Represents options for calculation.
type CalculationOptions struct {
	ptr unsafe.Pointer
}

// Default constructor.
func NewCalculationOptions() ( *CalculationOptions, error) {
	calculationoptions := &CalculationOptions{}
	CGoReturnPtr := C.New_CalculationOptions()
	if CGoReturnPtr.error_no == 0 {
		calculationoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(calculationoptions, DeleteCalculationOptions)
		return calculationoptions, nil
	} else {
		calculationoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return calculationoptions, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *CalculationOptions) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.CalculationOptions_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether errors encountered while calculating formulas should be ignored.
// The error may be unsupported function, external links, etc.
// The default value is true.
// Returns:
//   bool  
func (instance *CalculationOptions) GetIgnoreError()  (bool,  error)  {
	
	CGoReturnPtr := C.CalculationOptions_GetIgnoreError( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether errors encountered while calculating formulas should be ignored.
// The error may be unsupported function, external links, etc.
// The default value is true.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *CalculationOptions) SetIgnoreError(value bool)  error {
	
	CGoReturnPtr := C.CalculationOptions_SetIgnoreError( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether calculate the dependent cells recursively when calculating one cell and it depends on other cells.
// The default value is true.
// Returns:
//   bool  
func (instance *CalculationOptions) GetRecursive()  (bool,  error)  {
	
	CGoReturnPtr := C.CalculationOptions_GetRecursive( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether calculate the dependent cells recursively when calculating one cell and it depends on other cells.
// The default value is true.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *CalculationOptions) SetRecursive(value bool)  error {
	
	CGoReturnPtr := C.CalculationOptions_SetRecursive( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// The custom formula calculation engine to extend the default calculation engine of Aspose.Cells.
// Returns:
//   AbstractCalculationEngine  
func (instance *CalculationOptions) GetCustomEngine()  (*AbstractCalculationEngine,  error)  {
	
	CGoReturnPtr := C.CalculationOptions_GetCustomEngine( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &AbstractCalculationEngine{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteAbstractCalculationEngine) 

	return result, nil 
}
// The custom formula calculation engine to extend the default calculation engine of Aspose.Cells.
// Parameters:
//   value - AbstractCalculationEngine 
// Returns:
//   void  
func (instance *CalculationOptions) SetCustomEngine(value *AbstractCalculationEngine)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.CalculationOptions_SetCustomEngine( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// The stack size for calculating cells recursively. Default value is 200.
// Returns:
//   int32  
func (instance *CalculationOptions) GetCalcStackSize()  (int32,  error)  {
	
	CGoReturnPtr := C.CalculationOptions_GetCalcStackSize( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// The stack size for calculating cells recursively. Default value is 200.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *CalculationOptions) SetCalcStackSize(value int32)  error {
	
	CGoReturnPtr := C.CalculationOptions_SetCalcStackSize( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Specifies the strategy for processing precision of calculation.
// Returns:
//   int32  
func (instance *CalculationOptions) GetPrecisionStrategy()  (CalculationPrecisionStrategy,  error)  {
	
	CGoReturnPtr := C.CalculationOptions_GetPrecisionStrategy( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToCalculationPrecisionStrategy(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Specifies the strategy for processing precision of calculation.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *CalculationOptions) SetPrecisionStrategy(value CalculationPrecisionStrategy)  error {
	
	CGoReturnPtr := C.CalculationOptions_SetPrecisionStrategy( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Specifies the data sources for external links used in formulas.
// Returns:
//   []Workbook  
func (instance *CalculationOptions) GetLinkedDataSources()  ([]Workbook,  error)  {
	
	CGoReturnPtr := C.CalculationOptions_GetLinkedDataSources( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result:= make([]Workbook, CGoReturnPtr.column_length)
	for i := 0; i < int(CGoReturnPtr.column_length); i++ {
	   offset := uintptr(C.size_t(i)) * uintptr(CGoReturnPtr.size)
	   goObject := &Workbook{}
	   goObject.ptr =unsafe.Pointer(uintptr( unsafe.Pointer(CGoReturnPtr.return_value)) + offset)
	   result[i] = *goObject
	}
	 

	return result, nil 
}
// Specifies the data sources for external links used in formulas.
// Parameters:
//   value - []Workbook 
// Returns:
//   void  
func (instance *CalculationOptions) SetLinkedDataSources(value []Workbook)  error {
	
	value_length := len(value)
	vector_value:= make([]unsafe.Pointer, value_length)
	for i := 0; i < value_length; i++ {
		vector_value[i] = value[i].ptr
	}


	CGoReturnPtr := C.CalculationOptions_SetLinkedDataSources( instance.ptr, unsafe.Pointer(&vector_value[0]), C.int( len(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Specifies the encoding used for encoding/decoding characters when calculating formulas.
// For functions such as CHAR, CODE, the calculated result depends on the region settings and default charset of the environment.
// With this property user can specify the proper encoding used for those function to get the expected result.
// Returns:
//   int32  
func (instance *CalculationOptions) GetCharacterEncoding()  (EncodingType,  error)  {
	
	CGoReturnPtr := C.CalculationOptions_GetCharacterEncoding( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToEncodingType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Specifies the encoding used for encoding/decoding characters when calculating formulas.
// For functions such as CHAR, CODE, the calculated result depends on the region settings and default charset of the environment.
// With this property user can specify the proper encoding used for those function to get the expected result.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *CalculationOptions) SetCharacterEncoding(value EncodingType)  error {
	
	CGoReturnPtr := C.CalculationOptions_SetCharacterEncoding( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}



func DeleteCalculationOptions(calculationoptions *CalculationOptions){
	runtime.SetFinalizer(calculationoptions, nil)
	C.Delete_CalculationOptions(calculationoptions.ptr)
	calculationoptions.ptr = nil
}

// Class Cell 

// Encapsulates the object that represents a single Workbook cell.
type Cell struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *Cell) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.Cell_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Calculates the formula of the cell.
// Parameters:
//   options - CalculationOptions 
// Returns:
//   void  
func (instance *Cell) Calculate(options *CalculationOptions)  error {
	
	var options_ptr unsafe.Pointer = nil
	if options != nil {
	  options_ptr =options.ptr
	}

	CGoReturnPtr := C.Cell_Calculate( instance.ptr, options_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the parent worksheet.
// Returns:
//   Worksheet  
func (instance *Cell) GetWorksheet()  (*Worksheet,  error)  {
	
	CGoReturnPtr := C.Cell_GetWorksheet( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Worksheet{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteWorksheet) 

	return result, nil 
}
// Puts a boolean value into the cell.
// Parameters:
//   boolValue - bool 
// Returns:
//   void  
func (instance *Cell) PutValue_Bool(boolvalue bool)  error {
	
	CGoReturnPtr := C.Cell_PutValue_Boolean( instance.ptr, C.bool(boolvalue))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Puts an integer value into the cell.
// Parameters:
//   intValue - int32 
// Returns:
//   void  
func (instance *Cell) PutValue_Int(intvalue int32)  error {
	
	CGoReturnPtr := C.Cell_PutValue_Integer( instance.ptr, C.int(intvalue))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Puts a double value into the cell.
// Parameters:
//   doubleValue - float64 
// Returns:
//   void  
func (instance *Cell) PutValue_Double(doublevalue float64)  error {
	
	CGoReturnPtr := C.Cell_PutValue_Double( instance.ptr, C.double(doublevalue))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Puts a value into the cell, if appropriate the value will be converted to other data type and cell's number format will be reset.
// Parameters:
//   stringValue - string 
//   isConverted - bool 
//   setStyle - bool 
// Returns:
//   void  
func (instance *Cell) PutValue_String_Bool_Bool(stringvalue string, isconverted bool, setstyle bool)  error {
	
	CGoReturnPtr := C.Cell_PutValue_String_Boolean_Boolean( instance.ptr, C.CString(stringvalue), C.bool(isconverted), C.bool(setstyle))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Puts a string value into the cell and converts the value to other data type if appropriate.
// Parameters:
//   stringValue - string 
//   isConverted - bool 
// Returns:
//   void  
func (instance *Cell) PutValue_String_Bool(stringvalue string, isconverted bool)  error {
	
	CGoReturnPtr := C.Cell_PutValue_String_Boolean( instance.ptr, C.CString(stringvalue), C.bool(isconverted))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Puts a string value into the cell.
// Parameters:
//   stringValue - string 
// Returns:
//   void  
func (instance *Cell) PutValue_String(stringvalue string)  error {
	
	CGoReturnPtr := C.Cell_PutValue_String( instance.ptr, C.CString(stringvalue))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Puts a DateTime value into the cell.
// Parameters:
//   dateTime - Date 
// Returns:
//   void  
func (instance *Cell) PutValue_Date(datetime time.Time)  error {
	
	time_datetime := C.Get_Date( C.int(datetime.Year()), C.int(datetime.Month()) , C.int(datetime.Day()) , C.int(datetime.Hour()) , C.int(datetime.Minute()) , C.int(datetime.Second())  )

	CGoReturnPtr := C.Cell_PutValue_Date( instance.ptr, time_datetime)
	C.Delete_GetDate( time_datetime)

	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the DateTime value contained in the cell.
// Returns:
//   Date  
func (instance *Cell) GetDateTimeValue()  (time.Time,  error)  {
	
	CGoReturnPtr := C.Cell_GetDateTimeValue( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  time.Unix(0, 0), err
	}
	result := time.Date(int( C.Date_Get_year(CGoReturnPtr.return_value).return_value ),time.Month(int( C.Date_Get_month(CGoReturnPtr.return_value).return_value)),int( C.Date_Get_day(CGoReturnPtr.return_value).return_value),int(  C.Date_Get_hour(CGoReturnPtr.return_value).return_value),int( C.Date_Get_minute(CGoReturnPtr.return_value).return_value),int(  C.Date_Get_second(CGoReturnPtr.return_value).return_value), 0, time.UTC) 

	return result, nil 
}
// Puts an object value into the cell.
// Parameters:
//   objectValue - Object 
// Returns:
//   void  
func (instance *Cell) PutValue_Object(objectvalue *Object)  error {
	
	var objectvalue_ptr unsafe.Pointer = nil
	if objectvalue != nil {
	  objectvalue_ptr =objectvalue.ptr
	}

	CGoReturnPtr := C.Cell_PutValue_Object( instance.ptr, objectvalue_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets row number (zero based) of the cell.
// Returns:
//   int32  
func (instance *Cell) GetRow()  (int32,  error)  {
	
	CGoReturnPtr := C.Cell_GetRow( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets column number (zero based) of the cell.
// Returns:
//   int32  
func (instance *Cell) GetColumn()  (int32,  error)  {
	
	CGoReturnPtr := C.Cell_GetColumn( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents if the specified cell contains formula.
// Returns:
//   bool  
func (instance *Cell) IsFormula()  (bool,  error)  {
	
	CGoReturnPtr := C.Cell_IsFormula( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Checks whether there is custom function(unsupported function) in this cell's formula.
// Returns:
//   bool  
func (instance *Cell) GetHasCustomFunction()  (bool,  error)  {
	
	CGoReturnPtr := C.Cell_GetHasCustomFunction( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents cell value type.
// Returns:
//   int32  
func (instance *Cell) GetType()  (CellValueType,  error)  {
	
	CGoReturnPtr := C.Cell_GetType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToCellValueType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets the name of the cell.
// Returns:
//   string  
func (instance *Cell) GetName()  (string,  error)  {
	
	CGoReturnPtr := C.Cell_GetName( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Checks if the value of this cell is an error.
// Returns:
//   bool  
func (instance *Cell) IsErrorValue()  (bool,  error)  {
	
	CGoReturnPtr := C.Cell_IsErrorValue( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether the value of this cell is numeric(int, double and datetime)
// Returns:
//   bool  
func (instance *Cell) IsNumericValue()  (bool,  error)  {
	
	CGoReturnPtr := C.Cell_IsNumericValue( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the string value by specific formatted strategy.
// Parameters:
//   formatStrategy - int32 
// Returns:
//   string  
func (instance *Cell) GetStringValue_CellValueFormatStrategy(formatstrategy CellValueFormatStrategy)  (string,  error)  {
	
	CGoReturnPtr := C.Cell_GetStringValue_CellValueFormatStrategy( instance.ptr, C.int( int32(formatstrategy)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the string value contained in the cell. If the type of this cell is string, then return the string value itself.
// For other cell types, the formatted string value (formatted with the specified style of this cell) will be returned.
// The formatted cell value is same with what you can get from excel when copying a cell as text(such as
// copying cell to text editor or exporting to csv).
// Returns:
//   string  
func (instance *Cell) GetStringValue()  (string,  error)  {
	
	CGoReturnPtr := C.Cell_GetStringValue( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents the category type of this cell's number formatting.
// Returns:
//   int32  
func (instance *Cell) GetNumberCategoryType()  (NumberCategoryType,  error)  {
	
	CGoReturnPtr := C.Cell_GetNumberCategoryType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToNumberCategoryType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets the formatted string value of this cell by cell's display style.
// Returns:
//   string  
func (instance *Cell) GetDisplayStringValue()  (string,  error)  {
	
	CGoReturnPtr := C.Cell_GetDisplayStringValue( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the integer value contained in the cell.
// Returns:
//   int32  
func (instance *Cell) GetIntValue()  (int32,  error)  {
	
	CGoReturnPtr := C.Cell_GetIntValue( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the double value contained in the cell.
// Returns:
//   float64  
func (instance *Cell) GetDoubleValue()  (float64,  error)  {
	
	CGoReturnPtr := C.Cell_GetDoubleValue( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := float64(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the float value contained in the cell.
// Returns:
//   float32  
func (instance *Cell) GetFloatValue()  (float32,  error)  {
	
	CGoReturnPtr := C.Cell_GetFloatValue( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := float32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the boolean value contained in the cell.
// Returns:
//   bool  
func (instance *Cell) GetBoolValue()  (bool,  error)  {
	
	CGoReturnPtr := C.Cell_GetBoolValue( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the width of the value in unit of pixels.
// Returns:
//   int32  
func (instance *Cell) GetWidthOfValue()  (int32,  error)  {
	
	CGoReturnPtr := C.Cell_GetWidthOfValue( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the height of the value in unit of pixels.
// Returns:
//   int32  
func (instance *Cell) GetHeightOfValue()  (int32,  error)  {
	
	CGoReturnPtr := C.Cell_GetHeightOfValue( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the display style of this cell.
// Returns:
//   Style  
func (instance *Cell) GetDisplayStyle()  (*Style,  error)  {
	
	CGoReturnPtr := C.Cell_GetDisplayStyle( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Style{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteStyle) 

	return result, nil 
}
// Gets the display style of this cell.
// Parameters:
//   includeMergedBorders - bool 
// Returns:
//   Style  
func (instance *Cell) GetDisplayStyle_Bool(includemergedborders bool)  (*Style,  error)  {
	
	CGoReturnPtr := C.Cell_GetDisplayStyle_Boolean( instance.ptr, C.bool(includemergedborders))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Style{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteStyle) 

	return result, nil 
}
// Gets the display style of this cell.
// Parameters:
//   adjacentBorders - int32 
// Returns:
//   Style  
func (instance *Cell) GetDisplayStyle_BorderType(adjacentborders BorderType)  (*Style,  error)  {
	
	CGoReturnPtr := C.Cell_GetDisplayStyle_BorderType( instance.ptr, C.int( int32(adjacentborders)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Style{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteStyle) 

	return result, nil 
}
// Gets format conditions which applies to this cell.
// Returns:
//   []FormatConditionCollection  
func (instance *Cell) GetFormatConditions()  ([]FormatConditionCollection,  error)  {
	
	CGoReturnPtr := C.Cell_GetFormatConditions( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result:= make([]FormatConditionCollection, CGoReturnPtr.column_length)
	for i := 0; i < int(CGoReturnPtr.column_length); i++ {
	   offset := uintptr(C.size_t(i)) * uintptr(CGoReturnPtr.size)
	   goObject := &FormatConditionCollection{}
	   goObject.ptr =unsafe.Pointer(uintptr( unsafe.Pointer(CGoReturnPtr.return_value)) + offset)
	   result[i] = *goObject
	}
	 

	return result, nil 
}
// Gets the cell style.
// Returns:
//   Style  
func (instance *Cell) GetStyle()  (*Style,  error)  {
	
	CGoReturnPtr := C.Cell_GetStyle( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Style{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteStyle) 

	return result, nil 
}
// If checkBorders is true, check whether other cells' borders will effect the style of this cell.
// Parameters:
//   checkBorders - bool 
// Returns:
//   Style  
func (instance *Cell) GetStyle_Bool(checkborders bool)  (*Style,  error)  {
	
	CGoReturnPtr := C.Cell_GetStyle_Boolean( instance.ptr, C.bool(checkborders))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Style{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteStyle) 

	return result, nil 
}
// Sets the cell style.
// Parameters:
//   style - Style 
// Returns:
//   void  
func (instance *Cell) SetStyle_Style(style *Style)  error {
	
	var style_ptr unsafe.Pointer = nil
	if style != nil {
	  style_ptr =style.ptr
	}

	CGoReturnPtr := C.Cell_SetStyle_Style( instance.ptr, style_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Apply the changed property of style to the cell.
// Parameters:
//   style - Style 
//   explicitFlag - bool 
// Returns:
//   void  
func (instance *Cell) SetStyle_Style_Bool(style *Style, explicitflag bool)  error {
	
	var style_ptr unsafe.Pointer = nil
	if style != nil {
	  style_ptr =style.ptr
	}

	CGoReturnPtr := C.Cell_SetStyle_Style_Boolean( instance.ptr, style_ptr, C.bool(explicitflag))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Apply the cell style based on flags.
// Parameters:
//   style - Style 
//   flag - StyleFlag 
// Returns:
//   void  
func (instance *Cell) SetStyle_Style_StyleFlag(style *Style, flag *StyleFlag)  error {
	
	var style_ptr unsafe.Pointer = nil
	if style != nil {
	  style_ptr =style.ptr
	}
	var flag_ptr unsafe.Pointer = nil
	if flag != nil {
	  flag_ptr =flag.ptr
	}

	CGoReturnPtr := C.Cell_SetStyle_Style_StyleFlag( instance.ptr, style_ptr, flag_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether this cell has custom style settings(different from the default one inherited
// from corresponding row, column, or workbook).
// Returns:
//   bool  
func (instance *Cell) GetHasCustomStyle()  (bool,  error)  {
	
	CGoReturnPtr := C.Cell_GetHasCustomStyle( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets cell's shared style index in the style pool.
// Returns:
//   int32  
func (instance *Cell) GetSharedStyleIndex()  (int32,  error)  {
	
	CGoReturnPtr := C.Cell_GetSharedStyleIndex( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets a formula of the <see cref="Cell"/>.
// Returns:
//   string  
func (instance *Cell) GetFormula()  (string,  error)  {
	
	CGoReturnPtr := C.Cell_GetFormula( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets a formula of the <see cref="Cell"/>.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *Cell) SetFormula_String(value string)  error {
	
	CGoReturnPtr := C.Cell_SetFormula_String( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Get the locale formatted formula of the cell.
// Returns:
//   string  
func (instance *Cell) GetFormulaLocal()  (string,  error)  {
	
	CGoReturnPtr := C.Cell_GetFormulaLocal( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Get the locale formatted formula of the cell.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *Cell) SetFormulaLocal(value string)  error {
	
	CGoReturnPtr := C.Cell_SetFormulaLocal( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets a R1C1 formula of the <see cref="Cell"/>.
// Returns:
//   string  
func (instance *Cell) GetR1C1Formula()  (string,  error)  {
	
	CGoReturnPtr := C.Cell_GetR1C1Formula( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets a R1C1 formula of the <see cref="Cell"/>.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *Cell) SetR1C1Formula(value string)  error {
	
	CGoReturnPtr := C.Cell_SetR1C1Formula( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Set the formula and the value(calculated result) of the formula.
// Parameters:
//   formula - string 
//   value - Object 
// Returns:
//   void  
func (instance *Cell) SetFormula_String_Object(formula string, value *Object)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.Cell_SetFormula_String_Object( instance.ptr, C.CString(formula), value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Set the formula and the value(calculated result) of the formula.
// Parameters:
//   formula - string 
//   options - FormulaParseOptions 
// Returns:
//   void  
func (instance *Cell) SetFormula_String_FormulaParseOptions(formula string, options *FormulaParseOptions)  error {
	
	var options_ptr unsafe.Pointer = nil
	if options != nil {
	  options_ptr =options.ptr
	}

	CGoReturnPtr := C.Cell_SetFormula_String_FormulaParseOptions( instance.ptr, C.CString(formula), options_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Get the formula of this cell.
// Parameters:
//   isR1C1 - bool 
//   isLocal - bool 
// Returns:
//   string  
func (instance *Cell) GetFormula_Bool_Bool(isr1c1 bool, islocal bool)  (string,  error)  {
	
	CGoReturnPtr := C.Cell_GetFormula_Boolean_Boolean( instance.ptr, C.bool(isr1c1), C.bool(islocal))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Set the formula and the value(calculated result) of the formula.
// Parameters:
//   formula - string 
//   options - FormulaParseOptions 
//   value - Object 
// Returns:
//   void  
func (instance *Cell) SetFormula_String_FormulaParseOptions_Object(formula string, options *FormulaParseOptions, value *Object)  error {
	
	var options_ptr unsafe.Pointer = nil
	if options != nil {
	  options_ptr =options.ptr
	}
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.Cell_SetFormula_String_FormulaParseOptions_Object( instance.ptr, C.CString(formula), options_ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Sets an array formula(legacy array formula entered via CTRL+SHIFT+ENTER in ms excel) to a range of cells.
// Parameters:
//   arrayFormula - string 
//   rowNumber - int32 
//   columnNumber - int32 
// Returns:
//   void  
func (instance *Cell) SetArrayFormula_String_Int_Int(arrayformula string, rownumber int32, columnnumber int32)  error {
	
	CGoReturnPtr := C.Cell_SetArrayFormula_String_Integer_Integer( instance.ptr, C.CString(arrayformula), C.int(rownumber), C.int(columnnumber))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Sets an array formula to a range of cells.
// Parameters:
//   arrayFormula - string 
//   rowNumber - int32 
//   columnNumber - int32 
//   options - FormulaParseOptions 
// Returns:
//   void  
func (instance *Cell) SetArrayFormula_String_Int_Int_FormulaParseOptions(arrayformula string, rownumber int32, columnnumber int32, options *FormulaParseOptions)  error {
	
	var options_ptr unsafe.Pointer = nil
	if options != nil {
	  options_ptr =options.ptr
	}

	CGoReturnPtr := C.Cell_SetArrayFormula_String_Integer_Integer_FormulaParseOptions( instance.ptr, C.CString(arrayformula), C.int(rownumber), C.int(columnnumber), options_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Sets an array formula to a range of cells.
// Parameters:
//   arrayFormula - string 
//   rowNumber - int32 
//   columnNumber - int32 
//   options - FormulaParseOptions 
//   values - []Vector<Object> 
// Returns:
//   void  
func (instance *Cell) SetArrayFormula_String_Int_Int_FormulaParseOptions_Object2Array(arrayformula string, rownumber int32, columnnumber int32, options *FormulaParseOptions, values [][]interface{})  error {
	
	var options_ptr unsafe.Pointer = nil
	if options != nil {
	  options_ptr =options.ptr
	}
	vector_values, values_row_length, values_column_length := toObject2Array(values)

	CGoReturnPtr := C.Cell_SetArrayFormula_String_Integer_Integer_FormulaParseOptions_Object2Array( instance.ptr, C.CString(arrayformula), C.int(rownumber), C.int(columnnumber), options_ptr, unsafe.Pointer(&vector_values[0]), C.int( values_row_length), C.int(values_column_length))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Sets shared formulas to a range of cells.
// Parameters:
//   sharedFormula - string 
//   rowNumber - int32 
//   columnNumber - int32 
// Returns:
//   void  
func (instance *Cell) SetSharedFormula_String_Int_Int(sharedformula string, rownumber int32, columnnumber int32)  error {
	
	CGoReturnPtr := C.Cell_SetSharedFormula_String_Integer_Integer( instance.ptr, C.CString(sharedformula), C.int(rownumber), C.int(columnnumber))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Sets shared formulas to a range of cells.
// Parameters:
//   sharedFormula - string 
//   rowNumber - int32 
//   columnNumber - int32 
//   options - FormulaParseOptions 
// Returns:
//   void  
func (instance *Cell) SetSharedFormula_String_Int_Int_FormulaParseOptions(sharedformula string, rownumber int32, columnnumber int32, options *FormulaParseOptions)  error {
	
	var options_ptr unsafe.Pointer = nil
	if options != nil {
	  options_ptr =options.ptr
	}

	CGoReturnPtr := C.Cell_SetSharedFormula_String_Integer_Integer_FormulaParseOptions( instance.ptr, C.CString(sharedformula), C.int(rownumber), C.int(columnnumber), options_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Sets shared formulas to a range of cells.
// Parameters:
//   sharedFormula - string 
//   rowNumber - int32 
//   columnNumber - int32 
//   options - FormulaParseOptions 
//   values - []Vector<Object> 
// Returns:
//   void  
func (instance *Cell) SetSharedFormula_String_Int_Int_FormulaParseOptions_Object2Array(sharedformula string, rownumber int32, columnnumber int32, options *FormulaParseOptions, values [][]interface{})  error {
	
	var options_ptr unsafe.Pointer = nil
	if options != nil {
	  options_ptr =options.ptr
	}
	vector_values, values_row_length, values_column_length := toObject2Array(values)

	CGoReturnPtr := C.Cell_SetSharedFormula_String_Integer_Integer_FormulaParseOptions_Object2Array( instance.ptr, C.CString(sharedformula), C.int(rownumber), C.int(columnnumber), options_ptr, unsafe.Pointer(&vector_values[0]), C.int( values_row_length), C.int(values_column_length))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether this cell contains an external link.
// Only applies when the cell is a formula cell.
// Returns:
//   bool  
func (instance *Cell) GetContainsExternalLink()  (bool,  error)  {
	
	CGoReturnPtr := C.Cell_GetContainsExternalLink( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets all references appearing in this cell's formula.
// Returns:
//   ReferredAreaCollection  
func (instance *Cell) GetPrecedents()  (*ReferredAreaCollection,  error)  {
	
	CGoReturnPtr := C.Cell_GetPrecedents( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &ReferredAreaCollection{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteReferredAreaCollection) 

	return result, nil 
}
// Get all cells whose formula references to this cell directly.
// Parameters:
//   isAll - bool 
// Returns:
//   []Cell  
func (instance *Cell) GetDependents(isall bool)  ([]Cell,  error)  {
	
	CGoReturnPtr := C.Cell_GetDependents( instance.ptr, C.bool(isall))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result:= make([]Cell, CGoReturnPtr.column_length)
	for i := 0; i < int(CGoReturnPtr.column_length); i++ {
	   offset := uintptr(C.size_t(i)) * uintptr(CGoReturnPtr.size)
	   goObject := &Cell{}
	   goObject.ptr =unsafe.Pointer(uintptr( unsafe.Pointer(CGoReturnPtr.return_value)) + offset)
	   result[i] = *goObject
	}
	 

	return result, nil 
}
// Gets all precedents(reference to cells in current workbook) used by this cell's formula while calculating it.
// Returns:
//   unsafe.Pointer  
func (instance *Cell) GetPrecedentsInCalculation()  (*ReferredAreaEnumerator,  error)  {
	
	CGoReturnPtr := C.Cell_GetPrecedentsInCalculation( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &ReferredAreaEnumerator{}
	result.ptr = CGoReturnPtr.return_value
	runtime.SetFinalizer(result, DeleteReferredAreaEnumerator)
	 

	return result, nil 
}
// Gets all cells whose calculated result depends on this cell.
// Parameters:
//   recursive - bool 
// Returns:
//   unsafe.Pointer  
func (instance *Cell) GetDependentsInCalculation(recursive bool)  (*CellEnumerator,  error)  {
	
	CGoReturnPtr := C.Cell_GetDependentsInCalculation( instance.ptr, C.bool(recursive))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &CellEnumerator{}
	result.ptr = CGoReturnPtr.return_value
	runtime.SetFinalizer(result, DeleteCellEnumerator)
	 

	return result, nil 
}
// Indicates the cell's formula is an array formula
// and it is the first cell of the array.
// Returns:
//   bool  
func (instance *Cell) IsArrayHeader()  (bool,  error)  {
	
	CGoReturnPtr := C.Cell_IsArrayHeader( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether the cell's formula is dynamic array formula(true) or legacy array formula(false).
// Returns:
//   bool  
func (instance *Cell) IsDynamicArrayFormula()  (bool,  error)  {
	
	CGoReturnPtr := C.Cell_IsDynamicArrayFormula( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the array range if the cell's formula is an array formula.
// Returns:
//   CellArea  
func (instance *Cell) GetArrayRange()  (*CellArea,  error)  {
	
	CGoReturnPtr := C.Cell_GetArrayRange( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &CellArea{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteCellArea) 

	return result, nil 
}
// Indicates whether the cell formula is an array formula.
// Returns:
//   bool  
func (instance *Cell) IsArrayFormula()  (bool,  error)  {
	
	CGoReturnPtr := C.Cell_IsArrayFormula( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether the cell formula is part of shared formula.
// Returns:
//   bool  
func (instance *Cell) IsSharedFormula()  (bool,  error)  {
	
	CGoReturnPtr := C.Cell_IsSharedFormula( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether this cell is part of table formula.
// Returns:
//   bool  
func (instance *Cell) IsTableFormula()  (bool,  error)  {
	
	CGoReturnPtr := C.Cell_IsTableFormula( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Sets dynamic array formula and make the formula spill into neighboring cells if possible.
// Parameters:
//   arrayFormula - string 
//   options - FormulaParseOptions 
//   calculateValue - bool 
// Returns:
//   CellArea  
func (instance *Cell) SetDynamicArrayFormula_String_FormulaParseOptions_Bool(arrayformula string, options *FormulaParseOptions, calculatevalue bool)  (*CellArea,  error)  {
	
	var options_ptr unsafe.Pointer = nil
	if options != nil {
	  options_ptr =options.ptr
	}

	CGoReturnPtr := C.Cell_SetDynamicArrayFormula_String_FormulaParseOptions_Boolean( instance.ptr, C.CString(arrayformula), options_ptr, C.bool(calculatevalue))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &CellArea{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteCellArea) 

	return result, nil 
}
// Sets dynamic array formula and make the formula spill into neighboring cells if possible.
// Parameters:
//   arrayFormula - string 
//   options - FormulaParseOptions 
//   values - []Vector<Object> 
//   calculateRange - bool 
//   calculateValue - bool 
// Returns:
//   CellArea  
func (instance *Cell) SetDynamicArrayFormula_String_FormulaParseOptions_Object2Array_Bool_Bool(arrayformula string, options *FormulaParseOptions, values [][]interface{}, calculaterange bool, calculatevalue bool)  (*CellArea,  error)  {
	
	var options_ptr unsafe.Pointer = nil
	if options != nil {
	  options_ptr =options.ptr
	}
	vector_values, values_row_length, values_column_length := toObject2Array(values)

	CGoReturnPtr := C.Cell_SetDynamicArrayFormula_String_FormulaParseOptions_Object2Array_Boolean_Boolean( instance.ptr, C.CString(arrayformula), options_ptr, unsafe.Pointer(&vector_values[0]), C.int( values_row_length), C.int(values_column_length), C.bool(calculaterange), C.bool(calculatevalue))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &CellArea{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteCellArea) 

	return result, nil 
}
// Sets dynamic array formula and make the formula spill into neighboring cells if possible.
// Parameters:
//   arrayFormula - string 
//   options - FormulaParseOptions 
//   values - []Vector<Object> 
//   calculateRange - bool 
//   calculateValue - bool 
//   copts - CalculationOptions 
// Returns:
//   CellArea  
func (instance *Cell) SetDynamicArrayFormula_String_FormulaParseOptions_Object2Array_Bool_Bool_CalculationOptions(arrayformula string, options *FormulaParseOptions, values [][]interface{}, calculaterange bool, calculatevalue bool, copts *CalculationOptions)  (*CellArea,  error)  {
	
	var options_ptr unsafe.Pointer = nil
	if options != nil {
	  options_ptr =options.ptr
	}
	vector_values, values_row_length, values_column_length := toObject2Array(values)
	var copts_ptr unsafe.Pointer = nil
	if copts != nil {
	  copts_ptr =copts.ptr
	}

	CGoReturnPtr := C.Cell_SetDynamicArrayFormula_String_FormulaParseOptions_Object2Array_Boolean_Boolean_CalculationOptions( instance.ptr, C.CString(arrayformula), options_ptr, unsafe.Pointer(&vector_values[0]), C.int( values_row_length), C.int(values_column_length), C.bool(calculaterange), C.bool(calculatevalue), copts_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &CellArea{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteCellArea) 

	return result, nil 
}
// Create two-variable data table for given range starting from this cell.
// Parameters:
//   rowNumber - int32 
//   columnNumber - int32 
//   rowInputCell - string 
//   columnInputCell - string 
//   values - []Vector<Object> 
// Returns:
//   void  
func (instance *Cell) SetTableFormula_Int_Int_String_String_Object2Array(rownumber int32, columnnumber int32, rowinputcell string, columninputcell string, values [][]interface{})  error {
	
	vector_values, values_row_length, values_column_length := toObject2Array(values)

	CGoReturnPtr := C.Cell_SetTableFormula_Integer_Integer_String_String_Object2Array( instance.ptr, C.int(rownumber), C.int(columnnumber), C.CString(rowinputcell), C.CString(columninputcell), unsafe.Pointer(&vector_values[0]), C.int( values_row_length), C.int(values_column_length))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Create one-variable data table for given range starting from this cell.
// Parameters:
//   rowNumber - int32 
//   columnNumber - int32 
//   inputCell - string 
//   isRowInput - bool 
//   values - []Vector<Object> 
// Returns:
//   void  
func (instance *Cell) SetTableFormula_Int_Int_String_Bool_Object2Array(rownumber int32, columnnumber int32, inputcell string, isrowinput bool, values [][]interface{})  error {
	
	vector_values, values_row_length, values_column_length := toObject2Array(values)

	CGoReturnPtr := C.Cell_SetTableFormula_Integer_Integer_String_Boolean_Object2Array( instance.ptr, C.int(rownumber), C.int(columnnumber), C.CString(inputcell), C.bool(isrowinput), unsafe.Pointer(&vector_values[0]), C.int( values_row_length), C.int(values_column_length))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Create two-variable data table for given range starting from this cell.
// Parameters:
//   rowNumber - int32 
//   columnNumber - int32 
//   rowIndexOfRowInputCell - int32 
//   columnIndexOfRowInputCell - int32 
//   rowIndexOfColumnInputCell - int32 
//   columnIndexOfColumnInputCell - int32 
//   values - []Vector<Object> 
// Returns:
//   void  
func (instance *Cell) SetTableFormula_Int_Int_Int_Int_Int_Int_Object2Array(rownumber int32, columnnumber int32, rowindexofrowinputcell int32, columnindexofrowinputcell int32, rowindexofcolumninputcell int32, columnindexofcolumninputcell int32, values [][]interface{})  error {
	
	vector_values, values_row_length, values_column_length := toObject2Array(values)

	CGoReturnPtr := C.Cell_SetTableFormula_Integer_Integer_Integer_Integer_Integer_Integer_Object2Array( instance.ptr, C.int(rownumber), C.int(columnnumber), C.int(rowindexofrowinputcell), C.int(columnindexofrowinputcell), C.int(rowindexofcolumninputcell), C.int(columnindexofcolumninputcell), unsafe.Pointer(&vector_values[0]), C.int( values_row_length), C.int(values_column_length))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Create one-variable data table for given range starting from this cell.
// Parameters:
//   rowNumber - int32 
//   columnNumber - int32 
//   rowIndexOfInputCell - int32 
//   columnIndexOfInputCell - int32 
//   isRowInput - bool 
//   values - []Vector<Object> 
// Returns:
//   void  
func (instance *Cell) SetTableFormula_Int_Int_Int_Int_Bool_Object2Array(rownumber int32, columnnumber int32, rowindexofinputcell int32, columnindexofinputcell int32, isrowinput bool, values [][]interface{})  error {
	
	vector_values, values_row_length, values_column_length := toObject2Array(values)

	CGoReturnPtr := C.Cell_SetTableFormula_Integer_Integer_Integer_Integer_Boolean_Object2Array( instance.ptr, C.int(rownumber), C.int(columnnumber), C.int(rowindexofinputcell), C.int(columnindexofinputcell), C.bool(isrowinput), unsafe.Pointer(&vector_values[0]), C.int( values_row_length), C.int(values_column_length))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Remove array formula.
// Parameters:
//   leaveNormalFormula - bool 
// Returns:
//   void  
func (instance *Cell) RemoveArrayFormula(leavenormalformula bool)  error {
	
	CGoReturnPtr := C.Cell_RemoveArrayFormula( instance.ptr, C.bool(leavenormalformula))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Copies data from a source cell.
// Parameters:
//   cell - Cell 
// Returns:
//   void  
func (instance *Cell) Copy(cell *Cell)  error {
	
	var cell_ptr unsafe.Pointer = nil
	if cell != nil {
	  cell_ptr =cell.ptr
	}

	CGoReturnPtr := C.Cell_Copy( instance.ptr, cell_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets/sets the value contained in this cell.
// Returns:
//   Object  
func (instance *Cell) GetValue()  (*Object,  error)  {
	
	CGoReturnPtr := C.Cell_GetValue( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Object{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteObject) 

	return result, nil 
}
// Gets/sets the value contained in this cell.
// Parameters:
//   value - Object 
// Returns:
//   void  
func (instance *Cell) SetValue(value *Object)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.Cell_SetValue( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates if the cell's style is set. If return false, it means this cell has a default cell format.
// Returns:
//   bool  
func (instance *Cell) IsStyleSet()  (bool,  error)  {
	
	CGoReturnPtr := C.Cell_IsStyleSet( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Returns a Characters object that represents a range of characters within the cell text.
// Parameters:
//   startIndex - int32 
//   length - int32 
// Returns:
//   FontSetting  
func (instance *Cell) Characters(startindex int32, length int32)  (*FontSetting,  error)  {
	
	CGoReturnPtr := C.Cell_Characters( instance.ptr, C.int(startindex), C.int(length))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &FontSetting{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteFontSetting) 

	return result, nil 
}
// Replace text of the cell with options.
// Parameters:
//   placeHolder - string 
//   newValue - string 
//   options - ReplaceOptions 
// Returns:
//   void  
func (instance *Cell) Replace(placeholder string, newvalue string, options *ReplaceOptions)  error {
	
	var options_ptr unsafe.Pointer = nil
	if options != nil {
	  options_ptr =options.ptr
	}

	CGoReturnPtr := C.Cell_Replace( instance.ptr, C.CString(placeholder), C.CString(newvalue), options_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Insert some characters to the cell.
// If the cell is rich formatted, this method could keep the original formatting.
// Parameters:
//   index - int32 
//   text - string 
// Returns:
//   void  
func (instance *Cell) InsertText(index int32, text string)  error {
	
	CGoReturnPtr := C.Cell_InsertText( instance.ptr, C.int(index), C.CString(text))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether the string value of this cell is a rich formatted text.
// Returns:
//   bool  
func (instance *Cell) IsRichText()  (bool,  error)  {
	
	CGoReturnPtr := C.Cell_IsRichText( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Returns all Characters objects
// that represents a range of characters within the cell text.
// Returns:
//   []FontSetting  
func (instance *Cell) GetCharacters()  ([]FontSetting,  error)  {
	
	CGoReturnPtr := C.Cell_GetCharacters( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result:= make([]FontSetting, CGoReturnPtr.column_length)
	for i := 0; i < int(CGoReturnPtr.column_length); i++ {
	   offset := uintptr(C.size_t(i)) * uintptr(CGoReturnPtr.size)
	   goObject := &FontSetting{}
	   goObject.ptr =unsafe.Pointer(uintptr( unsafe.Pointer(CGoReturnPtr.return_value)) + offset)
	   result[i] = *goObject
	}
	 

	return result, nil 
}
// Returns all Characters objects
// that represents a range of characters within the cell text.
// Parameters:
//   flag - bool 
// Returns:
//   []FontSetting  
func (instance *Cell) GetCharacters_Bool(flag bool)  ([]FontSetting,  error)  {
	
	CGoReturnPtr := C.Cell_GetCharacters_Boolean( instance.ptr, C.bool(flag))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result:= make([]FontSetting, CGoReturnPtr.column_length)
	for i := 0; i < int(CGoReturnPtr.column_length); i++ {
	   offset := uintptr(C.size_t(i)) * uintptr(CGoReturnPtr.size)
	   goObject := &FontSetting{}
	   goObject.ptr =unsafe.Pointer(uintptr( unsafe.Pointer(CGoReturnPtr.return_value)) + offset)
	   result[i] = *goObject
	}
	 

	return result, nil 
}
// Sets rich text format of the cell.
// Parameters:
//   characters - []FontSetting 
// Returns:
//   void  
func (instance *Cell) SetCharacters(characters []FontSetting)  error {
	
	characters_length := len(characters)
	vector_characters:= make([]unsafe.Pointer, characters_length)
	for i := 0; i < characters_length; i++ {
		vector_characters[i] = characters[i].ptr
	}


	CGoReturnPtr := C.Cell_SetCharacters( instance.ptr, unsafe.Pointer(&vector_characters[0]), C.int( len(characters)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Checks if a cell is part of a merged range or not.
// Returns:
//   bool  
func (instance *Cell) IsMerged()  (bool,  error)  {
	
	CGoReturnPtr := C.Cell_IsMerged( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Returns a <see cref="Range"/> object which represents a merged range.
// Returns:
//   Range  
func (instance *Cell) GetMergedRange()  (*Range,  error)  {
	
	CGoReturnPtr := C.Cell_GetMergedRange( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Range{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteRange) 

	return result, nil 
}
// Gets the comment of this cell.
// Returns:
//   Comment  
func (instance *Cell) GetComment()  (*Comment,  error)  {
	
	CGoReturnPtr := C.Cell_GetComment( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Comment{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteComment) 

	return result, nil 
}
// Gets and sets the html string which contains data and some formats in this cell.
// Returns:
//   string  
func (instance *Cell) GetHtmlString()  (string,  error)  {
	
	CGoReturnPtr := C.Cell_GetHtmlString( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the html string which contains data and some formats in this cell.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *Cell) SetHtmlString(value string)  error {
	
	CGoReturnPtr := C.Cell_SetHtmlString( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the html string which contains data and some formats in this cell.
// Parameters:
//   html5 - bool 
// Returns:
//   string  
func (instance *Cell) GetHtmlString_Bool(html5 bool)  (string,  error)  {
	
	CGoReturnPtr := C.Cell_GetHtmlString_Boolean( instance.ptr, C.bool(html5))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Returns a string represents the current Cell object.
// Returns:
//   string  
func (instance *Cell) ToString()  (string,  error)  {
	
	CGoReturnPtr := C.Cell_ToString( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Convert <see cref="Cell"/> to JSON struct data.
// Returns:
//   string  
func (instance *Cell) ToJson()  (string,  error)  {
	
	CGoReturnPtr := C.Cell_ToJson( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Checks whether this object refers to the same cell with another.
// Parameters:
//   obj - Object 
// Returns:
//   bool  
func (instance *Cell) Equals_Object(obj *Object)  (bool,  error)  {
	
	var obj_ptr unsafe.Pointer = nil
	if obj != nil {
	  obj_ptr =obj.ptr
	}

	CGoReturnPtr := C.Cell_Equals_Object( instance.ptr, obj_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Serves as a hash function for a particular type.
// Returns:
//   int32  
func (instance *Cell) GetHashCode()  (int32,  error)  {
	
	CGoReturnPtr := C.Cell_GetHashCode( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Checks whether this object refers to the same cell with another cell object.
// Parameters:
//   cell - Cell 
// Returns:
//   bool  
func (instance *Cell) Equals_Cell(cell *Cell)  (bool,  error)  {
	
	var cell_ptr unsafe.Pointer = nil
	if cell != nil {
	  cell_ptr =cell.ptr
	}

	CGoReturnPtr := C.Cell_Equals_Cell( instance.ptr, cell_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Get the result of the conditional formatting.
// Returns:
//   ConditionalFormattingResult  
func (instance *Cell) GetConditionalFormattingResult()  (*ConditionalFormattingResult,  error)  {
	
	CGoReturnPtr := C.Cell_GetConditionalFormattingResult( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &ConditionalFormattingResult{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteConditionalFormattingResult) 

	return result, nil 
}
// Gets the validation applied to this cell.
// Returns:
//   Validation  
func (instance *Cell) GetValidation()  (*Validation,  error)  {
	
	CGoReturnPtr := C.Cell_GetValidation( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Validation{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteValidation) 

	return result, nil 
}
// Gets the value of validation which applied to this cell.
// Returns:
//   bool  
func (instance *Cell) GetValidationValue()  (bool,  error)  {
	
	CGoReturnPtr := C.Cell_GetValidationValue( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the table which contains this cell.
// Returns:
//   ListObject  
func (instance *Cell) GetTable()  (*ListObject,  error)  {
	
	CGoReturnPtr := C.Cell_GetTable( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &ListObject{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteListObject) 

	return result, nil 
}
// Indicates whether setting this cell as a check box.
// Returns:
//   bool  
func (instance *Cell) IsCheckBoxStyle()  (bool,  error)  {
	
	CGoReturnPtr := C.Cell_IsCheckBoxStyle( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether setting this cell as a check box.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Cell) SetIsCheckBoxStyle(value bool)  error {
	
	CGoReturnPtr := C.Cell_SetIsCheckBoxStyle( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets rich value of the cell.
// Returns:
//   CellRichValue  
func (instance *Cell) GetRichValue()  (*CellRichValue,  error)  {
	
	CGoReturnPtr := C.Cell_GetRichValue( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &CellRichValue{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteCellRichValue) 

	return result, nil 
}
// Gets and sets the embeddedn image in the cell.
// Returns:
//   []byte  
func (instance *Cell) GetEmbeddedImage()  ([]byte,  error)  {
	
	CGoReturnPtr := C.Cell_GetEmbeddedImage( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := C.GoBytes(unsafe.Pointer(CGoReturnPtr.return_value), C.int(CGoReturnPtr.column_length))
	 

	return result, nil 
}
// Gets and sets the embeddedn image in the cell.
// Parameters:
//   value - []byte 
// Returns:
//   void  
func (instance *Cell) SetEmbeddedImage(value []byte)  error {
	
	CGoReturnPtr := C.Cell_SetEmbeddedImage( instance.ptr, unsafe.Pointer(&value[0]), C.int( len(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Returns:
//   void  
func (instance *Cell) Dispose()  error {
	
	CGoReturnPtr := C.Cell_Dispose( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}



func DeleteCell(cell *Cell){
	runtime.SetFinalizer(cell, nil)
	C.Delete_Cell(cell.ptr)
	cell.ptr = nil
}

// Class CellArea 

// Represent an area of cells.
type CellArea struct {
	ptr unsafe.Pointer
}

// Default constructor.
func NewCellArea() ( *CellArea, error) {
	cellarea := &CellArea{}
	CGoReturnPtr := C.New_CellArea()
	if CGoReturnPtr.error_no == 0 {
		cellarea.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(cellarea, DeleteCellArea)
		return cellarea, nil
	} else {
		cellarea.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return cellarea, err
	}	
}

// Creates a cell area.
// Parameters:
//   startRow - int32 
//   startColumn - int32 
//   endRow - int32 
//   endColumn - int32 
// Returns:
//   CellArea  
func CellArea_CreateCellArea_Int_Int_Int_Int(startrow int32, startcolumn int32, endrow int32, endcolumn int32)  (*CellArea,  error)  {
	
	CGoReturnPtr := C.CellArea_CreateCellArea_Integer_Integer_Integer_Integer(C.int(startrow), C.int(startcolumn), C.int(endrow), C.int(endcolumn))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &CellArea{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteCellArea) 

	return result, nil 
}
// Creates a cell area.
// Parameters:
//   startCellName - string 
//   endCellName - string 
// Returns:
//   CellArea  
func CellArea_CreateCellArea_String_String(startcellname string, endcellname string)  (*CellArea,  error)  {
	
	CGoReturnPtr := C.CellArea_CreateCellArea_String_String(C.CString(startcellname), C.CString(endcellname))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &CellArea{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteCellArea) 

	return result, nil 
}
// Returns a string represents the current cell area object.
// Returns:
//   string  
func (instance *CellArea) ToString()  (string,  error)  {
	
	CGoReturnPtr := C.CellArea_ToString( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}

func (cellarea *CellArea) Set_StartRow(value int32 ) {
	C.CellArea_Set_StartRow(cellarea.ptr, C.int( value ))
}

func (cellarea *CellArea) Get_StartRow() (int32 , error) {
	CGoReturnPtr := C.CellArea_Get_StartRow(cellarea.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return 0, err
	}
	result := int32(CGoReturnPtr.return_value)
	return result, nil 
}

func (cellarea *CellArea) Set_EndRow(value int32 ) {
	C.CellArea_Set_EndRow(cellarea.ptr, C.int( value ))
}

func (cellarea *CellArea) Get_EndRow() (int32 , error) {
	CGoReturnPtr := C.CellArea_Get_EndRow(cellarea.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return 0, err
	}
	result := int32(CGoReturnPtr.return_value)
	return result, nil 
}

func (cellarea *CellArea) Set_StartColumn(value int32 ) {
	C.CellArea_Set_StartColumn(cellarea.ptr, C.int( value ))
}

func (cellarea *CellArea) Get_StartColumn() (int32 , error) {
	CGoReturnPtr := C.CellArea_Get_StartColumn(cellarea.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return 0, err
	}
	result := int32(CGoReturnPtr.return_value)
	return result, nil 
}

func (cellarea *CellArea) Set_EndColumn(value int32 ) {
	C.CellArea_Set_EndColumn(cellarea.ptr, C.int( value ))
}

func (cellarea *CellArea) Get_EndColumn() (int32 , error) {
	CGoReturnPtr := C.CellArea_Get_EndColumn(cellarea.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return 0, err
	}
	result := int32(CGoReturnPtr.return_value)
	return result, nil 
}


func DeleteCellArea(cellarea *CellArea){
	runtime.SetFinalizer(cellarea, nil)
	C.Delete_CellArea(cellarea.ptr)
	cellarea.ptr = nil
}

// Class CellRichValue 

// Represents rich value of the cell.
type CellRichValue struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *CellRichValue) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.CellRichValue_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the error value type of the cell.
// Returns:
//   int32  
func (instance *CellRichValue) GetErrorValue()  (ErrorCellValueType,  error)  {
	
	CGoReturnPtr := C.CellRichValue_GetErrorValue( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToErrorCellValueType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets the image data of the cell.
// Returns:
//   []byte  
func (instance *CellRichValue) GetImage()  ([]byte,  error)  {
	
	CGoReturnPtr := C.CellRichValue_GetImage( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := C.GoBytes(unsafe.Pointer(CGoReturnPtr.return_value), C.int(CGoReturnPtr.column_length))
	 

	return result, nil 
}
// Gets the alt text associated with the image.
// Returns:
//   string  
func (instance *CellRichValue) GetAltText()  (string,  error)  {
	
	CGoReturnPtr := C.CellRichValue_GetAltText( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the alt text associated with the image.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *CellRichValue) SetAltText(value string)  error {
	
	CGoReturnPtr := C.CellRichValue_SetAltText( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}



func DeleteCellRichValue(cellrichvalue *CellRichValue){
	runtime.SetFinalizer(cellrichvalue, nil)
	C.Delete_CellRichValue(cellrichvalue.ptr)
	cellrichvalue.ptr = nil
}

// Class Cells 

// Encapsulates a collection of cell relevant objects, such as <see cref="Cell"/>, <see cref="Row"/>, ...etc.
type Cells struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *Cells) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.Cells_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the list of fields of ods.
// Returns:
//   OdsCellFieldCollection  
func (instance *Cells) GetOdsCellFields()  (*OdsCellFieldCollection,  error)  {
	
	CGoReturnPtr := C.Cells_GetOdsCellFields( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &OdsCellFieldCollection{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteOdsCellFieldCollection) 

	return result, nil 
}
// Performs application-defined tasks associated with freeing, releasing, or
// resetting unmanaged resources.
// Returns:
//   void  
func (instance *Cells) Dispose()  error {
	
	CGoReturnPtr := C.Cells_Dispose( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the total count of instantiated Cell objects.
// Returns:
//   int32  
func (instance *Cells) GetCount()  (int32,  error)  {
	
	CGoReturnPtr := C.Cells_GetCount( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the total count of instantiated Cell objects.
// Returns:
//   int64  
func (instance *Cells) GetCountLarge()  (int64,  error)  {
	
	CGoReturnPtr := C.Cells_GetCountLarge( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int64(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the cells enumerator.
// Returns:
//   unsafe.Pointer  
func (instance *Cells) GetEnumerator()  (*CellEnumerator,  error)  {
	
	CGoReturnPtr := C.Cells_GetEnumerator( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &CellEnumerator{}
	result.ptr = CGoReturnPtr.return_value
	runtime.SetFinalizer(result, DeleteCellEnumerator)
	 

	return result, nil 
}
// Gets the collection of <see cref="Row"/> objects that represents the individual rows in this worksheet.
// Returns:
//   RowCollection  
func (instance *Cells) GetRows()  (*RowCollection,  error)  {
	
	CGoReturnPtr := C.Cells_GetRows( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &RowCollection{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteRowCollection) 

	return result, nil 
}
// Gets all merged cells.
// Returns:
//   []CellArea  
func (instance *Cells) GetMergedAreas()  ([]CellArea,  error)  {
	
	CGoReturnPtr := C.Cells_GetMergedAreas( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result:= make([]CellArea, CGoReturnPtr.column_length)
	for i := 0; i < int(CGoReturnPtr.column_length); i++ {
	   offset := uintptr(C.size_t(i)) * uintptr(CGoReturnPtr.size)
	   goObject := &CellArea{}
	   goObject.ptr =unsafe.Pointer(uintptr( unsafe.Pointer(CGoReturnPtr.return_value)) + offset)
	   result[i] = *goObject
	}
	 

	return result, nil 
}
// Gets the <see cref="Cell"/> element or null at the specified cell row index and column index.
// Parameters:
//   row - int32 
//   column - int32 
// Returns:
//   Cell  
func (instance *Cells) CheckCell(row int32, column int32)  (*Cell,  error)  {
	
	CGoReturnPtr := C.Cells_CheckCell( instance.ptr, C.int(row), C.int(column))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Cell{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteCell) 

	return result, nil 
}
// Gets the <see cref="Row"/> element or null at the specified cell row index.
// Parameters:
//   row - int32 
// Returns:
//   Row  
func (instance *Cells) CheckRow(row int32)  (*Row,  error)  {
	
	CGoReturnPtr := C.Cells_CheckRow( instance.ptr, C.int(row))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Row{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteRow) 

	return result, nil 
}
// Gets the <see cref="Column"/> element or null at the specified column index.
// Parameters:
//   columnIndex - int32 
// Returns:
//   Column  
func (instance *Cells) CheckColumn(columnindex int32)  (*Column,  error)  {
	
	CGoReturnPtr := C.Cells_CheckColumn( instance.ptr, C.int(columnindex))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Column{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteColumn) 

	return result, nil 
}
// Checks whether a row at given index is hidden.
// Parameters:
//   rowIndex - int32 
// Returns:
//   bool  
func (instance *Cells) IsRowHidden(rowindex int32)  (bool,  error)  {
	
	CGoReturnPtr := C.Cells_IsRowHidden( instance.ptr, C.int(rowindex))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Checks whether a column at given index is hidden.
// Parameters:
//   columnIndex - int32 
// Returns:
//   bool  
func (instance *Cells) IsColumnHidden(columnindex int32)  (bool,  error)  {
	
	CGoReturnPtr := C.Cells_IsColumnHidden( instance.ptr, C.int(columnindex))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Adds a range object reference to cells
// Parameters:
//   rangeObject - Range 
// Returns:
//   void  
func (instance *Cells) AddRange(rangeobject *Range)  error {
	
	var rangeobject_ptr unsafe.Pointer = nil
	if rangeobject != nil {
	  rangeobject_ptr =rangeobject.ptr
	}

	CGoReturnPtr := C.Cells_AddRange( instance.ptr, rangeobject_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Creates a <see cref="Range"/> object from a range of cells.
// Parameters:
//   upperLeftCell - string 
//   lowerRightCell - string 
// Returns:
//   Range  
func (instance *Cells) CreateRange_String_String(upperleftcell string, lowerrightcell string)  (*Range,  error)  {
	
	CGoReturnPtr := C.Cells_CreateRange_String_String( instance.ptr, C.CString(upperleftcell), C.CString(lowerrightcell))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Range{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteRange) 

	return result, nil 
}
// Creates a <see cref="Range"/> object from a range of cells.
// Parameters:
//   firstRow - int32 
//   firstColumn - int32 
//   totalRows - int32 
//   totalColumns - int32 
// Returns:
//   Range  
func (instance *Cells) CreateRange_Int_Int_Int_Int(firstrow int32, firstcolumn int32, totalrows int32, totalcolumns int32)  (*Range,  error)  {
	
	CGoReturnPtr := C.Cells_CreateRange_Integer_Integer_Integer_Integer( instance.ptr, C.int(firstrow), C.int(firstcolumn), C.int(totalrows), C.int(totalcolumns))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Range{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteRange) 

	return result, nil 
}
// Creates a <see cref="Range"/> object from an address of the range.
// Parameters:
//   address - string 
// Returns:
//   Range  
func (instance *Cells) CreateRange_String(address string)  (*Range,  error)  {
	
	CGoReturnPtr := C.Cells_CreateRange_String( instance.ptr, C.CString(address))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Range{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteRange) 

	return result, nil 
}
// Creates a <see cref="Range"/> object from rows of cells or columns of cells.
// Parameters:
//   firstIndex - int32 
//   number - int32 
//   isVertical - bool 
// Returns:
//   Range  
func (instance *Cells) CreateRange_Int_Int_Bool(firstindex int32, number int32, isvertical bool)  (*Range,  error)  {
	
	CGoReturnPtr := C.Cells_CreateRange_Integer_Integer_Boolean( instance.ptr, C.int(firstindex), C.int(number), C.bool(isvertical))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Range{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteRange) 

	return result, nil 
}
// Gets the <see cref="Cell"/> element at the specified cell row index and column index.
// Parameters:
//   row - int32 
//   column - int32 
// Returns:
//   Cell  
func (instance *Cells) Get_Int_Int(row int32, column int32)  (*Cell,  error)  {
	
	CGoReturnPtr := C.Cells_Get_Integer_Integer( instance.ptr, C.int(row), C.int(column))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Cell{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteCell) 

	return result, nil 
}
// Gets the <see cref="Cell"/> element at the specified cell name.
// Parameters:
//   cellName - string 
// Returns:
//   Cell  
func (instance *Cells) Get_String(cellname string)  (*Cell,  error)  {
	
	CGoReturnPtr := C.Cells_Get_String( instance.ptr, C.CString(cellname))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Cell{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteCell) 

	return result, nil 
}
// Gets or sets whether the cells data model should support Multi-Thread reading.
// Default value of this property is false.
// Returns:
//   bool  
func (instance *Cells) GetMultiThreadReading()  (bool,  error)  {
	
	CGoReturnPtr := C.Cells_GetMultiThreadReading( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets whether the cells data model should support Multi-Thread reading.
// Default value of this property is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Cells) SetMultiThreadReading(value bool)  error {
	
	CGoReturnPtr := C.Cells_SetMultiThreadReading( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the memory usage option for this cells.
// Returns:
//   int32  
func (instance *Cells) GetMemorySetting()  (MemorySetting,  error)  {
	
	CGoReturnPtr := C.Cells_GetMemorySetting( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToMemorySetting(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets or sets the memory usage option for this cells.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *Cells) SetMemorySetting(value MemorySetting)  error {
	
	CGoReturnPtr := C.Cells_SetMemorySetting( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Clears all data of the worksheet.
// Returns:
//   void  
func (instance *Cells) Clear()  error {
	
	CGoReturnPtr := C.Cells_Clear( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the default style of the worksheet.
// Returns:
//   Style  
func (instance *Cells) GetStyle()  (*Style,  error)  {
	
	CGoReturnPtr := C.Cells_GetStyle( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Style{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteStyle) 

	return result, nil 
}
// Gets and sets the default style of the worksheet.
// Parameters:
//   value - Style 
// Returns:
//   void  
func (instance *Cells) SetStyle(value *Style)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.Cells_SetStyle( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the default column width in the worksheet, in unit of inches.
// Returns:
//   float64  
func (instance *Cells) GetStandardWidthInch()  (float64,  error)  {
	
	CGoReturnPtr := C.Cells_GetStandardWidthInch( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := float64(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets the default column width in the worksheet, in unit of inches.
// Parameters:
//   value - float64 
// Returns:
//   void  
func (instance *Cells) SetStandardWidthInch(value float64)  error {
	
	CGoReturnPtr := C.Cells_SetStandardWidthInch( instance.ptr, C.double(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the default column width in the worksheet, in unit of pixels.
// Returns:
//   int32  
func (instance *Cells) GetStandardWidthPixels()  (int32,  error)  {
	
	CGoReturnPtr := C.Cells_GetStandardWidthPixels( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets the default column width in the worksheet, in unit of pixels.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *Cells) SetStandardWidthPixels(value int32)  error {
	
	CGoReturnPtr := C.Cells_SetStandardWidthPixels( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the default column width in the worksheet, in unit of characters.
// Returns:
//   float64  
func (instance *Cells) GetStandardWidth()  (float64,  error)  {
	
	CGoReturnPtr := C.Cells_GetStandardWidth( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := float64(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets the default column width in the worksheet, in unit of characters.
// Parameters:
//   value - float64 
// Returns:
//   void  
func (instance *Cells) SetStandardWidth(value float64)  error {
	
	CGoReturnPtr := C.Cells_SetStandardWidth( instance.ptr, C.double(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the default row height in this worksheet, in unit of points.
// Returns:
//   float64  
func (instance *Cells) GetStandardHeight()  (float64,  error)  {
	
	CGoReturnPtr := C.Cells_GetStandardHeight( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := float64(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets the default row height in this worksheet, in unit of points.
// Parameters:
//   value - float64 
// Returns:
//   void  
func (instance *Cells) SetStandardHeight(value float64)  error {
	
	CGoReturnPtr := C.Cells_SetStandardHeight( instance.ptr, C.double(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the default row height in this worksheet, in unit of pixels.
// Returns:
//   int32  
func (instance *Cells) GetStandardHeightPixels()  (int32,  error)  {
	
	CGoReturnPtr := C.Cells_GetStandardHeightPixels( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets the default row height in this worksheet, in unit of pixels.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *Cells) SetStandardHeightPixels(value int32)  error {
	
	CGoReturnPtr := C.Cells_SetStandardHeightPixels( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the default row height in this worksheet, in unit of inches.
// Returns:
//   float64  
func (instance *Cells) GetStandardHeightInch()  (float64,  error)  {
	
	CGoReturnPtr := C.Cells_GetStandardHeightInch( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := float64(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets the default row height in this worksheet, in unit of inches.
// Parameters:
//   value - float64 
// Returns:
//   void  
func (instance *Cells) SetStandardHeightInch(value float64)  error {
	
	CGoReturnPtr := C.Cells_SetStandardHeightInch( instance.ptr, C.double(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Imports an array of formula into a worksheet.
// Parameters:
//   stringArray - []string 
//   firstRow - int32 
//   firstColumn - int32 
//   isVertical - bool 
// Returns:
//   void  
func (instance *Cells) ImportFormulaArray(stringarray []string, firstrow int32, firstcolumn int32, isvertical bool)  error {
	
	vector_stringarray := make([]*C.char, len(stringarray))
	for i, str := range stringarray {
	cStr := C.CString(str)
	defer C.free(unsafe.Pointer(cStr))
	vector_stringarray[i] = cStr
	}

	CGoReturnPtr := C.Cells_ImportFormulaArray( instance.ptr, unsafe.Pointer(&vector_stringarray[0]), C.int( len(stringarray)), C.int(firstrow), C.int(firstcolumn), C.bool(isvertical))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Splits content in specified column into multiple columns..
// Parameters:
//   row - int32 
//   column - int32 
//   totalRows - int32 
//   options - TxtLoadOptions 
// Returns:
//   int32  
func (instance *Cells) TextToColumns(row int32, column int32, totalrows int32, options *TxtLoadOptions)  (int32,  error)  {
	
	var options_ptr unsafe.Pointer = nil
	if options != nil {
	  options_ptr =options.ptr
	}

	CGoReturnPtr := C.Cells_TextToColumns( instance.ptr, C.int(row), C.int(column), C.int(totalrows), options_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Import a CSV file to the cells.
// Parameters:
//   fileName - string 
//   splitter - string 
//   convertNumericData - bool 
//   firstRow - int32 
//   firstColumn - int32 
// Returns:
//   void  
func (instance *Cells) ImportCSV_String_String_Bool_Int_Int(filename string, splitter string, convertnumericdata bool, firstrow int32, firstcolumn int32)  error {
	
	CGoReturnPtr := C.Cells_ImportCSV_String_String_Boolean_Integer_Integer( instance.ptr, C.CString(filename), C.CString(splitter), C.bool(convertnumericdata), C.int(firstrow), C.int(firstcolumn))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Import a CSV file to the cells.
// Parameters:
//   stream - []byte 
//   splitter - string 
//   convertNumericData - bool 
//   firstRow - int32 
//   firstColumn - int32 
// Returns:
//   void  
func (instance *Cells) ImportCSV_Stream_String_Bool_Int_Int(stream []byte, splitter string, convertnumericdata bool, firstrow int32, firstcolumn int32)  error {
	
	CGoReturnPtr := C.Cells_ImportCSV_Stream_String_Boolean_Integer_Integer( instance.ptr, unsafe.Pointer(&stream[0]), C.int( len(stream)), C.CString(splitter), C.bool(convertnumericdata), C.int(firstrow), C.int(firstcolumn))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Import a CSV file to the cells.
// Parameters:
//   fileName - string 
//   options - TxtLoadOptions 
//   firstRow - int32 
//   firstColumn - int32 
// Returns:
//   void  
func (instance *Cells) ImportCSV_String_TxtLoadOptions_Int_Int(filename string, options *TxtLoadOptions, firstrow int32, firstcolumn int32)  error {
	
	var options_ptr unsafe.Pointer = nil
	if options != nil {
	  options_ptr =options.ptr
	}

	CGoReturnPtr := C.Cells_ImportCSV_String_TxtLoadOptions_Integer_Integer( instance.ptr, C.CString(filename), options_ptr, C.int(firstrow), C.int(firstcolumn))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Import a CSV file to the cells.
// Parameters:
//   stream - []byte 
//   options - TxtLoadOptions 
//   firstRow - int32 
//   firstColumn - int32 
// Returns:
//   void  
func (instance *Cells) ImportCSV_Stream_TxtLoadOptions_Int_Int(stream []byte, options *TxtLoadOptions, firstrow int32, firstcolumn int32)  error {
	
	var options_ptr unsafe.Pointer = nil
	if options != nil {
	  options_ptr =options.ptr
	}

	CGoReturnPtr := C.Cells_ImportCSV_Stream_TxtLoadOptions_Integer_Integer( instance.ptr, unsafe.Pointer(&stream[0]), C.int( len(stream)), options_ptr, C.int(firstrow), C.int(firstcolumn))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets a value indicating whether all worksheet values are preserved as strings.
// Default is false.
// Returns:
//   bool  
func (instance *Cells) GetPreserveString()  (bool,  error)  {
	
	CGoReturnPtr := C.Cells_GetPreserveString( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets a value indicating whether all worksheet values are preserved as strings.
// Default is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Cells) SetPreserveString(value bool)  error {
	
	CGoReturnPtr := C.Cells_SetPreserveString( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Merges a specified range of cells into a single cell.
// Parameters:
//   firstRow - int32 
//   firstColumn - int32 
//   totalRows - int32 
//   totalColumns - int32 
// Returns:
//   void  
func (instance *Cells) Merge_Int_Int_Int_Int(firstrow int32, firstcolumn int32, totalrows int32, totalcolumns int32)  error {
	
	CGoReturnPtr := C.Cells_Merge_Integer_Integer_Integer_Integer( instance.ptr, C.int(firstrow), C.int(firstcolumn), C.int(totalrows), C.int(totalcolumns))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Merges a specified range of cells into a single cell.
// Parameters:
//   firstRow - int32 
//   firstColumn - int32 
//   totalRows - int32 
//   totalColumns - int32 
//   mergeConflict - bool 
// Returns:
//   void  
func (instance *Cells) Merge_Int_Int_Int_Int_Bool(firstrow int32, firstcolumn int32, totalrows int32, totalcolumns int32, mergeconflict bool)  error {
	
	CGoReturnPtr := C.Cells_Merge_Integer_Integer_Integer_Integer_Boolean( instance.ptr, C.int(firstrow), C.int(firstcolumn), C.int(totalrows), C.int(totalcolumns), C.bool(mergeconflict))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Merges a specified range of cells into a single cell.
// Parameters:
//   firstRow - int32 
//   firstColumn - int32 
//   totalRows - int32 
//   totalColumns - int32 
//   checkConflict - bool 
//   mergeConflict - bool 
// Returns:
//   void  
func (instance *Cells) Merge_Int_Int_Int_Int_Bool_Bool(firstrow int32, firstcolumn int32, totalrows int32, totalcolumns int32, checkconflict bool, mergeconflict bool)  error {
	
	CGoReturnPtr := C.Cells_Merge_Integer_Integer_Integer_Integer_Boolean_Boolean( instance.ptr, C.int(firstrow), C.int(firstcolumn), C.int(totalrows), C.int(totalcolumns), C.bool(checkconflict), C.bool(mergeconflict))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Unmerges a specified range of merged cells.
// Parameters:
//   firstRow - int32 
//   firstColumn - int32 
//   totalRows - int32 
//   totalColumns - int32 
// Returns:
//   void  
func (instance *Cells) UnMerge(firstrow int32, firstcolumn int32, totalrows int32, totalcolumns int32)  error {
	
	CGoReturnPtr := C.Cells_UnMerge( instance.ptr, C.int(firstrow), C.int(firstcolumn), C.int(totalrows), C.int(totalcolumns))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Clears all merged ranges.
// Returns:
//   void  
func (instance *Cells) ClearMergedCells()  error {
	
	CGoReturnPtr := C.Cells_ClearMergedCells( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Hides a row.
// Parameters:
//   row - int32 
// Returns:
//   void  
func (instance *Cells) HideRow(row int32)  error {
	
	CGoReturnPtr := C.Cells_HideRow( instance.ptr, C.int(row))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Unhides a row.
// Parameters:
//   row - int32 
//   height - float64 
// Returns:
//   void  
func (instance *Cells) UnhideRow(row int32, height float64)  error {
	
	CGoReturnPtr := C.Cells_UnhideRow( instance.ptr, C.int(row), C.double(height))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Hides multiple rows.
// Parameters:
//   row - int32 
//   totalRows - int32 
// Returns:
//   void  
func (instance *Cells) HideRows(row int32, totalrows int32)  error {
	
	CGoReturnPtr := C.Cells_HideRows( instance.ptr, C.int(row), C.int(totalrows))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Unhides the hidden rows.
// Parameters:
//   row - int32 
//   totalRows - int32 
//   height - float64 
// Returns:
//   void  
func (instance *Cells) UnhideRows(row int32, totalrows int32, height float64)  error {
	
	CGoReturnPtr := C.Cells_UnhideRows( instance.ptr, C.int(row), C.int(totalrows), C.double(height))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Sets row height in unit of pixels.
// Parameters:
//   row - int32 
//   pixels - int32 
// Returns:
//   void  
func (instance *Cells) SetRowHeightPixel(row int32, pixels int32)  error {
	
	CGoReturnPtr := C.Cells_SetRowHeightPixel( instance.ptr, C.int(row), C.int(pixels))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Sets row height in unit of inches.
// Parameters:
//   row - int32 
//   inches - float64 
// Returns:
//   void  
func (instance *Cells) SetRowHeightInch(row int32, inches float64)  error {
	
	CGoReturnPtr := C.Cells_SetRowHeightInch( instance.ptr, C.int(row), C.double(inches))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Sets the height of the specified row.
// Parameters:
//   row - int32 
//   height - float64 
// Returns:
//   void  
func (instance *Cells) SetRowHeight(row int32, height float64)  error {
	
	CGoReturnPtr := C.Cells_SetRowHeight( instance.ptr, C.int(row), C.double(height))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets row's height.
// Parameters:
//   row - int32 
//   isOriginal - bool 
//   unitType - int32 
// Returns:
//   float64  
func (instance *Cells) GetRowHeight_Int_Bool_CellsUnitType(row int32, isoriginal bool, unittype CellsUnitType)  (float64,  error)  {
	
	CGoReturnPtr := C.Cells_GetRowHeight_Integer_Boolean_CellsUnitType( instance.ptr, C.int(row), C.bool(isoriginal), C.int( int32(unittype)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := float64(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the column width.
// Parameters:
//   column - int32 
//   isOriginal - bool 
//   unitType - int32 
// Returns:
//   float64  
func (instance *Cells) GetColumnWidth_Int_Bool_CellsUnitType(column int32, isoriginal bool, unittype CellsUnitType)  (float64,  error)  {
	
	CGoReturnPtr := C.Cells_GetColumnWidth_Integer_Boolean_CellsUnitType( instance.ptr, C.int(column), C.bool(isoriginal), C.int( int32(unittype)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := float64(CGoReturnPtr.return_value) 

	return result, nil 
}
// Hides a column.
// Parameters:
//   column - int32 
// Returns:
//   void  
func (instance *Cells) HideColumn(column int32)  error {
	
	CGoReturnPtr := C.Cells_HideColumn( instance.ptr, C.int(column))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Unhides a column
// Parameters:
//   column - int32 
//   width - float64 
// Returns:
//   void  
func (instance *Cells) UnhideColumn(column int32, width float64)  error {
	
	CGoReturnPtr := C.Cells_UnhideColumn( instance.ptr, C.int(column), C.double(width))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Hide multiple columns.
// Parameters:
//   column - int32 
//   totalColumns - int32 
// Returns:
//   void  
func (instance *Cells) HideColumns(column int32, totalcolumns int32)  error {
	
	CGoReturnPtr := C.Cells_HideColumns( instance.ptr, C.int(column), C.int(totalcolumns))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Unhide multiple columns.
// Parameters:
//   column - int32 
//   totalColumns - int32 
//   width - float64 
// Returns:
//   void  
func (instance *Cells) UnhideColumns(column int32, totalcolumns int32, width float64)  error {
	
	CGoReturnPtr := C.Cells_UnhideColumns( instance.ptr, C.int(column), C.int(totalcolumns), C.double(width))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the height of a specified row, in unit of points.
// Parameters:
//   row - int32 
// Returns:
//   float64  
func (instance *Cells) GetRowHeight_Int(row int32)  (float64,  error)  {
	
	CGoReturnPtr := C.Cells_GetRowHeight_Integer( instance.ptr, C.int(row))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := float64(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the height of a specified row.
// Parameters:
//   row - int32 
// Returns:
//   float64  
func (instance *Cells) GetViewRowHeight(row int32)  (float64,  error)  {
	
	CGoReturnPtr := C.Cells_GetViewRowHeight( instance.ptr, C.int(row))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := float64(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the height of a specified row in unit of inches.
// Parameters:
//   row - int32 
// Returns:
//   float64  
func (instance *Cells) GetRowHeightInch(row int32)  (float64,  error)  {
	
	CGoReturnPtr := C.Cells_GetRowHeightInch( instance.ptr, C.int(row))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := float64(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the height of a specified row in unit of inches.
// Parameters:
//   row - int32 
// Returns:
//   float64  
func (instance *Cells) GetViewRowHeightInch(row int32)  (float64,  error)  {
	
	CGoReturnPtr := C.Cells_GetViewRowHeightInch( instance.ptr, C.int(row))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := float64(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the height of a specified row in unit of pixel.
// Parameters:
//   row - int32 
// Returns:
//   int32  
func (instance *Cells) GetRowHeightPixel(row int32)  (int32,  error)  {
	
	CGoReturnPtr := C.Cells_GetRowHeightPixel( instance.ptr, C.int(row))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Sets column width in unit of pixels in normal view.
// Parameters:
//   column - int32 
//   pixels - int32 
// Returns:
//   void  
func (instance *Cells) SetColumnWidthPixel(column int32, pixels int32)  error {
	
	CGoReturnPtr := C.Cells_SetColumnWidthPixel( instance.ptr, C.int(column), C.int(pixels))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Sets column width in unit of inches  in normal view.
// Parameters:
//   column - int32 
//   inches - float64 
// Returns:
//   void  
func (instance *Cells) SetColumnWidthInch(column int32, inches float64)  error {
	
	CGoReturnPtr := C.Cells_SetColumnWidthInch( instance.ptr, C.int(column), C.double(inches))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Sets the width of the specified column in normal view.
// Parameters:
//   column - int32 
//   width - float64 
// Returns:
//   void  
func (instance *Cells) SetColumnWidth(column int32, width float64)  error {
	
	CGoReturnPtr := C.Cells_SetColumnWidth( instance.ptr, C.int(column), C.double(width))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the width of the specified column in normal view, in units of pixel.
// Parameters:
//   column - int32 
// Returns:
//   int32  
func (instance *Cells) GetColumnWidthPixel(column int32)  (int32,  error)  {
	
	CGoReturnPtr := C.Cells_GetColumnWidthPixel( instance.ptr, C.int(column))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the width(in unit of characters) of the specified column in normal view
// Parameters:
//   column - int32 
// Returns:
//   float64  
func (instance *Cells) GetColumnWidth_Int(column int32)  (float64,  error)  {
	
	CGoReturnPtr := C.Cells_GetColumnWidth_Integer( instance.ptr, C.int(column))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := float64(CGoReturnPtr.return_value) 

	return result, nil 
}
// Get the width in different view type.
// Parameters:
//   column - int32 
// Returns:
//   int32  
func (instance *Cells) GetViewColumnWidthPixel(column int32)  (int32,  error)  {
	
	CGoReturnPtr := C.Cells_GetViewColumnWidthPixel( instance.ptr, C.int(column))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Sets the width of the column in different view.
// Parameters:
//   column - int32 
//   pixels - int32 
// Returns:
//   void  
func (instance *Cells) SetViewColumnWidthPixel(column int32, pixels int32)  error {
	
	CGoReturnPtr := C.Cells_SetViewColumnWidthPixel( instance.ptr, C.int(column), C.int(pixels))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Minimum row index of cell which contains data or style.
// Returns:
//   int32  
func (instance *Cells) GetMinRow()  (int32,  error)  {
	
	CGoReturnPtr := C.Cells_GetMinRow( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Maximum row index of cell which contains data or style.
// Returns:
//   int32  
func (instance *Cells) GetMaxRow()  (int32,  error)  {
	
	CGoReturnPtr := C.Cells_GetMaxRow( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Minimum column index of those cells that have been instantiated in the collection(does not include the column
// where style is defined for the whole column but no cell has been instantiated in it).
// Returns:
//   int32  
func (instance *Cells) GetMinColumn()  (int32,  error)  {
	
	CGoReturnPtr := C.Cells_GetMinColumn( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Maximum column index of those cells that have been instantiated in the collection(does not include the column
// where style is defined for the whole column but no cell has been instantiated in it).
// Returns:
//   int32  
func (instance *Cells) GetMaxColumn()  (int32,  error)  {
	
	CGoReturnPtr := C.Cells_GetMaxColumn( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Minimum row index of cell which contains data.
// Returns:
//   int32  
func (instance *Cells) GetMinDataRow()  (int32,  error)  {
	
	CGoReturnPtr := C.Cells_GetMinDataRow( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Maximum row index of cell which contains data.
// Returns:
//   int32  
func (instance *Cells) GetMaxDataRow()  (int32,  error)  {
	
	CGoReturnPtr := C.Cells_GetMaxDataRow( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Minimum column index of cell which contains data.
// Returns:
//   int32  
func (instance *Cells) GetMinDataColumn()  (int32,  error)  {
	
	CGoReturnPtr := C.Cells_GetMinDataColumn( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Maximum column index of cell which contains data.
// Returns:
//   int32  
func (instance *Cells) GetMaxDataColumn()  (int32,  error)  {
	
	CGoReturnPtr := C.Cells_GetMaxDataColumn( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the last row index of cell which contains data in the specified column.
// Parameters:
//   column - int32 
// Returns:
//   int32  
func (instance *Cells) GetLastDataRow(column int32)  (int32,  error)  {
	
	CGoReturnPtr := C.Cells_GetLastDataRow( instance.ptr, C.int(column))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the first row index of cell which contains data in the specified column.
// Parameters:
//   column - int32 
// Returns:
//   int32  
func (instance *Cells) GetFirstDataRow(column int32)  (int32,  error)  {
	
	CGoReturnPtr := C.Cells_GetFirstDataRow( instance.ptr, C.int(column))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates that row height and default font height matches
// Returns:
//   bool  
func (instance *Cells) IsDefaultRowHeightMatched()  (bool,  error)  {
	
	CGoReturnPtr := C.Cells_IsDefaultRowHeightMatched( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates that row height and default font height matches
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Cells) SetIsDefaultRowHeightMatched(value bool)  error {
	
	CGoReturnPtr := C.Cells_SetIsDefaultRowHeightMatched( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether the row is default hidden.
// Returns:
//   bool  
func (instance *Cells) IsDefaultRowHidden()  (bool,  error)  {
	
	CGoReturnPtr := C.Cells_IsDefaultRowHidden( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether the row is default hidden.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Cells) SetIsDefaultRowHidden(value bool)  error {
	
	CGoReturnPtr := C.Cells_SetIsDefaultRowHidden( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the collection of <see cref="Column"/> objects that represents the individual columns in this worksheet.
// Returns:
//   ColumnCollection  
func (instance *Cells) GetColumns()  (*ColumnCollection,  error)  {
	
	CGoReturnPtr := C.Cells_GetColumns( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &ColumnCollection{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteColumnCollection) 

	return result, nil 
}
// Applies formats for a whole column.
// Parameters:
//   column - int32 
//   style - Style 
//   flag - StyleFlag 
// Returns:
//   void  
func (instance *Cells) ApplyColumnStyle(column int32, style *Style, flag *StyleFlag)  error {
	
	var style_ptr unsafe.Pointer = nil
	if style != nil {
	  style_ptr =style.ptr
	}
	var flag_ptr unsafe.Pointer = nil
	if flag != nil {
	  flag_ptr =flag.ptr
	}

	CGoReturnPtr := C.Cells_ApplyColumnStyle( instance.ptr, C.int(column), style_ptr, flag_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Applies formats for a whole row.
// Parameters:
//   row - int32 
//   style - Style 
//   flag - StyleFlag 
// Returns:
//   void  
func (instance *Cells) ApplyRowStyle(row int32, style *Style, flag *StyleFlag)  error {
	
	var style_ptr unsafe.Pointer = nil
	if style != nil {
	  style_ptr =style.ptr
	}
	var flag_ptr unsafe.Pointer = nil
	if flag != nil {
	  flag_ptr =flag.ptr
	}

	CGoReturnPtr := C.Cells_ApplyRowStyle( instance.ptr, C.int(row), style_ptr, flag_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Applies formats for a whole worksheet.
// Parameters:
//   style - Style 
//   flag - StyleFlag 
// Returns:
//   void  
func (instance *Cells) ApplyStyle(style *Style, flag *StyleFlag)  error {
	
	var style_ptr unsafe.Pointer = nil
	if style != nil {
	  style_ptr =style.ptr
	}
	var flag_ptr unsafe.Pointer = nil
	if flag != nil {
	  flag_ptr =flag.ptr
	}

	CGoReturnPtr := C.Cells_ApplyStyle( instance.ptr, style_ptr, flag_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Copies data and formats of a whole column.
// Parameters:
//   sourceCells0 - Cells 
//   sourceColumnIndex - int32 
//   destinationColumnIndex - int32 
//   columnNumber - int32 
//   pasteOptions - PasteOptions 
// Returns:
//   void  
func (instance *Cells) CopyColumns_Cells_Int_Int_Int_PasteOptions(sourcecells0 *Cells, sourcecolumnindex int32, destinationcolumnindex int32, columnnumber int32, pasteoptions *PasteOptions)  error {
	
	var sourcecells0_ptr unsafe.Pointer = nil
	if sourcecells0 != nil {
	  sourcecells0_ptr =sourcecells0.ptr
	}
	var pasteoptions_ptr unsafe.Pointer = nil
	if pasteoptions != nil {
	  pasteoptions_ptr =pasteoptions.ptr
	}

	CGoReturnPtr := C.Cells_CopyColumns_Cells_Integer_Integer_Integer_PasteOptions( instance.ptr, sourcecells0_ptr, C.int(sourcecolumnindex), C.int(destinationcolumnindex), C.int(columnnumber), pasteoptions_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Copies data and formats of a whole column.
// Parameters:
//   sourceCells - Cells 
//   sourceColumnIndex - int32 
//   destinationColumnIndex - int32 
// Returns:
//   void  
func (instance *Cells) CopyColumn(sourcecells *Cells, sourcecolumnindex int32, destinationcolumnindex int32)  error {
	
	var sourcecells_ptr unsafe.Pointer = nil
	if sourcecells != nil {
	  sourcecells_ptr =sourcecells.ptr
	}

	CGoReturnPtr := C.Cells_CopyColumn( instance.ptr, sourcecells_ptr, C.int(sourcecolumnindex), C.int(destinationcolumnindex))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Copies data and formats of a whole column.
// Parameters:
//   sourceCells0 - Cells 
//   sourceColumnIndex - int32 
//   destinationColumnIndex - int32 
//   columnNumber - int32 
// Returns:
//   void  
func (instance *Cells) CopyColumns_Cells_Int_Int_Int(sourcecells0 *Cells, sourcecolumnindex int32, destinationcolumnindex int32, columnnumber int32)  error {
	
	var sourcecells0_ptr unsafe.Pointer = nil
	if sourcecells0 != nil {
	  sourcecells0_ptr =sourcecells0.ptr
	}

	CGoReturnPtr := C.Cells_CopyColumns_Cells_Integer_Integer_Integer( instance.ptr, sourcecells0_ptr, C.int(sourcecolumnindex), C.int(destinationcolumnindex), C.int(columnnumber))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Copies data and formats of the whole columns.
// Parameters:
//   sourceCells - Cells 
//   sourceColumnIndex - int32 
//   sourceTotalColumns - int32 
//   destinationColumnIndex - int32 
//   destinationTotalColumns - int32 
// Returns:
//   void  
func (instance *Cells) CopyColumns_Cells_Int_Int_Int_Int(sourcecells *Cells, sourcecolumnindex int32, sourcetotalcolumns int32, destinationcolumnindex int32, destinationtotalcolumns int32)  error {
	
	var sourcecells_ptr unsafe.Pointer = nil
	if sourcecells != nil {
	  sourcecells_ptr =sourcecells.ptr
	}

	CGoReturnPtr := C.Cells_CopyColumns_Cells_Integer_Integer_Integer_Integer( instance.ptr, sourcecells_ptr, C.int(sourcecolumnindex), C.int(sourcetotalcolumns), C.int(destinationcolumnindex), C.int(destinationtotalcolumns))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Copies data and formats of a whole row.
// Parameters:
//   sourceCells - Cells 
//   sourceRowIndex - int32 
//   destinationRowIndex - int32 
// Returns:
//   void  
func (instance *Cells) CopyRow(sourcecells *Cells, sourcerowindex int32, destinationrowindex int32)  error {
	
	var sourcecells_ptr unsafe.Pointer = nil
	if sourcecells != nil {
	  sourcecells_ptr =sourcecells.ptr
	}

	CGoReturnPtr := C.Cells_CopyRow( instance.ptr, sourcecells_ptr, C.int(sourcerowindex), C.int(destinationrowindex))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Copies data and formats of some whole rows.
// Parameters:
//   sourceCells - Cells 
//   sourceRowIndex - int32 
//   destinationRowIndex - int32 
//   rowNumber - int32 
// Returns:
//   void  
func (instance *Cells) CopyRows_Cells_Int_Int_Int(sourcecells *Cells, sourcerowindex int32, destinationrowindex int32, rownumber int32)  error {
	
	var sourcecells_ptr unsafe.Pointer = nil
	if sourcecells != nil {
	  sourcecells_ptr =sourcecells.ptr
	}

	CGoReturnPtr := C.Cells_CopyRows_Cells_Integer_Integer_Integer( instance.ptr, sourcecells_ptr, C.int(sourcerowindex), C.int(destinationrowindex), C.int(rownumber))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Copies data and formats of some whole rows.
// Parameters:
//   sourceCells0 - Cells 
//   sourceRowIndex - int32 
//   destinationRowIndex - int32 
//   rowNumber - int32 
//   copyOptions - CopyOptions 
// Returns:
//   void  
func (instance *Cells) CopyRows_Cells_Int_Int_Int_CopyOptions(sourcecells0 *Cells, sourcerowindex int32, destinationrowindex int32, rownumber int32, copyoptions *CopyOptions)  error {
	
	var sourcecells0_ptr unsafe.Pointer = nil
	if sourcecells0 != nil {
	  sourcecells0_ptr =sourcecells0.ptr
	}
	var copyoptions_ptr unsafe.Pointer = nil
	if copyoptions != nil {
	  copyoptions_ptr =copyoptions.ptr
	}

	CGoReturnPtr := C.Cells_CopyRows_Cells_Integer_Integer_Integer_CopyOptions( instance.ptr, sourcecells0_ptr, C.int(sourcerowindex), C.int(destinationrowindex), C.int(rownumber), copyoptions_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Copies data and formats of some whole rows.
// Parameters:
//   sourceCells0 - Cells 
//   sourceRowIndex - int32 
//   destinationRowIndex - int32 
//   rowNumber - int32 
//   copyOptions - CopyOptions 
//   pasteOptions - PasteOptions 
// Returns:
//   void  
func (instance *Cells) CopyRows_Cells_Int_Int_Int_CopyOptions_PasteOptions(sourcecells0 *Cells, sourcerowindex int32, destinationrowindex int32, rownumber int32, copyoptions *CopyOptions, pasteoptions *PasteOptions)  error {
	
	var sourcecells0_ptr unsafe.Pointer = nil
	if sourcecells0 != nil {
	  sourcecells0_ptr =sourcecells0.ptr
	}
	var copyoptions_ptr unsafe.Pointer = nil
	if copyoptions != nil {
	  copyoptions_ptr =copyoptions.ptr
	}
	var pasteoptions_ptr unsafe.Pointer = nil
	if pasteoptions != nil {
	  pasteoptions_ptr =pasteoptions.ptr
	}

	CGoReturnPtr := C.Cells_CopyRows_Cells_Integer_Integer_Integer_CopyOptions_PasteOptions( instance.ptr, sourcecells0_ptr, C.int(sourcerowindex), C.int(destinationrowindex), C.int(rownumber), copyoptions_ptr, pasteoptions_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the outline level (zero-based) of the row.
// Parameters:
//   rowIndex - int32 
// Returns:
//   int32  
func (instance *Cells) GetGroupedRowOutlineLevel(rowindex int32)  (int32,  error)  {
	
	CGoReturnPtr := C.Cells_GetGroupedRowOutlineLevel( instance.ptr, C.int(rowindex))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the outline level (zero-based) of the column.
// Parameters:
//   columnIndex - int32 
// Returns:
//   int32  
func (instance *Cells) GetGroupedColumnOutlineLevel(columnindex int32)  (int32,  error)  {
	
	CGoReturnPtr := C.Cells_GetGroupedColumnOutlineLevel( instance.ptr, C.int(columnindex))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the max grouped column outline level (zero-based).
// Returns:
//   int32  
func (instance *Cells) GetMaxGroupedColumnOutlineLevel()  (int32,  error)  {
	
	CGoReturnPtr := C.Cells_GetMaxGroupedColumnOutlineLevel( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the max grouped row outline level (zero-based).
// Returns:
//   int32  
func (instance *Cells) GetMaxGroupedRowOutlineLevel()  (int32,  error)  {
	
	CGoReturnPtr := C.Cells_GetMaxGroupedRowOutlineLevel( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Expands the grouped rows/columns.
// Parameters:
//   isVertical - bool 
//   index - int32 
// Returns:
//   void  
func (instance *Cells) ShowGroupDetail(isvertical bool, index int32)  error {
	
	CGoReturnPtr := C.Cells_ShowGroupDetail( instance.ptr, C.bool(isvertical), C.int(index))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Collapses the grouped rows/columns.
// Parameters:
//   isVertical - bool 
//   index - int32 
// Returns:
//   void  
func (instance *Cells) HideGroupDetail(isvertical bool, index int32)  error {
	
	CGoReturnPtr := C.Cells_HideGroupDetail( instance.ptr, C.bool(isvertical), C.int(index))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Ungroups columns.
// Parameters:
//   firstIndex - int32 
//   lastIndex - int32 
// Returns:
//   void  
func (instance *Cells) UngroupColumns(firstindex int32, lastindex int32)  error {
	
	CGoReturnPtr := C.Cells_UngroupColumns( instance.ptr, C.int(firstindex), C.int(lastindex))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Groups columns.
// Parameters:
//   firstIndex - int32 
//   lastIndex - int32 
// Returns:
//   void  
func (instance *Cells) GroupColumns_Int_Int(firstindex int32, lastindex int32)  error {
	
	CGoReturnPtr := C.Cells_GroupColumns_Integer_Integer( instance.ptr, C.int(firstindex), C.int(lastindex))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Groups columns.
// Parameters:
//   firstIndex - int32 
//   lastIndex - int32 
//   isHidden - bool 
// Returns:
//   void  
func (instance *Cells) GroupColumns_Int_Int_Bool(firstindex int32, lastindex int32, ishidden bool)  error {
	
	CGoReturnPtr := C.Cells_GroupColumns_Integer_Integer_Boolean( instance.ptr, C.int(firstindex), C.int(lastindex), C.bool(ishidden))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Ungroups rows.
// Parameters:
//   firstIndex - int32 
//   lastIndex - int32 
//   isAll - bool 
// Returns:
//   void  
func (instance *Cells) UngroupRows_Int_Int_Bool(firstindex int32, lastindex int32, isall bool)  error {
	
	CGoReturnPtr := C.Cells_UngroupRows_Integer_Integer_Boolean( instance.ptr, C.int(firstindex), C.int(lastindex), C.bool(isall))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Ungroups rows.
// Parameters:
//   firstIndex - int32 
//   lastIndex - int32 
// Returns:
//   void  
func (instance *Cells) UngroupRows_Int_Int(firstindex int32, lastindex int32)  error {
	
	CGoReturnPtr := C.Cells_UngroupRows_Integer_Integer( instance.ptr, C.int(firstindex), C.int(lastindex))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Groups rows.
// Parameters:
//   firstIndex - int32 
//   lastIndex - int32 
//   isHidden - bool 
// Returns:
//   void  
func (instance *Cells) GroupRows_Int_Int_Bool(firstindex int32, lastindex int32, ishidden bool)  error {
	
	CGoReturnPtr := C.Cells_GroupRows_Integer_Integer_Boolean( instance.ptr, C.int(firstindex), C.int(lastindex), C.bool(ishidden))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Groups rows.
// Parameters:
//   firstIndex - int32 
//   lastIndex - int32 
// Returns:
//   void  
func (instance *Cells) GroupRows_Int_Int(firstindex int32, lastindex int32)  error {
	
	CGoReturnPtr := C.Cells_GroupRows_Integer_Integer( instance.ptr, C.int(firstindex), C.int(lastindex))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Deletes a column.
// Parameters:
//   columnIndex - int32 
//   updateReference - bool 
// Returns:
//   void  
func (instance *Cells) DeleteColumn_Int_Bool(columnindex int32, updatereference bool)  error {
	
	CGoReturnPtr := C.Cells_DeleteColumn_Integer_Boolean( instance.ptr, C.int(columnindex), C.bool(updatereference))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Deletes a column.
// Parameters:
//   columnIndex - int32 
// Returns:
//   void  
func (instance *Cells) DeleteColumn_Int(columnindex int32)  error {
	
	CGoReturnPtr := C.Cells_DeleteColumn_Integer( instance.ptr, C.int(columnindex))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Deletes several columns.
// Parameters:
//   columnIndex - int32 
//   totalColumns - int32 
//   updateReference - bool 
// Returns:
//   void  
func (instance *Cells) DeleteColumns_Int_Int_Bool(columnindex int32, totalcolumns int32, updatereference bool)  error {
	
	CGoReturnPtr := C.Cells_DeleteColumns_Integer_Integer_Boolean( instance.ptr, C.int(columnindex), C.int(totalcolumns), C.bool(updatereference))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Deletes several columns.
// Parameters:
//   columnIndex - int32 
//   totalColumns - int32 
//   options - DeleteOptions 
// Returns:
//   void  
func (instance *Cells) DeleteColumns_Int_Int_DeleteOptions(columnindex int32, totalcolumns int32, options *DeleteOptions)  error {
	
	var options_ptr unsafe.Pointer = nil
	if options != nil {
	  options_ptr =options.ptr
	}

	CGoReturnPtr := C.Cells_DeleteColumns_Integer_Integer_DeleteOptions( instance.ptr, C.int(columnindex), C.int(totalcolumns), options_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Check whether the range could be deleted.
// Parameters:
//   startRow - int32 
//   startColumn - int32 
//   totalRows - int32 
//   totalColumns - int32 
// Returns:
//   bool  
func (instance *Cells) IsDeletingRangeEnabled(startrow int32, startcolumn int32, totalrows int32, totalcolumns int32)  (bool,  error)  {
	
	CGoReturnPtr := C.Cells_IsDeletingRangeEnabled( instance.ptr, C.int(startrow), C.int(startcolumn), C.int(totalrows), C.int(totalcolumns))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Deletes a row.
// Parameters:
//   rowIndex - int32 
// Returns:
//   void  
func (instance *Cells) DeleteRow_Int(rowindex int32)  error {
	
	CGoReturnPtr := C.Cells_DeleteRow_Integer( instance.ptr, C.int(rowindex))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Deletes a row.
// Parameters:
//   rowIndex - int32 
//   updateReference - bool 
// Returns:
//   void  
func (instance *Cells) DeleteRow_Int_Bool(rowindex int32, updatereference bool)  error {
	
	CGoReturnPtr := C.Cells_DeleteRow_Integer_Boolean( instance.ptr, C.int(rowindex), C.bool(updatereference))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Deletes multiple rows.
// Parameters:
//   rowIndex - int32 
//   totalRows - int32 
// Returns:
//   bool  
func (instance *Cells) DeleteRows_Int_Int(rowindex int32, totalrows int32)  (bool,  error)  {
	
	CGoReturnPtr := C.Cells_DeleteRows_Integer_Integer( instance.ptr, C.int(rowindex), C.int(totalrows))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Deletes multiple rows in the worksheet.
// Parameters:
//   rowIndex - int32 
//   totalRows - int32 
//   updateReference - bool 
// Returns:
//   bool  
func (instance *Cells) DeleteRows_Int_Int_Bool(rowindex int32, totalrows int32, updatereference bool)  (bool,  error)  {
	
	CGoReturnPtr := C.Cells_DeleteRows_Integer_Integer_Boolean( instance.ptr, C.int(rowindex), C.int(totalrows), C.bool(updatereference))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Deletes multiple rows in the worksheet.
// Parameters:
//   rowIndex - int32 
//   totalRows - int32 
//   options - DeleteOptions 
// Returns:
//   bool  
func (instance *Cells) DeleteRows_Int_Int_DeleteOptions(rowindex int32, totalrows int32, options *DeleteOptions)  (bool,  error)  {
	
	var options_ptr unsafe.Pointer = nil
	if options != nil {
	  options_ptr =options.ptr
	}

	CGoReturnPtr := C.Cells_DeleteRows_Integer_Integer_DeleteOptions( instance.ptr, C.int(rowindex), C.int(totalrows), options_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Delete all blank columns which do not contain any data.
// Returns:
//   void  
func (instance *Cells) DeleteBlankColumns()  error {
	
	CGoReturnPtr := C.Cells_DeleteBlankColumns( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Delete all blank columns which do not contain any data.
// Parameters:
//   options - DeleteOptions 
// Returns:
//   void  
func (instance *Cells) DeleteBlankColumns_DeleteOptions(options *DeleteOptions)  error {
	
	var options_ptr unsafe.Pointer = nil
	if options != nil {
	  options_ptr =options.ptr
	}

	CGoReturnPtr := C.Cells_DeleteBlankColumns_DeleteOptions( instance.ptr, options_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Checks whether given column is blank(does not contain any data).
// Parameters:
//   columnIndex - int32 
// Returns:
//   bool  
func (instance *Cells) IsBlankColumn(columnindex int32)  (bool,  error)  {
	
	CGoReturnPtr := C.Cells_IsBlankColumn( instance.ptr, C.int(columnindex))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Delete all blank rows which do not contain any data or other object.
// Returns:
//   void  
func (instance *Cells) DeleteBlankRows()  error {
	
	CGoReturnPtr := C.Cells_DeleteBlankRows( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Delete all blank rows which do not contain any data or some special objects such as visible comment, pivot table.
// Parameters:
//   options - DeleteOptions 
// Returns:
//   void  
func (instance *Cells) DeleteBlankRows_DeleteOptions(options *DeleteOptions)  error {
	
	var options_ptr unsafe.Pointer = nil
	if options != nil {
	  options_ptr =options.ptr
	}

	CGoReturnPtr := C.Cells_DeleteBlankRows_DeleteOptions( instance.ptr, options_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Inserts some columns into the worksheet.
// Parameters:
//   columnIndex - int32 
//   totalColumns - int32 
// Returns:
//   void  
func (instance *Cells) InsertColumns_Int_Int(columnindex int32, totalcolumns int32)  error {
	
	CGoReturnPtr := C.Cells_InsertColumns_Integer_Integer( instance.ptr, C.int(columnindex), C.int(totalcolumns))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Inserts some columns into the worksheet.
// Parameters:
//   columnIndex - int32 
//   totalColumns - int32 
//   updateReference - bool 
// Returns:
//   void  
func (instance *Cells) InsertColumns_Int_Int_Bool(columnindex int32, totalcolumns int32, updatereference bool)  error {
	
	CGoReturnPtr := C.Cells_InsertColumns_Integer_Integer_Boolean( instance.ptr, C.int(columnindex), C.int(totalcolumns), C.bool(updatereference))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Inserts some columns into the worksheet.
// Parameters:
//   columnIndex - int32 
//   totalColumns - int32 
//   options - InsertOptions 
// Returns:
//   void  
func (instance *Cells) InsertColumns_Int_Int_InsertOptions(columnindex int32, totalcolumns int32, options *InsertOptions)  error {
	
	var options_ptr unsafe.Pointer = nil
	if options != nil {
	  options_ptr =options.ptr
	}

	CGoReturnPtr := C.Cells_InsertColumns_Integer_Integer_InsertOptions( instance.ptr, C.int(columnindex), C.int(totalcolumns), options_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Inserts a new column into the worksheet.
// Parameters:
//   columnIndex - int32 
//   updateReference - bool 
// Returns:
//   void  
func (instance *Cells) InsertColumn_Int_Bool(columnindex int32, updatereference bool)  error {
	
	CGoReturnPtr := C.Cells_InsertColumn_Integer_Boolean( instance.ptr, C.int(columnindex), C.bool(updatereference))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Inserts a new column into the worksheet.
// Parameters:
//   columnIndex - int32 
// Returns:
//   void  
func (instance *Cells) InsertColumn_Int(columnindex int32)  error {
	
	CGoReturnPtr := C.Cells_InsertColumn_Integer( instance.ptr, C.int(columnindex))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Inserts multiple rows into the worksheet.
// Parameters:
//   rowIndex - int32 
//   totalRows - int32 
//   updateReference - bool 
// Returns:
//   void  
func (instance *Cells) InsertRows_Int_Int_Bool(rowindex int32, totalrows int32, updatereference bool)  error {
	
	CGoReturnPtr := C.Cells_InsertRows_Integer_Integer_Boolean( instance.ptr, C.int(rowindex), C.int(totalrows), C.bool(updatereference))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Inserts multiple rows into the worksheet.
// Parameters:
//   rowIndex - int32 
//   totalRows - int32 
//   options - InsertOptions 
// Returns:
//   void  
func (instance *Cells) InsertRows_Int_Int_InsertOptions(rowindex int32, totalrows int32, options *InsertOptions)  error {
	
	var options_ptr unsafe.Pointer = nil
	if options != nil {
	  options_ptr =options.ptr
	}

	CGoReturnPtr := C.Cells_InsertRows_Integer_Integer_InsertOptions( instance.ptr, C.int(rowindex), C.int(totalrows), options_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Inserts multiple rows into the worksheet.
// Parameters:
//   rowIndex - int32 
//   totalRows - int32 
// Returns:
//   void  
func (instance *Cells) InsertRows_Int_Int(rowindex int32, totalrows int32)  error {
	
	CGoReturnPtr := C.Cells_InsertRows_Integer_Integer( instance.ptr, C.int(rowindex), C.int(totalrows))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Inserts a new row into the worksheet.
// Parameters:
//   rowIndex - int32 
// Returns:
//   void  
func (instance *Cells) InsertRow(rowindex int32)  error {
	
	CGoReturnPtr := C.Cells_InsertRow( instance.ptr, C.int(rowindex))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the collection of <see cref="Range"/> objects created at run time.
// Returns:
//   RangeCollection  
func (instance *Cells) GetRanges()  (*RangeCollection,  error)  {
	
	CGoReturnPtr := C.Cells_GetRanges( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &RangeCollection{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteRangeCollection) 

	return result, nil 
}
// Clears contents and formatting of a range.
// Parameters:
//   range - CellArea 
// Returns:
//   void  
func (instance *Cells) ClearRange_CellArea(range_ *CellArea)  error {
	
	var range__ptr unsafe.Pointer = nil
	if range_ != nil {
	  range__ptr =range_.ptr
	}

	CGoReturnPtr := C.Cells_ClearRange_CellArea( instance.ptr, range__ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Clears contents and formatting of a range.
// Parameters:
//   startRow - int32 
//   startColumn - int32 
//   endRow - int32 
//   endColumn - int32 
// Returns:
//   void  
func (instance *Cells) ClearRange_Int_Int_Int_Int(startrow int32, startcolumn int32, endrow int32, endcolumn int32)  error {
	
	CGoReturnPtr := C.Cells_ClearRange_Integer_Integer_Integer_Integer( instance.ptr, C.int(startrow), C.int(startcolumn), C.int(endrow), C.int(endcolumn))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Clears contents of a range.
// Parameters:
//   range - CellArea 
// Returns:
//   void  
func (instance *Cells) ClearContents_CellArea(range_ *CellArea)  error {
	
	var range__ptr unsafe.Pointer = nil
	if range_ != nil {
	  range__ptr =range_.ptr
	}

	CGoReturnPtr := C.Cells_ClearContents_CellArea( instance.ptr, range__ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Clears contents of a range.
// Parameters:
//   startRow - int32 
//   startColumn - int32 
//   endRow - int32 
//   endColumn - int32 
// Returns:
//   void  
func (instance *Cells) ClearContents_Int_Int_Int_Int(startrow int32, startcolumn int32, endrow int32, endcolumn int32)  error {
	
	CGoReturnPtr := C.Cells_ClearContents_Integer_Integer_Integer_Integer( instance.ptr, C.int(startrow), C.int(startcolumn), C.int(endrow), C.int(endcolumn))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Clears formatting of a range.
// Parameters:
//   range - CellArea 
// Returns:
//   void  
func (instance *Cells) ClearFormats_CellArea(range_ *CellArea)  error {
	
	var range__ptr unsafe.Pointer = nil
	if range_ != nil {
	  range__ptr =range_.ptr
	}

	CGoReturnPtr := C.Cells_ClearFormats_CellArea( instance.ptr, range__ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Clears formatting of a range.
// Parameters:
//   startRow - int32 
//   startColumn - int32 
//   endRow - int32 
//   endColumn - int32 
// Returns:
//   void  
func (instance *Cells) ClearFormats_Int_Int_Int_Int(startrow int32, startcolumn int32, endrow int32, endcolumn int32)  error {
	
	CGoReturnPtr := C.Cells_ClearFormats_Integer_Integer_Integer_Integer( instance.ptr, C.int(startrow), C.int(startcolumn), C.int(endrow), C.int(endcolumn))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the last cell in this worksheet.
// Returns:
//   Cell  
func (instance *Cells) GetLastCell()  (*Cell,  error)  {
	
	CGoReturnPtr := C.Cells_GetLastCell( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Cell{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteCell) 

	return result, nil 
}
// Link to a xml map.
// Parameters:
//   mapName - string 
//   row - int32 
//   column - int32 
//   path - string 
// Returns:
//   void  
func (instance *Cells) LinkToXmlMap(mapname string, row int32, column int32, path string)  error {
	
	CGoReturnPtr := C.Cells_LinkToXmlMap( instance.ptr, C.CString(mapname), C.int(row), C.int(column), C.CString(path))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the max range which includes data, merged cells and shapes.
// Returns:
//   Range  
func (instance *Cells) GetMaxDisplayRange()  (*Range,  error)  {
	
	CGoReturnPtr := C.Cells_GetMaxDisplayRange( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Range{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteRange) 

	return result, nil 
}
// Gets the first cell in this worksheet.
// Returns:
//   Cell  
func (instance *Cells) GetFirstCell()  (*Cell,  error)  {
	
	CGoReturnPtr := C.Cells_GetFirstCell( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Cell{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteCell) 

	return result, nil 
}
// Finds the cell containing with the input object.
// Parameters:
//   what - Object 
//   previousCell - Cell 
// Returns:
//   Cell  
func (instance *Cells) Find_Object_Cell(what *Object, previouscell *Cell)  (*Cell,  error)  {
	
	var what_ptr unsafe.Pointer = nil
	if what != nil {
	  what_ptr =what.ptr
	}
	var previouscell_ptr unsafe.Pointer = nil
	if previouscell != nil {
	  previouscell_ptr =previouscell.ptr
	}

	CGoReturnPtr := C.Cells_Find_Object_Cell( instance.ptr, what_ptr, previouscell_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Cell{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteCell) 

	return result, nil 
}
// Finds the cell containing with the input object.
// Parameters:
//   what - Object 
//   previousCell - Cell 
//   findOptions - FindOptions 
// Returns:
//   Cell  
func (instance *Cells) Find_Object_Cell_FindOptions(what *Object, previouscell *Cell, findoptions *FindOptions)  (*Cell,  error)  {
	
	var what_ptr unsafe.Pointer = nil
	if what != nil {
	  what_ptr =what.ptr
	}
	var previouscell_ptr unsafe.Pointer = nil
	if previouscell != nil {
	  previouscell_ptr =previouscell.ptr
	}
	var findoptions_ptr unsafe.Pointer = nil
	if findoptions != nil {
	  findoptions_ptr =findoptions.ptr
	}

	CGoReturnPtr := C.Cells_Find_Object_Cell_FindOptions( instance.ptr, what_ptr, previouscell_ptr, findoptions_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Cell{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteCell) 

	return result, nil 
}
// Gets the last cell in this row.
// Parameters:
//   rowIndex - int32 
// Returns:
//   Cell  
func (instance *Cells) EndCellInRow_Int(rowindex int32)  (*Cell,  error)  {
	
	CGoReturnPtr := C.Cells_EndCellInRow_Integer( instance.ptr, C.int(rowindex))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Cell{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteCell) 

	return result, nil 
}
// Gets the last cell in this column.
// Parameters:
//   columnIndex - int32 
// Returns:
//   Cell  
func (instance *Cells) EndCellInColumn_Int(columnindex int32)  (*Cell,  error)  {
	
	CGoReturnPtr := C.Cells_EndCellInColumn_Integer( instance.ptr, C.int(columnindex))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Cell{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteCell) 

	return result, nil 
}
// Gets the last cell with maximum column index in this range.
// Parameters:
//   startRow - int32 
//   endRow - int32 
//   startColumn - int32 
//   endColumn - int32 
// Returns:
//   Cell  
func (instance *Cells) EndCellInColumn_Int_Int_Int_Int(startrow int32, endrow int32, startcolumn int32, endcolumn int32)  (*Cell,  error)  {
	
	CGoReturnPtr := C.Cells_EndCellInColumn_Integer_Integer_Integer_Integer( instance.ptr, C.int(startrow), C.int(endrow), C.int(startcolumn), C.int(endcolumn))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Cell{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteCell) 

	return result, nil 
}
// Gets the last cell with maximum row index in this range.
// Parameters:
//   startRow - int32 
//   endRow - int32 
//   startColumn - int32 
//   endColumn - int32 
// Returns:
//   Cell  
func (instance *Cells) EndCellInRow_Int_Int_Int_Int(startrow int32, endrow int32, startcolumn int32, endcolumn int32)  (*Cell,  error)  {
	
	CGoReturnPtr := C.Cells_EndCellInRow_Integer_Integer_Integer_Integer( instance.ptr, C.int(startrow), C.int(endrow), C.int(startcolumn), C.int(endcolumn))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Cell{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteCell) 

	return result, nil 
}
// Moves the range.
// Parameters:
//   sourceArea - CellArea 
//   destRow - int32 
//   destColumn - int32 
// Returns:
//   void  
func (instance *Cells) MoveRange(sourcearea *CellArea, destrow int32, destcolumn int32)  error {
	
	var sourcearea_ptr unsafe.Pointer = nil
	if sourcearea != nil {
	  sourcearea_ptr =sourcearea.ptr
	}

	CGoReturnPtr := C.Cells_MoveRange( instance.ptr, sourcearea_ptr, C.int(destrow), C.int(destcolumn))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Insert cut range.
// Parameters:
//   cutRange - Range 
//   row - int32 
//   column - int32 
//   shiftType - int32 
// Returns:
//   void  
func (instance *Cells) InsertCutCells(cutrange *Range, row int32, column int32, shifttype ShiftType)  error {
	
	var cutrange_ptr unsafe.Pointer = nil
	if cutrange != nil {
	  cutrange_ptr =cutrange.ptr
	}

	CGoReturnPtr := C.Cells_InsertCutCells( instance.ptr, cutrange_ptr, C.int(row), C.int(column), C.int( int32(shifttype)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Inserts a range of cells and shift cells according to the shift option.
// Parameters:
//   area - CellArea 
//   shiftNumber - int32 
//   shiftType - int32 
//   updateReference - bool 
// Returns:
//   void  
func (instance *Cells) InsertRange_CellArea_Int_ShiftType_Bool(area *CellArea, shiftnumber int32, shifttype ShiftType, updatereference bool)  error {
	
	var area_ptr unsafe.Pointer = nil
	if area != nil {
	  area_ptr =area.ptr
	}

	CGoReturnPtr := C.Cells_InsertRange_CellArea_Integer_ShiftType_Boolean( instance.ptr, area_ptr, C.int(shiftnumber), C.int( int32(shifttype)), C.bool(updatereference))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Inserts a range of cells and shift cells according to the shift option.
// Parameters:
//   area - CellArea 
//   shiftType - int32 
// Returns:
//   void  
func (instance *Cells) InsertRange_CellArea_ShiftType(area *CellArea, shifttype ShiftType)  error {
	
	var area_ptr unsafe.Pointer = nil
	if area != nil {
	  area_ptr =area.ptr
	}

	CGoReturnPtr := C.Cells_InsertRange_CellArea_ShiftType( instance.ptr, area_ptr, C.int( int32(shifttype)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Inserts a range of cells and shift cells according to the shift option.
// Parameters:
//   area - CellArea 
//   shiftNumber - int32 
//   shiftType - int32 
// Returns:
//   void  
func (instance *Cells) InsertRange_CellArea_Int_ShiftType(area *CellArea, shiftnumber int32, shifttype ShiftType)  error {
	
	var area_ptr unsafe.Pointer = nil
	if area != nil {
	  area_ptr =area.ptr
	}

	CGoReturnPtr := C.Cells_InsertRange_CellArea_Integer_ShiftType( instance.ptr, area_ptr, C.int(shiftnumber), C.int( int32(shifttype)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Deletes a range of cells and shift cells according to the shift option.
// Parameters:
//   startRow - int32 
//   startColumn - int32 
//   endRow - int32 
//   endColumn - int32 
//   shiftType - int32 
// Returns:
//   void  
func (instance *Cells) DeleteRange(startrow int32, startcolumn int32, endrow int32, endcolumn int32, shifttype ShiftType)  error {
	
	CGoReturnPtr := C.Cells_DeleteRange( instance.ptr, C.int(startrow), C.int(startcolumn), C.int(endrow), C.int(endcolumn), C.int( int32(shifttype)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Exports data in the <see cref="Cells"/> collection to a two-dimension array object.
// Parameters:
//   firstRow - int32 
//   firstColumn - int32 
//   totalRows - int32 
//   totalColumns - int32 
// Returns:
//   []Vector<Object>  
func (instance *Cells) ExportArray(firstrow int32, firstcolumn int32, totalrows int32, totalcolumns int32)  ([][]Object,  error)  {
	
	CGoReturnPtr := C.Cells_ExportArray( instance.ptr, C.int(firstrow), C.int(firstcolumn), C.int(totalrows), C.int(totalcolumns))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result:= make([][]Object, CGoReturnPtr.row_length)
	for i := 0; i < int(CGoReturnPtr.row_length); i++ {
	result[i] = make([]Object, int(CGoReturnPtr.column_length))
	}
	for i := 0; i < int(CGoReturnPtr.row_length); i++ {
	for j := 0; j < int(CGoReturnPtr.column_length); j++ {
	   offset := uintptr(C.size_t(i) * C.size_t(int(CGoReturnPtr.column_length))  +  C.size_t(j)  ) * uintptr(CGoReturnPtr.size) 
	   goObject := &Object{}
	   goObject.ptr =unsafe.Pointer(uintptr( unsafe.Pointer(CGoReturnPtr.return_value)) + offset)
	   result[i][j] = *goObject
	}
	}
	 

	return result, nil 
}
// Retrieves subtotals setting of the range.
// Parameters:
//   ca - CellArea 
// Returns:
//   SubtotalSetting  
func (instance *Cells) RetrieveSubtotalSetting(ca *CellArea)  (*SubtotalSetting,  error)  {
	
	var ca_ptr unsafe.Pointer = nil
	if ca != nil {
	  ca_ptr =ca.ptr
	}

	CGoReturnPtr := C.Cells_RetrieveSubtotalSetting( instance.ptr, ca_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &SubtotalSetting{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteSubtotalSetting) 

	return result, nil 
}
// Creates subtotals for the range.
// Parameters:
//   ca - CellArea 
//   groupBy - int32 
//   function - int32 
//   totalList - []int32_t 
// Returns:
//   void  
func (instance *Cells) Subtotal_CellArea_Int_ConsolidationFunction_int32Array(ca *CellArea, groupby int32, function ConsolidationFunction, totallist []int32)  error {
	
	var ca_ptr unsafe.Pointer = nil
	if ca != nil {
	  ca_ptr =ca.ptr
	}

	CGoReturnPtr := C.Cells_Subtotal_CellArea_Integer_ConsolidationFunction_int32_tArray( instance.ptr, ca_ptr, C.int(groupby), C.int( int32(function)), unsafe.Pointer(&totallist[0]), C.int( len(totallist)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Creates subtotals for the range.
// Parameters:
//   ca - CellArea 
//   groupBy - int32 
//   function - int32 
//   totalList - []int32_t 
//   replace - bool 
//   pageBreaks - bool 
//   summaryBelowData - bool 
// Returns:
//   void  
func (instance *Cells) Subtotal_CellArea_Int_ConsolidationFunction_int32Array_Bool_Bool_Bool(ca *CellArea, groupby int32, function ConsolidationFunction, totallist []int32, replace bool, pagebreaks bool, summarybelowdata bool)  error {
	
	var ca_ptr unsafe.Pointer = nil
	if ca != nil {
	  ca_ptr =ca.ptr
	}

	CGoReturnPtr := C.Cells_Subtotal_CellArea_Integer_ConsolidationFunction_int32_tArray_Boolean_Boolean_Boolean( instance.ptr, ca_ptr, C.int(groupby), C.int( int32(function)), unsafe.Pointer(&totallist[0]), C.int( len(totallist)), C.bool(replace), C.bool(pagebreaks), C.bool(summarybelowdata))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Removes all formula and replaces with the value of the formula.
// Returns:
//   void  
func (instance *Cells) RemoveFormulas()  error {
	
	CGoReturnPtr := C.Cells_RemoveFormulas( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Removes duplicate rows in the sheet.
// Returns:
//   void  
func (instance *Cells) RemoveDuplicates()  error {
	
	CGoReturnPtr := C.Cells_RemoveDuplicates( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Removes duplicate values in the range.
// Parameters:
//   startRow - int32 
//   startColumn - int32 
//   endRow - int32 
//   endColumn - int32 
// Returns:
//   void  
func (instance *Cells) RemoveDuplicates_Int_Int_Int_Int(startrow int32, startcolumn int32, endrow int32, endcolumn int32)  error {
	
	CGoReturnPtr := C.Cells_RemoveDuplicates_Integer_Integer_Integer_Integer( instance.ptr, C.int(startrow), C.int(startcolumn), C.int(endrow), C.int(endcolumn))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Removes duplicate data of the range.
// Parameters:
//   startRow - int32 
//   startColumn - int32 
//   endRow - int32 
//   endColumn - int32 
//   hasHeaders - bool 
//   columnOffsets - []int32_t 
// Returns:
//   void  
func (instance *Cells) RemoveDuplicates_Int_Int_Int_Int_Bool_int32Array(startrow int32, startcolumn int32, endrow int32, endcolumn int32, hasheaders bool, columnoffsets []int32)  error {
	
	CGoReturnPtr := C.Cells_RemoveDuplicates_Integer_Integer_Integer_Integer_Boolean_int32_tArray( instance.ptr, C.int(startrow), C.int(startcolumn), C.int(endrow), C.int(endcolumn), C.bool(hasheaders), unsafe.Pointer(&columnoffsets[0]), C.int( len(columnoffsets)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Converts all string data in the worksheet to numeric value if possible.
// Returns:
//   void  
func (instance *Cells) ConvertStringToNumericValue()  error {
	
	CGoReturnPtr := C.Cells_ConvertStringToNumericValue( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Get all cells which refer to the specific cell.
// Parameters:
//   isAll - bool 
//   row - int32 
//   column - int32 
// Returns:
//   []Cell  
func (instance *Cells) GetDependents(isall bool, row int32, column int32)  ([]Cell,  error)  {
	
	CGoReturnPtr := C.Cells_GetDependents( instance.ptr, C.bool(isall), C.int(row), C.int(column))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result:= make([]Cell, CGoReturnPtr.column_length)
	for i := 0; i < int(CGoReturnPtr.column_length); i++ {
	   offset := uintptr(C.size_t(i)) * uintptr(CGoReturnPtr.size)
	   goObject := &Cell{}
	   goObject.ptr =unsafe.Pointer(uintptr( unsafe.Pointer(CGoReturnPtr.return_value)) + offset)
	   result[i] = *goObject
	}
	 

	return result, nil 
}
// Gets all cells whose calculated result depends on specific cell.
// Parameters:
//   row - int32 
//   column - int32 
//   recursive - bool 
// Returns:
//   unsafe.Pointer  
func (instance *Cells) GetDependentsInCalculation(row int32, column int32, recursive bool)  (*CellEnumerator,  error)  {
	
	CGoReturnPtr := C.Cells_GetDependentsInCalculation( instance.ptr, C.int(row), C.int(column), C.bool(recursive))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &CellEnumerator{}
	result.ptr = CGoReturnPtr.return_value
	runtime.SetFinalizer(result, DeleteCellEnumerator)
	 

	return result, nil 
}
// Gets all cells that contain embedded picture.
// Returns:
//   unsafe.Pointer  
func (instance *Cells) GetCellsWithPlaceInCellPicture()  (*CellEnumerator,  error)  {
	
	CGoReturnPtr := C.Cells_GetCellsWithPlaceInCellPicture( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &CellEnumerator{}
	result.ptr = CGoReturnPtr.return_value
	runtime.SetFinalizer(result, DeleteCellEnumerator)
	 

	return result, nil 
}
// Get the style of given cell.
// Parameters:
//   row - int32 
//   column - int32 
// Returns:
//   Style  
func (instance *Cells) GetCellStyle(row int32, column int32)  (*Style,  error)  {
	
	CGoReturnPtr := C.Cells_GetCellStyle( instance.ptr, C.int(row), C.int(column))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Style{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteStyle) 

	return result, nil 
}
// Get the display style of given cell.
// Parameters:
//   row - int32 
//   column - int32 
// Returns:
//   Style  
func (instance *Cells) GetCellDisplayStyle_Int_Int(row int32, column int32)  (*Style,  error)  {
	
	CGoReturnPtr := C.Cells_GetCellDisplayStyle_Integer_Integer( instance.ptr, C.int(row), C.int(column))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Style{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteStyle) 

	return result, nil 
}
// Get the display style of given cell.
// Parameters:
//   row - int32 
//   column - int32 
//   adjacentBorders - int32 
// Returns:
//   Style  
func (instance *Cells) GetCellDisplayStyle_Int_Int_BorderType(row int32, column int32, adjacentborders BorderType)  (*Style,  error)  {
	
	CGoReturnPtr := C.Cells_GetCellDisplayStyle_Integer_Integer_BorderType( instance.ptr, C.int(row), C.int(column), C.int( int32(adjacentborders)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Style{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteStyle) 

	return result, nil 
}



func DeleteCells(cells *Cells){
	runtime.SetFinalizer(cells, nil)
	C.Delete_Cells(cells.ptr)
	cells.ptr = nil
}

// Class CellsColor 

// Represents all types of color.
type CellsColor struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *CellsColor) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.CellsColor_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and set the color which should apply to cell or shape.
// Returns:
//   bool  
func (instance *CellsColor) IsShapeColor()  (bool,  error)  {
	
	CGoReturnPtr := C.CellsColor_IsShapeColor( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and set the color which should apply to cell or shape.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *CellsColor) SetIsShapeColor(value bool)  error {
	
	CGoReturnPtr := C.CellsColor_SetIsShapeColor( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// The color type.
// Returns:
//   int32  
func (instance *CellsColor) GetType()  (ColorType,  error)  {
	
	CGoReturnPtr := C.CellsColor_GetType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToColorType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets the theme color. Only applies for theme color type.
// Returns:
//   ThemeColor  
func (instance *CellsColor) GetThemeColor()  (*ThemeColor,  error)  {
	
	CGoReturnPtr := C.CellsColor_GetThemeColor( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &ThemeColor{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteThemeColor) 

	return result, nil 
}
// Gets the theme color. Only applies for theme color type.
// Parameters:
//   value - ThemeColor 
// Returns:
//   void  
func (instance *CellsColor) SetThemeColor(value *ThemeColor)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.CellsColor_SetThemeColor( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the color index in the color palette. Only applies of indexed color.
// Returns:
//   int32  
func (instance *CellsColor) GetColorIndex()  (int32,  error)  {
	
	CGoReturnPtr := C.CellsColor_GetColorIndex( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the color index in the color palette. Only applies of indexed color.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *CellsColor) SetColorIndex(value int32)  error {
	
	CGoReturnPtr := C.CellsColor_SetColorIndex( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the RGB color.
// Returns:
//   Color  
func (instance *CellsColor) GetColor()  (*Color,  error)  {
	
	CGoReturnPtr := C.CellsColor_GetColor( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Gets and sets the RGB color.
// Parameters:
//   value - Color 
// Returns:
//   void  
func (instance *CellsColor) SetColor(value *Color)  error {
	
	CGoReturnPtr := C.CellsColor_SetColor( instance.ptr, value.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the color from a 32-bit ARGB value.
// Returns:
//   int32  
func (instance *CellsColor) GetArgb()  (int32,  error)  {
	
	CGoReturnPtr := C.CellsColor_GetArgb( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the color from a 32-bit ARGB value.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *CellsColor) SetArgb(value int32)  error {
	
	CGoReturnPtr := C.CellsColor_SetArgb( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets transparency as a value from 0.0 (opaque) through 1.0 (clear).
// Returns:
//   float64  
func (instance *CellsColor) GetTransparency()  (float64,  error)  {
	
	CGoReturnPtr := C.CellsColor_GetTransparency( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := float64(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets transparency as a value from 0.0 (opaque) through 1.0 (clear).
// Parameters:
//   value - float64 
// Returns:
//   void  
func (instance *CellsColor) SetTransparency(value float64)  error {
	
	CGoReturnPtr := C.CellsColor_SetTransparency( instance.ptr, C.double(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Set the tint of the shape color
// Parameters:
//   tint - float64 
// Returns:
//   void  
func (instance *CellsColor) SetTintOfShapeColor(tint float64)  error {
	
	CGoReturnPtr := C.CellsColor_SetTintOfShapeColor( instance.ptr, C.double(tint))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}



func DeleteCellsColor(cellscolor *CellsColor){
	runtime.SetFinalizer(cellscolor, nil)
	C.Delete_CellsColor(cellscolor.ptr)
	cellscolor.ptr = nil
}

// Class CellsFactory 

// Utility for instantiating classes of Cells model.
type CellsFactory struct {
	ptr unsafe.Pointer
}

// Default constructor.
func NewCellsFactory() ( *CellsFactory, error) {
	cellsfactory := &CellsFactory{}
	CGoReturnPtr := C.New_CellsFactory()
	if CGoReturnPtr.error_no == 0 {
		cellsfactory.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(cellsfactory, DeleteCellsFactory)
		return cellsfactory, nil
	} else {
		cellsfactory.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return cellsfactory, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *CellsFactory) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.CellsFactory_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Creates a new style.
// Returns:
//   Style  
func (instance *CellsFactory) CreateStyle()  (*Style,  error)  {
	
	CGoReturnPtr := C.CellsFactory_CreateStyle( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Style{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteStyle) 

	return result, nil 
}



func DeleteCellsFactory(cellsfactory *CellsFactory){
	runtime.SetFinalizer(cellsfactory, nil)
	C.Delete_CellsFactory(cellsfactory.ptr)
	cellsfactory.ptr = nil
}

// Class CellsHelper 

// Provides helper functions.
type CellsHelper struct {
	ptr unsafe.Pointer
}


// Gets and sets the number of significant digits.
// The default value is 17.
// Returns:
//   int32  
func CellsHelper_GetSignificantDigits()  (int32,  error)  {
	
	CGoReturnPtr := C.CellsHelper_GetSignificantDigits()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the number of significant digits.
// The default value is 17.
// Parameters:
//   value - int32 
// Returns:
//   void  
func CellsHelper_SetSignificantDigits(value int32)  error {
	
	CGoReturnPtr := C.CellsHelper_SetSignificantDigits(C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the DPI of the machine.
// Returns:
//   float64  
func CellsHelper_GetDPI()  (float64,  error)  {
	
	CGoReturnPtr := C.CellsHelper_GetDPI()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := float64(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the DPI of the machine.
// Parameters:
//   value - float64 
// Returns:
//   void  
func CellsHelper_SetDPI(value float64)  error {
	
	CGoReturnPtr := C.CellsHelper_SetDPI(C.double(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Get width of text in unit of points.
// Parameters:
//   text - string 
//   font - Font 
//   scaling - float64 
// Returns:
//   float64  
func CellsHelper_GetTextWidth(text string, font *Font, scaling float64)  (float64,  error)  {
	
	var font_ptr unsafe.Pointer = nil
	if font != nil {
	  font_ptr =font.ptr
	}

	CGoReturnPtr := C.CellsHelper_GetTextWidth(C.CString(text), font_ptr, C.double(scaling))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := float64(CGoReturnPtr.return_value) 

	return result, nil 
}
// Get the release version.
// Returns:
//   string  
func CellsHelper_GetVersion()  (string,  error)  {
	
	CGoReturnPtr := C.CellsHelper_GetVersion()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the cell row and column indexes according to its name.
// Parameters:
//   cellName - string 
//   row - int32 
//   column - int32 
// Returns:
//   void  
func CellsHelper_CellNameToIndex(cellname string)  (int32, int32,  error)  {
	var row int32
	crow := (*C.int)(unsafe.Pointer(&row))
	var column int32
	ccolumn := (*C.int)(unsafe.Pointer(&column))
	
	CGoReturnPtr := C.CellsHelper_CellNameToIndex(C.CString(cellname), (crow), (ccolumn))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, 0, err
	}
	 

	return row, column, nil 
}
// Gets cell name according to its row and column indexes.
// Parameters:
//   row - int32 
//   column - int32 
// Returns:
//   string  
func CellsHelper_CellIndexToName(row int32, column int32)  (string,  error)  {
	
	CGoReturnPtr := C.CellsHelper_CellIndexToName(C.int(row), C.int(column))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets column name according to column index.
// Parameters:
//   column - int32 
// Returns:
//   string  
func CellsHelper_ColumnIndexToName(column int32)  (string,  error)  {
	
	CGoReturnPtr := C.CellsHelper_ColumnIndexToName(C.int(column))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets column index according to column name.
// Parameters:
//   columnName - string 
// Returns:
//   int32  
func CellsHelper_ColumnNameToIndex(columnname string)  (int32,  error)  {
	
	CGoReturnPtr := C.CellsHelper_ColumnNameToIndex(C.CString(columnname))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets row name according to row index.
// Parameters:
//   row - int32 
// Returns:
//   string  
func CellsHelper_RowIndexToName(row int32)  (string,  error)  {
	
	CGoReturnPtr := C.CellsHelper_RowIndexToName(C.int(row))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets row index according to row name.
// Parameters:
//   rowName - string 
// Returns:
//   int32  
func CellsHelper_RowNameToIndex(rowname string)  (int32,  error)  {
	
	CGoReturnPtr := C.CellsHelper_RowNameToIndex(C.CString(rowname))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Convert the double value to the date time value.
// Parameters:
//   doubleValue - float64 
//   date1904 - bool 
// Returns:
//   Date  
func CellsHelper_GetDateTimeFromDouble(doublevalue float64, date1904 bool)  (time.Time,  error)  {
	
	CGoReturnPtr := C.CellsHelper_GetDateTimeFromDouble(C.double(doublevalue), C.bool(date1904))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  time.Unix(0, 0), err
	}
	result := time.Date(int( C.Date_Get_year(CGoReturnPtr.return_value).return_value ),time.Month(int( C.Date_Get_month(CGoReturnPtr.return_value).return_value)),int( C.Date_Get_day(CGoReturnPtr.return_value).return_value),int(  C.Date_Get_hour(CGoReturnPtr.return_value).return_value),int( C.Date_Get_minute(CGoReturnPtr.return_value).return_value),int(  C.Date_Get_second(CGoReturnPtr.return_value).return_value), 0, time.UTC) 

	return result, nil 
}
// Convert the date time to double value.
// Parameters:
//   dateTime - Date 
//   date1904 - bool 
// Returns:
//   float64  
func CellsHelper_GetDoubleFromDateTime(datetime time.Time, date1904 bool)  (float64,  error)  {
	
	time_datetime := C.Get_Date( C.int(datetime.Year()), C.int(datetime.Month()) , C.int(datetime.Day()) , C.int(datetime.Hour()) , C.int(datetime.Minute()) , C.int(datetime.Second())  )

	CGoReturnPtr := C.CellsHelper_GetDoubleFromDateTime(time_datetime, C.bool(date1904))
	C.Delete_GetDate( time_datetime)

	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := float64(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets the startup path, which is referred to by some external formula references.
// Returns:
//   string  
func CellsHelper_GetStartupPath()  (string,  error)  {
	
	CGoReturnPtr := C.CellsHelper_GetStartupPath()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets the startup path, which is referred to by some external formula references.
// Parameters:
//   value - string 
// Returns:
//   void  
func CellsHelper_SetStartupPath(value string)  error {
	
	CGoReturnPtr := C.CellsHelper_SetStartupPath(C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the alternate startup path, which is referred to by some external formula references.
// Returns:
//   string  
func CellsHelper_GetAltStartPath()  (string,  error)  {
	
	CGoReturnPtr := C.CellsHelper_GetAltStartPath()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets the alternate startup path, which is referred to by some external formula references.
// Parameters:
//   value - string 
// Returns:
//   void  
func CellsHelper_SetAltStartPath(value string)  error {
	
	CGoReturnPtr := C.CellsHelper_SetAltStartPath(C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the library path which is referred to by some external formula references.
// Returns:
//   string  
func CellsHelper_GetLibraryPath()  (string,  error)  {
	
	CGoReturnPtr := C.CellsHelper_GetLibraryPath()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets the library path which is referred to by some external formula references.
// Parameters:
//   value - string 
// Returns:
//   void  
func CellsHelper_SetLibraryPath(value string)  error {
	
	CGoReturnPtr := C.CellsHelper_SetLibraryPath(C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets all used colors in the workbook.
// Parameters:
//   workbook - Workbook 
// Returns:
//   []Color  
func CellsHelper_GetUsedColors(workbook *Workbook)  ([]Color,  error)  {
	
	var workbook_ptr unsafe.Pointer = nil
	if workbook != nil {
	  workbook_ptr =workbook.ptr
	}

	CGoReturnPtr := C.CellsHelper_GetUsedColors(workbook_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result:= make([]Color, CGoReturnPtr.column_length)
	for i := 0; i < int(CGoReturnPtr.column_length); i++ {
	   offset := uintptr(C.size_t(i)) * uintptr(CGoReturnPtr.size)
	   goObject := &Color{}
	   goObject.ptr =unsafe.Pointer(uintptr( unsafe.Pointer(CGoReturnPtr.return_value)) + offset)
	   result[i] = *goObject
	}
	 

	return result, nil 
}
// Merges some large xls files to a xls file.
// Parameters:
//   files - []string 
//   cachedFile - string 
//   destFile - string 
// Returns:
//   void  
func CellsHelper_MergeFiles(files []string, cachedfile string, destfile string)  error {
	
	vector_files := make([]*C.char, len(files))
	for i, str := range files {
	cStr := C.CString(str)
	defer C.free(unsafe.Pointer(cStr))
	vector_files[i] = cStr
	}

	CGoReturnPtr := C.CellsHelper_MergeFiles(unsafe.Pointer(&vector_files[0]), C.int( len(files)), C.CString(cachedfile), C.CString(destfile))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Checks given sheet name and create a valid one when needed.
// If given sheet name conforms to the rules of excel sheet name, then return it.
// Otherwise string will be truncated if length exceeds the limit
// and invalid characters will be replaced with ' ', then return the rebuilt string value.
// Parameters:
//   nameProposal - string 
// Returns:
//   string  
func CellsHelper_CreateSafeSheetName_String(nameproposal string)  (string,  error)  {
	
	CGoReturnPtr := C.CellsHelper_CreateSafeSheetName_String(C.CString(nameproposal))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Checks given sheet name and create a valid one when needed.
// If given sheet name conforms to the rules of excel sheet name, then return it.
// Otherwise string will be truncated if length exceeds the limit
// and invalid characters will be replaced with given character, then return the rebuilt string value.
// Parameters:
//   nameProposal - string 
//   replaceChar - byte 
// Returns:
//   string  
func CellsHelper_CreateSafeSheetName_String_Char(nameproposal string, replacechar byte)  (string,  error)  {
	
	CGoReturnPtr := C.CellsHelper_CreateSafeSheetName_String_Char(C.CString(nameproposal), C.char(replacechar))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether the name of the sheet should be enclosed in single quotes
// Parameters:
//   sheetName - string 
// Returns:
//   bool  
func CellsHelper_NeedQuoteInFormula(sheetname string)  (bool,  error)  {
	
	CGoReturnPtr := C.CellsHelper_NeedQuoteInFormula(C.CString(sheetname))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Please set this property True when running on a cloud platform, such as: Azure, AWSLambda, etc,
// Returns:
//   bool  
func CellsHelper_IsCloudPlatform()  (bool,  error)  {
	
	CGoReturnPtr := C.CellsHelper_IsCloudPlatform()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Please set this property True when running on a cloud platform, such as: Azure, AWSLambda, etc,
// Parameters:
//   value - bool 
// Returns:
//   void  
func CellsHelper_SetIsCloudPlatform(value bool)  error {
	
	CGoReturnPtr := C.CellsHelper_SetIsCloudPlatform(C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}



func DeleteCellsHelper(cellshelper *CellsHelper){
	runtime.SetFinalizer(cellshelper, nil)
	C.Delete_CellsHelper(cellshelper.ptr)
	cellshelper.ptr = nil
}

// Class CellValue 

// Represents the cell value and corresponding type.
type CellValue struct {
	ptr unsafe.Pointer
}

// Default constructor.
func NewCellValue() ( *CellValue, error) {
	cellvalue := &CellValue{}
	CGoReturnPtr := C.New_CellValue()
	if CGoReturnPtr.error_no == 0 {
		cellvalue.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(cellvalue, DeleteCellValue)
		return cellvalue, nil
	} else {
		cellvalue.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return cellvalue, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *CellValue) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.CellValue_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets/sets the type of cell value.
// Returns:
//   int32  
func (instance *CellValue) GetType()  (CellValueType,  error)  {
	
	CGoReturnPtr := C.CellValue_GetType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToCellValueType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets/sets the type of cell value.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *CellValue) SetType(value CellValueType)  error {
	
	CGoReturnPtr := C.CellValue_SetType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets/sets the cell value.
// Returns:
//   Object  
func (instance *CellValue) GetValue()  (*Object,  error)  {
	
	CGoReturnPtr := C.CellValue_GetValue( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Object{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteObject) 

	return result, nil 
}
// Gets/sets the cell value.
// Parameters:
//   value - Object 
// Returns:
//   void  
func (instance *CellValue) SetValue(value *Object)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.CellValue_SetValue( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}



func DeleteCellValue(cellvalue *CellValue){
	runtime.SetFinalizer(cellvalue, nil)
	C.Delete_CellValue(cellvalue.ptr)
	cellvalue.ptr = nil
}

// Class CellWatch 

// Represents Cell Watch Item in the 'watch window'.
type CellWatch struct {
	ptr unsafe.Pointer
}

// Default constructor.
func NewCellWatch() ( *CellWatch, error) {
	cellwatch := &CellWatch{}
	CGoReturnPtr := C.New_CellWatch()
	if CGoReturnPtr.error_no == 0 {
		cellwatch.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(cellwatch, DeleteCellWatch)
		return cellwatch, nil
	} else {
		cellwatch.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return cellwatch, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *CellWatch) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.CellWatch_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the row of the cell.
// Returns:
//   int32  
func (instance *CellWatch) GetRow()  (int32,  error)  {
	
	CGoReturnPtr := C.CellWatch_GetRow( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the row of the cell.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *CellWatch) SetRow(value int32)  error {
	
	CGoReturnPtr := C.CellWatch_SetRow( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the column of the cell.
// Returns:
//   int32  
func (instance *CellWatch) GetColumn()  (int32,  error)  {
	
	CGoReturnPtr := C.CellWatch_GetColumn( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the column of the cell.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *CellWatch) SetColumn(value int32)  error {
	
	CGoReturnPtr := C.CellWatch_SetColumn( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the name of the cell.
// Returns:
//   string  
func (instance *CellWatch) GetCellName()  (string,  error)  {
	
	CGoReturnPtr := C.CellWatch_GetCellName( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the name of the cell.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *CellWatch) SetCellName(value string)  error {
	
	CGoReturnPtr := C.CellWatch_SetCellName( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}



func DeleteCellWatch(cellwatch *CellWatch){
	runtime.SetFinalizer(cellwatch, nil)
	C.Delete_CellWatch(cellwatch.ptr)
	cellwatch.ptr = nil
}

// Class CellWatchCollection 

// Represents the collection of cells on this worksheet being watched in the 'watch window'.
type CellWatchCollection struct {
	ptr unsafe.Pointer
}

// Default constructor.
func NewCellWatchCollection() ( *CellWatchCollection, error) {
	cellwatchcollection := &CellWatchCollection{}
	CGoReturnPtr := C.New_CellWatchCollection()
	if CGoReturnPtr.error_no == 0 {
		cellwatchcollection.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(cellwatchcollection, DeleteCellWatchCollection)
		return cellwatchcollection, nil
	} else {
		cellwatchcollection.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return cellwatchcollection, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *CellWatchCollection) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.CellWatchCollection_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Adds <see cref="CellWatch"/> with row and column.
// Parameters:
//   row - int32 
//   column - int32 
// Returns:
//   int32  
func (instance *CellWatchCollection) Add_Int_Int(row int32, column int32)  (int32,  error)  {
	
	CGoReturnPtr := C.CellWatchCollection_Add_Integer_Integer( instance.ptr, C.int(row), C.int(column))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Adds <see cref="CellWatch"/> with the name the of cell.
// Parameters:
//   cellName - string 
// Returns:
//   int32  
func (instance *CellWatchCollection) Add_String(cellname string)  (int32,  error)  {
	
	CGoReturnPtr := C.CellWatchCollection_Add_String( instance.ptr, C.CString(cellname))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets <see cref="CellWatch"/> by index.
// Parameters:
//   index - int32 
// Returns:
//   CellWatch  
func (instance *CellWatchCollection) Get_Int(index int32)  (*CellWatch,  error)  {
	
	CGoReturnPtr := C.CellWatchCollection_Get_Integer( instance.ptr, C.int(index))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &CellWatch{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteCellWatch) 

	return result, nil 
}
// Gets and sets <see cref="CellWatch"/> by the name of the cell.
// Parameters:
//   cellName - string 
// Returns:
//   CellWatch  
func (instance *CellWatchCollection) Get_String(cellname string)  (*CellWatch,  error)  {
	
	CGoReturnPtr := C.CellWatchCollection_Get_String( instance.ptr, C.CString(cellname))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &CellWatch{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteCellWatch) 

	return result, nil 
}
// Returns:
//   int32  
func (instance *CellWatchCollection) GetCount()  (int32,  error)  {
	
	CGoReturnPtr := C.CellWatchCollection_GetCount( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}



func DeleteCellWatchCollection(cellwatchcollection *CellWatchCollection){
	runtime.SetFinalizer(cellwatchcollection, nil)
	C.Delete_CellWatchCollection(cellwatchcollection.ptr)
	cellwatchcollection.ptr = nil
}

// Class ColorFilter 

// Represents filtering the range by color.
type ColorFilter struct {
	ptr unsafe.Pointer
}

// Constructs from an Object convertible to this.
// Parameters:
//   obj - Object 
func NewColorFilter(obj *Object) ( *ColorFilter, error) {
	colorfilter := &ColorFilter{}
	var obj_ptr unsafe.Pointer = nil
	if obj != nil {
	  obj_ptr =obj.ptr
	}

	CGoReturnPtr := C.New_ColorFilter(obj_ptr)
	if CGoReturnPtr.error_no == 0 {
		colorfilter.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(colorfilter, DeleteColorFilter)
		return colorfilter, nil
	} else {
		colorfilter.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return colorfilter, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *ColorFilter) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.ColorFilter_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the Object.
// Returns:
//   Object  
func (instance *ColorFilter) ToObject()  (*Object,  error)  {
	
	CGoReturnPtr := C.ColorFilter_ToObject( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Object{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteObject) 

	return result, nil 
}
// Whether filter by the cell's fill color.
// Returns:
//   bool  
func (instance *ColorFilter) GetFilterByFillColor()  (bool,  error)  {
	
	CGoReturnPtr := C.ColorFilter_GetFilterByFillColor( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Whether filter by the cell's fill color.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *ColorFilter) SetFilterByFillColor(value bool)  error {
	
	CGoReturnPtr := C.ColorFilter_SetFilterByFillColor( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the color of this filter.
// Parameters:
//   sheets - WorksheetCollection 
// Returns:
//   Color  
func (instance *ColorFilter) GetColor(sheets *WorksheetCollection)  (*Color,  error)  {
	
	var sheets_ptr unsafe.Pointer = nil
	if sheets != nil {
	  sheets_ptr =sheets.ptr
	}

	CGoReturnPtr := C.ColorFilter_GetColor( instance.ptr, sheets_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}



func DeleteColorFilter(colorfilter *ColorFilter){
	runtime.SetFinalizer(colorfilter, nil)
	C.Delete_ColorFilter(colorfilter.ptr)
	colorfilter.ptr = nil
}

// Class ColorScale 

// Describe the ColorScale conditional formatting rule.
// This conditional formatting rule creates a gradated color scale on the cells.
type ColorScale struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *ColorScale) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.ColorScale_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether conditional formatting is 3 color scale.
// Returns:
//   bool  
func (instance *ColorScale) GetIs3ColorScale()  (bool,  error)  {
	
	CGoReturnPtr := C.ColorScale_GetIs3ColorScale( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether conditional formatting is 3 color scale.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *ColorScale) SetIs3ColorScale(value bool)  error {
	
	CGoReturnPtr := C.ColorScale_SetIs3ColorScale( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Get or set this ColorScale's min value object.
// Cannot set null or CFValueObject with type FormatConditionValueType.Max to it.
// Returns:
//   ConditionalFormattingValue  
func (instance *ColorScale) GetMinCfvo()  (*ConditionalFormattingValue,  error)  {
	
	CGoReturnPtr := C.ColorScale_GetMinCfvo( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &ConditionalFormattingValue{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteConditionalFormattingValue) 

	return result, nil 
}
// Get or set this ColorScale's mid value object.
// Cannot set CFValueObject with type FormatConditionValueType.Max or FormatConditionValueType.Min to it.
// Returns:
//   ConditionalFormattingValue  
func (instance *ColorScale) GetMidCfvo()  (*ConditionalFormattingValue,  error)  {
	
	CGoReturnPtr := C.ColorScale_GetMidCfvo( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &ConditionalFormattingValue{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteConditionalFormattingValue) 

	return result, nil 
}
// Get or set this ColorScale's max value object.
// Cannot set null or CFValueObject with type FormatConditionValueType.Min to it.
// Returns:
//   ConditionalFormattingValue  
func (instance *ColorScale) GetMaxCfvo()  (*ConditionalFormattingValue,  error)  {
	
	CGoReturnPtr := C.ColorScale_GetMaxCfvo( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &ConditionalFormattingValue{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteConditionalFormattingValue) 

	return result, nil 
}
// Get or set the gradient color for the minimum value in the range.
// Returns:
//   Color  
func (instance *ColorScale) GetMinColor()  (*Color,  error)  {
	
	CGoReturnPtr := C.ColorScale_GetMinColor( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Get or set the gradient color for the minimum value in the range.
// Parameters:
//   value - Color 
// Returns:
//   void  
func (instance *ColorScale) SetMinColor(value *Color)  error {
	
	CGoReturnPtr := C.ColorScale_SetMinColor( instance.ptr, value.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Get or set the gradient color for the middle value in the range.
// Returns:
//   Color  
func (instance *ColorScale) GetMidColor()  (*Color,  error)  {
	
	CGoReturnPtr := C.ColorScale_GetMidColor( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Get or set the gradient color for the middle value in the range.
// Parameters:
//   value - Color 
// Returns:
//   void  
func (instance *ColorScale) SetMidColor(value *Color)  error {
	
	CGoReturnPtr := C.ColorScale_SetMidColor( instance.ptr, value.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Get or set the gradient color for the maximum value in the range.
// Returns:
//   Color  
func (instance *ColorScale) GetMaxColor()  (*Color,  error)  {
	
	CGoReturnPtr := C.ColorScale_GetMaxColor( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Get or set the gradient color for the maximum value in the range.
// Parameters:
//   value - Color 
// Returns:
//   void  
func (instance *ColorScale) SetMaxColor(value *Color)  error {
	
	CGoReturnPtr := C.ColorScale_SetMaxColor( instance.ptr, value.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}



func DeleteColorScale(colorscale *ColorScale){
	runtime.SetFinalizer(colorscale, nil)
	C.Delete_ColorScale(colorscale.ptr)
	colorscale.ptr = nil
}

// Class Column 

// Represents a single column in a worksheet.
type Column struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *Column) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.Column_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the index of this column.
// Returns:
//   int32  
func (instance *Column) GetIndex()  (int32,  error)  {
	
	CGoReturnPtr := C.Column_GetIndex( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the column width in unit of characters.
// Returns:
//   float64  
func (instance *Column) GetWidth()  (float64,  error)  {
	
	CGoReturnPtr := C.Column_GetWidth( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := float64(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the column width in unit of characters.
// Parameters:
//   value - float64 
// Returns:
//   void  
func (instance *Column) SetWidth(value float64)  error {
	
	CGoReturnPtr := C.Column_SetWidth( instance.ptr, C.double(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the group level of the column.
// Returns:
//   byte  
func (instance *Column) GetGroupLevel()  (byte,  error)  {
	
	CGoReturnPtr := C.Column_GetGroupLevel( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := byte(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the group level of the column.
// Parameters:
//   value - byte 
// Returns:
//   void  
func (instance *Column) SetGroupLevel(value byte)  error {
	
	CGoReturnPtr := C.Column_SetGroupLevel( instance.ptr, C.uint8_t(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether the column is hidden.
// Returns:
//   bool  
func (instance *Column) IsHidden()  (bool,  error)  {
	
	CGoReturnPtr := C.Column_IsHidden( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether the column is hidden.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Column) SetIsHidden(value bool)  error {
	
	CGoReturnPtr := C.Column_SetIsHidden( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether this column has custom style settings(different from the default one inherited from workbook).
// Returns:
//   bool  
func (instance *Column) GetHasCustomStyle()  (bool,  error)  {
	
	CGoReturnPtr := C.Column_GetHasCustomStyle( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Applies formats for a whole column.
// Parameters:
//   style - Style 
//   flag - StyleFlag 
// Returns:
//   void  
func (instance *Column) ApplyStyle(style *Style, flag *StyleFlag)  error {
	
	var style_ptr unsafe.Pointer = nil
	if style != nil {
	  style_ptr =style.ptr
	}
	var flag_ptr unsafe.Pointer = nil
	if flag != nil {
	  flag_ptr =flag.ptr
	}

	CGoReturnPtr := C.Column_ApplyStyle( instance.ptr, style_ptr, flag_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the style of this column.
// Returns:
//   Style  
func (instance *Column) GetStyle()  (*Style,  error)  {
	
	CGoReturnPtr := C.Column_GetStyle( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Style{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteStyle) 

	return result, nil 
}
// Sets the style of this column.
// Parameters:
//   style - Style 
// Returns:
//   void  
func (instance *Column) SetStyle(style *Style)  error {
	
	var style_ptr unsafe.Pointer = nil
	if style != nil {
	  style_ptr =style.ptr
	}

	CGoReturnPtr := C.Column_SetStyle( instance.ptr, style_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// whether the column is collapsed
// Returns:
//   bool  
func (instance *Column) IsCollapsed()  (bool,  error)  {
	
	CGoReturnPtr := C.Column_IsCollapsed( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// whether the column is collapsed
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Column) SetIsCollapsed(value bool)  error {
	
	CGoReturnPtr := C.Column_SetIsCollapsed( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}



func DeleteColumn(column *Column){
	runtime.SetFinalizer(column, nil)
	C.Delete_Column(column.ptr)
	column.ptr = nil
}

// Class ColumnCollection 

// Collection of the <see cref="Column"/> objects that represent the individual column(setting)s in a worksheet.
// The Column object only represents the settings such as column width, styles, .etc. for the whole column,
// has nothing to do with the fact that there are non-empty cells(data) or not in corresponding column.
// And the "Count" of this collection only represents the count Column objects that have been instantiated in this collection,
// has nothing to do with the fact that there are non-empty cells(data) or not in the worksheet.
type ColumnCollection struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *ColumnCollection) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.ColumnCollection_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the <see cref="Column"/> object by the position in the list.
// Parameters:
//   index - int32 
// Returns:
//   Column  
func (instance *ColumnCollection) GetColumnByIndex(index int32)  (*Column,  error)  {
	
	CGoReturnPtr := C.ColumnCollection_GetColumnByIndex( instance.ptr, C.int(index))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Column{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteColumn) 

	return result, nil 
}
// Gets a <see cref="Column"/> object by column index.
// The Column object of given column index will be instantiated if it does not exist before.
// Parameters:
//   columnIndex - int32 
// Returns:
//   Column  
func (instance *ColumnCollection) Get(columnindex int32)  (*Column,  error)  {
	
	CGoReturnPtr := C.ColumnCollection_Get( instance.ptr, C.int(columnindex))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Column{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteColumn) 

	return result, nil 
}
// Returns:
//   int32  
func (instance *ColumnCollection) GetCount()  (int32,  error)  {
	
	CGoReturnPtr := C.ColumnCollection_GetCount( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}



func DeleteColumnCollection(columncollection *ColumnCollection){
	runtime.SetFinalizer(columncollection, nil)
	C.Delete_ColumnCollection(columncollection.ptr)
	columncollection.ptr = nil
}

// Class Comment 

// Encapsulates the object that represents a cell comment.
type Comment struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *Comment) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.Comment_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets Name of the original comment author
// Returns:
//   string  
func (instance *Comment) GetAuthor()  (string,  error)  {
	
	CGoReturnPtr := C.Comment_GetAuthor( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets Name of the original comment author
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *Comment) SetAuthor(value string)  error {
	
	CGoReturnPtr := C.Comment_SetAuthor( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Get a Shape object that represents the shape attached to the specified comment.
// Returns:
//   CommentShape  
func (instance *Comment) GetCommentShape()  (*CommentShape,  error)  {
	
	CGoReturnPtr := C.Comment_GetCommentShape( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &CommentShape{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteCommentShape) 

	return result, nil 
}
// Gets the row index of the comment.
// Returns:
//   int32  
func (instance *Comment) GetRow()  (int32,  error)  {
	
	CGoReturnPtr := C.Comment_GetRow( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the column index of the comment.
// Returns:
//   int32  
func (instance *Comment) GetColumn()  (int32,  error)  {
	
	CGoReturnPtr := C.Comment_GetColumn( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether this comment is a threaded comment.
// Returns:
//   bool  
func (instance *Comment) IsThreadedComment()  (bool,  error)  {
	
	CGoReturnPtr := C.Comment_IsThreadedComment( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the list of threaded comments;
// Returns:
//   ThreadedCommentCollection  
func (instance *Comment) GetThreadedComments()  (*ThreadedCommentCollection,  error)  {
	
	CGoReturnPtr := C.Comment_GetThreadedComments( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &ThreadedCommentCollection{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteThreadedCommentCollection) 

	return result, nil 
}
// Represents the content of comment.
// Returns:
//   string  
func (instance *Comment) GetNote()  (string,  error)  {
	
	CGoReturnPtr := C.Comment_GetNote( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents the content of comment.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *Comment) SetNote(value string)  error {
	
	CGoReturnPtr := C.Comment_SetNote( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the html string which contains data and some formats in this comment.
// Returns:
//   string  
func (instance *Comment) GetHtmlNote()  (string,  error)  {
	
	CGoReturnPtr := C.Comment_GetHtmlNote( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the html string which contains data and some formats in this comment.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *Comment) SetHtmlNote(value string)  error {
	
	CGoReturnPtr := C.Comment_SetHtmlNote( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the font of comment.
// Returns:
//   Font  
func (instance *Comment) GetFont()  (*Font,  error)  {
	
	CGoReturnPtr := C.Comment_GetFont( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Font{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteFont) 

	return result, nil 
}
// Format some characters with the font setting.
// Parameters:
//   startIndex - int32 
//   length - int32 
//   font - Font 
//   flag - StyleFlag 
// Returns:
//   void  
func (instance *Comment) FormatCharacters(startindex int32, length int32, font *Font, flag *StyleFlag)  error {
	
	var font_ptr unsafe.Pointer = nil
	if font != nil {
	  font_ptr =font.ptr
	}
	var flag_ptr unsafe.Pointer = nil
	if flag != nil {
	  flag_ptr =flag.ptr
	}

	CGoReturnPtr := C.Comment_FormatCharacters( instance.ptr, C.int(startindex), C.int(length), font_ptr, flag_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Returns a Characters object that represents a range of characters within the comment text.
// Parameters:
//   startIndex - int32 
//   length - int32 
// Returns:
//   FontSetting  
func (instance *Comment) Characters(startindex int32, length int32)  (*FontSetting,  error)  {
	
	CGoReturnPtr := C.Comment_Characters( instance.ptr, C.int(startindex), C.int(length))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &FontSetting{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteFontSetting) 

	return result, nil 
}
// Returns all Characters objects
// that represents a range of characters within the comment text.
// Returns:
//   []FontSetting  
func (instance *Comment) GetRichFormattings()  ([]FontSetting,  error)  {
	
	CGoReturnPtr := C.Comment_GetRichFormattings( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result:= make([]FontSetting, CGoReturnPtr.column_length)
	for i := 0; i < int(CGoReturnPtr.column_length); i++ {
	   offset := uintptr(C.size_t(i)) * uintptr(CGoReturnPtr.size)
	   goObject := &FontSetting{}
	   goObject.ptr =unsafe.Pointer(uintptr( unsafe.Pointer(CGoReturnPtr.return_value)) + offset)
	   result[i] = *goObject
	}
	 

	return result, nil 
}
// Represents if the comment is visible or not.
// Returns:
//   bool  
func (instance *Comment) IsVisible()  (bool,  error)  {
	
	CGoReturnPtr := C.Comment_IsVisible( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents if the comment is visible or not.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Comment) SetIsVisible(value bool)  error {
	
	CGoReturnPtr := C.Comment_SetIsVisible( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the text orientation type of the comment.
// Returns:
//   int32  
func (instance *Comment) GetTextOrientationType()  (TextOrientationType,  error)  {
	
	CGoReturnPtr := C.Comment_GetTextOrientationType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToTextOrientationType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets and sets the text orientation type of the comment.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *Comment) SetTextOrientationType(value TextOrientationType)  error {
	
	CGoReturnPtr := C.Comment_SetTextOrientationType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the text horizontal alignment type of the comment.
// Returns:
//   int32  
func (instance *Comment) GetTextHorizontalAlignment()  (TextAlignmentType,  error)  {
	
	CGoReturnPtr := C.Comment_GetTextHorizontalAlignment( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToTextAlignmentType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets and sets the text horizontal alignment type of the comment.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *Comment) SetTextHorizontalAlignment(value TextAlignmentType)  error {
	
	CGoReturnPtr := C.Comment_SetTextHorizontalAlignment( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the text vertical alignment type of the comment.
// Returns:
//   int32  
func (instance *Comment) GetTextVerticalAlignment()  (TextAlignmentType,  error)  {
	
	CGoReturnPtr := C.Comment_GetTextVerticalAlignment( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToTextAlignmentType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets and sets the text vertical alignment type of the comment.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *Comment) SetTextVerticalAlignment(value TextAlignmentType)  error {
	
	CGoReturnPtr := C.Comment_SetTextVerticalAlignment( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates if size of comment is adjusted automatically according to its content.
// Note: In some special cases (such as Mac environment), this setting may not take effect. If this setting does not take effect, please replace it with FitToTextSize().
// Returns:
//   bool  
func (instance *Comment) GetAutoSize()  (bool,  error)  {
	
	CGoReturnPtr := C.Comment_GetAutoSize( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates if size of comment is adjusted automatically according to its content.
// Note: In some special cases (such as Mac environment), this setting may not take effect. If this setting does not take effect, please replace it with FitToTextSize().
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Comment) SetAutoSize(value bool)  error {
	
	CGoReturnPtr := C.Comment_SetAutoSize( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents the height of the comment, in unit of centimeters.
// Returns:
//   float64  
func (instance *Comment) GetHeightCM()  (float64,  error)  {
	
	CGoReturnPtr := C.Comment_GetHeightCM( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := float64(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents the height of the comment, in unit of centimeters.
// Parameters:
//   value - float64 
// Returns:
//   void  
func (instance *Comment) SetHeightCM(value float64)  error {
	
	CGoReturnPtr := C.Comment_SetHeightCM( instance.ptr, C.double(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents the width of the comment, in unit of centimeters.
// Returns:
//   float64  
func (instance *Comment) GetWidthCM()  (float64,  error)  {
	
	CGoReturnPtr := C.Comment_GetWidthCM( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := float64(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents the width of the comment, in unit of centimeters.
// Parameters:
//   value - float64 
// Returns:
//   void  
func (instance *Comment) SetWidthCM(value float64)  error {
	
	CGoReturnPtr := C.Comment_SetWidthCM( instance.ptr, C.double(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents the width of the comment, in unit of pixels.
// Returns:
//   int32  
func (instance *Comment) GetWidth()  (int32,  error)  {
	
	CGoReturnPtr := C.Comment_GetWidth( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents the width of the comment, in unit of pixels.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *Comment) SetWidth(value int32)  error {
	
	CGoReturnPtr := C.Comment_SetWidth( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents the Height of the comment, in unit of pixels.
// Returns:
//   int32  
func (instance *Comment) GetHeight()  (int32,  error)  {
	
	CGoReturnPtr := C.Comment_GetHeight( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents the Height of the comment, in unit of pixels.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *Comment) SetHeight(value int32)  error {
	
	CGoReturnPtr := C.Comment_SetHeight( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents the width of the comment, in unit of inches.
// Returns:
//   float64  
func (instance *Comment) GetWidthInch()  (float64,  error)  {
	
	CGoReturnPtr := C.Comment_GetWidthInch( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := float64(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents the width of the comment, in unit of inches.
// Parameters:
//   value - float64 
// Returns:
//   void  
func (instance *Comment) SetWidthInch(value float64)  error {
	
	CGoReturnPtr := C.Comment_SetWidthInch( instance.ptr, C.double(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents the height of the comment, in unit of inches.
// Returns:
//   float64  
func (instance *Comment) GetHeightInch()  (float64,  error)  {
	
	CGoReturnPtr := C.Comment_GetHeightInch( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := float64(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents the height of the comment, in unit of inches.
// Parameters:
//   value - float64 
// Returns:
//   void  
func (instance *Comment) SetHeightInch(value float64)  error {
	
	CGoReturnPtr := C.Comment_SetHeightInch( instance.ptr, C.double(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}



func DeleteComment(comment *Comment){
	runtime.SetFinalizer(comment, nil)
	C.Delete_Comment(comment.ptr)
	comment.ptr = nil
}

// Class CommentCollection 

// Encapsulates a collection of <see cref="Comment"/> objects.
type CommentCollection struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *CommentCollection) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.CommentCollection_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Adds a threaded comment.
// Parameters:
//   row - int32 
//   column - int32 
//   text - string 
//   author - ThreadedCommentAuthor 
// Returns:
//   int32  
func (instance *CommentCollection) AddThreadedComment_Int_Int_String_ThreadedCommentAuthor(row int32, column int32, text string, author *ThreadedCommentAuthor)  (int32,  error)  {
	
	var author_ptr unsafe.Pointer = nil
	if author != nil {
	  author_ptr =author.ptr
	}

	CGoReturnPtr := C.CommentCollection_AddThreadedComment_Integer_Integer_String_ThreadedCommentAuthor( instance.ptr, C.int(row), C.int(column), C.CString(text), author_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Adds a threaded comment.
// Parameters:
//   cellName - string 
//   text - string 
//   author - ThreadedCommentAuthor 
// Returns:
//   int32  
func (instance *CommentCollection) AddThreadedComment_String_String_ThreadedCommentAuthor(cellname string, text string, author *ThreadedCommentAuthor)  (int32,  error)  {
	
	var author_ptr unsafe.Pointer = nil
	if author != nil {
	  author_ptr =author.ptr
	}

	CGoReturnPtr := C.CommentCollection_AddThreadedComment_String_String_ThreadedCommentAuthor( instance.ptr, C.CString(cellname), C.CString(text), author_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the threaded comments by row and column index.
// Parameters:
//   row - int32 
//   column - int32 
// Returns:
//   ThreadedCommentCollection  
func (instance *CommentCollection) GetThreadedComments_Int_Int(row int32, column int32)  (*ThreadedCommentCollection,  error)  {
	
	CGoReturnPtr := C.CommentCollection_GetThreadedComments_Integer_Integer( instance.ptr, C.int(row), C.int(column))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &ThreadedCommentCollection{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteThreadedCommentCollection) 

	return result, nil 
}
// Gets the threaded comments by cell name.
// Parameters:
//   cellName - string 
// Returns:
//   ThreadedCommentCollection  
func (instance *CommentCollection) GetThreadedComments_String(cellname string)  (*ThreadedCommentCollection,  error)  {
	
	CGoReturnPtr := C.CommentCollection_GetThreadedComments_String( instance.ptr, C.CString(cellname))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &ThreadedCommentCollection{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteThreadedCommentCollection) 

	return result, nil 
}
// Adds a comment to the collection.
// Parameters:
//   row - int32 
//   column - int32 
// Returns:
//   int32  
func (instance *CommentCollection) Add_Int_Int(row int32, column int32)  (int32,  error)  {
	
	CGoReturnPtr := C.CommentCollection_Add_Integer_Integer( instance.ptr, C.int(row), C.int(column))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Adds a comment to the collection.
// Parameters:
//   cellName - string 
// Returns:
//   int32  
func (instance *CommentCollection) Add_String(cellname string)  (int32,  error)  {
	
	CGoReturnPtr := C.CommentCollection_Add_String( instance.ptr, C.CString(cellname))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the <see cref="Comment"/> element at the specified index.
// Parameters:
//   index - int32 
// Returns:
//   Comment  
func (instance *CommentCollection) Get_Int(index int32)  (*Comment,  error)  {
	
	CGoReturnPtr := C.CommentCollection_Get_Integer( instance.ptr, C.int(index))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Comment{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteComment) 

	return result, nil 
}
// Gets the <see cref="Comment"/> element at the specified cell.
// Parameters:
//   cellName - string 
// Returns:
//   Comment  
func (instance *CommentCollection) Get_String(cellname string)  (*Comment,  error)  {
	
	CGoReturnPtr := C.CommentCollection_Get_String( instance.ptr, C.CString(cellname))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Comment{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteComment) 

	return result, nil 
}
// Gets the <see cref="Comment"/> element at the specified row index and column index.
// Parameters:
//   row - int32 
//   column - int32 
// Returns:
//   Comment  
func (instance *CommentCollection) Get_Int_Int(row int32, column int32)  (*Comment,  error)  {
	
	CGoReturnPtr := C.CommentCollection_Get_Integer_Integer( instance.ptr, C.int(row), C.int(column))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Comment{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteComment) 

	return result, nil 
}
// Removes the comment of the specific cell.
// Parameters:
//   cellName - string 
// Returns:
//   void  
func (instance *CommentCollection) RemoveAt_String(cellname string)  error {
	
	CGoReturnPtr := C.CommentCollection_RemoveAt_String( instance.ptr, C.CString(cellname))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Removes the comment of the specific cell.
// Parameters:
//   row - int32 
//   column - int32 
// Returns:
//   void  
func (instance *CommentCollection) RemoveAt_Int_Int(row int32, column int32)  error {
	
	CGoReturnPtr := C.CommentCollection_RemoveAt_Integer_Integer( instance.ptr, C.int(row), C.int(column))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Removes all comments;
// Returns:
//   void  
func (instance *CommentCollection) Clear()  error {
	
	CGoReturnPtr := C.CommentCollection_Clear( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Returns:
//   int32  
func (instance *CommentCollection) GetCount()  (int32,  error)  {
	
	CGoReturnPtr := C.CommentCollection_GetCount( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}



func DeleteCommentCollection(commentcollection *CommentCollection){
	runtime.SetFinalizer(commentcollection, nil)
	C.Delete_CommentCollection(commentcollection.ptr)
	commentcollection.ptr = nil
}

// Class ConditionalFormattingCollection 

// Encapsulates a collection of <see cref="FormatCondition"/> objects.
type ConditionalFormattingCollection struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *ConditionalFormattingCollection) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.ConditionalFormattingCollection_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Remove all conditional formatting in the range.
// Parameters:
//   startRow - int32 
//   startColumn - int32 
//   totalRows - int32 
//   totalColumns - int32 
// Returns:
//   void  
func (instance *ConditionalFormattingCollection) RemoveArea(startrow int32, startcolumn int32, totalrows int32, totalcolumns int32)  error {
	
	CGoReturnPtr := C.ConditionalFormattingCollection_RemoveArea( instance.ptr, C.int(startrow), C.int(startcolumn), C.int(totalrows), C.int(totalcolumns))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Copies conditional formatting.
// Parameters:
//   cfs - ConditionalFormattingCollection 
// Returns:
//   void  
func (instance *ConditionalFormattingCollection) Copy(cfs *ConditionalFormattingCollection)  error {
	
	var cfs_ptr unsafe.Pointer = nil
	if cfs != nil {
	  cfs_ptr =cfs.ptr
	}

	CGoReturnPtr := C.ConditionalFormattingCollection_Copy( instance.ptr, cfs_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the FormatConditions element at the specified index.
// Parameters:
//   index - int32 
// Returns:
//   FormatConditionCollection  
func (instance *ConditionalFormattingCollection) Get(index int32)  (*FormatConditionCollection,  error)  {
	
	CGoReturnPtr := C.ConditionalFormattingCollection_Get( instance.ptr, C.int(index))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &FormatConditionCollection{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteFormatConditionCollection) 

	return result, nil 
}
// Adds a FormatConditions to the collection.
// Returns:
//   int32  
func (instance *ConditionalFormattingCollection) Add()  (int32,  error)  {
	
	CGoReturnPtr := C.ConditionalFormattingCollection_Add( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Returns:
//   int32  
func (instance *ConditionalFormattingCollection) GetCount()  (int32,  error)  {
	
	CGoReturnPtr := C.ConditionalFormattingCollection_GetCount( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}



func DeleteConditionalFormattingCollection(conditionalformattingcollection *ConditionalFormattingCollection){
	runtime.SetFinalizer(conditionalformattingcollection, nil)
	C.Delete_ConditionalFormattingCollection(conditionalformattingcollection.ptr)
	conditionalformattingcollection.ptr = nil
}

// Class ConditionalFormattingIcon 

// Represents  the custom  icon of conditional formatting rule.
type ConditionalFormattingIcon struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *ConditionalFormattingIcon) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.ConditionalFormattingIcon_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the image data with the setting of cell.
// Parameters:
//   cell - Cell 
// Returns:
//   []byte  
func (instance *ConditionalFormattingIcon) GetImageData_Cell(cell *Cell)  ([]byte,  error)  {
	
	var cell_ptr unsafe.Pointer = nil
	if cell != nil {
	  cell_ptr =cell.ptr
	}

	CGoReturnPtr := C.ConditionalFormattingIcon_GetImageData_Cell( instance.ptr, cell_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := C.GoBytes(unsafe.Pointer(CGoReturnPtr.return_value), C.int(CGoReturnPtr.column_length))
	 

	return result, nil 
}
// Gets the icon set data.
// Returns:
//   []byte  
func (instance *ConditionalFormattingIcon) GetImageData()  ([]byte,  error)  {
	
	CGoReturnPtr := C.ConditionalFormattingIcon_GetImageData( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := C.GoBytes(unsafe.Pointer(CGoReturnPtr.return_value), C.int(CGoReturnPtr.column_length))
	 

	return result, nil 
}
// Gets and sets the icon set type.
// Returns:
//   int32  
func (instance *ConditionalFormattingIcon) GetType()  (IconSetType,  error)  {
	
	CGoReturnPtr := C.ConditionalFormattingIcon_GetType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToIconSetType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets and sets the icon set type.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *ConditionalFormattingIcon) SetType(value IconSetType)  error {
	
	CGoReturnPtr := C.ConditionalFormattingIcon_SetType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the icon's index in the icon set.
// Returns:
//   int32  
func (instance *ConditionalFormattingIcon) GetIndex()  (int32,  error)  {
	
	CGoReturnPtr := C.ConditionalFormattingIcon_GetIndex( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the icon's index in the icon set.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *ConditionalFormattingIcon) SetIndex(value int32)  error {
	
	CGoReturnPtr := C.ConditionalFormattingIcon_SetIndex( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Get the icon set data
// Parameters:
//   type - int32 
//   index - int32 
// Returns:
//   []byte  
func ConditionalFormattingIcon_GetIconImageData(type_ IconSetType, index int32)  ([]byte,  error)  {
	
	CGoReturnPtr := C.ConditionalFormattingIcon_GetIconImageData(C.int( int32(type_)), C.int(index))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := C.GoBytes(unsafe.Pointer(CGoReturnPtr.return_value), C.int(CGoReturnPtr.column_length))
	 

	return result, nil 
}



func DeleteConditionalFormattingIcon(conditionalformattingicon *ConditionalFormattingIcon){
	runtime.SetFinalizer(conditionalformattingicon, nil)
	C.Delete_ConditionalFormattingIcon(conditionalformattingicon.ptr)
	conditionalformattingicon.ptr = nil
}

// Class ConditionalFormattingIconCollection 

// Represents  a collection of <see cref="ConditionalFormattingIcon"/> objects.
type ConditionalFormattingIconCollection struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *ConditionalFormattingIconCollection) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.ConditionalFormattingIconCollection_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the ConditionalFormattingIcon element at the specified index.
// Parameters:
//   index - int32 
// Returns:
//   ConditionalFormattingIcon  
func (instance *ConditionalFormattingIconCollection) Get(index int32)  (*ConditionalFormattingIcon,  error)  {
	
	CGoReturnPtr := C.ConditionalFormattingIconCollection_Get( instance.ptr, C.int(index))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &ConditionalFormattingIcon{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteConditionalFormattingIcon) 

	return result, nil 
}
// Adds <see cref="ConditionalFormattingIcon"/> object.
// Parameters:
//   type - int32 
//   index - int32 
// Returns:
//   int32  
func (instance *ConditionalFormattingIconCollection) Add_IconSetType_Int(type_ IconSetType, index int32)  (int32,  error)  {
	
	CGoReturnPtr := C.ConditionalFormattingIconCollection_Add_IconSetType_Integer( instance.ptr, C.int( int32(type_)), C.int(index))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Adds <see cref="ConditionalFormattingIcon"/> object.
// Parameters:
//   cficon - ConditionalFormattingIcon 
// Returns:
//   int32  
func (instance *ConditionalFormattingIconCollection) Add_ConditionalFormattingIcon(cficon *ConditionalFormattingIcon)  (int32,  error)  {
	
	var cficon_ptr unsafe.Pointer = nil
	if cficon != nil {
	  cficon_ptr =cficon.ptr
	}

	CGoReturnPtr := C.ConditionalFormattingIconCollection_Add_ConditionalFormattingIcon( instance.ptr, cficon_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Returns:
//   int32  
func (instance *ConditionalFormattingIconCollection) GetCount()  (int32,  error)  {
	
	CGoReturnPtr := C.ConditionalFormattingIconCollection_GetCount( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}



func DeleteConditionalFormattingIconCollection(conditionalformattingiconcollection *ConditionalFormattingIconCollection){
	runtime.SetFinalizer(conditionalformattingiconcollection, nil)
	C.Delete_ConditionalFormattingIconCollection(conditionalformattingiconcollection.ptr)
	conditionalformattingiconcollection.ptr = nil
}

// Class ConditionalFormattingResult 

// Represents the result of conditional formatting which applies to a cell.
type ConditionalFormattingResult struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *ConditionalFormattingResult) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.ConditionalFormattingResult_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the conditional result style.
// Returns:
//   Style  
func (instance *ConditionalFormattingResult) GetConditionalStyle()  (*Style,  error)  {
	
	CGoReturnPtr := C.ConditionalFormattingResult_GetConditionalStyle( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Style{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteStyle) 

	return result, nil 
}
// Gets the image of icon set.
// Returns:
//   ConditionalFormattingIcon  
func (instance *ConditionalFormattingResult) GetConditionalFormattingIcon()  (*ConditionalFormattingIcon,  error)  {
	
	CGoReturnPtr := C.ConditionalFormattingResult_GetConditionalFormattingIcon( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &ConditionalFormattingIcon{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteConditionalFormattingIcon) 

	return result, nil 
}
// Gets the DataBar object.
// Returns:
//   DataBar  
func (instance *ConditionalFormattingResult) GetConditionalFormattingDataBar()  (*DataBar,  error)  {
	
	CGoReturnPtr := C.ConditionalFormattingResult_GetConditionalFormattingDataBar( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &DataBar{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteDataBar) 

	return result, nil 
}
// Gets the ColorScale object.
// Returns:
//   ColorScale  
func (instance *ConditionalFormattingResult) GetConditionalFormattingColorScale()  (*ColorScale,  error)  {
	
	CGoReturnPtr := C.ConditionalFormattingResult_GetConditionalFormattingColorScale( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &ColorScale{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteColorScale) 

	return result, nil 
}
// Gets the display color of color scale.
// Returns:
//   Color  
func (instance *ConditionalFormattingResult) GetColorScaleResult()  (*Color,  error)  {
	
	CGoReturnPtr := C.ConditionalFormattingResult_GetColorScaleResult( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}



func DeleteConditionalFormattingResult(conditionalformattingresult *ConditionalFormattingResult){
	runtime.SetFinalizer(conditionalformattingresult, nil)
	C.Delete_ConditionalFormattingResult(conditionalformattingresult.ptr)
	conditionalformattingresult.ptr = nil
}

// Class ConditionalFormattingValue 

// Describes the values of the interpolation points in a gradient scale, dataBar or iconSet.
type ConditionalFormattingValue struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *ConditionalFormattingValue) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.ConditionalFormattingValue_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Get or set the value of this conditional formatting value object.
// It should be used in conjunction with Type.
// Returns:
//   Object  
func (instance *ConditionalFormattingValue) GetValue()  (*Object,  error)  {
	
	CGoReturnPtr := C.ConditionalFormattingValue_GetValue( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Object{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteObject) 

	return result, nil 
}
// Get or set the value of this conditional formatting value object.
// It should be used in conjunction with Type.
// Parameters:
//   value - Object 
// Returns:
//   void  
func (instance *ConditionalFormattingValue) SetValue(value *Object)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.ConditionalFormattingValue_SetValue( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Get or set the type of this conditional formatting value object.
// Setting the type to FormatConditionValueType.Min or FormatConditionValueType.Max
// will auto set "Value" to null.
// Returns:
//   int32  
func (instance *ConditionalFormattingValue) GetType()  (FormatConditionValueType,  error)  {
	
	CGoReturnPtr := C.ConditionalFormattingValue_GetType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToFormatConditionValueType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Get or set the type of this conditional formatting value object.
// Setting the type to FormatConditionValueType.Min or FormatConditionValueType.Max
// will auto set "Value" to null.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *ConditionalFormattingValue) SetType(value FormatConditionValueType)  error {
	
	CGoReturnPtr := C.ConditionalFormattingValue_SetType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Get or set the Greater Than Or Equal flag.
// Use only for icon sets, determines whether this threshold value uses
// the greater than or equal to operator.
// 'false' indicates 'greater than' is used instead of 'greater than or equal to'.
// Default value is true.
// Returns:
//   bool  
func (instance *ConditionalFormattingValue) IsGTE()  (bool,  error)  {
	
	CGoReturnPtr := C.ConditionalFormattingValue_IsGTE( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Get or set the Greater Than Or Equal flag.
// Use only for icon sets, determines whether this threshold value uses
// the greater than or equal to operator.
// 'false' indicates 'greater than' is used instead of 'greater than or equal to'.
// Default value is true.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *ConditionalFormattingValue) SetIsGTE(value bool)  error {
	
	CGoReturnPtr := C.ConditionalFormattingValue_SetIsGTE( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}



func DeleteConditionalFormattingValue(conditionalformattingvalue *ConditionalFormattingValue){
	runtime.SetFinalizer(conditionalformattingvalue, nil)
	C.Delete_ConditionalFormattingValue(conditionalformattingvalue.ptr)
	conditionalformattingvalue.ptr = nil
}

// Class ConditionalFormattingValueCollection 

// Describes a collection of CFValueObject.
// Use only for icon sets.
type ConditionalFormattingValueCollection struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *ConditionalFormattingValueCollection) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.ConditionalFormattingValueCollection_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Get the CFValueObject element at the specified index.
// Parameters:
//   index - int32 
// Returns:
//   ConditionalFormattingValue  
func (instance *ConditionalFormattingValueCollection) Get(index int32)  (*ConditionalFormattingValue,  error)  {
	
	CGoReturnPtr := C.ConditionalFormattingValueCollection_Get( instance.ptr, C.int(index))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &ConditionalFormattingValue{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteConditionalFormattingValue) 

	return result, nil 
}
// Adds <see cref="ConditionalFormattingValue"/> object.
// Parameters:
//   type - int32 
//   value - string 
// Returns:
//   int32  
func (instance *ConditionalFormattingValueCollection) Add(type_ FormatConditionValueType, value string)  (int32,  error)  {
	
	CGoReturnPtr := C.ConditionalFormattingValueCollection_Add( instance.ptr, C.int( int32(type_)), C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Returns:
//   int32  
func (instance *ConditionalFormattingValueCollection) GetCount()  (int32,  error)  {
	
	CGoReturnPtr := C.ConditionalFormattingValueCollection_GetCount( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}



func DeleteConditionalFormattingValueCollection(conditionalformattingvaluecollection *ConditionalFormattingValueCollection){
	runtime.SetFinalizer(conditionalformattingvaluecollection, nil)
	C.Delete_ConditionalFormattingValueCollection(conditionalformattingvaluecollection.ptr)
	conditionalformattingvaluecollection.ptr = nil
}

// Class CopyOptions 

// Represents the copy options.
type CopyOptions struct {
	ptr unsafe.Pointer
}

// CopyOptions constructor.
func NewCopyOptions() ( *CopyOptions, error) {
	copyoptions := &CopyOptions{}
	CGoReturnPtr := C.New_CopyOptions()
	if CGoReturnPtr.error_no == 0 {
		copyoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(copyoptions, DeleteCopyOptions)
		return copyoptions, nil
	} else {
		copyoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return copyoptions, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *CopyOptions) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.CopyOptions_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether keeping macros;
// Returns:
//   bool  
func (instance *CopyOptions) GetKeepMacros()  (bool,  error)  {
	
	CGoReturnPtr := C.CopyOptions_GetKeepMacros( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether keeping macros;
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *CopyOptions) SetKeepMacros(value bool)  error {
	
	CGoReturnPtr := C.CopyOptions_SetKeepMacros( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether extend ranges when copying the range to adjacent range.
// Returns:
//   bool  
func (instance *CopyOptions) GetExtendToAdjacentRange()  (bool,  error)  {
	
	CGoReturnPtr := C.CopyOptions_GetExtendToAdjacentRange( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether extend ranges when copying the range to adjacent range.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *CopyOptions) SetExtendToAdjacentRange(value bool)  error {
	
	CGoReturnPtr := C.CopyOptions_SetExtendToAdjacentRange( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether copying the names.
// Returns:
//   bool  
func (instance *CopyOptions) GetCopyNames()  (bool,  error)  {
	
	CGoReturnPtr := C.CopyOptions_GetCopyNames( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether copying the names.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *CopyOptions) SetCopyNames(value bool)  error {
	
	CGoReturnPtr := C.CopyOptions_SetCopyNames( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// If the formula is not valid for the dest destination, only copy values.
// Returns:
//   bool  
func (instance *CopyOptions) GetCopyInvalidFormulasAsValues()  (bool,  error)  {
	
	CGoReturnPtr := C.CopyOptions_GetCopyInvalidFormulasAsValues( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// If the formula is not valid for the dest destination, only copy values.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *CopyOptions) SetCopyInvalidFormulasAsValues(value bool)  error {
	
	CGoReturnPtr := C.CopyOptions_SetCopyInvalidFormulasAsValues( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether copying column width in unit of characters.
// Returns:
//   bool  
func (instance *CopyOptions) GetColumnCharacterWidth()  (bool,  error)  {
	
	CGoReturnPtr := C.CopyOptions_GetColumnCharacterWidth( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether copying column width in unit of characters.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *CopyOptions) SetColumnCharacterWidth(value bool)  error {
	
	CGoReturnPtr := C.CopyOptions_SetColumnCharacterWidth( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// In ms excel, when copying formulas which refer to other worksheets while copying a worksheet to another one,
// the copied formulas should refer to source workbook.
// However, for some situations user may need the copied formulas refer to worksheets with the same name
// in the same workbook, such as when those worksheets have been copied before this copy operation,
// then this property should be kept as true.
// Returns:
//   bool  
func (instance *CopyOptions) GetReferToSheetWithSameName()  (bool,  error)  {
	
	CGoReturnPtr := C.CopyOptions_GetReferToSheetWithSameName( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// In ms excel, when copying formulas which refer to other worksheets while copying a worksheet to another one,
// the copied formulas should refer to source workbook.
// However, for some situations user may need the copied formulas refer to worksheets with the same name
// in the same workbook, such as when those worksheets have been copied before this copy operation,
// then this property should be kept as true.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *CopyOptions) SetReferToSheetWithSameName(value bool)  error {
	
	CGoReturnPtr := C.CopyOptions_SetReferToSheetWithSameName( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// When copying the range in the same file and the chart refers to the source sheet,
// False means the copied chart's data source will not be changed.
// True means the copied chart's data source refers to the destination sheet.
// Returns:
//   bool  
func (instance *CopyOptions) GetReferToDestinationSheet()  (bool,  error)  {
	
	CGoReturnPtr := C.CopyOptions_GetReferToDestinationSheet( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// When copying the range in the same file and the chart refers to the source sheet,
// False means the copied chart's data source will not be changed.
// True means the copied chart's data source refers to the destination sheet.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *CopyOptions) SetReferToDestinationSheet(value bool)  error {
	
	CGoReturnPtr := C.CopyOptions_SetReferToDestinationSheet( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}



func DeleteCopyOptions(copyoptions *CopyOptions){
	runtime.SetFinalizer(copyoptions, nil)
	C.Delete_CopyOptions(copyoptions.ptr)
	copyoptions.ptr = nil
}

// Class CustomFilter 

// Represents the custom filter.
type CustomFilter struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *CustomFilter) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.CustomFilter_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the filter operator type.
// Returns:
//   int32  
func (instance *CustomFilter) GetFilterOperatorType()  (FilterOperatorType,  error)  {
	
	CGoReturnPtr := C.CustomFilter_GetFilterOperatorType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToFilterOperatorType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets and sets the filter operator type.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *CustomFilter) SetFilterOperatorType(value FilterOperatorType)  error {
	
	CGoReturnPtr := C.CustomFilter_SetFilterOperatorType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the criteria.
// Returns:
//   Object  
func (instance *CustomFilter) GetCriteria()  (*Object,  error)  {
	
	CGoReturnPtr := C.CustomFilter_GetCriteria( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Object{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteObject) 

	return result, nil 
}
// Gets and sets the criteria.
// Parameters:
//   value - Object 
// Returns:
//   void  
func (instance *CustomFilter) SetCriteria_Object(value *Object)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.CustomFilter_SetCriteria_Object( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Sets the filter criteria.
// Parameters:
//   filterOperator - int32 
//   criteria - Object 
// Returns:
//   void  
func (instance *CustomFilter) SetCriteria_FilterOperatorType_Object(filteroperator FilterOperatorType, criteria *Object)  error {
	
	var criteria_ptr unsafe.Pointer = nil
	if criteria != nil {
	  criteria_ptr =criteria.ptr
	}

	CGoReturnPtr := C.CustomFilter_SetCriteria_FilterOperatorType_Object( instance.ptr, C.int( int32(filteroperator)), criteria_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}



func DeleteCustomFilter(customfilter *CustomFilter){
	runtime.SetFinalizer(customfilter, nil)
	C.Delete_CustomFilter(customfilter.ptr)
	customfilter.ptr = nil
}

// Class CustomFilterCollection 

// Represents the custom filters.
type CustomFilterCollection struct {
	ptr unsafe.Pointer
}

// Constructs new instance.
func NewCustomFilterCollection() ( *CustomFilterCollection, error) {
	customfiltercollection := &CustomFilterCollection{}
	CGoReturnPtr := C.New_CustomFilterCollection()
	if CGoReturnPtr.error_no == 0 {
		customfiltercollection.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(customfiltercollection, DeleteCustomFilterCollection)
		return customfiltercollection, nil
	} else {
		customfiltercollection.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return customfiltercollection, err
	}	
}
// Constructs from an Object convertible to this.
// Parameters:
//   obj - Object 
func NewCustomFilterCollection_Object(obj *Object) ( *CustomFilterCollection, error) {
	customfiltercollection := &CustomFilterCollection{}
	var obj_ptr unsafe.Pointer = nil
	if obj != nil {
	  obj_ptr =obj.ptr
	}

	CGoReturnPtr := C.New_CustomFilterCollection_Object(obj_ptr)
	if CGoReturnPtr.error_no == 0 {
		customfiltercollection.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(customfiltercollection, DeleteCustomFilterCollection)
		return customfiltercollection, nil
	} else {
		customfiltercollection.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return customfiltercollection, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *CustomFilterCollection) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.CustomFilterCollection_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the Object.
// Returns:
//   Object  
func (instance *CustomFilterCollection) ToObject()  (*Object,  error)  {
	
	CGoReturnPtr := C.CustomFilterCollection_ToObject( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Object{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteObject) 

	return result, nil 
}
// Indicates whether the two criteria have an "and" relationship.
// Returns:
//   bool  
func (instance *CustomFilterCollection) GetAnd()  (bool,  error)  {
	
	CGoReturnPtr := C.CustomFilterCollection_GetAnd( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether the two criteria have an "and" relationship.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *CustomFilterCollection) SetAnd(value bool)  error {
	
	CGoReturnPtr := C.CustomFilterCollection_SetAnd( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the custom filter in the specific index.
// Parameters:
//   index - int32 
// Returns:
//   CustomFilter  
func (instance *CustomFilterCollection) Get(index int32)  (*CustomFilter,  error)  {
	
	CGoReturnPtr := C.CustomFilterCollection_Get( instance.ptr, C.int(index))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &CustomFilter{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteCustomFilter) 

	return result, nil 
}
// Returns:
//   int32  
func (instance *CustomFilterCollection) GetCount()  (int32,  error)  {
	
	CGoReturnPtr := C.CustomFilterCollection_GetCount( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}



func DeleteCustomFilterCollection(customfiltercollection *CustomFilterCollection){
	runtime.SetFinalizer(customfiltercollection, nil)
	C.Delete_CustomFilterCollection(customfiltercollection.ptr)
	customfiltercollection.ptr = nil
}

// Class CustomFunctionDefinition 

// Definition of custom function for calculating with user's custom engine.
type CustomFunctionDefinition struct {
	ptr unsafe.Pointer
}

// Default constructor.
func NewCustomFunctionDefinition() ( *CustomFunctionDefinition, error) {
	customfunctiondefinition := &CustomFunctionDefinition{}
	CGoReturnPtr := C.New_CustomFunctionDefinition()
	if CGoReturnPtr.error_no == 0 {
		customfunctiondefinition.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(customfunctiondefinition, DeleteCustomFunctionDefinition)
		return customfunctiondefinition, nil
	} else {
		customfunctiondefinition.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return customfunctiondefinition, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *CustomFunctionDefinition) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.CustomFunctionDefinition_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the indices of given custom function's parameters that need to be calculated in array mode.
// Parameters:
//   functionName - string 
// Returns:
//   []int32_t  
func (instance *CustomFunctionDefinition) GetArrayModeParameters(functionname string)  ([]int32,  error)  {
	
	CGoReturnPtr := C.CustomFunctionDefinition_GetArrayModeParameters( instance.ptr, C.CString(functionname))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result:= make([]int32, CGoReturnPtr.column_length)
	for i := 0; i < int(CGoReturnPtr.column_length); i++ {
	   offset := uintptr(C.size_t(i)) * uintptr(CGoReturnPtr.size)
	   cObject := *(*C.int)(unsafe.Pointer( uintptr( unsafe.Pointer(CGoReturnPtr.return_value)) + offset))
	   goObject :=int32(cObject)
	   result[i] = goObject
	}
	 

	return result, nil 
}



func DeleteCustomFunctionDefinition(customfunctiondefinition *CustomFunctionDefinition){
	runtime.SetFinalizer(customfunctiondefinition, nil)
	C.Delete_CustomFunctionDefinition(customfunctiondefinition.ptr)
	customfunctiondefinition.ptr = nil
}

// Class DataBar 

// Describe the DataBar conditional formatting rule.
// This conditional formatting rule displays a gradated
// data bar in the range of cells.
type DataBar struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *DataBar) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.DataBar_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the color of the axis for cells with conditional formatting as data bars.
// Returns:
//   Color  
func (instance *DataBar) GetAxisColor()  (*Color,  error)  {
	
	CGoReturnPtr := C.DataBar_GetAxisColor( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Gets the color of the axis for cells with conditional formatting as data bars.
// Parameters:
//   value - Color 
// Returns:
//   void  
func (instance *DataBar) SetAxisColor(value *Color)  error {
	
	CGoReturnPtr := C.DataBar_SetAxisColor( instance.ptr, value.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the position of the axis of the data bars specified by a conditional formatting rule.
// Returns:
//   int32  
func (instance *DataBar) GetAxisPosition()  (DataBarAxisPosition,  error)  {
	
	CGoReturnPtr := C.DataBar_GetAxisPosition( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToDataBarAxisPosition(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets or sets the position of the axis of the data bars specified by a conditional formatting rule.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *DataBar) SetAxisPosition(value DataBarAxisPosition)  error {
	
	CGoReturnPtr := C.DataBar_SetAxisPosition( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets how a data bar is filled with color.
// Returns:
//   int32  
func (instance *DataBar) GetBarFillType()  (DataBarFillType,  error)  {
	
	CGoReturnPtr := C.DataBar_GetBarFillType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToDataBarFillType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets or sets how a data bar is filled with color.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *DataBar) SetBarFillType(value DataBarFillType)  error {
	
	CGoReturnPtr := C.DataBar_SetBarFillType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the direction the databar is displayed.
// Returns:
//   int32  
func (instance *DataBar) GetDirection()  (TextDirectionType,  error)  {
	
	CGoReturnPtr := C.DataBar_GetDirection( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToTextDirectionType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets or sets the direction the databar is displayed.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *DataBar) SetDirection(value TextDirectionType)  error {
	
	CGoReturnPtr := C.DataBar_SetDirection( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets an object that specifies the border of a data bar.
// Returns:
//   DataBarBorder  
func (instance *DataBar) GetBarBorder()  (*DataBarBorder,  error)  {
	
	CGoReturnPtr := C.DataBar_GetBarBorder( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &DataBarBorder{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteDataBarBorder) 

	return result, nil 
}
// Gets the NegativeBarFormat object associated with a data bar conditional formatting rule.
// Returns:
//   NegativeBarFormat  
func (instance *DataBar) GetNegativeBarFormat()  (*NegativeBarFormat,  error)  {
	
	CGoReturnPtr := C.DataBar_GetNegativeBarFormat( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &NegativeBarFormat{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteNegativeBarFormat) 

	return result, nil 
}
// Get or set this DataBar's min value object.
// Cannot set null or CFValueObject with type FormatConditionValueType.Max to it.
// Returns:
//   ConditionalFormattingValue  
func (instance *DataBar) GetMinCfvo()  (*ConditionalFormattingValue,  error)  {
	
	CGoReturnPtr := C.DataBar_GetMinCfvo( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &ConditionalFormattingValue{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteConditionalFormattingValue) 

	return result, nil 
}
// Get or set this DataBar's max value object.
// Cannot set null or CFValueObject with type FormatConditionValueType.Min to it.
// Returns:
//   ConditionalFormattingValue  
func (instance *DataBar) GetMaxCfvo()  (*ConditionalFormattingValue,  error)  {
	
	CGoReturnPtr := C.DataBar_GetMaxCfvo( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &ConditionalFormattingValue{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteConditionalFormattingValue) 

	return result, nil 
}
// Get or set this DataBar's Color.
// Returns:
//   Color  
func (instance *DataBar) GetColor()  (*Color,  error)  {
	
	CGoReturnPtr := C.DataBar_GetColor( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Get or set this DataBar's Color.
// Parameters:
//   value - Color 
// Returns:
//   void  
func (instance *DataBar) SetColor(value *Color)  error {
	
	CGoReturnPtr := C.DataBar_SetColor( instance.ptr, value.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents the min length of data bar .
// Returns:
//   int32  
func (instance *DataBar) GetMinLength()  (int32,  error)  {
	
	CGoReturnPtr := C.DataBar_GetMinLength( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents the min length of data bar .
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *DataBar) SetMinLength(value int32)  error {
	
	CGoReturnPtr := C.DataBar_SetMinLength( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents the max length of data bar .
// Returns:
//   int32  
func (instance *DataBar) GetMaxLength()  (int32,  error)  {
	
	CGoReturnPtr := C.DataBar_GetMaxLength( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents the max length of data bar .
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *DataBar) SetMaxLength(value int32)  error {
	
	CGoReturnPtr := C.DataBar_SetMaxLength( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Get or set the flag indicating whether to show the values of the cells on which this data bar is applied.
// Default value is true.
// Returns:
//   bool  
func (instance *DataBar) GetShowValue()  (bool,  error)  {
	
	CGoReturnPtr := C.DataBar_GetShowValue( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Get or set the flag indicating whether to show the values of the cells on which this data bar is applied.
// Default value is true.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *DataBar) SetShowValue(value bool)  error {
	
	CGoReturnPtr := C.DataBar_SetShowValue( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Render data bar in cell to image byte array.
// Parameters:
//   cell - Cell 
//   imgOpts - ImageOrPrintOptions 
// Returns:
//   []byte  
func (instance *DataBar) ToImage(cell *Cell, imgopts *ImageOrPrintOptions)  ([]byte,  error)  {
	
	var cell_ptr unsafe.Pointer = nil
	if cell != nil {
	  cell_ptr =cell.ptr
	}
	var imgopts_ptr unsafe.Pointer = nil
	if imgopts != nil {
	  imgopts_ptr =imgopts.ptr
	}

	CGoReturnPtr := C.DataBar_ToImage( instance.ptr, cell_ptr, imgopts_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := C.GoBytes(unsafe.Pointer(CGoReturnPtr.return_value), C.int(CGoReturnPtr.column_length))
	 

	return result, nil 
}



func DeleteDataBar(databar *DataBar){
	runtime.SetFinalizer(databar, nil)
	C.Delete_DataBar(databar.ptr)
	databar.ptr = nil
}

// Class DataBarBorder 

// Represents the border of the data bars specified by a conditional formatting rule.
type DataBarBorder struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *DataBarBorder) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.DataBarBorder_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets the border's color of data bars specified by a conditional formatting rule.
// Returns:
//   Color  
func (instance *DataBarBorder) GetColor()  (*Color,  error)  {
	
	CGoReturnPtr := C.DataBarBorder_GetColor( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Gets or sets the border's color of data bars specified by a conditional formatting rule.
// Parameters:
//   value - Color 
// Returns:
//   void  
func (instance *DataBarBorder) SetColor(value *Color)  error {
	
	CGoReturnPtr := C.DataBarBorder_SetColor( instance.ptr, value.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the border's type of data bars specified by a conditional formatting rule.
// Returns:
//   int32  
func (instance *DataBarBorder) GetType()  (DataBarBorderType,  error)  {
	
	CGoReturnPtr := C.DataBarBorder_GetType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToDataBarBorderType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets or sets the border's type of data bars specified by a conditional formatting rule.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *DataBarBorder) SetType(value DataBarBorderType)  error {
	
	CGoReturnPtr := C.DataBarBorder_SetType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}



func DeleteDataBarBorder(databarborder *DataBarBorder){
	runtime.SetFinalizer(databarborder, nil)
	C.Delete_DataBarBorder(databarborder.ptr)
	databarborder.ptr = nil
}

// Class DataSorter 

// Summary description for DataSorter.
type DataSorter struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *DataSorter) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.DataSorter_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the key list of data sorter.
// Returns:
//   DataSorterKeyCollection  
func (instance *DataSorter) GetKeys()  (*DataSorterKeyCollection,  error)  {
	
	CGoReturnPtr := C.DataSorter_GetKeys( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &DataSorterKeyCollection{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteDataSorterKeyCollection) 

	return result, nil 
}
// Clear all settings.
// Returns:
//   void  
func (instance *DataSorter) Clear()  error {
	
	CGoReturnPtr := C.DataSorter_Clear( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents whether the range has headers.
// Returns:
//   bool  
func (instance *DataSorter) GetHasHeaders()  (bool,  error)  {
	
	CGoReturnPtr := C.DataSorter_GetHasHeaders( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents whether the range has headers.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *DataSorter) SetHasHeaders(value bool)  error {
	
	CGoReturnPtr := C.DataSorter_SetHasHeaders( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Adds sorted column index and sort order.
// Parameters:
//   key - int32 
//   order - int32 
// Returns:
//   void  
func (instance *DataSorter) AddKey_Int_SortOrder(key int32, order SortOrder)  error {
	
	CGoReturnPtr := C.DataSorter_AddKey_Integer_SortOrder( instance.ptr, C.int(key), C.int( int32(order)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Adds sorted column index and sort order with custom sort list.
// Parameters:
//   key - int32 
//   order - int32 
//   customList - string 
// Returns:
//   void  
func (instance *DataSorter) AddKey_Int_SortOrder_String(key int32, order SortOrder, customlist string)  error {
	
	CGoReturnPtr := C.DataSorter_AddKey_Integer_SortOrder_String( instance.ptr, C.int(key), C.int( int32(order)), C.CString(customlist))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Adds color sort key.
// Parameters:
//   key - int32 
//   type - int32 
//   order - int32 
//   color - Color 
// Returns:
//   void  
func (instance *DataSorter) AddColorKey(key int32, type_ SortOnType, order SortOrder, color *Color)  error {
	
	CGoReturnPtr := C.DataSorter_AddColorKey( instance.ptr, C.int(key), C.int( int32(type_)), C.int( int32(order)), color.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Adds sorted column index and sort order with custom sort list.
// Parameters:
//   key - int32 
//   type - int32 
//   order - int32 
//   customList - Object 
// Returns:
//   void  
func (instance *DataSorter) AddKey_Int_SortOnType_SortOrder_Object(key int32, type_ SortOnType, order SortOrder, customlist *Object)  error {
	
	var customlist_ptr unsafe.Pointer = nil
	if customlist != nil {
	  customlist_ptr =customlist.ptr
	}

	CGoReturnPtr := C.DataSorter_AddKey_Integer_SortOnType_SortOrder_Object( instance.ptr, C.int(key), C.int( int32(type_)), C.int( int32(order)), customlist_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Adds sorted column index and sort order with custom sort list.
// Parameters:
//   key - int32 
//   order - int32 
//   customList - []string 
// Returns:
//   void  
func (instance *DataSorter) AddKey_Int_SortOrder_stringArray(key int32, order SortOrder, customlist []string)  error {
	
	vector_customlist := make([]*C.char, len(customlist))
	for i, str := range customlist {
	cStr := C.CString(str)
	defer C.free(unsafe.Pointer(cStr))
	vector_customlist[i] = cStr
	}

	CGoReturnPtr := C.DataSorter_AddKey_Integer_SortOrder_U16StringArray( instance.ptr, C.int(key), C.int( int32(order)), unsafe.Pointer(&vector_customlist[0]), C.int( len(customlist)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents first sorted column index(absolute position, column A is 0, B is 1, ...).
// Returns:
//   int32  
func (instance *DataSorter) GetKey1()  (int32,  error)  {
	
	CGoReturnPtr := C.DataSorter_GetKey1( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents first sorted column index(absolute position, column A is 0, B is 1, ...).
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *DataSorter) SetKey1(value int32)  error {
	
	CGoReturnPtr := C.DataSorter_SetKey1( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents sort order of the first key.
// Returns:
//   int32  
func (instance *DataSorter) GetOrder1()  (SortOrder,  error)  {
	
	CGoReturnPtr := C.DataSorter_GetOrder1( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToSortOrder(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Represents sort order of the first key.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *DataSorter) SetOrder1(value SortOrder)  error {
	
	CGoReturnPtr := C.DataSorter_SetOrder1( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents second sorted column index(absolute position, column A is 0, B is 1, ...).
// Returns:
//   int32  
func (instance *DataSorter) GetKey2()  (int32,  error)  {
	
	CGoReturnPtr := C.DataSorter_GetKey2( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents second sorted column index(absolute position, column A is 0, B is 1, ...).
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *DataSorter) SetKey2(value int32)  error {
	
	CGoReturnPtr := C.DataSorter_SetKey2( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents sort order of the second key.
// Returns:
//   int32  
func (instance *DataSorter) GetOrder2()  (SortOrder,  error)  {
	
	CGoReturnPtr := C.DataSorter_GetOrder2( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToSortOrder(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Represents sort order of the second key.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *DataSorter) SetOrder2(value SortOrder)  error {
	
	CGoReturnPtr := C.DataSorter_SetOrder2( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents third sorted column index(absolute position, column A is 0, B is 1, ...).
// Returns:
//   int32  
func (instance *DataSorter) GetKey3()  (int32,  error)  {
	
	CGoReturnPtr := C.DataSorter_GetKey3( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents third sorted column index(absolute position, column A is 0, B is 1, ...).
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *DataSorter) SetKey3(value int32)  error {
	
	CGoReturnPtr := C.DataSorter_SetKey3( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents sort order of the third key.
// Returns:
//   int32  
func (instance *DataSorter) GetOrder3()  (SortOrder,  error)  {
	
	CGoReturnPtr := C.DataSorter_GetOrder3( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToSortOrder(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Represents sort order of the third key.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *DataSorter) SetOrder3(value SortOrder)  error {
	
	CGoReturnPtr := C.DataSorter_SetOrder3( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// True means that sorting orientation is from left to right.
// False means that sorting orientation is from top to bottom.
// The default value is false.
// Returns:
//   bool  
func (instance *DataSorter) GetSortLeftToRight()  (bool,  error)  {
	
	CGoReturnPtr := C.DataSorter_GetSortLeftToRight( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// True means that sorting orientation is from left to right.
// False means that sorting orientation is from top to bottom.
// The default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *DataSorter) SetSortLeftToRight(value bool)  error {
	
	CGoReturnPtr := C.DataSorter_SetSortLeftToRight( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets whether case sensitive when comparing string.
// Returns:
//   bool  
func (instance *DataSorter) GetCaseSensitive()  (bool,  error)  {
	
	CGoReturnPtr := C.DataSorter_GetCaseSensitive( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets whether case sensitive when comparing string.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *DataSorter) SetCaseSensitive(value bool)  error {
	
	CGoReturnPtr := C.DataSorter_SetCaseSensitive( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether sorting anything that looks like a number.
// Returns:
//   bool  
func (instance *DataSorter) GetSortAsNumber()  (bool,  error)  {
	
	CGoReturnPtr := C.DataSorter_GetSortAsNumber( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether sorting anything that looks like a number.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *DataSorter) SetSortAsNumber(value bool)  error {
	
	CGoReturnPtr := C.DataSorter_SetSortAsNumber( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Sorts the data of the area.
// Parameters:
//   cells - Cells 
//   startRow - int32 
//   startColumn - int32 
//   endRow - int32 
//   endColumn - int32 
// Returns:
//   []int32_t  
func (instance *DataSorter) Sort_Cells_Int_Int_Int_Int(cells *Cells, startrow int32, startcolumn int32, endrow int32, endcolumn int32)  ([]int32,  error)  {
	
	var cells_ptr unsafe.Pointer = nil
	if cells != nil {
	  cells_ptr =cells.ptr
	}

	CGoReturnPtr := C.DataSorter_Sort_Cells_Integer_Integer_Integer_Integer( instance.ptr, cells_ptr, C.int(startrow), C.int(startcolumn), C.int(endrow), C.int(endcolumn))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result:= make([]int32, CGoReturnPtr.column_length)
	for i := 0; i < int(CGoReturnPtr.column_length); i++ {
	   offset := uintptr(C.size_t(i)) * uintptr(CGoReturnPtr.size)
	   cObject := *(*C.int)(unsafe.Pointer( uintptr( unsafe.Pointer(CGoReturnPtr.return_value)) + offset))
	   goObject :=int32(cObject)
	   result[i] = goObject
	}
	 

	return result, nil 
}
// Sort the data of the area.
// Parameters:
//   cells - Cells 
//   area - CellArea 
// Returns:
//   []int32_t  
func (instance *DataSorter) Sort_Cells_CellArea(cells *Cells, area *CellArea)  ([]int32,  error)  {
	
	var cells_ptr unsafe.Pointer = nil
	if cells != nil {
	  cells_ptr =cells.ptr
	}
	var area_ptr unsafe.Pointer = nil
	if area != nil {
	  area_ptr =area.ptr
	}

	CGoReturnPtr := C.DataSorter_Sort_Cells_CellArea( instance.ptr, cells_ptr, area_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result:= make([]int32, CGoReturnPtr.column_length)
	for i := 0; i < int(CGoReturnPtr.column_length); i++ {
	   offset := uintptr(C.size_t(i)) * uintptr(CGoReturnPtr.size)
	   cObject := *(*C.int)(unsafe.Pointer( uintptr( unsafe.Pointer(CGoReturnPtr.return_value)) + offset))
	   goObject :=int32(cObject)
	   result[i] = goObject
	}
	 

	return result, nil 
}
// Sort the data in the range.
// Returns:
//   []int32_t  
func (instance *DataSorter) Sort()  ([]int32,  error)  {
	
	CGoReturnPtr := C.DataSorter_Sort( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result:= make([]int32, CGoReturnPtr.column_length)
	for i := 0; i < int(CGoReturnPtr.column_length); i++ {
	   offset := uintptr(C.size_t(i)) * uintptr(CGoReturnPtr.size)
	   cObject := *(*C.int)(unsafe.Pointer( uintptr( unsafe.Pointer(CGoReturnPtr.return_value)) + offset))
	   goObject :=int32(cObject)
	   result[i] = goObject
	}
	 

	return result, nil 
}



func DeleteDataSorter(datasorter *DataSorter){
	runtime.SetFinalizer(datasorter, nil)
	C.Delete_DataSorter(datasorter.ptr)
	datasorter.ptr = nil
}

// Class DataSorterKey 

// Represents the key of the data sorter.
type DataSorterKey struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *DataSorterKey) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.DataSorterKey_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates the order of sorting.
// Returns:
//   int32  
func (instance *DataSorterKey) GetOrder()  (SortOrder,  error)  {
	
	CGoReturnPtr := C.DataSorterKey_GetOrder( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToSortOrder(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets the sorted column index(absolute position, column A is 0, B is 1, ...).
// Returns:
//   int32  
func (instance *DataSorterKey) GetIndex()  (int32,  error)  {
	
	CGoReturnPtr := C.DataSorterKey_GetIndex( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents the type of sorting.
// Returns:
//   int32  
func (instance *DataSorterKey) GetType()  (SortOnType,  error)  {
	
	CGoReturnPtr := C.DataSorterKey_GetType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToSortOnType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Represents the icon set type.
// Returns:
//   int32  
func (instance *DataSorterKey) GetIconSetType()  (IconSetType,  error)  {
	
	CGoReturnPtr := C.DataSorterKey_GetIconSetType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToIconSetType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Represents the id of the icon set type.
// Returns:
//   int32  
func (instance *DataSorterKey) GetIconId()  (int32,  error)  {
	
	CGoReturnPtr := C.DataSorterKey_GetIconId( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the sorted color.
// Returns:
//   Color  
func (instance *DataSorterKey) GetColor()  (*Color,  error)  {
	
	CGoReturnPtr := C.DataSorterKey_GetColor( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}



func DeleteDataSorterKey(datasorterkey *DataSorterKey){
	runtime.SetFinalizer(datasorterkey, nil)
	C.Delete_DataSorterKey(datasorterkey.ptr)
	datasorterkey.ptr = nil
}

// Class DataSorterKeyCollection 

// Represents the key list of data sorter.
type DataSorterKeyCollection struct {
	ptr unsafe.Pointer
}

// Default constructor.
func NewDataSorterKeyCollection() ( *DataSorterKeyCollection, error) {
	datasorterkeycollection := &DataSorterKeyCollection{}
	CGoReturnPtr := C.New_DataSorterKeyCollection()
	if CGoReturnPtr.error_no == 0 {
		datasorterkeycollection.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(datasorterkeycollection, DeleteDataSorterKeyCollection)
		return datasorterkeycollection, nil
	} else {
		datasorterkeycollection.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return datasorterkeycollection, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *DataSorterKeyCollection) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.DataSorterKeyCollection_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets <see cref="DataSorterKey"/> by index.
// Parameters:
//   index - int32 
// Returns:
//   DataSorterKey  
func (instance *DataSorterKeyCollection) Get(index int32)  (*DataSorterKey,  error)  {
	
	CGoReturnPtr := C.DataSorterKeyCollection_Get( instance.ptr, C.int(index))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &DataSorterKey{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteDataSorterKey) 

	return result, nil 
}
// Returns:
//   int32  
func (instance *DataSorterKeyCollection) GetCount()  (int32,  error)  {
	
	CGoReturnPtr := C.DataSorterKeyCollection_GetCount( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}



func DeleteDataSorterKeyCollection(datasorterkeycollection *DataSorterKeyCollection){
	runtime.SetFinalizer(datasorterkeycollection, nil)
	C.Delete_DataSorterKeyCollection(datasorterkeycollection.ptr)
	datasorterkeycollection.ptr = nil
}

// Class DateTimeGroupItem 

// Represents the datetime's group setting.
type DateTimeGroupItem struct {
	ptr unsafe.Pointer
}

// Parameters:
//   type - int32 
//   year - int32 
//   month - int32 
//   day - int32 
//   hour - int32 
//   minute - int32 
//   second - int32 
func NewDateTimeGroupItem_DateTimeGroupingType_Int_Int_Int_Int_Int_Int(type_ DateTimeGroupingType, year int32, month int32, day int32, hour int32, minute int32, second int32) ( *DateTimeGroupItem, error) {
	datetimegroupitem := &DateTimeGroupItem{}
	CGoReturnPtr := C.New_DateTimeGroupItem_DateTimeGroupingType_Integer_Integer_Integer_Integer_Integer_Integer(C.int( int32(type_)), C.int(year), C.int(month), C.int(day), C.int(hour), C.int(minute), C.int(second))
	if CGoReturnPtr.error_no == 0 {
		datetimegroupitem.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(datetimegroupitem, DeleteDateTimeGroupItem)
		return datetimegroupitem, nil
	} else {
		datetimegroupitem.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return datetimegroupitem, err
	}	
}
// Constructs from an Object convertible to this.
// Parameters:
//   obj - Object 
func NewDateTimeGroupItem_Object(obj *Object) ( *DateTimeGroupItem, error) {
	datetimegroupitem := &DateTimeGroupItem{}
	var obj_ptr unsafe.Pointer = nil
	if obj != nil {
	  obj_ptr =obj.ptr
	}

	CGoReturnPtr := C.New_DateTimeGroupItem_Object(obj_ptr)
	if CGoReturnPtr.error_no == 0 {
		datetimegroupitem.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(datetimegroupitem, DeleteDateTimeGroupItem)
		return datetimegroupitem, nil
	} else {
		datetimegroupitem.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return datetimegroupitem, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *DateTimeGroupItem) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.DateTimeGroupItem_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the Object.
// Returns:
//   Object  
func (instance *DateTimeGroupItem) ToObject()  (*Object,  error)  {
	
	CGoReturnPtr := C.DateTimeGroupItem_ToObject( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Object{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteObject) 

	return result, nil 
}
// Gets the min value.
// Returns:
//   Date  
func (instance *DateTimeGroupItem) GetMinValue()  (time.Time,  error)  {
	
	CGoReturnPtr := C.DateTimeGroupItem_GetMinValue( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  time.Unix(0, 0), err
	}
	result := time.Date(int( C.Date_Get_year(CGoReturnPtr.return_value).return_value ),time.Month(int( C.Date_Get_month(CGoReturnPtr.return_value).return_value)),int( C.Date_Get_day(CGoReturnPtr.return_value).return_value),int(  C.Date_Get_hour(CGoReturnPtr.return_value).return_value),int( C.Date_Get_minute(CGoReturnPtr.return_value).return_value),int(  C.Date_Get_second(CGoReturnPtr.return_value).return_value), 0, time.UTC) 

	return result, nil 
}
// Gets and sets the group type.
// Returns:
//   int32  
func (instance *DateTimeGroupItem) GetDateTimeGroupingType()  (DateTimeGroupingType,  error)  {
	
	CGoReturnPtr := C.DateTimeGroupItem_GetDateTimeGroupingType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToDateTimeGroupingType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets and sets the group type.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *DateTimeGroupItem) SetDateTimeGroupingType(value DateTimeGroupingType)  error {
	
	CGoReturnPtr := C.DateTimeGroupItem_SetDateTimeGroupingType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the year of the grouped date time.
// Returns:
//   int32  
func (instance *DateTimeGroupItem) GetYear()  (int32,  error)  {
	
	CGoReturnPtr := C.DateTimeGroupItem_GetYear( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the year of the grouped date time.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *DateTimeGroupItem) SetYear(value int32)  error {
	
	CGoReturnPtr := C.DateTimeGroupItem_SetYear( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the month of the grouped date time.
// Returns:
//   int32  
func (instance *DateTimeGroupItem) GetMonth()  (int32,  error)  {
	
	CGoReturnPtr := C.DateTimeGroupItem_GetMonth( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the month of the grouped date time.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *DateTimeGroupItem) SetMonth(value int32)  error {
	
	CGoReturnPtr := C.DateTimeGroupItem_SetMonth( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the day of the grouped date time.
// Returns:
//   int32  
func (instance *DateTimeGroupItem) GetDay()  (int32,  error)  {
	
	CGoReturnPtr := C.DateTimeGroupItem_GetDay( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the day of the grouped date time.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *DateTimeGroupItem) SetDay(value int32)  error {
	
	CGoReturnPtr := C.DateTimeGroupItem_SetDay( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the hour of the grouped date time.
// Returns:
//   int32  
func (instance *DateTimeGroupItem) GetHour()  (int32,  error)  {
	
	CGoReturnPtr := C.DateTimeGroupItem_GetHour( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the hour of the grouped date time.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *DateTimeGroupItem) SetHour(value int32)  error {
	
	CGoReturnPtr := C.DateTimeGroupItem_SetHour( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the minute of the grouped date time.
// Returns:
//   int32  
func (instance *DateTimeGroupItem) GetMinute()  (int32,  error)  {
	
	CGoReturnPtr := C.DateTimeGroupItem_GetMinute( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the minute of the grouped date time.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *DateTimeGroupItem) SetMinute(value int32)  error {
	
	CGoReturnPtr := C.DateTimeGroupItem_SetMinute( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the second of the grouped date time.
// Returns:
//   int32  
func (instance *DateTimeGroupItem) GetSecond()  (int32,  error)  {
	
	CGoReturnPtr := C.DateTimeGroupItem_GetSecond( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the second of the grouped date time.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *DateTimeGroupItem) SetSecond(value int32)  error {
	
	CGoReturnPtr := C.DateTimeGroupItem_SetSecond( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}



func DeleteDateTimeGroupItem(datetimegroupitem *DateTimeGroupItem){
	runtime.SetFinalizer(datetimegroupitem, nil)
	C.Delete_DateTimeGroupItem(datetimegroupitem.ptr)
	datetimegroupitem.ptr = nil
}

// Class DefaultStyleSettings 

// Settings for the default values of workbook's style properties.
type DefaultStyleSettings struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *DefaultStyleSettings) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.DefaultStyleSettings_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether property for number format is preferrable when the style defines both built-in number and custom pattern.
// Default value is false, that means by default custom pattern will be used to format values as long as it is not empty for one style.
// Returns:
//   bool  
func (instance *DefaultStyleSettings) GetBuiltInPreference()  (bool,  error)  {
	
	CGoReturnPtr := C.DefaultStyleSettings_GetBuiltInPreference( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether property for number format is preferrable when the style defines both built-in number and custom pattern.
// Default value is false, that means by default custom pattern will be used to format values as long as it is not empty for one style.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *DefaultStyleSettings) SetBuiltInPreference(value bool)  error {
	
	CGoReturnPtr := C.DefaultStyleSettings_SetBuiltInPreference( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets/Sets the default font name for the workbook
// Returns:
//   string  
func (instance *DefaultStyleSettings) GetFontName()  (string,  error)  {
	
	CGoReturnPtr := C.DefaultStyleSettings_GetFontName( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets/Sets the default font name for the workbook
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *DefaultStyleSettings) SetFontName(value string)  error {
	
	CGoReturnPtr := C.DefaultStyleSettings_SetFontName( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets/Sets the default standard font size for the workbook.
// Returns:
//   float64  
func (instance *DefaultStyleSettings) GetFontSize()  (float64,  error)  {
	
	CGoReturnPtr := C.DefaultStyleSettings_GetFontSize( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := float64(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets/Sets the default standard font size for the workbook.
// Parameters:
//   value - float64 
// Returns:
//   void  
func (instance *DefaultStyleSettings) SetFontSize(value float64)  error {
	
	CGoReturnPtr := C.DefaultStyleSettings_SetFontSize( instance.ptr, C.double(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets/Sets the default value for horizontal alignment
// Returns:
//   int32  
func (instance *DefaultStyleSettings) GetHorizontalAlignment()  (TextAlignmentType,  error)  {
	
	CGoReturnPtr := C.DefaultStyleSettings_GetHorizontalAlignment( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToTextAlignmentType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets/Sets the default value for horizontal alignment
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *DefaultStyleSettings) SetHorizontalAlignment(value TextAlignmentType)  error {
	
	CGoReturnPtr := C.DefaultStyleSettings_SetHorizontalAlignment( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets/Sets the default value for vertical alignment
// Returns:
//   int32  
func (instance *DefaultStyleSettings) GetVerticalAlignment()  (TextAlignmentType,  error)  {
	
	CGoReturnPtr := C.DefaultStyleSettings_GetVerticalAlignment( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToTextAlignmentType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets/Sets the default value for vertical alignment
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *DefaultStyleSettings) SetVerticalAlignment(value TextAlignmentType)  error {
	
	CGoReturnPtr := C.DefaultStyleSettings_SetVerticalAlignment( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}



func DeleteDefaultStyleSettings(defaultstylesettings *DefaultStyleSettings){
	runtime.SetFinalizer(defaultstylesettings, nil)
	C.Delete_DefaultStyleSettings(defaultstylesettings.ptr)
	defaultstylesettings.ptr = nil
}

// Class DeleteBlankOptions 

// Represents the setting of deleting blank cells/rows/columns.
type DeleteBlankOptions struct {
	ptr unsafe.Pointer
}

// Default constructor.
func NewDeleteBlankOptions() ( *DeleteBlankOptions, error) {
	deleteblankoptions := &DeleteBlankOptions{}
	CGoReturnPtr := C.New_DeleteBlankOptions()
	if CGoReturnPtr.error_no == 0 {
		deleteblankoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(deleteblankoptions, DeleteDeleteBlankOptions)
		return deleteblankoptions, nil
	} else {
		deleteblankoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return deleteblankoptions, err
	}	
}
// Constructs from a parent object.
// Parameters:
//   src - DeleteOptions 
func NewDeleteBlankOptions_DeleteOptions(src *DeleteOptions) ( *DeleteBlankOptions, error) {
	deleteblankoptions := &DeleteBlankOptions{}
	var src_ptr unsafe.Pointer = nil
	if src != nil {
	  src_ptr =src.ptr
	}

	CGoReturnPtr := C.New_DeleteBlankOptions_DeleteOptions(src_ptr)
	if CGoReturnPtr.error_no == 0 {
		deleteblankoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(deleteblankoptions, DeleteDeleteBlankOptions)
		return deleteblankoptions, nil
	} else {
		deleteblankoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return deleteblankoptions, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *DeleteBlankOptions) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.DeleteBlankOptions_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Whether one cell will be taken as blank when its value is empty string.
// Default value is true.
// Returns:
//   bool  
func (instance *DeleteBlankOptions) GetEmptyStringAsBlank()  (bool,  error)  {
	
	CGoReturnPtr := C.DeleteBlankOptions_GetEmptyStringAsBlank( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Whether one cell will be taken as blank when its value is empty string.
// Default value is true.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *DeleteBlankOptions) SetEmptyStringAsBlank(value bool)  error {
	
	CGoReturnPtr := C.DeleteBlankOptions_SetEmptyStringAsBlank( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Whether one cell will be taken as blank when it is formula and the calculated result is null or empty string.
// Default value is false.
// Returns:
//   bool  
func (instance *DeleteBlankOptions) GetEmptyFormulaValueAsBlank()  (bool,  error)  {
	
	CGoReturnPtr := C.DeleteBlankOptions_GetEmptyFormulaValueAsBlank( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Whether one cell will be taken as blank when it is formula and the calculated result is null or empty string.
// Default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *DeleteBlankOptions) SetEmptyFormulaValueAsBlank(value bool)  error {
	
	CGoReturnPtr := C.DeleteBlankOptions_SetEmptyFormulaValueAsBlank( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Whether drawing related objects such as picture, shape, chart... will be taken as blank.
// Default value is true.
// Returns:
//   bool  
func (instance *DeleteBlankOptions) GetDrawingsAsBlank()  (bool,  error)  {
	
	CGoReturnPtr := C.DeleteBlankOptions_GetDrawingsAsBlank( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Whether drawing related objects such as picture, shape, chart... will be taken as blank.
// Default value is true.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *DeleteBlankOptions) SetDrawingsAsBlank(value bool)  error {
	
	CGoReturnPtr := C.DeleteBlankOptions_SetDrawingsAsBlank( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates how to process merged cells when deleting blank rows/columns.
// Returns:
//   int32  
func (instance *DeleteBlankOptions) GetMergedCellsShrinkType()  (MergedCellsShrinkType,  error)  {
	
	CGoReturnPtr := C.DeleteBlankOptions_GetMergedCellsShrinkType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToMergedCellsShrinkType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Indicates how to process merged cells when deleting blank rows/columns.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *DeleteBlankOptions) SetMergedCellsShrinkType(value MergedCellsShrinkType)  error {
	
	CGoReturnPtr := C.DeleteBlankOptions_SetMergedCellsShrinkType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Specifies the start row/column index of the range to check and delete blank rows/columns.
// Returns:
//   int32  
func (instance *DeleteBlankOptions) GetStartIndex()  (int32,  error)  {
	
	CGoReturnPtr := C.DeleteBlankOptions_GetStartIndex( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Specifies the start row/column index of the range to check and delete blank rows/columns.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *DeleteBlankOptions) SetStartIndex(value int32)  error {
	
	CGoReturnPtr := C.DeleteBlankOptions_SetStartIndex( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Specifies the end row/column index(inclusive) of the range to check and delete blank rows/columns.
// Default value is -1 and -1 means the maximum range of all objects(cells, drawings, ...) that need to be checked.
// Returns:
//   int32  
func (instance *DeleteBlankOptions) GetEndIndex()  (int32,  error)  {
	
	CGoReturnPtr := C.DeleteBlankOptions_GetEndIndex( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Specifies the end row/column index(inclusive) of the range to check and delete blank rows/columns.
// Default value is -1 and -1 means the maximum range of all objects(cells, drawings, ...) that need to be checked.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *DeleteBlankOptions) SetEndIndex(value int32)  error {
	
	CGoReturnPtr := C.DeleteBlankOptions_SetEndIndex( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates if update references in other worksheets.
// Returns:
//   bool  
func (instance *DeleteBlankOptions) GetUpdateReference()  (bool,  error)  {
	
	CGoReturnPtr := C.DeleteBlankOptions_GetUpdateReference( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates if update references in other worksheets.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *DeleteBlankOptions) SetUpdateReference(value bool)  error {
	
	CGoReturnPtr := C.DeleteBlankOptions_SetUpdateReference( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets/sets the monitor for tracking changes caused by the deletion.
// Returns:
//   AbstractFormulaChangeMonitor  
func (instance *DeleteBlankOptions) GetFormulaChangeMonitor()  (*AbstractFormulaChangeMonitor,  error)  {
	
	CGoReturnPtr := C.DeleteBlankOptions_GetFormulaChangeMonitor( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &AbstractFormulaChangeMonitor{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteAbstractFormulaChangeMonitor) 

	return result, nil 
}
// Gets/sets the monitor for tracking changes caused by the deletion.
// Parameters:
//   value - AbstractFormulaChangeMonitor 
// Returns:
//   void  
func (instance *DeleteBlankOptions) SetFormulaChangeMonitor(value *AbstractFormulaChangeMonitor)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.DeleteBlankOptions_SetFormulaChangeMonitor( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}


func (instance *DeleteBlankOptions) ToDeleteOptions() *DeleteOptions {
	parentClass := &DeleteOptions{}
	parentClass.ptr = instance.ptr
	return parentClass
}

func DeleteDeleteBlankOptions(deleteblankoptions *DeleteBlankOptions){
	runtime.SetFinalizer(deleteblankoptions, nil)
	C.Delete_DeleteBlankOptions(deleteblankoptions.ptr)
	deleteblankoptions.ptr = nil
}

// Class DeleteOptions 

// Represents the setting of deleting rows/columns.
type DeleteOptions struct {
	ptr unsafe.Pointer
}

// Default constructor.
func NewDeleteOptions() ( *DeleteOptions, error) {
	deleteoptions := &DeleteOptions{}
	CGoReturnPtr := C.New_DeleteOptions()
	if CGoReturnPtr.error_no == 0 {
		deleteoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(deleteoptions, DeleteDeleteOptions)
		return deleteoptions, nil
	} else {
		deleteoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return deleteoptions, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *DeleteOptions) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.DeleteOptions_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates if update references in other worksheets.
// Returns:
//   bool  
func (instance *DeleteOptions) GetUpdateReference()  (bool,  error)  {
	
	CGoReturnPtr := C.DeleteOptions_GetUpdateReference( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates if update references in other worksheets.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *DeleteOptions) SetUpdateReference(value bool)  error {
	
	CGoReturnPtr := C.DeleteOptions_SetUpdateReference( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets/sets the monitor for tracking changes caused by the deletion.
// Returns:
//   AbstractFormulaChangeMonitor  
func (instance *DeleteOptions) GetFormulaChangeMonitor()  (*AbstractFormulaChangeMonitor,  error)  {
	
	CGoReturnPtr := C.DeleteOptions_GetFormulaChangeMonitor( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &AbstractFormulaChangeMonitor{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteAbstractFormulaChangeMonitor) 

	return result, nil 
}
// Gets/sets the monitor for tracking changes caused by the deletion.
// Parameters:
//   value - AbstractFormulaChangeMonitor 
// Returns:
//   void  
func (instance *DeleteOptions) SetFormulaChangeMonitor(value *AbstractFormulaChangeMonitor)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.DeleteOptions_SetFormulaChangeMonitor( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}



func DeleteDeleteOptions(deleteoptions *DeleteOptions){
	runtime.SetFinalizer(deleteoptions, nil)
	C.Delete_DeleteOptions(deleteoptions.ptr)
	deleteoptions.ptr = nil
}

// Class DifSaveOptions 

// Represents the options of saving dif file.
type DifSaveOptions struct {
	ptr unsafe.Pointer
}

// Creates the options for saving DIF file.
func NewDifSaveOptions() ( *DifSaveOptions, error) {
	difsaveoptions := &DifSaveOptions{}
	CGoReturnPtr := C.New_DifSaveOptions()
	if CGoReturnPtr.error_no == 0 {
		difsaveoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(difsaveoptions, DeleteDifSaveOptions)
		return difsaveoptions, nil
	} else {
		difsaveoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return difsaveoptions, err
	}	
}
// Constructs from a parent object.
// Parameters:
//   src - SaveOptions 
func NewDifSaveOptions_SaveOptions(src *SaveOptions) ( *DifSaveOptions, error) {
	difsaveoptions := &DifSaveOptions{}
	var src_ptr unsafe.Pointer = nil
	if src != nil {
	  src_ptr =src.ptr
	}

	CGoReturnPtr := C.New_DifSaveOptions_SaveOptions(src_ptr)
	if CGoReturnPtr.error_no == 0 {
		difsaveoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(difsaveoptions, DeleteDifSaveOptions)
		return difsaveoptions, nil
	} else {
		difsaveoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return difsaveoptions, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *DifSaveOptions) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.DifSaveOptions_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the save file format.
// Returns:
//   int32  
func (instance *DifSaveOptions) GetSaveFormat()  (SaveFormat,  error)  {
	
	CGoReturnPtr := C.DifSaveOptions_GetSaveFormat( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToSaveFormat(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Make the workbook empty after saving the file.
// Returns:
//   bool  
func (instance *DifSaveOptions) GetClearData()  (bool,  error)  {
	
	CGoReturnPtr := C.DifSaveOptions_GetClearData( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Make the workbook empty after saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *DifSaveOptions) SetClearData(value bool)  error {
	
	CGoReturnPtr := C.DifSaveOptions_SetClearData( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// The folder for temporary files that may be used as data cache.
// Returns:
//   string  
func (instance *DifSaveOptions) GetCachedFileFolder()  (string,  error)  {
	
	CGoReturnPtr := C.DifSaveOptions_GetCachedFileFolder( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// The folder for temporary files that may be used as data cache.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *DifSaveOptions) SetCachedFileFolder(value string)  error {
	
	CGoReturnPtr := C.DifSaveOptions_SetCachedFileFolder( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether validate merged cells before saving the file.
// Returns:
//   bool  
func (instance *DifSaveOptions) GetValidateMergedAreas()  (bool,  error)  {
	
	CGoReturnPtr := C.DifSaveOptions_GetValidateMergedAreas( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether validate merged cells before saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *DifSaveOptions) SetValidateMergedAreas(value bool)  error {
	
	CGoReturnPtr := C.DifSaveOptions_SetValidateMergedAreas( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether merge the areas of conditional formatting and validation before saving the file.
// Returns:
//   bool  
func (instance *DifSaveOptions) GetMergeAreas()  (bool,  error)  {
	
	CGoReturnPtr := C.DifSaveOptions_GetMergeAreas( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether merge the areas of conditional formatting and validation before saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *DifSaveOptions) SetMergeAreas(value bool)  error {
	
	CGoReturnPtr := C.DifSaveOptions_SetMergeAreas( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// If true and the directory does not exist, the directory will be automatically created before saving the file.
// Returns:
//   bool  
func (instance *DifSaveOptions) GetCreateDirectory()  (bool,  error)  {
	
	CGoReturnPtr := C.DifSaveOptions_GetCreateDirectory( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// If true and the directory does not exist, the directory will be automatically created before saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *DifSaveOptions) SetCreateDirectory(value bool)  error {
	
	CGoReturnPtr := C.DifSaveOptions_SetCreateDirectory( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether sorting defined names before saving file.
// Returns:
//   bool  
func (instance *DifSaveOptions) GetSortNames()  (bool,  error)  {
	
	CGoReturnPtr := C.DifSaveOptions_GetSortNames( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether sorting defined names before saving file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *DifSaveOptions) SetSortNames(value bool)  error {
	
	CGoReturnPtr := C.DifSaveOptions_SetSortNames( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether sorting external defined names before saving file.
// Returns:
//   bool  
func (instance *DifSaveOptions) GetSortExternalNames()  (bool,  error)  {
	
	CGoReturnPtr := C.DifSaveOptions_GetSortExternalNames( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether sorting external defined names before saving file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *DifSaveOptions) SetSortExternalNames(value bool)  error {
	
	CGoReturnPtr := C.DifSaveOptions_SetSortExternalNames( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether refreshing chart cache data
// Returns:
//   bool  
func (instance *DifSaveOptions) GetRefreshChartCache()  (bool,  error)  {
	
	CGoReturnPtr := C.DifSaveOptions_GetRefreshChartCache( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether refreshing chart cache data
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *DifSaveOptions) SetRefreshChartCache(value bool)  error {
	
	CGoReturnPtr := C.DifSaveOptions_SetRefreshChartCache( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Whether check restriction of excel file when user modify cells related objects.
// For example, excel does not allow inputting string value longer than 32K.
// When you input a value longer than 32K, it will be truncated.
// Returns:
//   bool  
func (instance *DifSaveOptions) GetCheckExcelRestriction()  (bool,  error)  {
	
	CGoReturnPtr := C.DifSaveOptions_GetCheckExcelRestriction( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Whether check restriction of excel file when user modify cells related objects.
// For example, excel does not allow inputting string value longer than 32K.
// When you input a value longer than 32K, it will be truncated.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *DifSaveOptions) SetCheckExcelRestriction(value bool)  error {
	
	CGoReturnPtr := C.DifSaveOptions_SetCheckExcelRestriction( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether updating smart art setting.
// The default value is false.
// Returns:
//   bool  
func (instance *DifSaveOptions) GetUpdateSmartArt()  (bool,  error)  {
	
	CGoReturnPtr := C.DifSaveOptions_GetUpdateSmartArt( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether updating smart art setting.
// The default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *DifSaveOptions) SetUpdateSmartArt(value bool)  error {
	
	CGoReturnPtr := C.DifSaveOptions_SetUpdateSmartArt( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether encrypt document properties when saving as .xls file.
// The default value is true.
// Returns:
//   bool  
func (instance *DifSaveOptions) GetEncryptDocumentProperties()  (bool,  error)  {
	
	CGoReturnPtr := C.DifSaveOptions_GetEncryptDocumentProperties( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether encrypt document properties when saving as .xls file.
// The default value is true.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *DifSaveOptions) SetEncryptDocumentProperties(value bool)  error {
	
	CGoReturnPtr := C.DifSaveOptions_SetEncryptDocumentProperties( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}


func (instance *DifSaveOptions) ToSaveOptions() *SaveOptions {
	parentClass := &SaveOptions{}
	parentClass.ptr = instance.ptr
	return parentClass
}

func DeleteDifSaveOptions(difsaveoptions *DifSaveOptions){
	runtime.SetFinalizer(difsaveoptions, nil)
	C.Delete_DifSaveOptions(difsaveoptions.ptr)
	difsaveoptions.ptr = nil
}

// Class DocxSaveOptions 

// Represents options of saving .docx file.
type DocxSaveOptions struct {
	ptr unsafe.Pointer
}

// Represents options of saving .docx file.
func NewDocxSaveOptions() ( *DocxSaveOptions, error) {
	docxsaveoptions := &DocxSaveOptions{}
	CGoReturnPtr := C.New_DocxSaveOptions()
	if CGoReturnPtr.error_no == 0 {
		docxsaveoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(docxsaveoptions, DeleteDocxSaveOptions)
		return docxsaveoptions, nil
	} else {
		docxsaveoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return docxsaveoptions, err
	}	
}
// Represents options of saving .docx file.
// Parameters:
//   saveAsImage - bool 
func NewDocxSaveOptions_Bool(saveasimage bool) ( *DocxSaveOptions, error) {
	docxsaveoptions := &DocxSaveOptions{}
	CGoReturnPtr := C.New_DocxSaveOptions_Boolean(C.bool(saveasimage))
	if CGoReturnPtr.error_no == 0 {
		docxsaveoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(docxsaveoptions, DeleteDocxSaveOptions)
		return docxsaveoptions, nil
	} else {
		docxsaveoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return docxsaveoptions, err
	}	
}
// Constructs from a parent object.
// Parameters:
//   src - PaginatedSaveOptions 
func NewDocxSaveOptions_PaginatedSaveOptions(src *PaginatedSaveOptions) ( *DocxSaveOptions, error) {
	docxsaveoptions := &DocxSaveOptions{}
	var src_ptr unsafe.Pointer = nil
	if src != nil {
	  src_ptr =src.ptr
	}

	CGoReturnPtr := C.New_DocxSaveOptions_PaginatedSaveOptions(src_ptr)
	if CGoReturnPtr.error_no == 0 {
		docxsaveoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(docxsaveoptions, DeleteDocxSaveOptions)
		return docxsaveoptions, nil
	} else {
		docxsaveoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return docxsaveoptions, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *DocxSaveOptions) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.DocxSaveOptions_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Save all drawing objects as editable shapes in the word file, so you can edit them in Word.
// Returns:
//   bool  
func (instance *DocxSaveOptions) GetSaveAsEditableShapes()  (bool,  error)  {
	
	CGoReturnPtr := C.DocxSaveOptions_GetSaveAsEditableShapes( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Save all drawing objects as editable shapes in the word file, so you can edit them in Word.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *DocxSaveOptions) SetSaveAsEditableShapes(value bool)  error {
	
	CGoReturnPtr := C.DocxSaveOptions_SetSaveAsEditableShapes( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// When characters in the Excel are Unicode and not be set with correct font in cell style,
// They may appear as block in pdf,image.
// Set the DefaultFont such as MingLiu or MS Gothic to show these characters.
// If this property is not set, Aspose.Cells will use system default font to show these unicode characters.
// Returns:
//   string  
func (instance *DocxSaveOptions) GetDefaultFont()  (string,  error)  {
	
	CGoReturnPtr := C.DocxSaveOptions_GetDefaultFont( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// When characters in the Excel are Unicode and not be set with correct font in cell style,
// They may appear as block in pdf,image.
// Set the DefaultFont such as MingLiu or MS Gothic to show these characters.
// If this property is not set, Aspose.Cells will use system default font to show these unicode characters.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *DocxSaveOptions) SetDefaultFont(value string)  error {
	
	CGoReturnPtr := C.DocxSaveOptions_SetDefaultFont( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// When characters in the Excel are Unicode and not be set with correct font in cell style,
// They may appear as block in pdf,image.
// Set this to true to try to use workbook's default font to show these characters first.
// Returns:
//   bool  
func (instance *DocxSaveOptions) GetCheckWorkbookDefaultFont()  (bool,  error)  {
	
	CGoReturnPtr := C.DocxSaveOptions_GetCheckWorkbookDefaultFont( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// When characters in the Excel are Unicode and not be set with correct font in cell style,
// They may appear as block in pdf,image.
// Set this to true to try to use workbook's default font to show these characters first.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *DocxSaveOptions) SetCheckWorkbookDefaultFont(value bool)  error {
	
	CGoReturnPtr := C.DocxSaveOptions_SetCheckWorkbookDefaultFont( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether to check font compatibility for every character in text.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *DocxSaveOptions) SetCheckFontCompatibility(value bool)  error {
	
	CGoReturnPtr := C.DocxSaveOptions_SetCheckFontCompatibility( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether to check font compatibility for every character in text.
// Returns:
//   bool  
func (instance *DocxSaveOptions) GetCheckFontCompatibility()  (bool,  error)  {
	
	CGoReturnPtr := C.DocxSaveOptions_GetCheckFontCompatibility( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether to only substitute the font of character when the cell font is not compatibility for it.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *DocxSaveOptions) SetIsFontSubstitutionCharGranularity(value bool)  error {
	
	CGoReturnPtr := C.DocxSaveOptions_SetIsFontSubstitutionCharGranularity( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether to only substitute the font of character when the cell font is not compatibility for it.
// Returns:
//   bool  
func (instance *DocxSaveOptions) IsFontSubstitutionCharGranularity()  (bool,  error)  {
	
	CGoReturnPtr := C.DocxSaveOptions_IsFontSubstitutionCharGranularity( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// If OnePagePerSheet is true , all content of one sheet will output to only one page in result.
// The paper size of pagesetup will be invalid, and the other settings of pagesetup
// will still take effect.
// Returns:
//   bool  
func (instance *DocxSaveOptions) GetOnePagePerSheet()  (bool,  error)  {
	
	CGoReturnPtr := C.DocxSaveOptions_GetOnePagePerSheet( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// If OnePagePerSheet is true , all content of one sheet will output to only one page in result.
// The paper size of pagesetup will be invalid, and the other settings of pagesetup
// will still take effect.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *DocxSaveOptions) SetOnePagePerSheet(value bool)  error {
	
	CGoReturnPtr := C.DocxSaveOptions_SetOnePagePerSheet( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// If AllColumnsInOnePagePerSheet is true , all column content of one sheet will output to only one page in result.
// The width of paper size of pagesetup will be ignored, and the other settings of pagesetup
// will still take effect.
// Returns:
//   bool  
func (instance *DocxSaveOptions) GetAllColumnsInOnePagePerSheet()  (bool,  error)  {
	
	CGoReturnPtr := C.DocxSaveOptions_GetAllColumnsInOnePagePerSheet( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// If AllColumnsInOnePagePerSheet is true , all column content of one sheet will output to only one page in result.
// The width of paper size of pagesetup will be ignored, and the other settings of pagesetup
// will still take effect.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *DocxSaveOptions) SetAllColumnsInOnePagePerSheet(value bool)  error {
	
	CGoReturnPtr := C.DocxSaveOptions_SetAllColumnsInOnePagePerSheet( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates if you need to hide the error while rendering.
// The error can be error in shape, image, chart rendering, etc.
// Returns:
//   bool  
func (instance *DocxSaveOptions) GetIgnoreError()  (bool,  error)  {
	
	CGoReturnPtr := C.DocxSaveOptions_GetIgnoreError( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates if you need to hide the error while rendering.
// The error can be error in shape, image, chart rendering, etc.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *DocxSaveOptions) SetIgnoreError(value bool)  error {
	
	CGoReturnPtr := C.DocxSaveOptions_SetIgnoreError( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether to output a blank page when there is nothing to print.
// Returns:
//   bool  
func (instance *DocxSaveOptions) GetOutputBlankPageWhenNothingToPrint()  (bool,  error)  {
	
	CGoReturnPtr := C.DocxSaveOptions_GetOutputBlankPageWhenNothingToPrint( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether to output a blank page when there is nothing to print.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *DocxSaveOptions) SetOutputBlankPageWhenNothingToPrint(value bool)  error {
	
	CGoReturnPtr := C.DocxSaveOptions_SetOutputBlankPageWhenNothingToPrint( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the 0-based index of the first page to save.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *DocxSaveOptions) SetPageIndex(value int32)  error {
	
	CGoReturnPtr := C.DocxSaveOptions_SetPageIndex( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the 0-based index of the first page to save.
// Returns:
//   int32  
func (instance *DocxSaveOptions) GetPageIndex()  (int32,  error)  {
	
	CGoReturnPtr := C.DocxSaveOptions_GetPageIndex( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets the number of pages to save.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *DocxSaveOptions) SetPageCount(value int32)  error {
	
	CGoReturnPtr := C.DocxSaveOptions_SetPageCount( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the number of pages to save.
// Returns:
//   int32  
func (instance *DocxSaveOptions) GetPageCount()  (int32,  error)  {
	
	CGoReturnPtr := C.DocxSaveOptions_GetPageCount( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates which pages will not be printed.
// Returns:
//   int32  
func (instance *DocxSaveOptions) GetPrintingPageType()  (PrintingPageType,  error)  {
	
	CGoReturnPtr := C.DocxSaveOptions_GetPrintingPageType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToPrintingPageType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Indicates which pages will not be printed.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *DocxSaveOptions) SetPrintingPageType(value PrintingPageType)  error {
	
	CGoReturnPtr := C.DocxSaveOptions_SetPrintingPageType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets gridline type.
// Returns:
//   int32  
func (instance *DocxSaveOptions) GetGridlineType()  (GridlineType,  error)  {
	
	CGoReturnPtr := C.DocxSaveOptions_GetGridlineType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToGridlineType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets or sets gridline type.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *DocxSaveOptions) SetGridlineType(value GridlineType)  error {
	
	CGoReturnPtr := C.DocxSaveOptions_SetGridlineType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets gridline color.
// Returns:
//   Color  
func (instance *DocxSaveOptions) GetGridlineColor()  (*Color,  error)  {
	
	CGoReturnPtr := C.DocxSaveOptions_GetGridlineColor( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Gets or sets gridline color.
// Parameters:
//   value - Color 
// Returns:
//   void  
func (instance *DocxSaveOptions) SetGridlineColor(value *Color)  error {
	
	CGoReturnPtr := C.DocxSaveOptions_SetGridlineColor( instance.ptr, value.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets displaying text type when the text width is larger than cell width.
// Returns:
//   int32  
func (instance *DocxSaveOptions) GetTextCrossType()  (TextCrossType,  error)  {
	
	CGoReturnPtr := C.DocxSaveOptions_GetTextCrossType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToTextCrossType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets or sets displaying text type when the text width is larger than cell width.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *DocxSaveOptions) SetTextCrossType(value TextCrossType)  error {
	
	CGoReturnPtr := C.DocxSaveOptions_SetTextCrossType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets default edit language.
// Returns:
//   int32  
func (instance *DocxSaveOptions) GetDefaultEditLanguage()  (DefaultEditLanguage,  error)  {
	
	CGoReturnPtr := C.DocxSaveOptions_GetDefaultEditLanguage( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToDefaultEditLanguage(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets or sets default edit language.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *DocxSaveOptions) SetDefaultEditLanguage(value DefaultEditLanguage)  error {
	
	CGoReturnPtr := C.DocxSaveOptions_SetDefaultEditLanguage( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the sheets to render. Default is all visible sheets in the workbook: <see cref="Aspose.Cells.Rendering.SheetSet.Visible"/>.
// Returns:
//   SheetSet  
func (instance *DocxSaveOptions) GetSheetSet()  (*SheetSet,  error)  {
	
	CGoReturnPtr := C.DocxSaveOptions_GetSheetSet( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &SheetSet{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteSheetSet) 

	return result, nil 
}
// Gets or sets the sheets to render. Default is all visible sheets in the workbook: <see cref="Aspose.Cells.Rendering.SheetSet.Visible"/>.
// Parameters:
//   value - SheetSet 
// Returns:
//   void  
func (instance *DocxSaveOptions) SetSheetSet(value *SheetSet)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.DocxSaveOptions_SetSheetSet( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Implements this interface to get DrawObject and Bound when rendering.
// Returns:
//   DrawObjectEventHandler  
func (instance *DocxSaveOptions) GetDrawObjectEventHandler()  (*DrawObjectEventHandler,  error)  {
	
	CGoReturnPtr := C.DocxSaveOptions_GetDrawObjectEventHandler( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &DrawObjectEventHandler{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteDrawObjectEventHandler) 

	return result, nil 
}
// Implements this interface to get DrawObject and Bound when rendering.
// Parameters:
//   value - DrawObjectEventHandler 
// Returns:
//   void  
func (instance *DocxSaveOptions) SetDrawObjectEventHandler(value *DrawObjectEventHandler)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.DocxSaveOptions_SetDrawObjectEventHandler( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Setting for rendering Emf metafile.
// Returns:
//   int32  
func (instance *DocxSaveOptions) GetEmfRenderSetting()  (EmfRenderSetting,  error)  {
	
	CGoReturnPtr := C.DocxSaveOptions_GetEmfRenderSetting( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToEmfRenderSetting(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Setting for rendering Emf metafile.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *DocxSaveOptions) SetEmfRenderSetting(value EmfRenderSetting)  error {
	
	CGoReturnPtr := C.DocxSaveOptions_SetEmfRenderSetting( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets custom settings during rendering.
// Returns:
//   CustomRenderSettings  
func (instance *DocxSaveOptions) GetCustomRenderSettings()  (*CustomRenderSettings,  error)  {
	
	CGoReturnPtr := C.DocxSaveOptions_GetCustomRenderSettings( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &CustomRenderSettings{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteCustomRenderSettings) 

	return result, nil 
}
// Gets or sets custom settings during rendering.
// Parameters:
//   value - CustomRenderSettings 
// Returns:
//   void  
func (instance *DocxSaveOptions) SetCustomRenderSettings(value *CustomRenderSettings)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.DocxSaveOptions_SetCustomRenderSettings( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the save file format.
// Returns:
//   int32  
func (instance *DocxSaveOptions) GetSaveFormat()  (SaveFormat,  error)  {
	
	CGoReturnPtr := C.DocxSaveOptions_GetSaveFormat( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToSaveFormat(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Make the workbook empty after saving the file.
// Returns:
//   bool  
func (instance *DocxSaveOptions) GetClearData()  (bool,  error)  {
	
	CGoReturnPtr := C.DocxSaveOptions_GetClearData( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Make the workbook empty after saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *DocxSaveOptions) SetClearData(value bool)  error {
	
	CGoReturnPtr := C.DocxSaveOptions_SetClearData( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// The folder for temporary files that may be used as data cache.
// Returns:
//   string  
func (instance *DocxSaveOptions) GetCachedFileFolder()  (string,  error)  {
	
	CGoReturnPtr := C.DocxSaveOptions_GetCachedFileFolder( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// The folder for temporary files that may be used as data cache.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *DocxSaveOptions) SetCachedFileFolder(value string)  error {
	
	CGoReturnPtr := C.DocxSaveOptions_SetCachedFileFolder( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether validate merged cells before saving the file.
// Returns:
//   bool  
func (instance *DocxSaveOptions) GetValidateMergedAreas()  (bool,  error)  {
	
	CGoReturnPtr := C.DocxSaveOptions_GetValidateMergedAreas( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether validate merged cells before saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *DocxSaveOptions) SetValidateMergedAreas(value bool)  error {
	
	CGoReturnPtr := C.DocxSaveOptions_SetValidateMergedAreas( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether merge the areas of conditional formatting and validation before saving the file.
// Returns:
//   bool  
func (instance *DocxSaveOptions) GetMergeAreas()  (bool,  error)  {
	
	CGoReturnPtr := C.DocxSaveOptions_GetMergeAreas( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether merge the areas of conditional formatting and validation before saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *DocxSaveOptions) SetMergeAreas(value bool)  error {
	
	CGoReturnPtr := C.DocxSaveOptions_SetMergeAreas( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// If true and the directory does not exist, the directory will be automatically created before saving the file.
// Returns:
//   bool  
func (instance *DocxSaveOptions) GetCreateDirectory()  (bool,  error)  {
	
	CGoReturnPtr := C.DocxSaveOptions_GetCreateDirectory( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// If true and the directory does not exist, the directory will be automatically created before saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *DocxSaveOptions) SetCreateDirectory(value bool)  error {
	
	CGoReturnPtr := C.DocxSaveOptions_SetCreateDirectory( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether sorting defined names before saving file.
// Returns:
//   bool  
func (instance *DocxSaveOptions) GetSortNames()  (bool,  error)  {
	
	CGoReturnPtr := C.DocxSaveOptions_GetSortNames( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether sorting defined names before saving file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *DocxSaveOptions) SetSortNames(value bool)  error {
	
	CGoReturnPtr := C.DocxSaveOptions_SetSortNames( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether sorting external defined names before saving file.
// Returns:
//   bool  
func (instance *DocxSaveOptions) GetSortExternalNames()  (bool,  error)  {
	
	CGoReturnPtr := C.DocxSaveOptions_GetSortExternalNames( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether sorting external defined names before saving file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *DocxSaveOptions) SetSortExternalNames(value bool)  error {
	
	CGoReturnPtr := C.DocxSaveOptions_SetSortExternalNames( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether refreshing chart cache data
// Returns:
//   bool  
func (instance *DocxSaveOptions) GetRefreshChartCache()  (bool,  error)  {
	
	CGoReturnPtr := C.DocxSaveOptions_GetRefreshChartCache( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether refreshing chart cache data
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *DocxSaveOptions) SetRefreshChartCache(value bool)  error {
	
	CGoReturnPtr := C.DocxSaveOptions_SetRefreshChartCache( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Whether check restriction of excel file when user modify cells related objects.
// For example, excel does not allow inputting string value longer than 32K.
// When you input a value longer than 32K, it will be truncated.
// Returns:
//   bool  
func (instance *DocxSaveOptions) GetCheckExcelRestriction()  (bool,  error)  {
	
	CGoReturnPtr := C.DocxSaveOptions_GetCheckExcelRestriction( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Whether check restriction of excel file when user modify cells related objects.
// For example, excel does not allow inputting string value longer than 32K.
// When you input a value longer than 32K, it will be truncated.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *DocxSaveOptions) SetCheckExcelRestriction(value bool)  error {
	
	CGoReturnPtr := C.DocxSaveOptions_SetCheckExcelRestriction( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether updating smart art setting.
// The default value is false.
// Returns:
//   bool  
func (instance *DocxSaveOptions) GetUpdateSmartArt()  (bool,  error)  {
	
	CGoReturnPtr := C.DocxSaveOptions_GetUpdateSmartArt( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether updating smart art setting.
// The default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *DocxSaveOptions) SetUpdateSmartArt(value bool)  error {
	
	CGoReturnPtr := C.DocxSaveOptions_SetUpdateSmartArt( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether encrypt document properties when saving as .xls file.
// The default value is true.
// Returns:
//   bool  
func (instance *DocxSaveOptions) GetEncryptDocumentProperties()  (bool,  error)  {
	
	CGoReturnPtr := C.DocxSaveOptions_GetEncryptDocumentProperties( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether encrypt document properties when saving as .xls file.
// The default value is true.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *DocxSaveOptions) SetEncryptDocumentProperties(value bool)  error {
	
	CGoReturnPtr := C.DocxSaveOptions_SetEncryptDocumentProperties( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}


func (instance *DocxSaveOptions) ToPaginatedSaveOptions() *PaginatedSaveOptions {
	parentClass := &PaginatedSaveOptions{}
	parentClass.ptr = instance.ptr
	return parentClass
}
func (instance *DocxSaveOptions) ToSaveOptions() *SaveOptions {
	parentClass := &SaveOptions{}
	parentClass.ptr = instance.ptr
	return parentClass
}

func DeleteDocxSaveOptions(docxsaveoptions *DocxSaveOptions){
	runtime.SetFinalizer(docxsaveoptions, nil)
	C.Delete_DocxSaveOptions(docxsaveoptions.ptr)
	docxsaveoptions.ptr = nil
}

// Class DxfCollection 

// Represents the master differential formatting records.
type DxfCollection struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *DxfCollection) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.DxfCollection_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the element at the specified index.
// Parameters:
//   index - int32 
// Returns:
//   Style  
func (instance *DxfCollection) Get(index int32)  (*Style,  error)  {
	
	CGoReturnPtr := C.DxfCollection_Get( instance.ptr, C.int(index))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Style{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteStyle) 

	return result, nil 
}
// Returns:
//   int32  
func (instance *DxfCollection) GetCount()  (int32,  error)  {
	
	CGoReturnPtr := C.DxfCollection_GetCount( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}



func DeleteDxfCollection(dxfcollection *DxfCollection){
	runtime.SetFinalizer(dxfcollection, nil)
	C.Delete_DxfCollection(dxfcollection.ptr)
	dxfcollection.ptr = nil
}

// Class DynamicFilter 

// Represents the dynamic filter.
type DynamicFilter struct {
	ptr unsafe.Pointer
}

// Constructs from an Object convertible to this.
// Parameters:
//   obj - Object 
func NewDynamicFilter(obj *Object) ( *DynamicFilter, error) {
	dynamicfilter := &DynamicFilter{}
	var obj_ptr unsafe.Pointer = nil
	if obj != nil {
	  obj_ptr =obj.ptr
	}

	CGoReturnPtr := C.New_DynamicFilter(obj_ptr)
	if CGoReturnPtr.error_no == 0 {
		dynamicfilter.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(dynamicfilter, DeleteDynamicFilter)
		return dynamicfilter, nil
	} else {
		dynamicfilter.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return dynamicfilter, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *DynamicFilter) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.DynamicFilter_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the Object.
// Returns:
//   Object  
func (instance *DynamicFilter) ToObject()  (*Object,  error)  {
	
	CGoReturnPtr := C.DynamicFilter_ToObject( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Object{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteObject) 

	return result, nil 
}
// Gets and sets the dynamic filter type.
// Returns:
//   int32  
func (instance *DynamicFilter) GetDynamicFilterType()  (DynamicFilterType,  error)  {
	
	CGoReturnPtr := C.DynamicFilter_GetDynamicFilterType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToDynamicFilterType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets and sets the dynamic filter type.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *DynamicFilter) SetDynamicFilterType(value DynamicFilterType)  error {
	
	CGoReturnPtr := C.DynamicFilter_SetDynamicFilterType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the dynamic filter value.
// Returns:
//   Object  
func (instance *DynamicFilter) GetValue()  (*Object,  error)  {
	
	CGoReturnPtr := C.DynamicFilter_GetValue( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Object{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteObject) 

	return result, nil 
}
// Gets and sets the dynamic filter value.
// Parameters:
//   value - Object 
// Returns:
//   void  
func (instance *DynamicFilter) SetValue(value *Object)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.DynamicFilter_SetValue( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the dynamic filter max value.
// Returns:
//   Object  
func (instance *DynamicFilter) GetMaxValue()  (*Object,  error)  {
	
	CGoReturnPtr := C.DynamicFilter_GetMaxValue( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Object{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteObject) 

	return result, nil 
}
// Gets and sets the dynamic filter max value.
// Parameters:
//   value - Object 
// Returns:
//   void  
func (instance *DynamicFilter) SetMaxValue(value *Object)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.DynamicFilter_SetMaxValue( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}



func DeleteDynamicFilter(dynamicfilter *DynamicFilter){
	runtime.SetFinalizer(dynamicfilter, nil)
	C.Delete_DynamicFilter(dynamicfilter.ptr)
	dynamicfilter.ptr = nil
}

// Class EbookLoadOptions 

// Represents options when importing an ebook file.
type EbookLoadOptions struct {
	ptr unsafe.Pointer
}

// Creates an options of loading the ebook file.
func NewEbookLoadOptions() ( *EbookLoadOptions, error) {
	ebookloadoptions := &EbookLoadOptions{}
	CGoReturnPtr := C.New_EbookLoadOptions()
	if CGoReturnPtr.error_no == 0 {
		ebookloadoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(ebookloadoptions, DeleteEbookLoadOptions)
		return ebookloadoptions, nil
	} else {
		ebookloadoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return ebookloadoptions, err
	}	
}
// Creates an options of loading the ebook file.
// Parameters:
//   loadFormat - int32 
func NewEbookLoadOptions_LoadFormat(loadformat LoadFormat) ( *EbookLoadOptions, error) {
	ebookloadoptions := &EbookLoadOptions{}
	CGoReturnPtr := C.New_EbookLoadOptions_LoadFormat(C.int( int32(loadformat)))
	if CGoReturnPtr.error_no == 0 {
		ebookloadoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(ebookloadoptions, DeleteEbookLoadOptions)
		return ebookloadoptions, nil
	} else {
		ebookloadoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return ebookloadoptions, err
	}	
}
// Constructs from a parent object.
// Parameters:
//   src - HtmlLoadOptions 
func NewEbookLoadOptions_HtmlLoadOptions(src *HtmlLoadOptions) ( *EbookLoadOptions, error) {
	ebookloadoptions := &EbookLoadOptions{}
	var src_ptr unsafe.Pointer = nil
	if src != nil {
	  src_ptr =src.ptr
	}

	CGoReturnPtr := C.New_EbookLoadOptions_HtmlLoadOptions(src_ptr)
	if CGoReturnPtr.error_no == 0 {
		ebookloadoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(ebookloadoptions, DeleteEbookLoadOptions)
		return ebookloadoptions, nil
	} else {
		ebookloadoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return ebookloadoptions, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *EbookLoadOptions) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.EbookLoadOptions_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the default encoding. Only applies for csv file.
// Returns:
//   int32  
func (instance *EbookLoadOptions) GetEncoding()  (EncodingType,  error)  {
	
	CGoReturnPtr := C.EbookLoadOptions_GetEncoding( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToEncodingType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets and sets the default encoding. Only applies for csv file.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *EbookLoadOptions) SetEncoding(value EncodingType)  error {
	
	CGoReturnPtr := C.EbookLoadOptions_SetEncoding( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates the strategy to apply style for parsed values when converting string value to number or datetime.
// Returns:
//   int32  
func (instance *EbookLoadOptions) GetLoadStyleStrategy()  (TxtLoadStyleStrategy,  error)  {
	
	CGoReturnPtr := C.EbookLoadOptions_GetLoadStyleStrategy( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToTxtLoadStyleStrategy(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Indicates the strategy to apply style for parsed values when converting string value to number or datetime.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *EbookLoadOptions) SetLoadStyleStrategy(value TxtLoadStyleStrategy)  error {
	
	CGoReturnPtr := C.EbookLoadOptions_SetLoadStyleStrategy( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets a value that indicates whether the string in text file is converted to numeric data.
// Returns:
//   bool  
func (instance *EbookLoadOptions) GetConvertNumericData()  (bool,  error)  {
	
	CGoReturnPtr := C.EbookLoadOptions_GetConvertNumericData( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets a value that indicates whether the string in text file is converted to numeric data.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *EbookLoadOptions) SetConvertNumericData(value bool)  error {
	
	CGoReturnPtr := C.EbookLoadOptions_SetConvertNumericData( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets a value that indicates whether the string in text file is converted to date data.
// Returns:
//   bool  
func (instance *EbookLoadOptions) GetConvertDateTimeData()  (bool,  error)  {
	
	CGoReturnPtr := C.EbookLoadOptions_GetConvertDateTimeData( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets a value that indicates whether the string in text file is converted to date data.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *EbookLoadOptions) SetConvertDateTimeData(value bool)  error {
	
	CGoReturnPtr := C.EbookLoadOptions_SetConvertDateTimeData( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether not parsing a string value if the length is 15.
// Returns:
//   bool  
func (instance *EbookLoadOptions) GetKeepPrecision()  (bool,  error)  {
	
	CGoReturnPtr := C.EbookLoadOptions_GetKeepPrecision( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether not parsing a string value if the length is 15.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *EbookLoadOptions) SetKeepPrecision(value bool)  error {
	
	CGoReturnPtr := C.EbookLoadOptions_SetKeepPrecision( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether importing formulas if the original html file contains formulas
// Returns:
//   bool  
func (instance *EbookLoadOptions) GetLoadFormulas()  (bool,  error)  {
	
	CGoReturnPtr := C.EbookLoadOptions_GetLoadFormulas( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether importing formulas if the original html file contains formulas
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *EbookLoadOptions) SetLoadFormulas(value bool)  error {
	
	CGoReturnPtr := C.EbookLoadOptions_SetLoadFormulas( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether support the layout of <c>&lt;div&gt;</c> tag when the html file contains it.
// The default value is false.
// Returns:
//   bool  
func (instance *EbookLoadOptions) GetSupportDivTag()  (bool,  error)  {
	
	CGoReturnPtr := C.EbookLoadOptions_GetSupportDivTag( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether support the layout of <c>&lt;div&gt;</c> tag when the html file contains it.
// The default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *EbookLoadOptions) SetSupportDivTag(value bool)  error {
	
	CGoReturnPtr := C.EbookLoadOptions_SetSupportDivTag( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether delete redundant spaces when the text wraps lines using <c>&lt;br&gt;</c> tag.
// The default value is false.
// Returns:
//   bool  
func (instance *EbookLoadOptions) GetDeleteRedundantSpaces()  (bool,  error)  {
	
	CGoReturnPtr := C.EbookLoadOptions_GetDeleteRedundantSpaces( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether delete redundant spaces when the text wraps lines using <c>&lt;br&gt;</c> tag.
// The default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *EbookLoadOptions) SetDeleteRedundantSpaces(value bool)  error {
	
	CGoReturnPtr := C.EbookLoadOptions_SetDeleteRedundantSpaces( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether auto-fit columns and rows. The default value is false.
// Returns:
//   bool  
func (instance *EbookLoadOptions) GetAutoFitColsAndRows()  (bool,  error)  {
	
	CGoReturnPtr := C.EbookLoadOptions_GetAutoFitColsAndRows( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether auto-fit columns and rows. The default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *EbookLoadOptions) SetAutoFitColsAndRows(value bool)  error {
	
	CGoReturnPtr := C.EbookLoadOptions_SetAutoFitColsAndRows( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether the text is formula if it starts with "=".
// Returns:
//   bool  
func (instance *EbookLoadOptions) GetHasFormula()  (bool,  error)  {
	
	CGoReturnPtr := C.EbookLoadOptions_GetHasFormula( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether the text is formula if it starts with "=".
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *EbookLoadOptions) SetHasFormula(value bool)  error {
	
	CGoReturnPtr := C.EbookLoadOptions_SetHasFormula( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the program id of creating the file.
// Only for MHT files.
// Returns:
//   string  
func (instance *EbookLoadOptions) GetProgId()  (string,  error)  {
	
	CGoReturnPtr := C.EbookLoadOptions_GetProgId( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Get the HtmlTableLoadOptionCollection instance
// Returns:
//   HtmlTableLoadOptionCollection  
func (instance *EbookLoadOptions) GetTableLoadOptions()  (*HtmlTableLoadOptionCollection,  error)  {
	
	CGoReturnPtr := C.EbookLoadOptions_GetTableLoadOptions( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &HtmlTableLoadOptionCollection{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteHtmlTableLoadOptionCollection) 

	return result, nil 
}
// Gets the load format.
// Returns:
//   int32  
func (instance *EbookLoadOptions) GetLoadFormat()  (LoadFormat,  error)  {
	
	CGoReturnPtr := C.EbookLoadOptions_GetLoadFormat( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToLoadFormat(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets and set the password of the workbook.
// Returns:
//   string  
func (instance *EbookLoadOptions) GetPassword()  (string,  error)  {
	
	CGoReturnPtr := C.EbookLoadOptions_GetPassword( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and set the password of the workbook.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *EbookLoadOptions) SetPassword(value string)  error {
	
	CGoReturnPtr := C.EbookLoadOptions_SetPassword( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether parsing the formula when reading the file.
// Returns:
//   bool  
func (instance *EbookLoadOptions) GetParsingFormulaOnOpen()  (bool,  error)  {
	
	CGoReturnPtr := C.EbookLoadOptions_GetParsingFormulaOnOpen( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether parsing the formula when reading the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *EbookLoadOptions) SetParsingFormulaOnOpen(value bool)  error {
	
	CGoReturnPtr := C.EbookLoadOptions_SetParsingFormulaOnOpen( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether parsing pivot cached records when loading the file.
// The default value is false.
// Returns:
//   bool  
func (instance *EbookLoadOptions) GetParsingPivotCachedRecords()  (bool,  error)  {
	
	CGoReturnPtr := C.EbookLoadOptions_GetParsingPivotCachedRecords( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether parsing pivot cached records when loading the file.
// The default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *EbookLoadOptions) SetParsingPivotCachedRecords(value bool)  error {
	
	CGoReturnPtr := C.EbookLoadOptions_SetParsingPivotCachedRecords( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Sets the default print paper size from default printer's setting.
// Parameters:
//   type - int32 
// Returns:
//   void  
func (instance *EbookLoadOptions) SetPaperSize(type_ PaperSizeType)  error {
	
	CGoReturnPtr := C.EbookLoadOptions_SetPaperSize( instance.ptr, C.int( int32(type_)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the user interface language of the Workbook version based on CountryCode that has saved the file.
// Returns:
//   int32  
func (instance *EbookLoadOptions) GetLanguageCode()  (CountryCode,  error)  {
	
	CGoReturnPtr := C.EbookLoadOptions_GetLanguageCode( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToCountryCode(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets or sets the user interface language of the Workbook version based on CountryCode that has saved the file.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *EbookLoadOptions) SetLanguageCode(value CountryCode)  error {
	
	CGoReturnPtr := C.EbookLoadOptions_SetLanguageCode( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the regional settings used for the Workbook that will be loaded.
// Returns:
//   int32  
func (instance *EbookLoadOptions) GetRegion()  (CountryCode,  error)  {
	
	CGoReturnPtr := C.EbookLoadOptions_GetRegion( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToCountryCode(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets or sets the regional settings used for the Workbook that will be loaded.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *EbookLoadOptions) SetRegion(value CountryCode)  error {
	
	CGoReturnPtr := C.EbookLoadOptions_SetRegion( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the default style settings for initializing styles of the workbook
// Returns:
//   DefaultStyleSettings  
func (instance *EbookLoadOptions) GetDefaultStyleSettings()  (*DefaultStyleSettings,  error)  {
	
	CGoReturnPtr := C.EbookLoadOptions_GetDefaultStyleSettings( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &DefaultStyleSettings{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteDefaultStyleSettings) 

	return result, nil 
}
// Gets and sets the interrupt monitor.
// Returns:
//   AbstractInterruptMonitor  
func (instance *EbookLoadOptions) GetInterruptMonitor()  (*AbstractInterruptMonitor,  error)  {
	
	CGoReturnPtr := C.EbookLoadOptions_GetInterruptMonitor( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &AbstractInterruptMonitor{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteAbstractInterruptMonitor) 

	return result, nil 
}
// Gets and sets the interrupt monitor.
// Parameters:
//   value - AbstractInterruptMonitor 
// Returns:
//   void  
func (instance *EbookLoadOptions) SetInterruptMonitor(value *AbstractInterruptMonitor)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.EbookLoadOptions_SetInterruptMonitor( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Ignore the data which are not printed if directly printing the file
// Returns:
//   bool  
func (instance *EbookLoadOptions) GetIgnoreNotPrinted()  (bool,  error)  {
	
	CGoReturnPtr := C.EbookLoadOptions_GetIgnoreNotPrinted( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Ignore the data which are not printed if directly printing the file
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *EbookLoadOptions) SetIgnoreNotPrinted(value bool)  error {
	
	CGoReturnPtr := C.EbookLoadOptions_SetIgnoreNotPrinted( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Check whether data is valid in the template file.
// Returns:
//   bool  
func (instance *EbookLoadOptions) GetCheckDataValid()  (bool,  error)  {
	
	CGoReturnPtr := C.EbookLoadOptions_GetCheckDataValid( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Check whether data is valid in the template file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *EbookLoadOptions) SetCheckDataValid(value bool)  error {
	
	CGoReturnPtr := C.EbookLoadOptions_SetCheckDataValid( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Whether check restriction of excel file when user modify cells related objects.
// For example, excel does not allow inputting string value longer than 32K.
// When you input a value longer than 32K such as by Cell.PutValue(string), if this property is true, you will get an Exception.
// If this property is false, we will accept your input string value as the cell's value so that later
// you can output the complete string value for other file formats such as CSV.
// However, if you have set such kind of value that is invalid for excel file format,
// you should not save the workbook as excel file format later. Otherwise there may be unexpected error for the generated excel file.
// Returns:
//   bool  
func (instance *EbookLoadOptions) GetCheckExcelRestriction()  (bool,  error)  {
	
	CGoReturnPtr := C.EbookLoadOptions_GetCheckExcelRestriction( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Whether check restriction of excel file when user modify cells related objects.
// For example, excel does not allow inputting string value longer than 32K.
// When you input a value longer than 32K such as by Cell.PutValue(string), if this property is true, you will get an Exception.
// If this property is false, we will accept your input string value as the cell's value so that later
// you can output the complete string value for other file formats such as CSV.
// However, if you have set such kind of value that is invalid for excel file format,
// you should not save the workbook as excel file format later. Otherwise there may be unexpected error for the generated excel file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *EbookLoadOptions) SetCheckExcelRestriction(value bool)  error {
	
	CGoReturnPtr := C.EbookLoadOptions_SetCheckExcelRestriction( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Whether keep the unparsed data in memory for the Workbook when it is loaded from template file. Default is true.
// Returns:
//   bool  
func (instance *EbookLoadOptions) GetKeepUnparsedData()  (bool,  error)  {
	
	CGoReturnPtr := C.EbookLoadOptions_GetKeepUnparsedData( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Whether keep the unparsed data in memory for the Workbook when it is loaded from template file. Default is true.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *EbookLoadOptions) SetKeepUnparsedData(value bool)  error {
	
	CGoReturnPtr := C.EbookLoadOptions_SetKeepUnparsedData( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// The filter to denote how to load data.
// Returns:
//   LoadFilter  
func (instance *EbookLoadOptions) GetLoadFilter()  (*LoadFilter,  error)  {
	
	CGoReturnPtr := C.EbookLoadOptions_GetLoadFilter( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &LoadFilter{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteLoadFilter) 

	return result, nil 
}
// The filter to denote how to load data.
// Parameters:
//   value - LoadFilter 
// Returns:
//   void  
func (instance *EbookLoadOptions) SetLoadFilter(value *LoadFilter)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.EbookLoadOptions_SetLoadFilter( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the memory usage options.
// Returns:
//   int32  
func (instance *EbookLoadOptions) GetMemorySetting()  (MemorySetting,  error)  {
	
	CGoReturnPtr := C.EbookLoadOptions_GetMemorySetting( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToMemorySetting(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets or sets the memory usage options.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *EbookLoadOptions) SetMemorySetting(value MemorySetting)  error {
	
	CGoReturnPtr := C.EbookLoadOptions_SetMemorySetting( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the auto fitter options
// Returns:
//   AutoFitterOptions  
func (instance *EbookLoadOptions) GetAutoFitterOptions()  (*AutoFitterOptions,  error)  {
	
	CGoReturnPtr := C.EbookLoadOptions_GetAutoFitterOptions( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &AutoFitterOptions{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteAutoFitterOptions) 

	return result, nil 
}
// Gets and sets the auto fitter options
// Parameters:
//   value - AutoFitterOptions 
// Returns:
//   void  
func (instance *EbookLoadOptions) SetAutoFitterOptions(value *AutoFitterOptions)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.EbookLoadOptions_SetAutoFitterOptions( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether auto filtering the data when loading the files.
// Returns:
//   bool  
func (instance *EbookLoadOptions) GetAutoFilter()  (bool,  error)  {
	
	CGoReturnPtr := C.EbookLoadOptions_GetAutoFilter( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether auto filtering the data when loading the files.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *EbookLoadOptions) SetAutoFilter(value bool)  error {
	
	CGoReturnPtr := C.EbookLoadOptions_SetAutoFilter( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets individual font configs.
// Only works for the <see cref="Workbook"/> which uses this <see cref="LoadOptions"/> to load.
// Returns:
//   IndividualFontConfigs  
func (instance *EbookLoadOptions) GetFontConfigs()  (*IndividualFontConfigs,  error)  {
	
	CGoReturnPtr := C.EbookLoadOptions_GetFontConfigs( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &IndividualFontConfigs{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteIndividualFontConfigs) 

	return result, nil 
}
// Gets and sets individual font configs.
// Only works for the <see cref="Workbook"/> which uses this <see cref="LoadOptions"/> to load.
// Parameters:
//   value - IndividualFontConfigs 
// Returns:
//   void  
func (instance *EbookLoadOptions) SetFontConfigs(value *IndividualFontConfigs)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.EbookLoadOptions_SetFontConfigs( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether ignoring useless shapes.
// Returns:
//   bool  
func (instance *EbookLoadOptions) GetIgnoreUselessShapes()  (bool,  error)  {
	
	CGoReturnPtr := C.EbookLoadOptions_GetIgnoreUselessShapes( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether ignoring useless shapes.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *EbookLoadOptions) SetIgnoreUselessShapes(value bool)  error {
	
	CGoReturnPtr := C.EbookLoadOptions_SetIgnoreUselessShapes( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether preserve those spaces and line breaks that are padded between formula tokens
// while getting and setting formulas.
// Default value is false.
// Returns:
//   bool  
func (instance *EbookLoadOptions) GetPreservePaddingSpacesInFormula()  (bool,  error)  {
	
	CGoReturnPtr := C.EbookLoadOptions_GetPreservePaddingSpacesInFormula( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether preserve those spaces and line breaks that are padded between formula tokens
// while getting and setting formulas.
// Default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *EbookLoadOptions) SetPreservePaddingSpacesInFormula(value bool)  error {
	
	CGoReturnPtr := C.EbookLoadOptions_SetPreservePaddingSpacesInFormula( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}


func (instance *EbookLoadOptions) ToHtmlLoadOptions() *HtmlLoadOptions {
	parentClass := &HtmlLoadOptions{}
	parentClass.ptr = instance.ptr
	return parentClass
}
func (instance *EbookLoadOptions) ToAbstractTextLoadOptions() *AbstractTextLoadOptions {
	parentClass := &AbstractTextLoadOptions{}
	parentClass.ptr = instance.ptr
	return parentClass
}
func (instance *EbookLoadOptions) ToLoadOptions() *LoadOptions {
	parentClass := &LoadOptions{}
	parentClass.ptr = instance.ptr
	return parentClass
}

func DeleteEbookLoadOptions(ebookloadoptions *EbookLoadOptions){
	runtime.SetFinalizer(ebookloadoptions, nil)
	C.Delete_EbookLoadOptions(ebookloadoptions.ptr)
	ebookloadoptions.ptr = nil
}

// Class ErrorCheckOption 

// Error check setting applied on certain ranges.
type ErrorCheckOption struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *ErrorCheckOption) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.ErrorCheckOption_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Checks whether given error type will be checked.
// Parameters:
//   errorCheckType - int32 
// Returns:
//   bool  
func (instance *ErrorCheckOption) IsErrorCheck(errorchecktype ErrorCheckType)  (bool,  error)  {
	
	CGoReturnPtr := C.ErrorCheckOption_IsErrorCheck( instance.ptr, C.int( int32(errorchecktype)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Sets whether given error type will be checked.
// Parameters:
//   errorCheckType - int32 
//   isCheck - bool 
// Returns:
//   void  
func (instance *ErrorCheckOption) SetErrorCheck(errorchecktype ErrorCheckType, ischeck bool)  error {
	
	CGoReturnPtr := C.ErrorCheckOption_SetErrorCheck( instance.ptr, C.int( int32(errorchecktype)), C.bool(ischeck))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the count of ranges that influenced by this setting.
// Returns:
//   int32  
func (instance *ErrorCheckOption) GetCountOfRange()  (int32,  error)  {
	
	CGoReturnPtr := C.ErrorCheckOption_GetCountOfRange( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Adds one influenced range by this setting.
// Parameters:
//   ca - CellArea 
// Returns:
//   int32  
func (instance *ErrorCheckOption) AddRange(ca *CellArea)  (int32,  error)  {
	
	var ca_ptr unsafe.Pointer = nil
	if ca != nil {
	  ca_ptr =ca.ptr
	}

	CGoReturnPtr := C.ErrorCheckOption_AddRange( instance.ptr, ca_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the influenced range of this setting by given index.
// Parameters:
//   index - int32 
// Returns:
//   CellArea  
func (instance *ErrorCheckOption) GetRange(index int32)  (*CellArea,  error)  {
	
	CGoReturnPtr := C.ErrorCheckOption_GetRange( instance.ptr, C.int(index))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &CellArea{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteCellArea) 

	return result, nil 
}
// Removes one range by given index.
// Parameters:
//   index - int32 
// Returns:
//   void  
func (instance *ErrorCheckOption) RemoveRange(index int32)  error {
	
	CGoReturnPtr := C.ErrorCheckOption_RemoveRange( instance.ptr, C.int(index))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}



func DeleteErrorCheckOption(errorcheckoption *ErrorCheckOption){
	runtime.SetFinalizer(errorcheckoption, nil)
	C.Delete_ErrorCheckOption(errorcheckoption.ptr)
	errorcheckoption.ptr = nil
}

// Class ErrorCheckOptionCollection 

// Represents all error check option.
type ErrorCheckOptionCollection struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *ErrorCheckOptionCollection) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.ErrorCheckOptionCollection_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets <see cref="ErrorCheckOption"/> object by the given index.
// Parameters:
//   index - int32 
// Returns:
//   ErrorCheckOption  
func (instance *ErrorCheckOptionCollection) Get(index int32)  (*ErrorCheckOption,  error)  {
	
	CGoReturnPtr := C.ErrorCheckOptionCollection_Get( instance.ptr, C.int(index))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &ErrorCheckOption{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteErrorCheckOption) 

	return result, nil 
}
// Add an error check option.
// Returns:
//   int32  
func (instance *ErrorCheckOptionCollection) Add()  (int32,  error)  {
	
	CGoReturnPtr := C.ErrorCheckOptionCollection_Add( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Returns:
//   int32  
func (instance *ErrorCheckOptionCollection) GetCount()  (int32,  error)  {
	
	CGoReturnPtr := C.ErrorCheckOptionCollection_GetCount( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}



func DeleteErrorCheckOptionCollection(errorcheckoptioncollection *ErrorCheckOptionCollection){
	runtime.SetFinalizer(errorcheckoptioncollection, nil)
	C.Delete_ErrorCheckOptionCollection(errorcheckoptioncollection.ptr)
	errorcheckoptioncollection.ptr = nil
}

// Class ExternalLink 

// Represents an external link in a workbook.
type ExternalLink struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *ExternalLink) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.ExternalLink_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the type of external link.
// Returns:
//   int32  
func (instance *ExternalLink) GetType()  (ExternalLinkType,  error)  {
	
	CGoReturnPtr := C.ExternalLink_GetType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToExternalLinkType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Get the path type of this external link
// Returns:
//   string  
func (instance *ExternalLink) GetPathType()  (string,  error)  {
	
	CGoReturnPtr := C.ExternalLink_GetPathType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents stored data source of the external link.
// Returns:
//   string  
func (instance *ExternalLink) GetOriginalDataSource()  (string,  error)  {
	
	CGoReturnPtr := C.ExternalLink_GetOriginalDataSource( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents stored data source of the external link.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *ExternalLink) SetOriginalDataSource(value string)  error {
	
	CGoReturnPtr := C.ExternalLink_SetOriginalDataSource( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents data source of the external link.
// Returns:
//   string  
func (instance *ExternalLink) GetDataSource()  (string,  error)  {
	
	CGoReturnPtr := C.ExternalLink_GetDataSource( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents data source of the external link.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *ExternalLink) SetDataSource(value string)  error {
	
	CGoReturnPtr := C.ExternalLink_SetDataSource( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Adds an external name.
// Parameters:
//   text - string 
//   referTo - string 
// Returns:
//   void  
func (instance *ExternalLink) AddExternalName(text string, referto string)  error {
	
	CGoReturnPtr := C.ExternalLink_AddExternalName( instance.ptr, C.CString(text), C.CString(referto))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether this external link is referenced by others.
// Returns:
//   bool  
func (instance *ExternalLink) IsReferred()  (bool,  error)  {
	
	CGoReturnPtr := C.ExternalLink_IsReferred( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether this external link is visible in MS Excel.
// Returns:
//   bool  
func (instance *ExternalLink) IsVisible()  (bool,  error)  {
	
	CGoReturnPtr := C.ExternalLink_IsVisible( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}



func DeleteExternalLink(externallink *ExternalLink){
	runtime.SetFinalizer(externallink, nil)
	C.Delete_ExternalLink(externallink.ptr)
	externallink.ptr = nil
}

// Class ExternalLinkCollection 

// Represents external links collection in a workbook.
type ExternalLinkCollection struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *ExternalLinkCollection) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.ExternalLinkCollection_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the number of elements actually contained in the collection.
// Returns:
//   int32  
func (instance *ExternalLinkCollection) GetCount()  (int32,  error)  {
	
	CGoReturnPtr := C.ExternalLinkCollection_GetCount( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Adds an external link.
// Parameters:
//   fileName - string 
//   sheetNames - []string 
// Returns:
//   int32  
func (instance *ExternalLinkCollection) Add_String_stringArray(filename string, sheetnames []string)  (int32,  error)  {
	
	vector_sheetnames := make([]*C.char, len(sheetnames))
	for i, str := range sheetnames {
	cStr := C.CString(str)
	defer C.free(unsafe.Pointer(cStr))
	vector_sheetnames[i] = cStr
	}

	CGoReturnPtr := C.ExternalLinkCollection_Add_String_U16StringArray( instance.ptr, C.CString(filename), unsafe.Pointer(&vector_sheetnames[0]), C.int( len(sheetnames)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Add an external link .
// Parameters:
//   directoryType - int32 
//   fileName - string 
//   sheetNames - []string 
// Returns:
//   int32  
func (instance *ExternalLinkCollection) Add_DirectoryType_String_stringArray(directorytype DirectoryType, filename string, sheetnames []string)  (int32,  error)  {
	
	vector_sheetnames := make([]*C.char, len(sheetnames))
	for i, str := range sheetnames {
	cStr := C.CString(str)
	defer C.free(unsafe.Pointer(cStr))
	vector_sheetnames[i] = cStr
	}

	CGoReturnPtr := C.ExternalLinkCollection_Add_DirectoryType_String_U16StringArray( instance.ptr, C.int( int32(directorytype)), C.CString(filename), unsafe.Pointer(&vector_sheetnames[0]), C.int( len(sheetnames)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the <see cref="ExternalLink"/> element at the specified index.
// Parameters:
//   index - int32 
// Returns:
//   ExternalLink  
func (instance *ExternalLinkCollection) Get(index int32)  (*ExternalLink,  error)  {
	
	CGoReturnPtr := C.ExternalLinkCollection_Get( instance.ptr, C.int(index))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &ExternalLink{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteExternalLink) 

	return result, nil 
}
// Removes all external links.
// Returns:
//   void  
func (instance *ExternalLinkCollection) Clear()  error {
	
	CGoReturnPtr := C.ExternalLinkCollection_Clear( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Removes all external links.
// Parameters:
//   updateReferencesAsLocal - bool 
// Returns:
//   void  
func (instance *ExternalLinkCollection) Clear_Bool(updatereferencesaslocal bool)  error {
	
	CGoReturnPtr := C.ExternalLinkCollection_Clear_Boolean( instance.ptr, C.bool(updatereferencesaslocal))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Removes the specified external link from the workbook.
// Parameters:
//   index - int32 
// Returns:
//   void  
func (instance *ExternalLinkCollection) RemoveAt_Int(index int32)  error {
	
	CGoReturnPtr := C.ExternalLinkCollection_RemoveAt_Integer( instance.ptr, C.int(index))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Removes the specified external link from the workbook.
// Parameters:
//   index - int32 
//   updateReferencesAsLocal - bool 
// Returns:
//   void  
func (instance *ExternalLinkCollection) RemoveAt_Int_Bool(index int32, updatereferencesaslocal bool)  error {
	
	CGoReturnPtr := C.ExternalLinkCollection_RemoveAt_Integer_Boolean( instance.ptr, C.int(index), C.bool(updatereferencesaslocal))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Get an enumerator that iterates through this collection.
// Returns:
//   unsafe.Pointer  
func (instance *ExternalLinkCollection) GetEnumerator()  (*ExternalLinkEnumerator,  error)  {
	
	CGoReturnPtr := C.ExternalLinkCollection_GetEnumerator( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &ExternalLinkEnumerator{}
	result.ptr = CGoReturnPtr.return_value
	runtime.SetFinalizer(result, DeleteExternalLinkEnumerator)
	 

	return result, nil 
}



func DeleteExternalLinkCollection(externallinkcollection *ExternalLinkCollection){
	runtime.SetFinalizer(externallinkcollection, nil)
	C.Delete_ExternalLinkCollection(externallinkcollection.ptr)
	externallinkcollection.ptr = nil
}

// Class FileFontSource 

// Represents the single TrueType font file stored in the file system.
type FileFontSource struct {
	ptr unsafe.Pointer
}

// Ctor.
// Parameters:
//   filePath - string 
func NewFileFontSource_String(filepath string) ( *FileFontSource, error) {
	filefontsource := &FileFontSource{}
	CGoReturnPtr := C.New_FileFontSource_String(C.CString(filepath))
	if CGoReturnPtr.error_no == 0 {
		filefontsource.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(filefontsource, DeleteFileFontSource)
		return filefontsource, nil
	} else {
		filefontsource.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return filefontsource, err
	}	
}
// Constructs from a parent object.
// Parameters:
//   src - FontSourceBase 
func NewFileFontSource_FontSourceBase(src *FontSourceBase) ( *FileFontSource, error) {
	filefontsource := &FileFontSource{}
	var src_ptr unsafe.Pointer = nil
	if src != nil {
	  src_ptr =src.ptr
	}

	CGoReturnPtr := C.New_FileFontSource_FontSourceBase(src_ptr)
	if CGoReturnPtr.error_no == 0 {
		filefontsource.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(filefontsource, DeleteFileFontSource)
		return filefontsource, nil
	} else {
		filefontsource.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return filefontsource, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *FileFontSource) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.FileFontSource_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Path to font file.
// Returns:
//   string  
func (instance *FileFontSource) GetFilePath()  (string,  error)  {
	
	CGoReturnPtr := C.FileFontSource_GetFilePath( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Returns the type of the font source.
// Returns:
//   int32  
func (instance *FileFontSource) GetType()  (FontSourceType,  error)  {
	
	CGoReturnPtr := C.FileFontSource_GetType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToFontSourceType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}


func (instance *FileFontSource) ToFontSourceBase() *FontSourceBase {
	parentClass := &FontSourceBase{}
	parentClass.ptr = instance.ptr
	return parentClass
}

func DeleteFileFontSource(filefontsource *FileFontSource){
	runtime.SetFinalizer(filefontsource, nil)
	C.Delete_FileFontSource(filefontsource.ptr)
	filefontsource.ptr = nil
}

// Class FileFormatInfo 

// Contains data returned by <see cref="FileFormatUtil"/> file format detection methods.
type FileFormatInfo struct {
	ptr unsafe.Pointer
}

// Default constructor.
func NewFileFormatInfo() ( *FileFormatInfo, error) {
	fileformatinfo := &FileFormatInfo{}
	CGoReturnPtr := C.New_FileFormatInfo()
	if CGoReturnPtr.error_no == 0 {
		fileformatinfo.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(fileformatinfo, DeleteFileFormatInfo)
		return fileformatinfo, nil
	} else {
		fileformatinfo.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return fileformatinfo, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *FileFormatInfo) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.FileFormatInfo_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets whether the file is protected by Microsoft Rights Management Server.
// Returns:
//   bool  
func (instance *FileFormatInfo) IsProtectedByRMS()  (bool,  error)  {
	
	CGoReturnPtr := C.FileFormatInfo_IsProtectedByRMS( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Returns true if the document is encrypted and requires a password to open.
// Returns:
//   bool  
func (instance *FileFormatInfo) IsEncrypted()  (bool,  error)  {
	
	CGoReturnPtr := C.FileFormatInfo_IsEncrypted( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the detected file format.
// Returns:
//   int32  
func (instance *FileFormatInfo) GetFileFormatType()  (FileFormatType,  error)  {
	
	CGoReturnPtr := C.FileFormatInfo_GetFileFormatType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToFileFormatType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets the detected load format.
// Returns:
//   int32  
func (instance *FileFormatInfo) GetLoadFormat()  (LoadFormat,  error)  {
	
	CGoReturnPtr := C.FileFormatInfo_GetLoadFormat( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToLoadFormat(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}



func DeleteFileFormatInfo(fileformatinfo *FileFormatInfo){
	runtime.SetFinalizer(fileformatinfo, nil)
	C.Delete_FileFormatInfo(fileformatinfo.ptr)
	fileformatinfo.ptr = nil
}

// Class FileFormatUtil 

// Provides utility methods for converting file format enums to strings or file extensions and back.
type FileFormatUtil struct {
	ptr unsafe.Pointer
}


// Detects and returns the information about a format of an excel stored in a stream.
// Parameters:
//   stream - []byte 
// Returns:
//   FileFormatInfo  
func FileFormatUtil_DetectFileFormat_Stream(stream []byte)  (*FileFormatInfo,  error)  {
	
	CGoReturnPtr := C.FileFormatUtil_DetectFileFormat_Stream(unsafe.Pointer(&stream[0]), C.int( len(stream)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &FileFormatInfo{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteFileFormatInfo) 

	return result, nil 
}
// Detects and returns the information about a format of an excel stored in a stream.
// Parameters:
//   stream - []byte 
//   password - string 
// Returns:
//   FileFormatInfo  
func FileFormatUtil_DetectFileFormat_Stream_String(stream []byte, password string)  (*FileFormatInfo,  error)  {
	
	CGoReturnPtr := C.FileFormatUtil_DetectFileFormat_Stream_String(unsafe.Pointer(&stream[0]), C.int( len(stream)), C.CString(password))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &FileFormatInfo{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteFileFormatInfo) 

	return result, nil 
}
// Detects and returns the information about a format of an excel stored in a stream.
// Parameters:
//   stream - []byte 
//   password - string 
// Returns:
//   bool  
func FileFormatUtil_VerifyPassword(stream []byte, password string)  (bool,  error)  {
	
	CGoReturnPtr := C.FileFormatUtil_VerifyPassword(unsafe.Pointer(&stream[0]), C.int( len(stream)), C.CString(password))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Detects and returns the information about a format of an excel stored in a file.
// Parameters:
//   filePath - string 
// Returns:
//   FileFormatInfo  
func FileFormatUtil_DetectFileFormat_String(filepath string)  (*FileFormatInfo,  error)  {
	
	CGoReturnPtr := C.FileFormatUtil_DetectFileFormat_String(C.CString(filepath))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &FileFormatInfo{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteFileFormatInfo) 

	return result, nil 
}
// Detects and returns the information about a format of an excel stored in a file.
// Parameters:
//   filePath - string 
//   password - string 
// Returns:
//   FileFormatInfo  
func FileFormatUtil_DetectFileFormat_String_String(filepath string, password string)  (*FileFormatInfo,  error)  {
	
	CGoReturnPtr := C.FileFormatUtil_DetectFileFormat_String_String(C.CString(filepath), C.CString(password))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &FileFormatInfo{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteFileFormatInfo) 

	return result, nil 
}
// Converting file format to save format.
// Parameters:
//   format - int32 
// Returns:
//   int32  
func FileFormatUtil_FileFormatToSaveFormat(format FileFormatType)  (SaveFormat,  error)  {
	
	CGoReturnPtr := C.FileFormatUtil_FileFormatToSaveFormat(C.int( int32(format)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToSaveFormat(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Converts a file name extension into a SaveFormat value.
// Parameters:
//   extension - string 
// Returns:
//   int32  
func FileFormatUtil_ExtensionToSaveFormat(extension string)  (SaveFormat,  error)  {
	
	CGoReturnPtr := C.FileFormatUtil_ExtensionToSaveFormat(C.CString(extension))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToSaveFormat(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Returns true if the extension is .xlt, .xltX, .xltm,.ots.
// Parameters:
//   extension - string 
// Returns:
//   bool  
func FileFormatUtil_IsTemplateFormat(extension string)  (bool,  error)  {
	
	CGoReturnPtr := C.FileFormatUtil_IsTemplateFormat(C.CString(extension))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Converts a load format enumerated value into a file extension.
// Parameters:
//   loadFormat - int32 
// Returns:
//   string  
func FileFormatUtil_LoadFormatToExtension(loadformat LoadFormat)  (string,  error)  {
	
	CGoReturnPtr := C.FileFormatUtil_LoadFormatToExtension(C.int( int32(loadformat)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Converts a LoadFormat value to a SaveFormat value if possible.
// Parameters:
//   loadFormat - int32 
// Returns:
//   int32  
func FileFormatUtil_LoadFormatToSaveFormat(loadformat LoadFormat)  (SaveFormat,  error)  {
	
	CGoReturnPtr := C.FileFormatUtil_LoadFormatToSaveFormat(C.int( int32(loadformat)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToSaveFormat(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Converts a save format enumerated value into a file extension.
// Parameters:
//   format - int32 
// Returns:
//   string  
func FileFormatUtil_SaveFormatToExtension(format SaveFormat)  (string,  error)  {
	
	CGoReturnPtr := C.FileFormatUtil_SaveFormatToExtension(C.int( int32(format)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Converts a SaveFormat value to a LoadFormat value if possible.
// Parameters:
//   saveFormat - int32 
// Returns:
//   int32  
func FileFormatUtil_SaveFormatToLoadFormat(saveformat SaveFormat)  (LoadFormat,  error)  {
	
	CGoReturnPtr := C.FileFormatUtil_SaveFormatToLoadFormat(C.int( int32(saveformat)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToLoadFormat(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}



func DeleteFileFormatUtil(fileformatutil *FileFormatUtil){
	runtime.SetFinalizer(fileformatutil, nil)
	C.Delete_FileFormatUtil(fileformatutil.ptr)
	fileformatutil.ptr = nil
}

// Class FilterColumn 

// Represents a filter for a single column. The Filter object is a member of the Filters collection
type FilterColumn struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *FilterColumn) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.FilterColumn_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether the AutoFilter button for this column is visible.
// Returns:
//   bool  
func (instance *FilterColumn) IsDropdownVisible()  (bool,  error)  {
	
	CGoReturnPtr := C.FilterColumn_IsDropdownVisible( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether the AutoFilter button for this column is visible.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *FilterColumn) SetIsDropdownVisible(value bool)  error {
	
	CGoReturnPtr := C.FilterColumn_SetIsDropdownVisible( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the condition of filtering data.
// Returns:
//   Object  
func (instance *FilterColumn) GetFilter()  (*Object,  error)  {
	
	CGoReturnPtr := C.FilterColumn_GetFilter( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Object{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteObject) 

	return result, nil 
}
// Gets and sets the condition of filtering data.
// Parameters:
//   value - Object 
// Returns:
//   void  
func (instance *FilterColumn) SetFilter(value *Object)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.FilterColumn_SetFilter( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the type fo filtering data.
// Returns:
//   int32  
func (instance *FilterColumn) GetFilterType()  (FilterType,  error)  {
	
	CGoReturnPtr := C.FilterColumn_GetFilterType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToFilterType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets and sets the type fo filtering data.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *FilterColumn) SetFilterType(value FilterType)  error {
	
	CGoReturnPtr := C.FilterColumn_SetFilterType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the column offset in the range.
// Returns:
//   int32  
func (instance *FilterColumn) GetFieldIndex()  (int32,  error)  {
	
	CGoReturnPtr := C.FilterColumn_GetFieldIndex( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the column offset in the range.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *FilterColumn) SetFieldIndex(value int32)  error {
	
	CGoReturnPtr := C.FilterColumn_SetFieldIndex( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}



func DeleteFilterColumn(filtercolumn *FilterColumn){
	runtime.SetFinalizer(filtercolumn, nil)
	C.Delete_FilterColumn(filtercolumn.ptr)
	filtercolumn.ptr = nil
}

// Class FilterColumnCollection 

// A collection of Filter objects that represents all the filters in an autofiltered range.
type FilterColumnCollection struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *FilterColumnCollection) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.FilterColumnCollection_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Parameters:
//   index - int32 
// Returns:
//   void  
func (instance *FilterColumnCollection) RemoveAt(index int32)  error {
	
	CGoReturnPtr := C.FilterColumnCollection_RemoveAt( instance.ptr, C.int(index))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Returns a single Filter object from a collection.
// Parameters:
//   index - int32 
// Returns:
//   FilterColumn  
func (instance *FilterColumnCollection) GetByIndex(index int32)  (*FilterColumn,  error)  {
	
	CGoReturnPtr := C.FilterColumnCollection_GetByIndex( instance.ptr, C.int(index))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &FilterColumn{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteFilterColumn) 

	return result, nil 
}
// Gets <see cref="FilterColumn"/> object at the special field.
// Parameters:
//   fieldIndex - int32 
// Returns:
//   FilterColumn  
func (instance *FilterColumnCollection) Get(fieldindex int32)  (*FilterColumn,  error)  {
	
	CGoReturnPtr := C.FilterColumnCollection_Get( instance.ptr, C.int(fieldindex))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &FilterColumn{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteFilterColumn) 

	return result, nil 
}
// Returns:
//   int32  
func (instance *FilterColumnCollection) GetCount()  (int32,  error)  {
	
	CGoReturnPtr := C.FilterColumnCollection_GetCount( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}



func DeleteFilterColumnCollection(filtercolumncollection *FilterColumnCollection){
	runtime.SetFinalizer(filtercolumncollection, nil)
	C.Delete_FilterColumnCollection(filtercolumncollection.ptr)
	filtercolumncollection.ptr = nil
}

// Class FindOptions 

// Represents find options.
type FindOptions struct {
	ptr unsafe.Pointer
}

// Default constructor.
func NewFindOptions() ( *FindOptions, error) {
	findoptions := &FindOptions{}
	CGoReturnPtr := C.New_FindOptions()
	if CGoReturnPtr.error_no == 0 {
		findoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(findoptions, DeleteFindOptions)
		return findoptions, nil
	} else {
		findoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return findoptions, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *FindOptions) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.FindOptions_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates if the searched string is case sensitive.
// Returns:
//   bool  
func (instance *FindOptions) GetCaseSensitive()  (bool,  error)  {
	
	CGoReturnPtr := C.FindOptions_GetCaseSensitive( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates if the searched string is case sensitive.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *FindOptions) SetCaseSensitive(value bool)  error {
	
	CGoReturnPtr := C.FindOptions_SetCaseSensitive( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Look at type.
// Returns:
//   int32  
func (instance *FindOptions) GetLookAtType()  (LookAtType,  error)  {
	
	CGoReturnPtr := C.FindOptions_GetLookAtType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToLookAtType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Look at type.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *FindOptions) SetLookAtType(value LookAtType)  error {
	
	CGoReturnPtr := C.FindOptions_SetLookAtType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the searched range.
// Returns:
//   CellArea  
func (instance *FindOptions) GetRange()  (*CellArea,  error)  {
	
	CGoReturnPtr := C.FindOptions_GetRange( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &CellArea{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteCellArea) 

	return result, nil 
}
// Sets the searched range.
// Parameters:
//   ca - CellArea 
// Returns:
//   void  
func (instance *FindOptions) SetRange(ca *CellArea)  error {
	
	var ca_ptr unsafe.Pointer = nil
	if ca != nil {
	  ca_ptr =ca.ptr
	}

	CGoReturnPtr := C.FindOptions_SetRange( instance.ptr, ca_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether the searched range is set.
// Returns:
//   bool  
func (instance *FindOptions) IsRangeSet()  (bool,  error)  {
	
	CGoReturnPtr := C.FindOptions_IsRangeSet( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Whether search backward for cells.
// Returns:
//   bool  
func (instance *FindOptions) GetSearchBackward()  (bool,  error)  {
	
	CGoReturnPtr := C.FindOptions_GetSearchBackward( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Whether search backward for cells.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *FindOptions) SetSearchBackward(value bool)  error {
	
	CGoReturnPtr := C.FindOptions_SetSearchBackward( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether search order by rows or columns.
// Returns:
//   bool  
func (instance *FindOptions) GetSearchOrderByRows()  (bool,  error)  {
	
	CGoReturnPtr := C.FindOptions_GetSearchOrderByRows( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether search order by rows or columns.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *FindOptions) SetSearchOrderByRows(value bool)  error {
	
	CGoReturnPtr := C.FindOptions_SetSearchOrderByRows( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Look in type.
// Returns:
//   int32  
func (instance *FindOptions) GetLookInType()  (LookInType,  error)  {
	
	CGoReturnPtr := C.FindOptions_GetLookInType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToLookInType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Look in type.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *FindOptions) SetLookInType(value LookInType)  error {
	
	CGoReturnPtr := C.FindOptions_SetLookInType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether the searched key is regex.
// If true the searched key will be taken as regex and parsed.
// Otherwise the key will be parsed according to the rules in ms excel.
// Returns:
//   bool  
func (instance *FindOptions) GetRegexKey()  (bool,  error)  {
	
	CGoReturnPtr := C.FindOptions_GetRegexKey( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether the searched key is regex.
// If true the searched key will be taken as regex and parsed.
// Otherwise the key will be parsed according to the rules in ms excel.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *FindOptions) SetRegexKey(value bool)  error {
	
	CGoReturnPtr := C.FindOptions_SetRegexKey( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether searched cell value type should be same with the searched key.
// Returns:
//   bool  
func (instance *FindOptions) GetValueTypeSensitive()  (bool,  error)  {
	
	CGoReturnPtr := C.FindOptions_GetValueTypeSensitive( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether searched cell value type should be same with the searched key.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *FindOptions) SetValueTypeSensitive(value bool)  error {
	
	CGoReturnPtr := C.FindOptions_SetValueTypeSensitive( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// The format to search for.
// Returns:
//   Style  
func (instance *FindOptions) GetStyle()  (*Style,  error)  {
	
	CGoReturnPtr := C.FindOptions_GetStyle( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Style{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteStyle) 

	return result, nil 
}
// The format to search for.
// Parameters:
//   value - Style 
// Returns:
//   void  
func (instance *FindOptions) SetStyle(value *Style)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.FindOptions_SetStyle( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets a value that indicates whether converting the searched string value to numeric data.
// Returns:
//   bool  
func (instance *FindOptions) GetConvertNumericData()  (bool,  error)  {
	
	CGoReturnPtr := C.FindOptions_GetConvertNumericData( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets a value that indicates whether converting the searched string value to numeric data.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *FindOptions) SetConvertNumericData(value bool)  error {
	
	CGoReturnPtr := C.FindOptions_SetConvertNumericData( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}



func DeleteFindOptions(findoptions *FindOptions){
	runtime.SetFinalizer(findoptions, nil)
	C.Delete_FindOptions(findoptions.ptr)
	findoptions.ptr = nil
}

// Class FolderFontSource 

// Represents the folder that contains TrueType font files.
type FolderFontSource struct {
	ptr unsafe.Pointer
}

// Ctor.
// Parameters:
//   folderPath - string 
//   scanSubfolders - bool 
func NewFolderFontSource_String_Bool(folderpath string, scansubfolders bool) ( *FolderFontSource, error) {
	folderfontsource := &FolderFontSource{}
	CGoReturnPtr := C.New_FolderFontSource_String_Boolean(C.CString(folderpath), C.bool(scansubfolders))
	if CGoReturnPtr.error_no == 0 {
		folderfontsource.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(folderfontsource, DeleteFolderFontSource)
		return folderfontsource, nil
	} else {
		folderfontsource.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return folderfontsource, err
	}	
}
// Constructs from a parent object.
// Parameters:
//   src - FontSourceBase 
func NewFolderFontSource_FontSourceBase(src *FontSourceBase) ( *FolderFontSource, error) {
	folderfontsource := &FolderFontSource{}
	var src_ptr unsafe.Pointer = nil
	if src != nil {
	  src_ptr =src.ptr
	}

	CGoReturnPtr := C.New_FolderFontSource_FontSourceBase(src_ptr)
	if CGoReturnPtr.error_no == 0 {
		folderfontsource.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(folderfontsource, DeleteFolderFontSource)
		return folderfontsource, nil
	} else {
		folderfontsource.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return folderfontsource, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *FolderFontSource) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.FolderFontSource_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Path to fonts folder.
// Returns:
//   string  
func (instance *FolderFontSource) GetFolderPath()  (string,  error)  {
	
	CGoReturnPtr := C.FolderFontSource_GetFolderPath( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Determines whether or not to scan the subfolders.
// Returns:
//   bool  
func (instance *FolderFontSource) GetScanSubFolders()  (bool,  error)  {
	
	CGoReturnPtr := C.FolderFontSource_GetScanSubFolders( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Returns the type of the font source.
// Returns:
//   int32  
func (instance *FolderFontSource) GetType()  (FontSourceType,  error)  {
	
	CGoReturnPtr := C.FolderFontSource_GetType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToFontSourceType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}


func (instance *FolderFontSource) ToFontSourceBase() *FontSourceBase {
	parentClass := &FontSourceBase{}
	parentClass.ptr = instance.ptr
	return parentClass
}

func DeleteFolderFontSource(folderfontsource *FolderFontSource){
	runtime.SetFinalizer(folderfontsource, nil)
	C.Delete_FolderFontSource(folderfontsource.ptr)
	folderfontsource.ptr = nil
}

// Class Font 

// Encapsulates the font object used in a spreadsheet.
type Font struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *Font) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.Font_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represent the character set.
// Returns:
//   int32  
func (instance *Font) GetCharset()  (int32,  error)  {
	
	CGoReturnPtr := C.Font_GetCharset( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represent the character set.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *Font) SetCharset(value int32)  error {
	
	CGoReturnPtr := C.Font_SetCharset( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets a value indicating whether the font is italic.
// Returns:
//   bool  
func (instance *Font) IsItalic()  (bool,  error)  {
	
	CGoReturnPtr := C.Font_IsItalic( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets a value indicating whether the font is italic.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Font) SetIsItalic(value bool)  error {
	
	CGoReturnPtr := C.Font_SetIsItalic( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets a value indicating whether the font is bold.
// Returns:
//   bool  
func (instance *Font) IsBold()  (bool,  error)  {
	
	CGoReturnPtr := C.Font_IsBold( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets a value indicating whether the font is bold.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Font) SetIsBold(value bool)  error {
	
	CGoReturnPtr := C.Font_SetIsBold( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the text caps type.
// Returns:
//   int32  
func (instance *Font) GetCapsType()  (TextCapsType,  error)  {
	
	CGoReturnPtr := C.Font_GetCapsType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToTextCapsType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets and sets the text caps type.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *Font) SetCapsType(value TextCapsType)  error {
	
	CGoReturnPtr := C.Font_SetCapsType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the strike type of the text.
// Returns:
//   int32  
func (instance *Font) GetStrikeType()  (TextStrikeType,  error)  {
	
	CGoReturnPtr := C.Font_GetStrikeType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToTextStrikeType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets the strike type of the text.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *Font) SetStrikeType(value TextStrikeType)  error {
	
	CGoReturnPtr := C.Font_SetStrikeType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets a value indicating whether the font is single strikeout.
// Returns:
//   bool  
func (instance *Font) IsStrikeout()  (bool,  error)  {
	
	CGoReturnPtr := C.Font_IsStrikeout( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets a value indicating whether the font is single strikeout.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Font) SetIsStrikeout(value bool)  error {
	
	CGoReturnPtr := C.Font_SetIsStrikeout( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the script offset,in unit of percentage
// Returns:
//   float64  
func (instance *Font) GetScriptOffset()  (float64,  error)  {
	
	CGoReturnPtr := C.Font_GetScriptOffset( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := float64(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the script offset,in unit of percentage
// Parameters:
//   value - float64 
// Returns:
//   void  
func (instance *Font) SetScriptOffset(value float64)  error {
	
	CGoReturnPtr := C.Font_SetScriptOffset( instance.ptr, C.double(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets a value indicating whether the font is super script.
// Returns:
//   bool  
func (instance *Font) IsSuperscript()  (bool,  error)  {
	
	CGoReturnPtr := C.Font_IsSuperscript( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets a value indicating whether the font is super script.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Font) SetIsSuperscript(value bool)  error {
	
	CGoReturnPtr := C.Font_SetIsSuperscript( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets a value indicating whether the font is subscript.
// Returns:
//   bool  
func (instance *Font) IsSubscript()  (bool,  error)  {
	
	CGoReturnPtr := C.Font_IsSubscript( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets a value indicating whether the font is subscript.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Font) SetIsSubscript(value bool)  error {
	
	CGoReturnPtr := C.Font_SetIsSubscript( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the font underline type.
// Returns:
//   int32  
func (instance *Font) GetUnderline()  (FontUnderlineType,  error)  {
	
	CGoReturnPtr := C.Font_GetUnderline( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToFontUnderlineType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets or sets the font underline type.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *Font) SetUnderline(value FontUnderlineType)  error {
	
	CGoReturnPtr := C.Font_SetUnderline( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the double size of the font.
// Returns:
//   float64  
func (instance *Font) GetDoubleSize()  (float64,  error)  {
	
	CGoReturnPtr := C.Font_GetDoubleSize( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := float64(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the double size of the font.
// Parameters:
//   value - float64 
// Returns:
//   void  
func (instance *Font) SetDoubleSize(value float64)  error {
	
	CGoReturnPtr := C.Font_SetDoubleSize( instance.ptr, C.double(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the size of the font.
// Returns:
//   int32  
func (instance *Font) GetSize()  (int32,  error)  {
	
	CGoReturnPtr := C.Font_GetSize( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets the size of the font.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *Font) SetSize(value int32)  error {
	
	CGoReturnPtr := C.Font_SetSize( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the theme color.
// Returns:
//   ThemeColor  
func (instance *Font) GetThemeColor()  (*ThemeColor,  error)  {
	
	CGoReturnPtr := C.Font_GetThemeColor( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &ThemeColor{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteThemeColor) 

	return result, nil 
}
// Gets and sets the theme color.
// Parameters:
//   value - ThemeColor 
// Returns:
//   void  
func (instance *Font) SetThemeColor(value *ThemeColor)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.Font_SetThemeColor( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the <see cref="Color"/> of the font.
// Returns:
//   Color  
func (instance *Font) GetColor()  (*Color,  error)  {
	
	CGoReturnPtr := C.Font_GetColor( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Gets or sets the <see cref="Color"/> of the font.
// Parameters:
//   value - Color 
// Returns:
//   void  
func (instance *Font) SetColor(value *Color)  error {
	
	CGoReturnPtr := C.Font_SetColor( instance.ptr, value.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the color with a 32-bit ARGB value.
// Returns:
//   int32  
func (instance *Font) GetArgbColor()  (int32,  error)  {
	
	CGoReturnPtr := C.Font_GetArgbColor( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the color with a 32-bit ARGB value.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *Font) SetArgbColor(value int32)  error {
	
	CGoReturnPtr := C.Font_SetArgbColor( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Checks if two fonts are equals.
// Parameters:
//   font - Font 
// Returns:
//   bool  
func (instance *Font) Equals(font *Font)  (bool,  error)  {
	
	var font_ptr unsafe.Pointer = nil
	if font != nil {
	  font_ptr =font.ptr
	}

	CGoReturnPtr := C.Font_Equals( instance.ptr, font_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether the normalization of height that is to be applied to the text run.
// Returns:
//   bool  
func (instance *Font) IsNormalizeHeights()  (bool,  error)  {
	
	CGoReturnPtr := C.Font_IsNormalizeHeights( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether the normalization of height that is to be applied to the text run.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Font) SetIsNormalizeHeights(value bool)  error {
	
	CGoReturnPtr := C.Font_SetIsNormalizeHeights( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the scheme type of the font.
// Returns:
//   int32  
func (instance *Font) GetSchemeType()  (FontSchemeType,  error)  {
	
	CGoReturnPtr := C.Font_GetSchemeType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToFontSchemeType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets and sets the scheme type of the font.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *Font) SetSchemeType(value FontSchemeType)  error {
	
	CGoReturnPtr := C.Font_SetSchemeType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Returns a string represents the current Cell object.
// Returns:
//   string  
func (instance *Font) ToString()  (string,  error)  {
	
	CGoReturnPtr := C.Font_ToString( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets  or sets the name of the <see cref="Font"/>.
// Returns:
//   string  
func (instance *Font) GetName()  (string,  error)  {
	
	CGoReturnPtr := C.Font_GetName( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets  or sets the name of the <see cref="Font"/>.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *Font) SetName(value string)  error {
	
	CGoReturnPtr := C.Font_SetName( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}



func DeleteFont(font *Font){
	runtime.SetFinalizer(font, nil)
	C.Delete_Font(font.ptr)
	font.ptr = nil
}

// Class FontConfigs 

// Specifies font settings
type FontConfigs struct {
	ptr unsafe.Pointer
}

// Default constructor.
func NewFontConfigs() ( *FontConfigs, error) {
	fontconfigs := &FontConfigs{}
	CGoReturnPtr := C.New_FontConfigs()
	if CGoReturnPtr.error_no == 0 {
		fontconfigs.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(fontconfigs, DeleteFontConfigs)
		return fontconfigs, nil
	} else {
		fontconfigs.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return fontconfigs, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *FontConfigs) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.FontConfigs_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicate whether the font is available.
// Parameters:
//   fontName - string 
// Returns:
//   bool  
func FontConfigs_IsFontAvailable(fontname string)  (bool,  error)  {
	
	CGoReturnPtr := C.FontConfigs_IsFontAvailable(C.CString(fontname))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Get data infomation of font file data.
// Parameters:
//   fontName - string 
//   isBold - bool 
//   isItalic - bool 
//   isExactStyle - bool 
// Returns:
//   FontFileDataInfo  
func FontConfigs_GetFontFileDataInfo(fontname string, isbold bool, isitalic bool, isexactstyle bool)  (*FontFileDataInfo,  error)  {
	
	CGoReturnPtr := C.FontConfigs_GetFontFileDataInfo(C.CString(fontname), C.bool(isbold), C.bool(isitalic), C.bool(isexactstyle))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &FontFileDataInfo{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteFontFileDataInfo) 

	return result, nil 
}
// Gets or sets the default font name.
// Returns:
//   string  
func FontConfigs_GetDefaultFontName()  (string,  error)  {
	
	CGoReturnPtr := C.FontConfigs_GetDefaultFontName()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets the default font name.
// Parameters:
//   value - string 
// Returns:
//   void  
func FontConfigs_SetDefaultFontName(value string)  error {
	
	CGoReturnPtr := C.FontConfigs_SetDefaultFontName(C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicate whether to use system font substitutes first or not when a font is not presented and the substitute of this font is not set.
// e.g. On Ubuntu, "Arial" font is generally substituted by "Liberation Sans".
// Default value is false.
// Returns:
//   bool  
func FontConfigs_GetPreferSystemFontSubstitutes()  (bool,  error)  {
	
	CGoReturnPtr := C.FontConfigs_GetPreferSystemFontSubstitutes()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicate whether to use system font substitutes first or not when a font is not presented and the substitute of this font is not set.
// e.g. On Ubuntu, "Arial" font is generally substituted by "Liberation Sans".
// Default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func FontConfigs_SetPreferSystemFontSubstitutes(value bool)  error {
	
	CGoReturnPtr := C.FontConfigs_SetPreferSystemFontSubstitutes(C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Font substitute names for given original font name.
// Parameters:
//   originalFontName - string 
//   substituteFontNames - []string 
// Returns:
//   void  
func FontConfigs_SetFontSubstitutes(originalfontname string, substitutefontnames []string)  error {
	
	vector_substitutefontnames := make([]*C.char, len(substitutefontnames))
	for i, str := range substitutefontnames {
	cStr := C.CString(str)
	defer C.free(unsafe.Pointer(cStr))
	vector_substitutefontnames[i] = cStr
	}

	CGoReturnPtr := C.FontConfigs_SetFontSubstitutes(C.CString(originalfontname), unsafe.Pointer(&vector_substitutefontnames[0]), C.int( len(substitutefontnames)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Returns array containing font substitute names to be used if original font is not presented.
// Parameters:
//   originalFontName - string 
// Returns:
//   []string  
func FontConfigs_GetFontSubstitutes(originalfontname string)  ([]string,  error)  {
	
	CGoReturnPtr := C.FontConfigs_GetFontSubstitutes(C.CString(originalfontname))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result:= make([]string, CGoReturnPtr.column_length)
	for i := 0; i < int(CGoReturnPtr.column_length); i++ {
	   offset := uintptr(C.size_t(i)) * uintptr(CGoReturnPtr.size)
	   cObject := *(*C.char)(unsafe.Pointer( uintptr( unsafe.Pointer(CGoReturnPtr.return_value)) + offset))
	   goObject :=string(cObject)
	   result[i] = goObject
	}
	 

	return result, nil 
}
// Sets the fonts folder
// Parameters:
//   fontFolder - string 
//   recursive - bool 
// Returns:
//   void  
func FontConfigs_SetFontFolder(fontfolder string, recursive bool)  error {
	
	CGoReturnPtr := C.FontConfigs_SetFontFolder(C.CString(fontfolder), C.bool(recursive))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Sets the fonts folders
// Parameters:
//   fontFolders - []string 
//   recursive - bool 
// Returns:
//   void  
func FontConfigs_SetFontFolders(fontfolders []string, recursive bool)  error {
	
	vector_fontfolders := make([]*C.char, len(fontfolders))
	for i, str := range fontfolders {
	cStr := C.CString(str)
	defer C.free(unsafe.Pointer(cStr))
	vector_fontfolders[i] = cStr
	}

	CGoReturnPtr := C.FontConfigs_SetFontFolders(unsafe.Pointer(&vector_fontfolders[0]), C.int( len(fontfolders)), C.bool(recursive))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Sets the fonts sources.
// Parameters:
//   sources - []FontSourceBase 
// Returns:
//   void  
func FontConfigs_SetFontSources(sources []FontSourceBase)  error {
	
	sources_length := len(sources)
	vector_sources:= make([]unsafe.Pointer, sources_length)
	for i := 0; i < sources_length; i++ {
		vector_sources[i] = sources[i].ptr
	}


	CGoReturnPtr := C.FontConfigs_SetFontSources(unsafe.Pointer(&vector_sources[0]), C.int( len(sources)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets a copy of the array that contains the list of sources
// Returns:
//   []FontSourceBase  
func FontConfigs_GetFontSources()  ([]FontSourceBase,  error)  {
	
	CGoReturnPtr := C.FontConfigs_GetFontSources()
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result:= make([]FontSourceBase, CGoReturnPtr.column_length)
	for i := 0; i < int(CGoReturnPtr.column_length); i++ {
	   offset := uintptr(C.size_t(i)) * uintptr(CGoReturnPtr.size)
	   goObject := &FontSourceBase{}
	   goObject.ptr =unsafe.Pointer(uintptr( unsafe.Pointer(CGoReturnPtr.return_value)) + offset)
	   result[i] = *goObject
	}
	 

	return result, nil 
}



func DeleteFontConfigs(fontconfigs *FontConfigs){
	runtime.SetFinalizer(fontconfigs, nil)
	C.Delete_FontConfigs(fontconfigs.ptr)
	fontconfigs.ptr = nil
}

// Class FontFileDataInfo 

// Represents data infomation of font file data.
type FontFileDataInfo struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *FontFileDataInfo) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.FontFileDataInfo_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets binary data of font file.
// Returns:
//   []byte  
func (instance *FontFileDataInfo) GetData()  ([]byte,  error)  {
	
	CGoReturnPtr := C.FontFileDataInfo_GetData( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := C.GoBytes(unsafe.Pointer(CGoReturnPtr.return_value), C.int(CGoReturnPtr.column_length))
	 

	return result, nil 
}
// Gets font format type of font file.
// Returns:
//   int32  
func (instance *FontFileDataInfo) GetFormatType()  (FontFileFormatType,  error)  {
	
	CGoReturnPtr := C.FontFileDataInfo_GetFormatType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToFontFileFormatType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}



func DeleteFontFileDataInfo(fontfiledatainfo *FontFileDataInfo){
	runtime.SetFinalizer(fontfiledatainfo, nil)
	C.Delete_FontFileDataInfo(fontfiledatainfo.ptr)
	fontfiledatainfo.ptr = nil
}

// Class FontSetting 

// Represents a range of characters within the cell text.
type FontSetting struct {
	ptr unsafe.Pointer
}

// Parameters:
//   startIndex - int32 
//   length - int32 
//   sheets - WorksheetCollection 
func NewFontSetting(startindex int32, length int32, sheets *WorksheetCollection) ( *FontSetting, error) {
	fontsetting := &FontSetting{}
	var sheets_ptr unsafe.Pointer = nil
	if sheets != nil {
	  sheets_ptr =sheets.ptr
	}

	CGoReturnPtr := C.New_FontSetting(C.int(startindex), C.int(length), sheets_ptr)
	if CGoReturnPtr.error_no == 0 {
		fontsetting.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(fontsetting, DeleteFontSetting)
		return fontsetting, nil
	} else {
		fontsetting.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return fontsetting, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *FontSetting) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.FontSetting_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the start index of the characters.
// Returns:
//   int32  
func (instance *FontSetting) GetStartIndex()  (int32,  error)  {
	
	CGoReturnPtr := C.FontSetting_GetStartIndex( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the length of the characters.
// Returns:
//   int32  
func (instance *FontSetting) GetLength()  (int32,  error)  {
	
	CGoReturnPtr := C.FontSetting_GetLength( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Returns the font of this object.
// Returns:
//   Font  
func (instance *FontSetting) GetFont()  (*Font,  error)  {
	
	CGoReturnPtr := C.FontSetting_GetFont( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Font{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteFont) 

	return result, nil 
}
// Sets the preset WordArt style.
// Parameters:
//   style - int32 
// Returns:
//   void  
func (instance *FontSetting) SetWordArtStyle(style PresetWordArtStyle)  error {
	
	CGoReturnPtr := C.FontSetting_SetWordArtStyle( instance.ptr, C.int( int32(style)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Returns the text options.
// Returns:
//   TextOptions  
func (instance *FontSetting) GetTextOptions()  (*TextOptions,  error)  {
	
	CGoReturnPtr := C.FontSetting_GetTextOptions( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &TextOptions{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteTextOptions) 

	return result, nil 
}
// Gets the type of text node.
// Returns:
//   int32  
func (instance *FontSetting) GetType()  (TextNodeType,  error)  {
	
	CGoReturnPtr := C.FontSetting_GetType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToTextNodeType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}



func DeleteFontSetting(fontsetting *FontSetting){
	runtime.SetFinalizer(fontsetting, nil)
	C.Delete_FontSetting(fontsetting.ptr)
	fontsetting.ptr = nil
}

// Class FontSourceBase 

// This is an abstract base class for the classes that allow the user to specify various font sources
type FontSourceBase struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *FontSourceBase) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.FontSourceBase_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Returns the type of the font source.
// Returns:
//   int32  
func (instance *FontSourceBase) GetType()  (FontSourceType,  error)  {
	
	CGoReturnPtr := C.FontSourceBase_GetType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToFontSourceType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}



func DeleteFontSourceBase(fontsourcebase *FontSourceBase){
	runtime.SetFinalizer(fontsourcebase, nil)
	C.Delete_FontSourceBase(fontsourcebase.ptr)
	fontsourcebase.ptr = nil
}

// Class FormatCondition 

// Represents conditional formatting condition.
type FormatCondition struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *FormatCondition) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.FormatCondition_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the value or expression associated with this format condition.
// Parameters:
//   isR1C1 - bool 
//   isLocal - bool 
// Returns:
//   string  
func (instance *FormatCondition) GetFormula1_Bool_Bool(isr1c1 bool, islocal bool)  (string,  error)  {
	
	CGoReturnPtr := C.FormatCondition_GetFormula1_Boolean_Boolean( instance.ptr, C.bool(isr1c1), C.bool(islocal))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the value or expression associated with this format condition.
// Parameters:
//   isR1C1 - bool 
//   isLocal - bool 
// Returns:
//   string  
func (instance *FormatCondition) GetFormula2_Bool_Bool(isr1c1 bool, islocal bool)  (string,  error)  {
	
	CGoReturnPtr := C.FormatCondition_GetFormula2_Boolean_Boolean( instance.ptr, C.bool(isr1c1), C.bool(islocal))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the value or expression of the conditional formatting of the cell.
// Parameters:
//   isR1C1 - bool 
//   isLocal - bool 
//   row - int32 
//   column - int32 
// Returns:
//   string  
func (instance *FormatCondition) GetFormula1_Bool_Bool_Int_Int(isr1c1 bool, islocal bool, row int32, column int32)  (string,  error)  {
	
	CGoReturnPtr := C.FormatCondition_GetFormula1_Boolean_Boolean_Integer_Integer( instance.ptr, C.bool(isr1c1), C.bool(islocal), C.int(row), C.int(column))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the value or expression of the conditional formatting of the cell.
// Parameters:
//   isR1C1 - bool 
//   isLocal - bool 
//   row - int32 
//   column - int32 
// Returns:
//   string  
func (instance *FormatCondition) GetFormula2_Bool_Bool_Int_Int(isr1c1 bool, islocal bool, row int32, column int32)  (string,  error)  {
	
	CGoReturnPtr := C.FormatCondition_GetFormula2_Boolean_Boolean_Integer_Integer( instance.ptr, C.bool(isr1c1), C.bool(islocal), C.int(row), C.int(column))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Sets the value or expression associated with this format condition.
// Parameters:
//   formula1 - string 
//   formula2 - string 
//   isR1C1 - bool 
//   isLocal - bool 
// Returns:
//   void  
func (instance *FormatCondition) SetFormulas(formula1 string, formula2 string, isr1c1 bool, islocal bool)  error {
	
	CGoReturnPtr := C.FormatCondition_SetFormulas( instance.ptr, C.CString(formula1), C.CString(formula2), C.bool(isr1c1), C.bool(islocal))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Sets the value or expression associated with this format condition.
// Parameters:
//   formula - string 
//   isR1C1 - bool 
//   isLocal - bool 
// Returns:
//   void  
func (instance *FormatCondition) SetFormula1_String_Bool_Bool(formula string, isr1c1 bool, islocal bool)  error {
	
	CGoReturnPtr := C.FormatCondition_SetFormula1_String_Boolean_Boolean( instance.ptr, C.CString(formula), C.bool(isr1c1), C.bool(islocal))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Sets the value or expression associated with this format condition.
// Parameters:
//   formula - string 
//   isR1C1 - bool 
//   isLocal - bool 
// Returns:
//   void  
func (instance *FormatCondition) SetFormula2_String_Bool_Bool(formula string, isr1c1 bool, islocal bool)  error {
	
	CGoReturnPtr := C.FormatCondition_SetFormula2_String_Boolean_Boolean( instance.ptr, C.CString(formula), C.bool(isr1c1), C.bool(islocal))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the value or expression associated with conditional formatting.
// Returns:
//   string  
func (instance *FormatCondition) GetFormula1()  (string,  error)  {
	
	CGoReturnPtr := C.FormatCondition_GetFormula1( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the value or expression associated with conditional formatting.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *FormatCondition) SetFormula1_String(value string)  error {
	
	CGoReturnPtr := C.FormatCondition_SetFormula1_String( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the formula of the conditional formatting of the cell.
// Parameters:
//   row - int32 
//   column - int32 
// Returns:
//   string  
func (instance *FormatCondition) GetFormula1_Int_Int(row int32, column int32)  (string,  error)  {
	
	CGoReturnPtr := C.FormatCondition_GetFormula1_Integer_Integer( instance.ptr, C.int(row), C.int(column))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the value or expression associated with conditional formatting.
// Returns:
//   string  
func (instance *FormatCondition) GetFormula2()  (string,  error)  {
	
	CGoReturnPtr := C.FormatCondition_GetFormula2( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the value or expression associated with conditional formatting.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *FormatCondition) SetFormula2_String(value string)  error {
	
	CGoReturnPtr := C.FormatCondition_SetFormula2_String( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the formula of the conditional formatting of the cell.
// Parameters:
//   row - int32 
//   column - int32 
// Returns:
//   string  
func (instance *FormatCondition) GetFormula2_Int_Int(row int32, column int32)  (string,  error)  {
	
	CGoReturnPtr := C.FormatCondition_GetFormula2_Integer_Integer( instance.ptr, C.int(row), C.int(column))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the conditional format operator type.
// Returns:
//   int32  
func (instance *FormatCondition) GetOperator()  (OperatorType,  error)  {
	
	CGoReturnPtr := C.FormatCondition_GetOperator( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToOperatorType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets and sets the conditional format operator type.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *FormatCondition) SetOperator(value OperatorType)  error {
	
	CGoReturnPtr := C.FormatCondition_SetOperator( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// True, no rules with lower priority may be applied over this rule, when this rule evaluates to true.
// Only applies for Excel 2007;
// Returns:
//   bool  
func (instance *FormatCondition) GetStopIfTrue()  (bool,  error)  {
	
	CGoReturnPtr := C.FormatCondition_GetStopIfTrue( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// True, no rules with lower priority may be applied over this rule, when this rule evaluates to true.
// Only applies for Excel 2007;
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *FormatCondition) SetStopIfTrue(value bool)  error {
	
	CGoReturnPtr := C.FormatCondition_SetStopIfTrue( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// The priority of this conditional formatting rule. This value is used to determine which
// format should be evaluated and rendered. Lower numeric values are higher priority than
// higher numeric values, where '1' is the highest priority.
// Returns:
//   int32  
func (instance *FormatCondition) GetPriority()  (int32,  error)  {
	
	CGoReturnPtr := C.FormatCondition_GetPriority( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// The priority of this conditional formatting rule. This value is used to determine which
// format should be evaluated and rendered. Lower numeric values are higher priority than
// higher numeric values, where '1' is the highest priority.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *FormatCondition) SetPriority(value int32)  error {
	
	CGoReturnPtr := C.FormatCondition_SetPriority( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or setts style of conditional formatted cell ranges.
// Returns:
//   Style  
func (instance *FormatCondition) GetStyle()  (*Style,  error)  {
	
	CGoReturnPtr := C.FormatCondition_GetStyle( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Style{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteStyle) 

	return result, nil 
}
// Gets or setts style of conditional formatted cell ranges.
// Parameters:
//   value - Style 
// Returns:
//   void  
func (instance *FormatCondition) SetStyle(value *Style)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.FormatCondition_SetStyle( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets whether the conditional format Type.
// Returns:
//   int32  
func (instance *FormatCondition) GetType()  (FormatConditionType,  error)  {
	
	CGoReturnPtr := C.FormatCondition_GetType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToFormatConditionType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets and sets whether the conditional format Type.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *FormatCondition) SetType(value FormatConditionType)  error {
	
	CGoReturnPtr := C.FormatCondition_SetType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Get the conditional formatting's "IconSet" instance.
// The default instance's IconSetType is TrafficLights31.
// Valid only for type = IconSet.
// Returns:
//   IconSet  
func (instance *FormatCondition) GetIconSet()  (*IconSet,  error)  {
	
	CGoReturnPtr := C.FormatCondition_GetIconSet( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &IconSet{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteIconSet) 

	return result, nil 
}
// Get the conditional formatting's "DataBar" instance.
// The default instance's color is blue.
// Valid only for type is DataBar.
// Returns:
//   DataBar  
func (instance *FormatCondition) GetDataBar()  (*DataBar,  error)  {
	
	CGoReturnPtr := C.FormatCondition_GetDataBar( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &DataBar{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteDataBar) 

	return result, nil 
}
// Get the conditional formatting's "ColorScale" instance.
// The default instance is a "green-yellow-red" 3ColorScale .
// Valid only for type = ColorScale.
// Returns:
//   ColorScale  
func (instance *FormatCondition) GetColorScale()  (*ColorScale,  error)  {
	
	CGoReturnPtr := C.FormatCondition_GetColorScale( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &ColorScale{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteColorScale) 

	return result, nil 
}
// Get the conditional formatting's "Top10" instance.
// The default instance's rule highlights cells whose
// values fall in the top 10 bracket.
// Valid only for type is Top10.
// Returns:
//   Top10  
func (instance *FormatCondition) GetTop10()  (*Top10,  error)  {
	
	CGoReturnPtr := C.FormatCondition_GetTop10( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Top10{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteTop10) 

	return result, nil 
}
// Get the conditional formatting's "AboveAverage" instance.
// The default instance's rule highlights cells that are
// above the average for all values in the range.
// Valid only for type = AboveAverage.
// Returns:
//   AboveAverage  
func (instance *FormatCondition) GetAboveAverage()  (*AboveAverage,  error)  {
	
	CGoReturnPtr := C.FormatCondition_GetAboveAverage( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &AboveAverage{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteAboveAverage) 

	return result, nil 
}
// The text value in a "text contains" conditional formatting rule.
// Valid only for type = containsText, notContainsText, beginsWith and endsWith.
// The default value is null.
// Returns:
//   string  
func (instance *FormatCondition) GetText()  (string,  error)  {
	
	CGoReturnPtr := C.FormatCondition_GetText( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// The text value in a "text contains" conditional formatting rule.
// Valid only for type = containsText, notContainsText, beginsWith and endsWith.
// The default value is null.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *FormatCondition) SetText(value string)  error {
	
	CGoReturnPtr := C.FormatCondition_SetText( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// The applicable time period in a "date occurring" conditional formatting rule.
// Valid only for type = timePeriod.
// The default value is TimePeriodType.Today.
// Returns:
//   int32  
func (instance *FormatCondition) GetTimePeriod()  (TimePeriodType,  error)  {
	
	CGoReturnPtr := C.FormatCondition_GetTimePeriod( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToTimePeriodType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// The applicable time period in a "date occurring" conditional formatting rule.
// Valid only for type = timePeriod.
// The default value is TimePeriodType.Today.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *FormatCondition) SetTimePeriod(value TimePeriodType)  error {
	
	CGoReturnPtr := C.FormatCondition_SetTimePeriod( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}



func DeleteFormatCondition(formatcondition *FormatCondition){
	runtime.SetFinalizer(formatcondition, nil)
	C.Delete_FormatCondition(formatcondition.ptr)
	formatcondition.ptr = nil
}

// Class FormatConditionCollection 

// Represents conditional formatting.
// The FormatConditions can contain up to three conditional formats.
type FormatConditionCollection struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *FormatConditionCollection) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.FormatConditionCollection_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Adds a formatting condition and effected cell rang to the FormatConditions
// The FormatConditions can contain up to three conditional formats.
// References to the other sheets are not allowed in the formulas of conditional formatting.
// Parameters:
//   cellArea - CellArea 
//   type - int32 
//   operatorType - int32 
//   formula1 - string 
//   formula2 - string 
// Returns:
//   []int32_t  
func (instance *FormatConditionCollection) Add(cellarea *CellArea, type_ FormatConditionType, operatortype OperatorType, formula1 string, formula2 string)  ([]int32,  error)  {
	
	var cellarea_ptr unsafe.Pointer = nil
	if cellarea != nil {
	  cellarea_ptr =cellarea.ptr
	}

	CGoReturnPtr := C.FormatConditionCollection_Add( instance.ptr, cellarea_ptr, C.int( int32(type_)), C.int( int32(operatortype)), C.CString(formula1), C.CString(formula2))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result:= make([]int32, CGoReturnPtr.column_length)
	for i := 0; i < int(CGoReturnPtr.column_length); i++ {
	   offset := uintptr(C.size_t(i)) * uintptr(CGoReturnPtr.size)
	   cObject := *(*C.int)(unsafe.Pointer( uintptr( unsafe.Pointer(CGoReturnPtr.return_value)) + offset))
	   goObject :=int32(cObject)
	   result[i] = goObject
	}
	 

	return result, nil 
}
// Adds a conditional formatted cell range.
// Parameters:
//   cellArea - CellArea 
// Returns:
//   int32  
func (instance *FormatConditionCollection) AddArea(cellarea *CellArea)  (int32,  error)  {
	
	var cellarea_ptr unsafe.Pointer = nil
	if cellarea != nil {
	  cellarea_ptr =cellarea.ptr
	}

	CGoReturnPtr := C.FormatConditionCollection_AddArea( instance.ptr, cellarea_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Adds a formatting condition.
// Parameters:
//   type - int32 
//   operatorType - int32 
//   formula1 - string 
//   formula2 - string 
// Returns:
//   int32  
func (instance *FormatConditionCollection) AddCondition_FormatConditionType_OperatorType_String_String(type_ FormatConditionType, operatortype OperatorType, formula1 string, formula2 string)  (int32,  error)  {
	
	CGoReturnPtr := C.FormatConditionCollection_AddCondition_FormatConditionType_OperatorType_String_String( instance.ptr, C.int( int32(type_)), C.int( int32(operatortype)), C.CString(formula1), C.CString(formula2))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Add a format condition.
// Parameters:
//   type - int32 
// Returns:
//   int32  
func (instance *FormatConditionCollection) AddCondition_FormatConditionType(type_ FormatConditionType)  (int32,  error)  {
	
	CGoReturnPtr := C.FormatConditionCollection_AddCondition_FormatConditionType( instance.ptr, C.int( int32(type_)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the count of the conditions.
// Returns:
//   int32  
func (instance *FormatConditionCollection) GetCount()  (int32,  error)  {
	
	CGoReturnPtr := C.FormatConditionCollection_GetCount( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets count of conditionally formatted ranges.
// Returns:
//   int32  
func (instance *FormatConditionCollection) GetRangeCount()  (int32,  error)  {
	
	CGoReturnPtr := C.FormatConditionCollection_GetRangeCount( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the formatting condition by index.
// Parameters:
//   index - int32 
// Returns:
//   FormatCondition  
func (instance *FormatConditionCollection) Get(index int32)  (*FormatCondition,  error)  {
	
	CGoReturnPtr := C.FormatConditionCollection_Get( instance.ptr, C.int(index))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &FormatCondition{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteFormatCondition) 

	return result, nil 
}
// Gets the conditional formatted cell range by index.
// Parameters:
//   index - int32 
// Returns:
//   CellArea  
func (instance *FormatConditionCollection) GetCellArea(index int32)  (*CellArea,  error)  {
	
	CGoReturnPtr := C.FormatConditionCollection_GetCellArea( instance.ptr, C.int(index))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &CellArea{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteCellArea) 

	return result, nil 
}
// Removes conditional formatted cell range by index.
// Parameters:
//   index - int32 
// Returns:
//   void  
func (instance *FormatConditionCollection) RemoveArea_Int(index int32)  error {
	
	CGoReturnPtr := C.FormatConditionCollection_RemoveArea_Integer( instance.ptr, C.int(index))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Remove conditional formatting int the range.
// Parameters:
//   startRow - int32 
//   startColumn - int32 
//   totalRows - int32 
//   totalColumns - int32 
// Returns:
//   bool  
func (instance *FormatConditionCollection) RemoveArea_Int_Int_Int_Int(startrow int32, startcolumn int32, totalrows int32, totalcolumns int32)  (bool,  error)  {
	
	CGoReturnPtr := C.FormatConditionCollection_RemoveArea_Integer_Integer_Integer_Integer( instance.ptr, C.int(startrow), C.int(startcolumn), C.int(totalrows), C.int(totalcolumns))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Removes the formatting condition by index.
// Parameters:
//   index - int32 
// Returns:
//   void  
func (instance *FormatConditionCollection) RemoveCondition(index int32)  error {
	
	CGoReturnPtr := C.FormatConditionCollection_RemoveCondition( instance.ptr, C.int(index))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}



func DeleteFormatConditionCollection(formatconditioncollection *FormatConditionCollection){
	runtime.SetFinalizer(formatconditioncollection, nil)
	C.Delete_FormatConditionCollection(formatconditioncollection.ptr)
	formatconditioncollection.ptr = nil
}

// Class FormulaParseOptions 

// Represents options when parsing formula.
type FormulaParseOptions struct {
	ptr unsafe.Pointer
}

// Default constructor.
func NewFormulaParseOptions() ( *FormulaParseOptions, error) {
	formulaparseoptions := &FormulaParseOptions{}
	CGoReturnPtr := C.New_FormulaParseOptions()
	if CGoReturnPtr.error_no == 0 {
		formulaparseoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(formulaparseoptions, DeleteFormulaParseOptions)
		return formulaparseoptions, nil
	} else {
		formulaparseoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return formulaparseoptions, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *FormulaParseOptions) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.FormulaParseOptions_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Whether the formula is locale formatted. Default is false.
// Returns:
//   bool  
func (instance *FormulaParseOptions) GetLocaleDependent()  (bool,  error)  {
	
	CGoReturnPtr := C.FormulaParseOptions_GetLocaleDependent( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Whether the formula is locale formatted. Default is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *FormulaParseOptions) SetLocaleDependent(value bool)  error {
	
	CGoReturnPtr := C.FormulaParseOptions_SetLocaleDependent( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Whether the formula is R1C1 reference style. Default is false.
// Returns:
//   bool  
func (instance *FormulaParseOptions) GetR1C1Style()  (bool,  error)  {
	
	CGoReturnPtr := C.FormulaParseOptions_GetR1C1Style( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Whether the formula is R1C1 reference style. Default is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *FormulaParseOptions) SetR1C1Style(value bool)  error {
	
	CGoReturnPtr := C.FormulaParseOptions_SetR1C1Style( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Whether check addins in existing external links of current workbook for user defined function without external link.
// Default is true(if user defined function matches one addin in existing external links, then take it as the addin).
// Returns:
//   bool  
func (instance *FormulaParseOptions) GetCheckAddIn()  (bool,  error)  {
	
	CGoReturnPtr := C.FormulaParseOptions_GetCheckAddIn( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Whether check addins in existing external links of current workbook for user defined function without external link.
// Default is true(if user defined function matches one addin in existing external links, then take it as the addin).
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *FormulaParseOptions) SetCheckAddIn(value bool)  error {
	
	CGoReturnPtr := C.FormulaParseOptions_SetCheckAddIn( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Whether parse given formula. Default is true.
// If it is false, then given formula string will be kept as it is for the cell until user call other methods to parse them
// or parsed formula data is required by other operations such as calculating formulas.
// Returns:
//   bool  
func (instance *FormulaParseOptions) GetParse()  (bool,  error)  {
	
	CGoReturnPtr := C.FormulaParseOptions_GetParse( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Whether parse given formula. Default is true.
// If it is false, then given formula string will be kept as it is for the cell until user call other methods to parse them
// or parsed formula data is required by other operations such as calculating formulas.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *FormulaParseOptions) SetParse(value bool)  error {
	
	CGoReturnPtr := C.FormulaParseOptions_SetParse( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Definition for parsing custom functions.
// Returns:
//   CustomFunctionDefinition  
func (instance *FormulaParseOptions) GetCustomFunctionDefinition()  (*CustomFunctionDefinition,  error)  {
	
	CGoReturnPtr := C.FormulaParseOptions_GetCustomFunctionDefinition( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &CustomFunctionDefinition{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteCustomFunctionDefinition) 

	return result, nil 
}
// Definition for parsing custom functions.
// Parameters:
//   value - CustomFunctionDefinition 
// Returns:
//   void  
func (instance *FormulaParseOptions) SetCustomFunctionDefinition(value *CustomFunctionDefinition)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.FormulaParseOptions_SetCustomFunctionDefinition( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}



func DeleteFormulaParseOptions(formulaparseoptions *FormulaParseOptions){
	runtime.SetFinalizer(formulaparseoptions, nil)
	C.Delete_FormulaParseOptions(formulaparseoptions.ptr)
	formulaparseoptions.ptr = nil
}

// Class FormulaSettings 

// Settings of formulas and calculation.
type FormulaSettings struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *FormulaSettings) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.FormulaSettings_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether the application is required to perform a full calculation when the workbook is opened.
// Returns:
//   bool  
func (instance *FormulaSettings) GetCalculateOnOpen()  (bool,  error)  {
	
	CGoReturnPtr := C.FormulaSettings_GetCalculateOnOpen( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether the application is required to perform a full calculation when the workbook is opened.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *FormulaSettings) SetCalculateOnOpen(value bool)  error {
	
	CGoReturnPtr := C.FormulaSettings_SetCalculateOnOpen( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether recalculate the workbook before saving the document, when in manual calculation mode.
// Returns:
//   bool  
func (instance *FormulaSettings) GetCalculateOnSave()  (bool,  error)  {
	
	CGoReturnPtr := C.FormulaSettings_GetCalculateOnSave( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether recalculate the workbook before saving the document, when in manual calculation mode.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *FormulaSettings) SetCalculateOnSave(value bool)  error {
	
	CGoReturnPtr := C.FormulaSettings_SetCalculateOnSave( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether calculates all formulas every time when a calculation is triggered.
// Returns:
//   bool  
func (instance *FormulaSettings) GetForceFullCalculation()  (bool,  error)  {
	
	CGoReturnPtr := C.FormulaSettings_GetForceFullCalculation( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether calculates all formulas every time when a calculation is triggered.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *FormulaSettings) SetForceFullCalculation(value bool)  error {
	
	CGoReturnPtr := C.FormulaSettings_SetForceFullCalculation( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the mode for workbook calculation in ms excel.
// Returns:
//   int32  
func (instance *FormulaSettings) GetCalculationMode()  (CalcModeType,  error)  {
	
	CGoReturnPtr := C.FormulaSettings_GetCalculationMode( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToCalcModeType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets or sets the mode for workbook calculation in ms excel.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *FormulaSettings) SetCalculationMode(value CalcModeType)  error {
	
	CGoReturnPtr := C.FormulaSettings_SetCalculationMode( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Specifies the version of the calculation engine used to calculate values in the workbook.
// Returns:
//   string  
func (instance *FormulaSettings) GetCalculationId()  (string,  error)  {
	
	CGoReturnPtr := C.FormulaSettings_GetCalculationId( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Specifies the version of the calculation engine used to calculate values in the workbook.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *FormulaSettings) SetCalculationId(value string)  error {
	
	CGoReturnPtr := C.FormulaSettings_SetCalculationId( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether enable iterative calculation to resolve circular references.
// Returns:
//   bool  
func (instance *FormulaSettings) GetEnableIterativeCalculation()  (bool,  error)  {
	
	CGoReturnPtr := C.FormulaSettings_GetEnableIterativeCalculation( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether enable iterative calculation to resolve circular references.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *FormulaSettings) SetEnableIterativeCalculation(value bool)  error {
	
	CGoReturnPtr := C.FormulaSettings_SetEnableIterativeCalculation( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// The maximum iterations to resolve a circular reference.
// Returns:
//   int32  
func (instance *FormulaSettings) GetMaxIteration()  (int32,  error)  {
	
	CGoReturnPtr := C.FormulaSettings_GetMaxIteration( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// The maximum iterations to resolve a circular reference.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *FormulaSettings) SetMaxIteration(value int32)  error {
	
	CGoReturnPtr := C.FormulaSettings_SetMaxIteration( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// The maximum change to resolve a circular reference.
// Returns:
//   float64  
func (instance *FormulaSettings) GetMaxChange()  (float64,  error)  {
	
	CGoReturnPtr := C.FormulaSettings_GetMaxChange( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := float64(CGoReturnPtr.return_value) 

	return result, nil 
}
// The maximum change to resolve a circular reference.
// Parameters:
//   value - float64 
// Returns:
//   void  
func (instance *FormulaSettings) SetMaxChange(value float64)  error {
	
	CGoReturnPtr := C.FormulaSettings_SetMaxChange( instance.ptr, C.double(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Whether the precision of calculated result be set as they are displayed while calculating formulas
// Returns:
//   bool  
func (instance *FormulaSettings) GetPrecisionAsDisplayed()  (bool,  error)  {
	
	CGoReturnPtr := C.FormulaSettings_GetPrecisionAsDisplayed( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Whether the precision of calculated result be set as they are displayed while calculating formulas
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *FormulaSettings) SetPrecisionAsDisplayed(value bool)  error {
	
	CGoReturnPtr := C.FormulaSettings_SetPrecisionAsDisplayed( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Whether enable calculation chain for formulas. Default is false.
// Returns:
//   bool  
func (instance *FormulaSettings) GetEnableCalculationChain()  (bool,  error)  {
	
	CGoReturnPtr := C.FormulaSettings_GetEnableCalculationChain( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Whether enable calculation chain for formulas. Default is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *FormulaSettings) SetEnableCalculationChain(value bool)  error {
	
	CGoReturnPtr := C.FormulaSettings_SetEnableCalculationChain( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether preserve those spaces and line breaks that are padded between formula tokens
// while getting and setting formulas.
// Default value is false.
// Returns:
//   bool  
func (instance *FormulaSettings) GetPreservePaddingSpaces()  (bool,  error)  {
	
	CGoReturnPtr := C.FormulaSettings_GetPreservePaddingSpaces( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether preserve those spaces and line breaks that are padded between formula tokens
// while getting and setting formulas.
// Default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *FormulaSettings) SetPreservePaddingSpaces(value bool)  error {
	
	CGoReturnPtr := C.FormulaSettings_SetPreservePaddingSpaces( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}



func DeleteFormulaSettings(formulasettings *FormulaSettings){
	runtime.SetFinalizer(formulasettings, nil)
	C.Delete_FormulaSettings(formulasettings.ptr)
	formulasettings.ptr = nil
}

// Class GlobalizationSettings 

// Represents the globalization settings.
type GlobalizationSettings struct {
	ptr unsafe.Pointer
}

// Default constructor.
func NewGlobalizationSettings() ( *GlobalizationSettings, error) {
	globalizationsettings := &GlobalizationSettings{}
	CGoReturnPtr := C.New_GlobalizationSettings()
	if CGoReturnPtr.error_no == 0 {
		globalizationsettings.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(globalizationsettings, DeleteGlobalizationSettings)
		return globalizationsettings, nil
	} else {
		globalizationsettings.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return globalizationsettings, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *GlobalizationSettings) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.GlobalizationSettings_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the globalization settings for Chart.
// Returns:
//   ChartGlobalizationSettings  
func (instance *GlobalizationSettings) GetChartSettings()  (*ChartGlobalizationSettings,  error)  {
	
	CGoReturnPtr := C.GlobalizationSettings_GetChartSettings( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &ChartGlobalizationSettings{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteChartGlobalizationSettings) 

	return result, nil 
}
// Sets the globalization settings for Chart.
// Parameters:
//   value - ChartGlobalizationSettings 
// Returns:
//   void  
func (instance *GlobalizationSettings) SetChartSettings(value *ChartGlobalizationSettings)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.GlobalizationSettings_SetChartSettings( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the globalization settings for pivot table.
// Returns:
//   PivotGlobalizationSettings  
func (instance *GlobalizationSettings) GetPivotSettings()  (*PivotGlobalizationSettings,  error)  {
	
	CGoReturnPtr := C.GlobalizationSettings_GetPivotSettings( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &PivotGlobalizationSettings{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeletePivotGlobalizationSettings) 

	return result, nil 
}
// Sets the globalization settings for pivot table.
// Parameters:
//   value - PivotGlobalizationSettings 
// Returns:
//   void  
func (instance *GlobalizationSettings) SetPivotSettings(value *PivotGlobalizationSettings)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.GlobalizationSettings_SetPivotSettings( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the total name of the function.
// Parameters:
//   functionType - int32 
// Returns:
//   string  
func (instance *GlobalizationSettings) GetTotalName(functiontype ConsolidationFunction)  (string,  error)  {
	
	CGoReturnPtr := C.GlobalizationSettings_GetTotalName( instance.ptr, C.int( int32(functiontype)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the grand total name of the function.
// Parameters:
//   functionType - int32 
// Returns:
//   string  
func (instance *GlobalizationSettings) GetGrandTotalName(functiontype ConsolidationFunction)  (string,  error)  {
	
	CGoReturnPtr := C.GlobalizationSettings_GetGrandTotalName( instance.ptr, C.int( int32(functiontype)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the default sheet name for adding worksheet automatically.
// Default is "Sheet".
// Returns:
//   string  
func (instance *GlobalizationSettings) GetDefaultSheetName()  (string,  error)  {
	
	CGoReturnPtr := C.GlobalizationSettings_GetDefaultSheetName( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the type name of table rows that consists of the table header.
// Default is "Headers", so in formula "#Headers" represents the table header.
// Returns:
//   string  
func (instance *GlobalizationSettings) GetTableRowTypeOfHeaders()  (string,  error)  {
	
	CGoReturnPtr := C.GlobalizationSettings_GetTableRowTypeOfHeaders( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the type name of table rows that consists of data region of referenced table.
// Default is "Data", so in formula "#Data" represents the data region of the table.
// Returns:
//   string  
func (instance *GlobalizationSettings) GetTableRowTypeOfData()  (string,  error)  {
	
	CGoReturnPtr := C.GlobalizationSettings_GetTableRowTypeOfData( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the type name of table rows that consists of all rows in referenced table.
// Default is "All", so in formula "#All" represents all rows in referenced table.
// Returns:
//   string  
func (instance *GlobalizationSettings) GetTableRowTypeOfAll()  (string,  error)  {
	
	CGoReturnPtr := C.GlobalizationSettings_GetTableRowTypeOfAll( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the type name of table rows that consists of the total row of referenced table.
// Default is "Totals", so in formula "#Totals" represents the total row of referenced table.
// Returns:
//   string  
func (instance *GlobalizationSettings) GetTableRowTypeOfTotals()  (string,  error)  {
	
	CGoReturnPtr := C.GlobalizationSettings_GetTableRowTypeOfTotals( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the type name of table rows that consists of the current row in referenced table.
// Default is "This Row", so in formula "#This Row" represents the current row in referenced table.
// Returns:
//   string  
func (instance *GlobalizationSettings) GetTableRowTypeOfCurrent()  (string,  error)  {
	
	CGoReturnPtr := C.GlobalizationSettings_GetTableRowTypeOfCurrent( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the display string value for cell's error value
// Parameters:
//   err - string 
// Returns:
//   string  
func (instance *GlobalizationSettings) GetErrorValueString(err string)  (string,  error)  {
	
	CGoReturnPtr := C.GlobalizationSettings_GetErrorValueString( instance.ptr, C.CString(err))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the display string value for cell's boolean value
// Parameters:
//   bv - bool 
// Returns:
//   string  
func (instance *GlobalizationSettings) GetBooleanValueString(bv bool)  (string,  error)  {
	
	CGoReturnPtr := C.GlobalizationSettings_GetBooleanValueString( instance.ptr, C.bool(bv))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the locale dependent function name according to given standard function name.
// Parameters:
//   standardName - string 
// Returns:
//   string  
func (instance *GlobalizationSettings) GetLocalFunctionName(standardname string)  (string,  error)  {
	
	CGoReturnPtr := C.GlobalizationSettings_GetLocalFunctionName( instance.ptr, C.CString(standardname))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the standard function name according to given locale dependent function name.
// Parameters:
//   localName - string 
// Returns:
//   string  
func (instance *GlobalizationSettings) GetStandardFunctionName(localname string)  (string,  error)  {
	
	CGoReturnPtr := C.GlobalizationSettings_GetStandardFunctionName( instance.ptr, C.CString(localname))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the locale dependent text for built-in Name according to given standard text.
// Parameters:
//   standardName - string 
// Returns:
//   string  
func (instance *GlobalizationSettings) GetLocalBuiltInName(standardname string)  (string,  error)  {
	
	CGoReturnPtr := C.GlobalizationSettings_GetLocalBuiltInName( instance.ptr, C.CString(standardname))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the standard text of built-in Name according to given locale dependent text.
// Parameters:
//   localName - string 
// Returns:
//   string  
func (instance *GlobalizationSettings) GetStandardBuiltInName(localname string)  (string,  error)  {
	
	CGoReturnPtr := C.GlobalizationSettings_GetStandardBuiltInName( instance.ptr, C.CString(localname))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the separator for list, parameters of function, ...etc.
// Returns:
//   byte  
func (instance *GlobalizationSettings) GetListSeparator()  (byte,  error)  {
	
	CGoReturnPtr := C.GlobalizationSettings_GetListSeparator( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := byte(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the separator for rows in array data in formula.
// Returns:
//   byte  
func (instance *GlobalizationSettings) GetRowSeparatorOfFormulaArray()  (byte,  error)  {
	
	CGoReturnPtr := C.GlobalizationSettings_GetRowSeparatorOfFormulaArray( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := byte(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the separator for the items in array's row data in formula.
// Returns:
//   byte  
func (instance *GlobalizationSettings) GetColumnSeparatorOfFormulaArray()  (byte,  error)  {
	
	CGoReturnPtr := C.GlobalizationSettings_GetColumnSeparatorOfFormulaArray( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := byte(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets standard English font style name(Regular, Bold, Italic) for Header/Footer according to given locale font style name.
// Parameters:
//   localfontStyleName - string 
// Returns:
//   string  
func (instance *GlobalizationSettings) GetStandardHeaderFooterFontStyleName(localfontstylename string)  (string,  error)  {
	
	CGoReturnPtr := C.GlobalizationSettings_GetStandardHeaderFooterFontStyleName( instance.ptr, C.CString(localfontstylename))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the locale dependent comment title name according to comment title type.
// Parameters:
//   type - int32 
// Returns:
//   string  
func (instance *GlobalizationSettings) GetCommentTitleName(type_ CommentTitleType)  (string,  error)  {
	
	CGoReturnPtr := C.GlobalizationSettings_GetCommentTitleName( instance.ptr, C.int( int32(type_)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Compares two string values according to certain collation rules.
// Parameters:
//   v1 - string 
//   v2 - string 
//   ignoreCase - bool 
// Returns:
//   int32  
func (instance *GlobalizationSettings) Compare(v1 string, v2 string, ignorecase bool)  (int32,  error)  {
	
	CGoReturnPtr := C.GlobalizationSettings_Compare( instance.ptr, C.CString(v1), C.CString(v2), C.bool(ignorecase))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}



func DeleteGlobalizationSettings(globalizationsettings *GlobalizationSettings){
	runtime.SetFinalizer(globalizationsettings, nil)
	C.Delete_GlobalizationSettings(globalizationsettings.ptr)
	globalizationsettings.ptr = nil
}

// Class HeaderFooterCommand 

// Represents the command of header/footer
type HeaderFooterCommand struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *HeaderFooterCommand) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.HeaderFooterCommand_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the header/footer' command type .
// Returns:
//   int32  
func (instance *HeaderFooterCommand) GetType()  (HeaderFooterCommandType,  error)  {
	
	CGoReturnPtr := C.HeaderFooterCommand_GetType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToHeaderFooterCommandType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets the font of the command's value.
// Returns:
//   Font  
func (instance *HeaderFooterCommand) GetFont()  (*Font,  error)  {
	
	CGoReturnPtr := C.HeaderFooterCommand_GetFont( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Font{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteFont) 

	return result, nil 
}
// Gets the text of the command.
// Returns:
//   string  
func (instance *HeaderFooterCommand) GetText()  (string,  error)  {
	
	CGoReturnPtr := C.HeaderFooterCommand_GetText( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}



func DeleteHeaderFooterCommand(headerfootercommand *HeaderFooterCommand){
	runtime.SetFinalizer(headerfootercommand, nil)
	C.Delete_HeaderFooterCommand(headerfootercommand.ptr)
	headerfootercommand.ptr = nil
}

// Class HorizontalPageBreak 

// Encapsulates the object that represents a horizontal page break.
type HorizontalPageBreak struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *HorizontalPageBreak) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.HorizontalPageBreak_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the start column index of this horizontal page break.
// Returns:
//   int32  
func (instance *HorizontalPageBreak) GetStartColumn()  (int32,  error)  {
	
	CGoReturnPtr := C.HorizontalPageBreak_GetStartColumn( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the end column index of this horizontal page break.
// Returns:
//   int32  
func (instance *HorizontalPageBreak) GetEndColumn()  (int32,  error)  {
	
	CGoReturnPtr := C.HorizontalPageBreak_GetEndColumn( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the zero based row index.
// Returns:
//   int32  
func (instance *HorizontalPageBreak) GetRow()  (int32,  error)  {
	
	CGoReturnPtr := C.HorizontalPageBreak_GetRow( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}



func DeleteHorizontalPageBreak(horizontalpagebreak *HorizontalPageBreak){
	runtime.SetFinalizer(horizontalpagebreak, nil)
	C.Delete_HorizontalPageBreak(horizontalpagebreak.ptr)
	horizontalpagebreak.ptr = nil
}

// Class HorizontalPageBreakCollection 

// Encapsulates a collection of <see cref="HorizontalPageBreak"/> objects.
type HorizontalPageBreakCollection struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *HorizontalPageBreakCollection) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.HorizontalPageBreakCollection_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the <see cref="HorizontalPageBreak"/> element at the specified index.
// Parameters:
//   index - int32 
// Returns:
//   HorizontalPageBreak  
func (instance *HorizontalPageBreakCollection) Get_Int(index int32)  (*HorizontalPageBreak,  error)  {
	
	CGoReturnPtr := C.HorizontalPageBreakCollection_Get_Integer( instance.ptr, C.int(index))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &HorizontalPageBreak{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteHorizontalPageBreak) 

	return result, nil 
}
// Gets the <see cref="HorizontalPageBreak"/> element with the specified cell name.
// Parameters:
//   cellName - string 
// Returns:
//   HorizontalPageBreak  
func (instance *HorizontalPageBreakCollection) Get_String(cellname string)  (*HorizontalPageBreak,  error)  {
	
	CGoReturnPtr := C.HorizontalPageBreakCollection_Get_String( instance.ptr, C.CString(cellname))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &HorizontalPageBreak{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteHorizontalPageBreak) 

	return result, nil 
}
// Adds a horizontal page break to the collection.
// Parameters:
//   row - int32 
//   startColumn - int32 
//   endColumn - int32 
// Returns:
//   int32  
func (instance *HorizontalPageBreakCollection) Add_Int_Int_Int(row int32, startcolumn int32, endcolumn int32)  (int32,  error)  {
	
	CGoReturnPtr := C.HorizontalPageBreakCollection_Add_Integer_Integer_Integer( instance.ptr, C.int(row), C.int(startcolumn), C.int(endcolumn))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Adds a horizontal page break to the collection.
// Parameters:
//   row - int32 
// Returns:
//   int32  
func (instance *HorizontalPageBreakCollection) Add_Int(row int32)  (int32,  error)  {
	
	CGoReturnPtr := C.HorizontalPageBreakCollection_Add_Integer( instance.ptr, C.int(row))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Adds a horizontal page break to the collection.
// Parameters:
//   row - int32 
//   column - int32 
// Returns:
//   int32  
func (instance *HorizontalPageBreakCollection) Add_Int_Int(row int32, column int32)  (int32,  error)  {
	
	CGoReturnPtr := C.HorizontalPageBreakCollection_Add_Integer_Integer( instance.ptr, C.int(row), C.int(column))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Adds a horizontal page break to the collection.
// Parameters:
//   cellName - string 
// Returns:
//   int32  
func (instance *HorizontalPageBreakCollection) Add_String(cellname string)  (int32,  error)  {
	
	CGoReturnPtr := C.HorizontalPageBreakCollection_Add_String( instance.ptr, C.CString(cellname))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Removes the HPageBreak element at a specified name.
// Parameters:
//   index - int32 
// Returns:
//   void  
func (instance *HorizontalPageBreakCollection) RemoveAt(index int32)  error {
	
	CGoReturnPtr := C.HorizontalPageBreakCollection_RemoveAt( instance.ptr, C.int(index))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Returns:
//   int32  
func (instance *HorizontalPageBreakCollection) GetCount()  (int32,  error)  {
	
	CGoReturnPtr := C.HorizontalPageBreakCollection_GetCount( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}



func DeleteHorizontalPageBreakCollection(horizontalpagebreakcollection *HorizontalPageBreakCollection){
	runtime.SetFinalizer(horizontalpagebreakcollection, nil)
	C.Delete_HorizontalPageBreakCollection(horizontalpagebreakcollection.ptr)
	horizontalpagebreakcollection.ptr = nil
}

// Class HtmlLoadOptions 

// Represents options when importing a html file.
type HtmlLoadOptions struct {
	ptr unsafe.Pointer
}

// Creates an options of loading the file.
func NewHtmlLoadOptions() ( *HtmlLoadOptions, error) {
	htmlloadoptions := &HtmlLoadOptions{}
	CGoReturnPtr := C.New_HtmlLoadOptions()
	if CGoReturnPtr.error_no == 0 {
		htmlloadoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(htmlloadoptions, DeleteHtmlLoadOptions)
		return htmlloadoptions, nil
	} else {
		htmlloadoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return htmlloadoptions, err
	}	
}
// Creates an options of loading the file.
// Parameters:
//   loadFormat - int32 
func NewHtmlLoadOptions_LoadFormat(loadformat LoadFormat) ( *HtmlLoadOptions, error) {
	htmlloadoptions := &HtmlLoadOptions{}
	CGoReturnPtr := C.New_HtmlLoadOptions_LoadFormat(C.int( int32(loadformat)))
	if CGoReturnPtr.error_no == 0 {
		htmlloadoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(htmlloadoptions, DeleteHtmlLoadOptions)
		return htmlloadoptions, nil
	} else {
		htmlloadoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return htmlloadoptions, err
	}	
}
// Constructs from a parent object.
// Parameters:
//   src - AbstractTextLoadOptions 
func NewHtmlLoadOptions_AbstractTextLoadOptions(src *AbstractTextLoadOptions) ( *HtmlLoadOptions, error) {
	htmlloadoptions := &HtmlLoadOptions{}
	var src_ptr unsafe.Pointer = nil
	if src != nil {
	  src_ptr =src.ptr
	}

	CGoReturnPtr := C.New_HtmlLoadOptions_AbstractTextLoadOptions(src_ptr)
	if CGoReturnPtr.error_no == 0 {
		htmlloadoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(htmlloadoptions, DeleteHtmlLoadOptions)
		return htmlloadoptions, nil
	} else {
		htmlloadoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return htmlloadoptions, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *HtmlLoadOptions) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlLoadOptions_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether importing formulas if the original html file contains formulas
// Returns:
//   bool  
func (instance *HtmlLoadOptions) GetLoadFormulas()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlLoadOptions_GetLoadFormulas( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether importing formulas if the original html file contains formulas
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlLoadOptions) SetLoadFormulas(value bool)  error {
	
	CGoReturnPtr := C.HtmlLoadOptions_SetLoadFormulas( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether support the layout of <c>&lt;div&gt;</c> tag when the html file contains it.
// The default value is false.
// Returns:
//   bool  
func (instance *HtmlLoadOptions) GetSupportDivTag()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlLoadOptions_GetSupportDivTag( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether support the layout of <c>&lt;div&gt;</c> tag when the html file contains it.
// The default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlLoadOptions) SetSupportDivTag(value bool)  error {
	
	CGoReturnPtr := C.HtmlLoadOptions_SetSupportDivTag( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether delete redundant spaces when the text wraps lines using <c>&lt;br&gt;</c> tag.
// The default value is false.
// Returns:
//   bool  
func (instance *HtmlLoadOptions) GetDeleteRedundantSpaces()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlLoadOptions_GetDeleteRedundantSpaces( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether delete redundant spaces when the text wraps lines using <c>&lt;br&gt;</c> tag.
// The default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlLoadOptions) SetDeleteRedundantSpaces(value bool)  error {
	
	CGoReturnPtr := C.HtmlLoadOptions_SetDeleteRedundantSpaces( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether auto-fit columns and rows. The default value is false.
// Returns:
//   bool  
func (instance *HtmlLoadOptions) GetAutoFitColsAndRows()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlLoadOptions_GetAutoFitColsAndRows( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether auto-fit columns and rows. The default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlLoadOptions) SetAutoFitColsAndRows(value bool)  error {
	
	CGoReturnPtr := C.HtmlLoadOptions_SetAutoFitColsAndRows( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether the text is formula if it starts with "=".
// Returns:
//   bool  
func (instance *HtmlLoadOptions) GetHasFormula()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlLoadOptions_GetHasFormula( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether the text is formula if it starts with "=".
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlLoadOptions) SetHasFormula(value bool)  error {
	
	CGoReturnPtr := C.HtmlLoadOptions_SetHasFormula( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the program id of creating the file.
// Only for MHT files.
// Returns:
//   string  
func (instance *HtmlLoadOptions) GetProgId()  (string,  error)  {
	
	CGoReturnPtr := C.HtmlLoadOptions_GetProgId( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Get the HtmlTableLoadOptionCollection instance
// Returns:
//   HtmlTableLoadOptionCollection  
func (instance *HtmlLoadOptions) GetTableLoadOptions()  (*HtmlTableLoadOptionCollection,  error)  {
	
	CGoReturnPtr := C.HtmlLoadOptions_GetTableLoadOptions( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &HtmlTableLoadOptionCollection{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteHtmlTableLoadOptionCollection) 

	return result, nil 
}
// Gets and sets the default encoding. Only applies for csv file.
// Returns:
//   int32  
func (instance *HtmlLoadOptions) GetEncoding()  (EncodingType,  error)  {
	
	CGoReturnPtr := C.HtmlLoadOptions_GetEncoding( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToEncodingType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets and sets the default encoding. Only applies for csv file.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *HtmlLoadOptions) SetEncoding(value EncodingType)  error {
	
	CGoReturnPtr := C.HtmlLoadOptions_SetEncoding( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates the strategy to apply style for parsed values when converting string value to number or datetime.
// Returns:
//   int32  
func (instance *HtmlLoadOptions) GetLoadStyleStrategy()  (TxtLoadStyleStrategy,  error)  {
	
	CGoReturnPtr := C.HtmlLoadOptions_GetLoadStyleStrategy( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToTxtLoadStyleStrategy(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Indicates the strategy to apply style for parsed values when converting string value to number or datetime.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *HtmlLoadOptions) SetLoadStyleStrategy(value TxtLoadStyleStrategy)  error {
	
	CGoReturnPtr := C.HtmlLoadOptions_SetLoadStyleStrategy( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets a value that indicates whether the string in text file is converted to numeric data.
// Returns:
//   bool  
func (instance *HtmlLoadOptions) GetConvertNumericData()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlLoadOptions_GetConvertNumericData( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets a value that indicates whether the string in text file is converted to numeric data.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlLoadOptions) SetConvertNumericData(value bool)  error {
	
	CGoReturnPtr := C.HtmlLoadOptions_SetConvertNumericData( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets a value that indicates whether the string in text file is converted to date data.
// Returns:
//   bool  
func (instance *HtmlLoadOptions) GetConvertDateTimeData()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlLoadOptions_GetConvertDateTimeData( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets a value that indicates whether the string in text file is converted to date data.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlLoadOptions) SetConvertDateTimeData(value bool)  error {
	
	CGoReturnPtr := C.HtmlLoadOptions_SetConvertDateTimeData( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether not parsing a string value if the length is 15.
// Returns:
//   bool  
func (instance *HtmlLoadOptions) GetKeepPrecision()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlLoadOptions_GetKeepPrecision( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether not parsing a string value if the length is 15.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlLoadOptions) SetKeepPrecision(value bool)  error {
	
	CGoReturnPtr := C.HtmlLoadOptions_SetKeepPrecision( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the load format.
// Returns:
//   int32  
func (instance *HtmlLoadOptions) GetLoadFormat()  (LoadFormat,  error)  {
	
	CGoReturnPtr := C.HtmlLoadOptions_GetLoadFormat( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToLoadFormat(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets and set the password of the workbook.
// Returns:
//   string  
func (instance *HtmlLoadOptions) GetPassword()  (string,  error)  {
	
	CGoReturnPtr := C.HtmlLoadOptions_GetPassword( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and set the password of the workbook.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *HtmlLoadOptions) SetPassword(value string)  error {
	
	CGoReturnPtr := C.HtmlLoadOptions_SetPassword( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether parsing the formula when reading the file.
// Returns:
//   bool  
func (instance *HtmlLoadOptions) GetParsingFormulaOnOpen()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlLoadOptions_GetParsingFormulaOnOpen( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether parsing the formula when reading the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlLoadOptions) SetParsingFormulaOnOpen(value bool)  error {
	
	CGoReturnPtr := C.HtmlLoadOptions_SetParsingFormulaOnOpen( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether parsing pivot cached records when loading the file.
// The default value is false.
// Returns:
//   bool  
func (instance *HtmlLoadOptions) GetParsingPivotCachedRecords()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlLoadOptions_GetParsingPivotCachedRecords( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether parsing pivot cached records when loading the file.
// The default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlLoadOptions) SetParsingPivotCachedRecords(value bool)  error {
	
	CGoReturnPtr := C.HtmlLoadOptions_SetParsingPivotCachedRecords( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Sets the default print paper size from default printer's setting.
// Parameters:
//   type - int32 
// Returns:
//   void  
func (instance *HtmlLoadOptions) SetPaperSize(type_ PaperSizeType)  error {
	
	CGoReturnPtr := C.HtmlLoadOptions_SetPaperSize( instance.ptr, C.int( int32(type_)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the user interface language of the Workbook version based on CountryCode that has saved the file.
// Returns:
//   int32  
func (instance *HtmlLoadOptions) GetLanguageCode()  (CountryCode,  error)  {
	
	CGoReturnPtr := C.HtmlLoadOptions_GetLanguageCode( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToCountryCode(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets or sets the user interface language of the Workbook version based on CountryCode that has saved the file.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *HtmlLoadOptions) SetLanguageCode(value CountryCode)  error {
	
	CGoReturnPtr := C.HtmlLoadOptions_SetLanguageCode( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the regional settings used for the Workbook that will be loaded.
// Returns:
//   int32  
func (instance *HtmlLoadOptions) GetRegion()  (CountryCode,  error)  {
	
	CGoReturnPtr := C.HtmlLoadOptions_GetRegion( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToCountryCode(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets or sets the regional settings used for the Workbook that will be loaded.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *HtmlLoadOptions) SetRegion(value CountryCode)  error {
	
	CGoReturnPtr := C.HtmlLoadOptions_SetRegion( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the default style settings for initializing styles of the workbook
// Returns:
//   DefaultStyleSettings  
func (instance *HtmlLoadOptions) GetDefaultStyleSettings()  (*DefaultStyleSettings,  error)  {
	
	CGoReturnPtr := C.HtmlLoadOptions_GetDefaultStyleSettings( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &DefaultStyleSettings{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteDefaultStyleSettings) 

	return result, nil 
}
// Gets and sets the interrupt monitor.
// Returns:
//   AbstractInterruptMonitor  
func (instance *HtmlLoadOptions) GetInterruptMonitor()  (*AbstractInterruptMonitor,  error)  {
	
	CGoReturnPtr := C.HtmlLoadOptions_GetInterruptMonitor( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &AbstractInterruptMonitor{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteAbstractInterruptMonitor) 

	return result, nil 
}
// Gets and sets the interrupt monitor.
// Parameters:
//   value - AbstractInterruptMonitor 
// Returns:
//   void  
func (instance *HtmlLoadOptions) SetInterruptMonitor(value *AbstractInterruptMonitor)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.HtmlLoadOptions_SetInterruptMonitor( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Ignore the data which are not printed if directly printing the file
// Returns:
//   bool  
func (instance *HtmlLoadOptions) GetIgnoreNotPrinted()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlLoadOptions_GetIgnoreNotPrinted( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Ignore the data which are not printed if directly printing the file
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlLoadOptions) SetIgnoreNotPrinted(value bool)  error {
	
	CGoReturnPtr := C.HtmlLoadOptions_SetIgnoreNotPrinted( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Check whether data is valid in the template file.
// Returns:
//   bool  
func (instance *HtmlLoadOptions) GetCheckDataValid()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlLoadOptions_GetCheckDataValid( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Check whether data is valid in the template file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlLoadOptions) SetCheckDataValid(value bool)  error {
	
	CGoReturnPtr := C.HtmlLoadOptions_SetCheckDataValid( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Whether check restriction of excel file when user modify cells related objects.
// For example, excel does not allow inputting string value longer than 32K.
// When you input a value longer than 32K such as by Cell.PutValue(string), if this property is true, you will get an Exception.
// If this property is false, we will accept your input string value as the cell's value so that later
// you can output the complete string value for other file formats such as CSV.
// However, if you have set such kind of value that is invalid for excel file format,
// you should not save the workbook as excel file format later. Otherwise there may be unexpected error for the generated excel file.
// Returns:
//   bool  
func (instance *HtmlLoadOptions) GetCheckExcelRestriction()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlLoadOptions_GetCheckExcelRestriction( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Whether check restriction of excel file when user modify cells related objects.
// For example, excel does not allow inputting string value longer than 32K.
// When you input a value longer than 32K such as by Cell.PutValue(string), if this property is true, you will get an Exception.
// If this property is false, we will accept your input string value as the cell's value so that later
// you can output the complete string value for other file formats such as CSV.
// However, if you have set such kind of value that is invalid for excel file format,
// you should not save the workbook as excel file format later. Otherwise there may be unexpected error for the generated excel file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlLoadOptions) SetCheckExcelRestriction(value bool)  error {
	
	CGoReturnPtr := C.HtmlLoadOptions_SetCheckExcelRestriction( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Whether keep the unparsed data in memory for the Workbook when it is loaded from template file. Default is true.
// Returns:
//   bool  
func (instance *HtmlLoadOptions) GetKeepUnparsedData()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlLoadOptions_GetKeepUnparsedData( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Whether keep the unparsed data in memory for the Workbook when it is loaded from template file. Default is true.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlLoadOptions) SetKeepUnparsedData(value bool)  error {
	
	CGoReturnPtr := C.HtmlLoadOptions_SetKeepUnparsedData( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// The filter to denote how to load data.
// Returns:
//   LoadFilter  
func (instance *HtmlLoadOptions) GetLoadFilter()  (*LoadFilter,  error)  {
	
	CGoReturnPtr := C.HtmlLoadOptions_GetLoadFilter( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &LoadFilter{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteLoadFilter) 

	return result, nil 
}
// The filter to denote how to load data.
// Parameters:
//   value - LoadFilter 
// Returns:
//   void  
func (instance *HtmlLoadOptions) SetLoadFilter(value *LoadFilter)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.HtmlLoadOptions_SetLoadFilter( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the memory usage options.
// Returns:
//   int32  
func (instance *HtmlLoadOptions) GetMemorySetting()  (MemorySetting,  error)  {
	
	CGoReturnPtr := C.HtmlLoadOptions_GetMemorySetting( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToMemorySetting(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets or sets the memory usage options.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *HtmlLoadOptions) SetMemorySetting(value MemorySetting)  error {
	
	CGoReturnPtr := C.HtmlLoadOptions_SetMemorySetting( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the auto fitter options
// Returns:
//   AutoFitterOptions  
func (instance *HtmlLoadOptions) GetAutoFitterOptions()  (*AutoFitterOptions,  error)  {
	
	CGoReturnPtr := C.HtmlLoadOptions_GetAutoFitterOptions( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &AutoFitterOptions{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteAutoFitterOptions) 

	return result, nil 
}
// Gets and sets the auto fitter options
// Parameters:
//   value - AutoFitterOptions 
// Returns:
//   void  
func (instance *HtmlLoadOptions) SetAutoFitterOptions(value *AutoFitterOptions)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.HtmlLoadOptions_SetAutoFitterOptions( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether auto filtering the data when loading the files.
// Returns:
//   bool  
func (instance *HtmlLoadOptions) GetAutoFilter()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlLoadOptions_GetAutoFilter( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether auto filtering the data when loading the files.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlLoadOptions) SetAutoFilter(value bool)  error {
	
	CGoReturnPtr := C.HtmlLoadOptions_SetAutoFilter( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets individual font configs.
// Only works for the <see cref="Workbook"/> which uses this <see cref="LoadOptions"/> to load.
// Returns:
//   IndividualFontConfigs  
func (instance *HtmlLoadOptions) GetFontConfigs()  (*IndividualFontConfigs,  error)  {
	
	CGoReturnPtr := C.HtmlLoadOptions_GetFontConfigs( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &IndividualFontConfigs{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteIndividualFontConfigs) 

	return result, nil 
}
// Gets and sets individual font configs.
// Only works for the <see cref="Workbook"/> which uses this <see cref="LoadOptions"/> to load.
// Parameters:
//   value - IndividualFontConfigs 
// Returns:
//   void  
func (instance *HtmlLoadOptions) SetFontConfigs(value *IndividualFontConfigs)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.HtmlLoadOptions_SetFontConfigs( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether ignoring useless shapes.
// Returns:
//   bool  
func (instance *HtmlLoadOptions) GetIgnoreUselessShapes()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlLoadOptions_GetIgnoreUselessShapes( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether ignoring useless shapes.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlLoadOptions) SetIgnoreUselessShapes(value bool)  error {
	
	CGoReturnPtr := C.HtmlLoadOptions_SetIgnoreUselessShapes( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether preserve those spaces and line breaks that are padded between formula tokens
// while getting and setting formulas.
// Default value is false.
// Returns:
//   bool  
func (instance *HtmlLoadOptions) GetPreservePaddingSpacesInFormula()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlLoadOptions_GetPreservePaddingSpacesInFormula( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether preserve those spaces and line breaks that are padded between formula tokens
// while getting and setting formulas.
// Default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlLoadOptions) SetPreservePaddingSpacesInFormula(value bool)  error {
	
	CGoReturnPtr := C.HtmlLoadOptions_SetPreservePaddingSpacesInFormula( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}


func (instance *HtmlLoadOptions) ToAbstractTextLoadOptions() *AbstractTextLoadOptions {
	parentClass := &AbstractTextLoadOptions{}
	parentClass.ptr = instance.ptr
	return parentClass
}
func (instance *HtmlLoadOptions) ToLoadOptions() *LoadOptions {
	parentClass := &LoadOptions{}
	parentClass.ptr = instance.ptr
	return parentClass
}

func DeleteHtmlLoadOptions(htmlloadoptions *HtmlLoadOptions){
	runtime.SetFinalizer(htmlloadoptions, nil)
	C.Delete_HtmlLoadOptions(htmlloadoptions.ptr)
	htmlloadoptions.ptr = nil
}

// Class HtmlSaveOptions 

// Represents the options for saving html file.
type HtmlSaveOptions struct {
	ptr unsafe.Pointer
}

// Creates options for saving html file.
func NewHtmlSaveOptions() ( *HtmlSaveOptions, error) {
	htmlsaveoptions := &HtmlSaveOptions{}
	CGoReturnPtr := C.New_HtmlSaveOptions()
	if CGoReturnPtr.error_no == 0 {
		htmlsaveoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(htmlsaveoptions, DeleteHtmlSaveOptions)
		return htmlsaveoptions, nil
	} else {
		htmlsaveoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return htmlsaveoptions, err
	}	
}
// Creates options for saving htm file.
// Parameters:
//   saveFormat - int32 
func NewHtmlSaveOptions_SaveFormat(saveformat SaveFormat) ( *HtmlSaveOptions, error) {
	htmlsaveoptions := &HtmlSaveOptions{}
	CGoReturnPtr := C.New_HtmlSaveOptions_SaveFormat(C.int( int32(saveformat)))
	if CGoReturnPtr.error_no == 0 {
		htmlsaveoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(htmlsaveoptions, DeleteHtmlSaveOptions)
		return htmlsaveoptions, nil
	} else {
		htmlsaveoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return htmlsaveoptions, err
	}	
}
// Constructs from a parent object.
// Parameters:
//   src - SaveOptions 
func NewHtmlSaveOptions_SaveOptions(src *SaveOptions) ( *HtmlSaveOptions, error) {
	htmlsaveoptions := &HtmlSaveOptions{}
	var src_ptr unsafe.Pointer = nil
	if src != nil {
	  src_ptr =src.ptr
	}

	CGoReturnPtr := C.New_HtmlSaveOptions_SaveOptions(src_ptr)
	if CGoReturnPtr.error_no == 0 {
		htmlsaveoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(htmlsaveoptions, DeleteHtmlSaveOptions)
		return htmlsaveoptions, nil
	} else {
		htmlsaveoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return htmlsaveoptions, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *HtmlSaveOptions) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicate whether exporting those not visible shapes
// Returns:
//   bool  
func (instance *HtmlSaveOptions) GetIgnoreInvisibleShapes()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetIgnoreInvisibleShapes( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicate whether exporting those not visible shapes
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetIgnoreInvisibleShapes(value bool)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetIgnoreInvisibleShapes( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// The title of the html page.
// Only for saving to html stream.
// Returns:
//   string  
func (instance *HtmlSaveOptions) GetPageTitle()  (string,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetPageTitle( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// The title of the html page.
// Only for saving to html stream.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetPageTitle(value string)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetPageTitle( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// The directory that the attached files will be saved to.
// Only for saving to html stream.
// Returns:
//   string  
func (instance *HtmlSaveOptions) GetAttachedFilesDirectory()  (string,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetAttachedFilesDirectory( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// The directory that the attached files will be saved to.
// Only for saving to html stream.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetAttachedFilesDirectory(value string)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetAttachedFilesDirectory( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Specify the Url prefix of attached files such as image in the html file.
// Only for saving to html stream.
// Returns:
//   string  
func (instance *HtmlSaveOptions) GetAttachedFilesUrlPrefix()  (string,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetAttachedFilesUrlPrefix( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Specify the Url prefix of attached files such as image in the html file.
// Only for saving to html stream.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetAttachedFilesUrlPrefix(value string)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetAttachedFilesUrlPrefix( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Specify the default font name for exporting html, the default font will be used  when the font of style is not existing,
// If this property is null, Aspose.Cells will use universal font which have the same family with the original font,
// the default value is null.
// Returns:
//   string  
func (instance *HtmlSaveOptions) GetDefaultFontName()  (string,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetDefaultFontName( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Specify the default font name for exporting html, the default font will be used  when the font of style is not existing,
// If this property is null, Aspose.Cells will use universal font which have the same family with the original font,
// the default value is null.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetDefaultFontName(value string)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetDefaultFontName( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether to add a generic font to CSS font-family.
// The default value is true
// Returns:
//   bool  
func (instance *HtmlSaveOptions) GetAddGenericFont()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetAddGenericFont( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether to add a generic font to CSS font-family.
// The default value is true
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetAddGenericFont(value bool)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetAddGenericFont( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates if zooming in or out the html via worksheet zoom level when saving file to html, the default value is false.
// Returns:
//   bool  
func (instance *HtmlSaveOptions) GetWorksheetScalable()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetWorksheetScalable( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates if zooming in or out the html via worksheet zoom level when saving file to html, the default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetWorksheetScalable(value bool)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetWorksheetScalable( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates if exporting comments when saving file to html, the default value is false.
// Returns:
//   bool  
func (instance *HtmlSaveOptions) IsExportComments()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_IsExportComments( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates if exporting comments when saving file to html, the default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetIsExportComments(value bool)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetIsExportComments( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents type of exporting comments to html files.
// Returns:
//   int32  
func (instance *HtmlSaveOptions) GetExportCommentsType()  (PrintCommentsType,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetExportCommentsType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToPrintCommentsType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Represents type of exporting comments to html files.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetExportCommentsType(value PrintCommentsType)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetExportCommentsType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates if disable Downlevel-revealed conditional comments when exporting file to html, the default value is false.
// Returns:
//   bool  
func (instance *HtmlSaveOptions) GetDisableDownlevelRevealedComments()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetDisableDownlevelRevealedComments( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates if disable Downlevel-revealed conditional comments when exporting file to html, the default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetDisableDownlevelRevealedComments(value bool)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetDisableDownlevelRevealedComments( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether exporting image files to temp directory.
// Only for saving to html stream.
// Returns:
//   bool  
func (instance *HtmlSaveOptions) IsExpImageToTempDir()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_IsExpImageToTempDir( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether exporting image files to temp directory.
// Only for saving to html stream.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetIsExpImageToTempDir(value bool)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetIsExpImageToTempDir( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether using scalable unit to describe the image width
// when using scalable unit to describe the column width.
// The default value is true.
// Returns:
//   bool  
func (instance *HtmlSaveOptions) GetImageScalable()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetImageScalable( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether using scalable unit to describe the image width
// when using scalable unit to describe the column width.
// The default value is true.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetImageScalable(value bool)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetImageScalable( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether exporting column width in unit of scale to html.
// The default value is false.
// Returns:
//   bool  
func (instance *HtmlSaveOptions) GetWidthScalable()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetWidthScalable( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether exporting column width in unit of scale to html.
// The default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetWidthScalable(value bool)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetWidthScalable( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether exporting the single tab when the file only has one worksheet.
// The default value is false.
// Returns:
//   bool  
func (instance *HtmlSaveOptions) GetExportSingleTab()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetExportSingleTab( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether exporting the single tab when the file only has one worksheet.
// The default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetExportSingleTab(value bool)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetExportSingleTab( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Specifies whether images are saved in Base64 format to HTML, MHTML or EPUB.
// Returns:
//   bool  
func (instance *HtmlSaveOptions) GetExportImagesAsBase64()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetExportImagesAsBase64( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Specifies whether images are saved in Base64 format to HTML, MHTML or EPUB.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetExportImagesAsBase64(value bool)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetExportImagesAsBase64( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates if only exporting the active worksheet to html file.
// If true then only the active worksheet will be exported to html file;
// If false then the whole workbook will be exported to html file.
// The default value is false.
// Returns:
//   bool  
func (instance *HtmlSaveOptions) GetExportActiveWorksheetOnly()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetExportActiveWorksheetOnly( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates if only exporting the active worksheet to html file.
// If true then only the active worksheet will be exported to html file;
// If false then the whole workbook will be exported to html file.
// The default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetExportActiveWorksheetOnly(value bool)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetExportActiveWorksheetOnly( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates if only exporting the print area to html file. The default value is false.
// Returns:
//   bool  
func (instance *HtmlSaveOptions) GetExportPrintAreaOnly()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetExportPrintAreaOnly( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates if only exporting the print area to html file. The default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetExportPrintAreaOnly(value bool)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetExportPrintAreaOnly( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or Sets the exporting CellArea of current active Worksheet.
// If you set this attribute, the print area of current active Worksheet will be omitted.
// Only the specified area will be exported when saving the file to html.
// Returns:
//   CellArea  
func (instance *HtmlSaveOptions) GetExportArea()  (*CellArea,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetExportArea( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &CellArea{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteCellArea) 

	return result, nil 
}
// Gets or Sets the exporting CellArea of current active Worksheet.
// If you set this attribute, the print area of current active Worksheet will be omitted.
// Only the specified area will be exported when saving the file to html.
// Parameters:
//   value - CellArea 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetExportArea(value *CellArea)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.HtmlSaveOptions_SetExportArea( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether html tag(such as <c>&lt;div&gt;&lt;/div&gt;</c>) in cell should be parsed as cell value or preserved as it is.
// The default value is true.
// Returns:
//   bool  
func (instance *HtmlSaveOptions) GetParseHtmlTagInCell()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetParseHtmlTagInCell( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether html tag(such as <c>&lt;div&gt;&lt;/div&gt;</c>) in cell should be parsed as cell value or preserved as it is.
// The default value is true.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetParseHtmlTagInCell(value bool)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetParseHtmlTagInCell( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates if a cross-cell string will be displayed in the same way as MS Excel when saving an Excel file in html format.
// By default the value is Default, so, for cross-cell strings, there is little difference between the html files created by Aspose.Cells and MS Excel.
// But the performance for creating large html files,setting the value to Cross would be several times faster than setting it to Default or Fit2Cell.
// Returns:
//   int32  
func (instance *HtmlSaveOptions) GetHtmlCrossStringType()  (HtmlCrossType,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetHtmlCrossStringType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToHtmlCrossType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Indicates if a cross-cell string will be displayed in the same way as MS Excel when saving an Excel file in html format.
// By default the value is Default, so, for cross-cell strings, there is little difference between the html files created by Aspose.Cells and MS Excel.
// But the performance for creating large html files,setting the value to Cross would be several times faster than setting it to Default or Fit2Cell.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetHtmlCrossStringType(value HtmlCrossType)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetHtmlCrossStringType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Hidden column(the width of this column is 0) in excel,before save this into html format,
// if HtmlHiddenColDisplayType is "Remove",the hidden column would not been output,
// if the value is "Hidden", the column would been output,but was hidden,the default value is "Hidden"
// Returns:
//   int32  
func (instance *HtmlSaveOptions) GetHiddenColDisplayType()  (HtmlHiddenColDisplayType,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetHiddenColDisplayType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToHtmlHiddenColDisplayType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Hidden column(the width of this column is 0) in excel,before save this into html format,
// if HtmlHiddenColDisplayType is "Remove",the hidden column would not been output,
// if the value is "Hidden", the column would been output,but was hidden,the default value is "Hidden"
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetHiddenColDisplayType(value HtmlHiddenColDisplayType)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetHiddenColDisplayType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Hidden row(the height of this row is 0) in excel,before save this into html format,
// if HtmlHiddenRowDisplayType is "Remove",the hidden row would not been output,
// if the value is "Hidden", the row would been output,but was hidden,the default value is "Hidden"
// Returns:
//   int32  
func (instance *HtmlSaveOptions) GetHiddenRowDisplayType()  (HtmlHiddenRowDisplayType,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetHiddenRowDisplayType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToHtmlHiddenRowDisplayType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Hidden row(the height of this row is 0) in excel,before save this into html format,
// if HtmlHiddenRowDisplayType is "Remove",the hidden row would not been output,
// if the value is "Hidden", the row would been output,but was hidden,the default value is "Hidden"
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetHiddenRowDisplayType(value HtmlHiddenRowDisplayType)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetHiddenRowDisplayType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// If not set,use Encoding.UTF8 as default enconding type.
// Returns:
//   int32  
func (instance *HtmlSaveOptions) GetEncoding()  (EncodingType,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetEncoding( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToEncodingType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// If not set,use Encoding.UTF8 as default enconding type.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetEncoding(value EncodingType)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetEncoding( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Get the ImageOrPrintOptions object before exporting
// Returns:
//   ImageOrPrintOptions  
func (instance *HtmlSaveOptions) GetImageOptions()  (*ImageOrPrintOptions,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetImageOptions( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &ImageOrPrintOptions{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteImageOrPrintOptions) 

	return result, nil 
}
// Indicates whether save the html as single file.
// The default value is false.
// Returns:
//   bool  
func (instance *HtmlSaveOptions) GetSaveAsSingleFile()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetSaveAsSingleFile( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether save the html as single file.
// The default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetSaveAsSingleFile(value bool)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetSaveAsSingleFile( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether showing all sheets when saving  as a single html file.
// Returns:
//   bool  
func (instance *HtmlSaveOptions) GetShowAllSheets()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetShowAllSheets( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether showing all sheets when saving  as a single html file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetShowAllSheets(value bool)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetShowAllSheets( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether exporting page headers.
// Returns:
//   bool  
func (instance *HtmlSaveOptions) GetExportPageHeaders()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetExportPageHeaders( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether exporting page headers.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetExportPageHeaders(value bool)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetExportPageHeaders( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether exporting page headers.
// Returns:
//   bool  
func (instance *HtmlSaveOptions) GetExportPageFooters()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetExportPageFooters( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether exporting page headers.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetExportPageFooters(value bool)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetExportPageFooters( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicating if exporting the hidden worksheet content.The default value is true.
// Returns:
//   bool  
func (instance *HtmlSaveOptions) GetExportHiddenWorksheet()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetExportHiddenWorksheet( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicating if exporting the hidden worksheet content.The default value is true.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetExportHiddenWorksheet(value bool)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetExportHiddenWorksheet( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicating if html or mht file is presentation preference.
// The default value is false.
// if you want to get more beautiful presentation,please set the value to true.
// Returns:
//   bool  
func (instance *HtmlSaveOptions) GetPresentationPreference()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetPresentationPreference( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicating if html or mht file is presentation preference.
// The default value is false.
// if you want to get more beautiful presentation,please set the value to true.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetPresentationPreference(value bool)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetPresentationPreference( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the prefix of the css name,the default value is "".
// Returns:
//   string  
func (instance *HtmlSaveOptions) GetCellCssPrefix()  (string,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetCellCssPrefix( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the prefix of the css name,the default value is "".
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetCellCssPrefix(value string)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetCellCssPrefix( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the prefix of the type css name such as tr,col,td and so on, they are contained in the table element
// which has the specific TableCssId attribute. The default value is "".
// Returns:
//   string  
func (instance *HtmlSaveOptions) GetTableCssId()  (string,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetTableCssId( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the prefix of the type css name such as tr,col,td and so on, they are contained in the table element
// which has the specific TableCssId attribute. The default value is "".
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetTableCssId(value string)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetTableCssId( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicating whether using full path link in sheet00x.htm,filelist.xml and tabstrip.htm.
// The default value is false.
// Returns:
//   bool  
func (instance *HtmlSaveOptions) IsFullPathLink()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_IsFullPathLink( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicating whether using full path link in sheet00x.htm,filelist.xml and tabstrip.htm.
// The default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetIsFullPathLink(value bool)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetIsFullPathLink( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicating whether export the worksheet css separately.The default value is false.
// Returns:
//   bool  
func (instance *HtmlSaveOptions) GetExportWorksheetCSSSeparately()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetExportWorksheetCSSSeparately( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicating whether export the worksheet css separately.The default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetExportWorksheetCSSSeparately(value bool)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetExportWorksheetCSSSeparately( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicating whether exporting the similar border style when the border style is not supported by browsers.
// If you want to import the html or mht file to excel, please keep the default value.
// The default value is false.
// Returns:
//   bool  
func (instance *HtmlSaveOptions) GetExportSimilarBorderStyle()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetExportSimilarBorderStyle( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicating whether exporting the similar border style when the border style is not supported by browsers.
// If you want to import the html or mht file to excel, please keep the default value.
// The default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetExportSimilarBorderStyle(value bool)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetExportSimilarBorderStyle( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// The option to merge contiguous empty cells(empty td elements)
// The default value is MergeEmptyTdType.Default.
// Returns:
//   int32  
func (instance *HtmlSaveOptions) GetMergeEmptyTdType()  (MergeEmptyTdType,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetMergeEmptyTdType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToMergeEmptyTdType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// The option to merge contiguous empty cells(empty td elements)
// The default value is MergeEmptyTdType.Default.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetMergeEmptyTdType(value MergeEmptyTdType)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetMergeEmptyTdType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether exporting excel coordinate of nonblank cells when saving file to html. The default value is false.
// If you want to import the output html to excel, please keep the default value.
// Returns:
//   bool  
func (instance *HtmlSaveOptions) GetExportCellCoordinate()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetExportCellCoordinate( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether exporting excel coordinate of nonblank cells when saving file to html. The default value is false.
// If you want to import the output html to excel, please keep the default value.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetExportCellCoordinate(value bool)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetExportCellCoordinate( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether exporting extra headings when the length of text is longer than max display column.
// The default value is false. If you want to import the html file to excel, please keep the default value.
// Returns:
//   bool  
func (instance *HtmlSaveOptions) GetExportExtraHeadings()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetExportExtraHeadings( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether exporting extra headings when the length of text is longer than max display column.
// The default value is false. If you want to import the html file to excel, please keep the default value.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetExportExtraHeadings(value bool)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetExportExtraHeadings( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether exports sheet's row and column headings when saving to HTML files.
// Returns:
//   bool  
func (instance *HtmlSaveOptions) GetExportRowColumnHeadings()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetExportRowColumnHeadings( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether exports sheet's row and column headings when saving to HTML files.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetExportRowColumnHeadings(value bool)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetExportRowColumnHeadings( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether exporting formula when saving file to html. The default value is true.
// If you want to import the output html to excel, please keep the default value.
// Returns:
//   bool  
func (instance *HtmlSaveOptions) GetExportFormula()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetExportFormula( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether exporting formula when saving file to html. The default value is true.
// If you want to import the output html to excel, please keep the default value.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetExportFormula(value bool)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetExportFormula( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether adding tooltip text when the data can't be fully displayed.
// The default value is false.
// Returns:
//   bool  
func (instance *HtmlSaveOptions) GetAddTooltipText()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetAddTooltipText( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether adding tooltip text when the data can't be fully displayed.
// The default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetAddTooltipText(value bool)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetAddTooltipText( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicating whether exporting the gridlines.The default value is false.
// Returns:
//   bool  
func (instance *HtmlSaveOptions) GetExportGridLines()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetExportGridLines( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicating whether exporting the gridlines.The default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetExportGridLines(value bool)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetExportGridLines( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicating whether exporting bogus bottom row data. The default value is true.If you want to import the html or mht file
// to excel, please keep the default value.
// Returns:
//   bool  
func (instance *HtmlSaveOptions) GetExportBogusRowData()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetExportBogusRowData( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicating whether exporting bogus bottom row data. The default value is true.If you want to import the html or mht file
// to excel, please keep the default value.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetExportBogusRowData(value bool)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetExportBogusRowData( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicating whether excludes unused styles.
// For the generated html files, excluding unused styles can make the file size smaller
// without affecting the visual effects. So the default value of this property is true.
// If user needs to keep all styles in the workbook for the generated html(such as the scenario that user
// needs to restore the workbook from the generated html later), please set this property as false.
// Returns:
//   bool  
func (instance *HtmlSaveOptions) GetExcludeUnusedStyles()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetExcludeUnusedStyles( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicating whether excludes unused styles.
// For the generated html files, excluding unused styles can make the file size smaller
// without affecting the visual effects. So the default value of this property is true.
// If user needs to keep all styles in the workbook for the generated html(such as the scenario that user
// needs to restore the workbook from the generated html later), please set this property as false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetExcludeUnusedStyles(value bool)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetExcludeUnusedStyles( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicating whether exporting document properties.The default value is true.If you want to import
// the html or mht file to excel, please keep the default value.
// Returns:
//   bool  
func (instance *HtmlSaveOptions) GetExportDocumentProperties()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetExportDocumentProperties( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicating whether exporting document properties.The default value is true.If you want to import
// the html or mht file to excel, please keep the default value.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetExportDocumentProperties(value bool)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetExportDocumentProperties( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicating whether exporting worksheet properties.The default value is true.If you want to import
// the html or mht file to excel, please keep the default value.
// Returns:
//   bool  
func (instance *HtmlSaveOptions) GetExportWorksheetProperties()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetExportWorksheetProperties( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicating whether exporting worksheet properties.The default value is true.If you want to import
// the html or mht file to excel, please keep the default value.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetExportWorksheetProperties(value bool)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetExportWorksheetProperties( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicating whether exporting workbook properties.The default value is true.If you want to import
// the html or mht file to excel, please keep the default value.
// Returns:
//   bool  
func (instance *HtmlSaveOptions) GetExportWorkbookProperties()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetExportWorkbookProperties( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicating whether exporting workbook properties.The default value is true.If you want to import
// the html or mht file to excel, please keep the default value.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetExportWorkbookProperties(value bool)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetExportWorkbookProperties( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicating whether exporting frame scripts and document properties. The default value is true.If you want to import the html or mht file
// to excel, please keep the default value.
// Returns:
//   bool  
func (instance *HtmlSaveOptions) GetExportFrameScriptsAndProperties()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetExportFrameScriptsAndProperties( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicating whether exporting frame scripts and document properties. The default value is true.If you want to import the html or mht file
// to excel, please keep the default value.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetExportFrameScriptsAndProperties(value bool)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetExportFrameScriptsAndProperties( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicating the rule of exporting html file data.The default value is All.
// Returns:
//   int32  
func (instance *HtmlSaveOptions) GetExportDataOptions()  (HtmlExportDataOptions,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetExportDataOptions( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToHtmlExportDataOptions(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Indicating the rule of exporting html file data.The default value is All.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetExportDataOptions(value HtmlExportDataOptions)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetExportDataOptions( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicating the type of target attribute in <c>&lt;a&gt;</c> link. The default value is HtmlLinkTargetType.Parent.
// Returns:
//   int32  
func (instance *HtmlSaveOptions) GetLinkTargetType()  (HtmlLinkTargetType,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetLinkTargetType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToHtmlLinkTargetType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Indicating the type of target attribute in <c>&lt;a&gt;</c> link. The default value is HtmlLinkTargetType.Parent.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetLinkTargetType(value HtmlLinkTargetType)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetLinkTargetType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicating whether the output HTML is compatible with IE browser.
// The defalut value is false
// Returns:
//   bool  
func (instance *HtmlSaveOptions) IsIECompatible()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_IsIECompatible( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicating whether the output HTML is compatible with IE browser.
// The defalut value is false
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetIsIECompatible(value bool)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetIsIECompatible( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicating whether show the whole formatted data of cell when overflowing the column.
// If true then ignore the column width and the whole data of cell will be exported.
// If false then the data will be exported same as Excel.
// The default value is false.
// Returns:
//   bool  
func (instance *HtmlSaveOptions) GetFormatDataIgnoreColumnWidth()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetFormatDataIgnoreColumnWidth( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicating whether show the whole formatted data of cell when overflowing the column.
// If true then ignore the column width and the whole data of cell will be exported.
// If false then the data will be exported same as Excel.
// The default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetFormatDataIgnoreColumnWidth(value bool)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetFormatDataIgnoreColumnWidth( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether to calculate formulas before saving html file.
// Returns:
//   bool  
func (instance *HtmlSaveOptions) GetCalculateFormula()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetCalculateFormula( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether to calculate formulas before saving html file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetCalculateFormula(value bool)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetCalculateFormula( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether JavaScript is compatible with browsers that do not support JavaScript.
// The default value is true.
// Returns:
//   bool  
func (instance *HtmlSaveOptions) IsJsBrowserCompatible()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_IsJsBrowserCompatible( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether JavaScript is compatible with browsers that do not support JavaScript.
// The default value is true.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetIsJsBrowserCompatible(value bool)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetIsJsBrowserCompatible( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether the output HTML is compatible with mobile devices.
// The default value is false.
// Returns:
//   bool  
func (instance *HtmlSaveOptions) IsMobileCompatible()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_IsMobileCompatible( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether the output HTML is compatible with mobile devices.
// The default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetIsMobileCompatible(value bool)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetIsMobileCompatible( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the additional css styles for the formatter.
// Only works when <see cref="SaveAsSingleFile"/> is True.
// Returns:
//   string  
func (instance *HtmlSaveOptions) GetCssStyles()  (string,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetCssStyles( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets the additional css styles for the formatter.
// Only works when <see cref="SaveAsSingleFile"/> is True.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetCssStyles(value string)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetCssStyles( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether to hide overflow text when the cell format is set to wrap text.
// The default value is false
// Returns:
//   bool  
func (instance *HtmlSaveOptions) GetHideOverflowWrappedText()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetHideOverflowWrappedText( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether to hide overflow text when the cell format is set to wrap text.
// The default value is false
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetHideOverflowWrappedText(value bool)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetHideOverflowWrappedText( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether the table borders are collapsed.
// The default value is true.
// Returns:
//   bool  
func (instance *HtmlSaveOptions) IsBorderCollapsed()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_IsBorderCollapsed( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether the table borders are collapsed.
// The default value is true.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetIsBorderCollapsed(value bool)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetIsBorderCollapsed( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether the html character entities are replaced with decimal code.
// (e.g. "&amp;nbsp;" is replaced with "&amp;#160;").
// The default value is false.
// Returns:
//   bool  
func (instance *HtmlSaveOptions) GetEncodeEntityAsCode()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetEncodeEntityAsCode( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether the html character entities are replaced with decimal code.
// (e.g. "&amp;nbsp;" is replaced with "&amp;#160;").
// The default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetEncodeEntityAsCode(value bool)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetEncodeEntityAsCode( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates how export OfficeMath objects to HTML, Default value is Image.
// Returns:
//   int32  
func (instance *HtmlSaveOptions) GetOfficeMathOutputMode()  (HtmlOfficeMathOutputType,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetOfficeMathOutputMode( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToHtmlOfficeMathOutputType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Indicates how export OfficeMath objects to HTML, Default value is Image.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetOfficeMathOutputMode(value HtmlOfficeMathOutputType)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetOfficeMathOutputMode( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Specifies the attribute that indicates the CellName to be written.
// (e.g. If the value is "id", then for cell "A1", the output will be:&lt;td id='A1'&gt;).
// The default value is null.
// Returns:
//   string  
func (instance *HtmlSaveOptions) GetCellNameAttribute()  (string,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetCellNameAttribute( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Specifies the attribute that indicates the CellName to be written.
// (e.g. If the value is "id", then for cell "A1", the output will be:&lt;td id='A1'&gt;).
// The default value is null.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetCellNameAttribute(value string)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetCellNameAttribute( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether only inline styles are applied, without relying on CSS.
// The default value is false.
// Returns:
//   bool  
func (instance *HtmlSaveOptions) GetDisableCss()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetDisableCss( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether only inline styles are applied, without relying on CSS.
// The default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetDisableCss(value bool)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetDisableCss( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Optimize the output of html by using CSS custom properties. For example, for the scenario that there are multiple occurences for one base64 image, with custom property the image data only needs to be saved once so the performance of the resultant html can be improved.
// The default value is false.
// Returns:
//   bool  
func (instance *HtmlSaveOptions) GetEnableCssCustomProperties()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetEnableCssCustomProperties( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Optimize the output of html by using CSS custom properties. For example, for the scenario that there are multiple occurences for one base64 image, with custom property the image data only needs to be saved once so the performance of the resultant html can be improved.
// The default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetEnableCssCustomProperties(value bool)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetEnableCssCustomProperties( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Specifies version of HTML standard that should be used when saving the HTML format.
// Default value is HtmlVersion.Default.
// Returns:
//   int32  
func (instance *HtmlSaveOptions) GetHtmlVersion()  (HtmlVersion,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetHtmlVersion( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToHtmlVersion(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Specifies version of HTML standard that should be used when saving the HTML format.
// Default value is HtmlVersion.Default.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetHtmlVersion(value HtmlVersion)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetHtmlVersion( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the sheets to render. Default is all visible sheets in the workbook: <see cref="Aspose.Cells.Rendering.SheetSet.Visible"/>.
// Returns:
//   SheetSet  
func (instance *HtmlSaveOptions) GetSheetSet()  (*SheetSet,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetSheetSet( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &SheetSet{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteSheetSet) 

	return result, nil 
}
// Gets or sets the sheets to render. Default is all visible sheets in the workbook: <see cref="Aspose.Cells.Rendering.SheetSet.Visible"/>.
// Parameters:
//   value - SheetSet 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetSheetSet(value *SheetSet)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.HtmlSaveOptions_SetSheetSet( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the save file format.
// Returns:
//   int32  
func (instance *HtmlSaveOptions) GetSaveFormat()  (SaveFormat,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetSaveFormat( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToSaveFormat(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Make the workbook empty after saving the file.
// Returns:
//   bool  
func (instance *HtmlSaveOptions) GetClearData()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetClearData( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Make the workbook empty after saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetClearData(value bool)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetClearData( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// The folder for temporary files that may be used as data cache.
// Returns:
//   string  
func (instance *HtmlSaveOptions) GetCachedFileFolder()  (string,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetCachedFileFolder( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// The folder for temporary files that may be used as data cache.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetCachedFileFolder(value string)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetCachedFileFolder( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether validate merged cells before saving the file.
// Returns:
//   bool  
func (instance *HtmlSaveOptions) GetValidateMergedAreas()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetValidateMergedAreas( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether validate merged cells before saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetValidateMergedAreas(value bool)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetValidateMergedAreas( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether merge the areas of conditional formatting and validation before saving the file.
// Returns:
//   bool  
func (instance *HtmlSaveOptions) GetMergeAreas()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetMergeAreas( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether merge the areas of conditional formatting and validation before saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetMergeAreas(value bool)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetMergeAreas( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// If true and the directory does not exist, the directory will be automatically created before saving the file.
// Returns:
//   bool  
func (instance *HtmlSaveOptions) GetCreateDirectory()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetCreateDirectory( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// If true and the directory does not exist, the directory will be automatically created before saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetCreateDirectory(value bool)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetCreateDirectory( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether sorting defined names before saving file.
// Returns:
//   bool  
func (instance *HtmlSaveOptions) GetSortNames()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetSortNames( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether sorting defined names before saving file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetSortNames(value bool)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetSortNames( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether sorting external defined names before saving file.
// Returns:
//   bool  
func (instance *HtmlSaveOptions) GetSortExternalNames()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetSortExternalNames( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether sorting external defined names before saving file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetSortExternalNames(value bool)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetSortExternalNames( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether refreshing chart cache data
// Returns:
//   bool  
func (instance *HtmlSaveOptions) GetRefreshChartCache()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetRefreshChartCache( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether refreshing chart cache data
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetRefreshChartCache(value bool)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetRefreshChartCache( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Whether check restriction of excel file when user modify cells related objects.
// For example, excel does not allow inputting string value longer than 32K.
// When you input a value longer than 32K, it will be truncated.
// Returns:
//   bool  
func (instance *HtmlSaveOptions) GetCheckExcelRestriction()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetCheckExcelRestriction( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Whether check restriction of excel file when user modify cells related objects.
// For example, excel does not allow inputting string value longer than 32K.
// When you input a value longer than 32K, it will be truncated.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetCheckExcelRestriction(value bool)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetCheckExcelRestriction( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether updating smart art setting.
// The default value is false.
// Returns:
//   bool  
func (instance *HtmlSaveOptions) GetUpdateSmartArt()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetUpdateSmartArt( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether updating smart art setting.
// The default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetUpdateSmartArt(value bool)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetUpdateSmartArt( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether encrypt document properties when saving as .xls file.
// The default value is true.
// Returns:
//   bool  
func (instance *HtmlSaveOptions) GetEncryptDocumentProperties()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlSaveOptions_GetEncryptDocumentProperties( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether encrypt document properties when saving as .xls file.
// The default value is true.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlSaveOptions) SetEncryptDocumentProperties(value bool)  error {
	
	CGoReturnPtr := C.HtmlSaveOptions_SetEncryptDocumentProperties( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}


func (instance *HtmlSaveOptions) ToSaveOptions() *SaveOptions {
	parentClass := &SaveOptions{}
	parentClass.ptr = instance.ptr
	return parentClass
}

func DeleteHtmlSaveOptions(htmlsaveoptions *HtmlSaveOptions){
	runtime.SetFinalizer(htmlsaveoptions, nil)
	C.Delete_HtmlSaveOptions(htmlsaveoptions.ptr)
	htmlsaveoptions.ptr = nil
}

// Class HtmlTableLoadOption 

// Represents the option when import table from html.
type HtmlTableLoadOption struct {
	ptr unsafe.Pointer
}

// Default constructor.
func NewHtmlTableLoadOption() ( *HtmlTableLoadOption, error) {
	htmltableloadoption := &HtmlTableLoadOption{}
	CGoReturnPtr := C.New_HtmlTableLoadOption()
	if CGoReturnPtr.error_no == 0 {
		htmltableloadoption.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(htmltableloadoption, DeleteHtmlTableLoadOption)
		return htmltableloadoption, nil
	} else {
		htmltableloadoption.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return htmltableloadoption, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *HtmlTableLoadOption) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlTableLoadOption_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Get or set the index of table to import from html.
// Returns:
//   int32  
func (instance *HtmlTableLoadOption) GetTableIndex()  (int32,  error)  {
	
	CGoReturnPtr := C.HtmlTableLoadOption_GetTableIndex( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Get or set the index of table to import from html.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *HtmlTableLoadOption) SetTableIndex(value int32)  error {
	
	CGoReturnPtr := C.HtmlTableLoadOption_SetTableIndex( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Get or set the id of table to import from html
// Returns:
//   string  
func (instance *HtmlTableLoadOption) GetId()  (string,  error)  {
	
	CGoReturnPtr := C.HtmlTableLoadOption_GetId( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Get or set the id of table to import from html
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *HtmlTableLoadOption) SetId(value string)  error {
	
	CGoReturnPtr := C.HtmlTableLoadOption_SetId( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Get or set the original index of worksheet in the html.
// Returns:
//   int32  
func (instance *HtmlTableLoadOption) GetOriginalSheetIndex()  (int32,  error)  {
	
	CGoReturnPtr := C.HtmlTableLoadOption_GetOriginalSheetIndex( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Get or set the original index of worksheet in the html.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *HtmlTableLoadOption) SetOriginalSheetIndex(value int32)  error {
	
	CGoReturnPtr := C.HtmlTableLoadOption_SetOriginalSheetIndex( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Get or set the target index of worksheet where the table is to be located.
// Returns:
//   int32  
func (instance *HtmlTableLoadOption) GetTargetSheetIndex()  (int32,  error)  {
	
	CGoReturnPtr := C.HtmlTableLoadOption_GetTargetSheetIndex( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Get or set the target index of worksheet where the table is to be located.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *HtmlTableLoadOption) SetTargetSheetIndex(value int32)  error {
	
	CGoReturnPtr := C.HtmlTableLoadOption_SetTargetSheetIndex( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether generate list objects from imported table.
// The default value is false.
// Returns:
//   bool  
func (instance *HtmlTableLoadOption) GetTableToListObject()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlTableLoadOption_GetTableToListObject( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether generate list objects from imported table.
// The default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlTableLoadOption) SetTableToListObject(value bool)  error {
	
	CGoReturnPtr := C.HtmlTableLoadOption_SetTableToListObject( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}



func DeleteHtmlTableLoadOption(htmltableloadoption *HtmlTableLoadOption){
	runtime.SetFinalizer(htmltableloadoption, nil)
	C.Delete_HtmlTableLoadOption(htmltableloadoption.ptr)
	htmltableloadoption.ptr = nil
}

// Class HtmlTableLoadOptionCollection 

// Represents the table options when importing html.
type HtmlTableLoadOptionCollection struct {
	ptr unsafe.Pointer
}

// Default constructor.
func NewHtmlTableLoadOptionCollection() ( *HtmlTableLoadOptionCollection, error) {
	htmltableloadoptioncollection := &HtmlTableLoadOptionCollection{}
	CGoReturnPtr := C.New_HtmlTableLoadOptionCollection()
	if CGoReturnPtr.error_no == 0 {
		htmltableloadoptioncollection.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(htmltableloadoptioncollection, DeleteHtmlTableLoadOptionCollection)
		return htmltableloadoptioncollection, nil
	} else {
		htmltableloadoptioncollection.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return htmltableloadoptioncollection, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *HtmlTableLoadOptionCollection) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlTableLoadOptionCollection_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether generate list objects from imported tables.
// The default value is false.
// Returns:
//   bool  
func (instance *HtmlTableLoadOptionCollection) GetTableToListObject()  (bool,  error)  {
	
	CGoReturnPtr := C.HtmlTableLoadOptionCollection_GetTableToListObject( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether generate list objects from imported tables.
// The default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *HtmlTableLoadOptionCollection) SetTableToListObject(value bool)  error {
	
	CGoReturnPtr := C.HtmlTableLoadOptionCollection_SetTableToListObject( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the <see cref="HtmlTableLoadOption"/> element at the specified index.
// Parameters:
//   index - int32 
// Returns:
//   HtmlTableLoadOption  
func (instance *HtmlTableLoadOptionCollection) Get(index int32)  (*HtmlTableLoadOption,  error)  {
	
	CGoReturnPtr := C.HtmlTableLoadOptionCollection_Get( instance.ptr, C.int(index))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &HtmlTableLoadOption{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteHtmlTableLoadOption) 

	return result, nil 
}
// Adds one HtmlTableLoadOption into this collection.
// Parameters:
//   item - HtmlTableLoadOption 
// Returns:
//   int32  
func (instance *HtmlTableLoadOptionCollection) Add_HtmlTableLoadOption(item *HtmlTableLoadOption)  (int32,  error)  {
	
	var item_ptr unsafe.Pointer = nil
	if item != nil {
	  item_ptr =item.ptr
	}

	CGoReturnPtr := C.HtmlTableLoadOptionCollection_Add_HtmlTableLoadOption( instance.ptr, item_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Add a HtmlTableLoadOption to the list.
// Parameters:
//   tableIndex - int32 
// Returns:
//   int32  
func (instance *HtmlTableLoadOptionCollection) Add_Int(tableindex int32)  (int32,  error)  {
	
	CGoReturnPtr := C.HtmlTableLoadOptionCollection_Add_Integer( instance.ptr, C.int(tableindex))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Add a HtmlTableLoadOption to the list.
// Parameters:
//   tableId - string 
// Returns:
//   int32  
func (instance *HtmlTableLoadOptionCollection) Add_String(tableid string)  (int32,  error)  {
	
	CGoReturnPtr := C.HtmlTableLoadOptionCollection_Add_String( instance.ptr, C.CString(tableid))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Add a HtmlTableLoadOption to the list.
// Parameters:
//   tableIndex - int32 
//   targetSheetIndex - int32 
// Returns:
//   int32  
func (instance *HtmlTableLoadOptionCollection) Add_Int_Int(tableindex int32, targetsheetindex int32)  (int32,  error)  {
	
	CGoReturnPtr := C.HtmlTableLoadOptionCollection_Add_Integer_Integer( instance.ptr, C.int(tableindex), C.int(targetsheetindex))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Add a HtmlTableLoadOption to the list.
// Parameters:
//   tableId - string 
//   targetSheetIndex - int32 
// Returns:
//   int32  
func (instance *HtmlTableLoadOptionCollection) Add_String_Int(tableid string, targetsheetindex int32)  (int32,  error)  {
	
	CGoReturnPtr := C.HtmlTableLoadOptionCollection_Add_String_Integer( instance.ptr, C.CString(tableid), C.int(targetsheetindex))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Add a HtmlTableLoadOption to the list.
// Parameters:
//   tableIndex - int32 
//   targetSheetIndex - int32 
//   originalSheetIndex - int32 
// Returns:
//   int32  
func (instance *HtmlTableLoadOptionCollection) Add_Int_Int_Int(tableindex int32, targetsheetindex int32, originalsheetindex int32)  (int32,  error)  {
	
	CGoReturnPtr := C.HtmlTableLoadOptionCollection_Add_Integer_Integer_Integer( instance.ptr, C.int(tableindex), C.int(targetsheetindex), C.int(originalsheetindex))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Add a HtmlTableLoadOption to the list.
// Parameters:
//   tableId - string 
//   targetSheetIndex - int32 
//   originalSheetIndex - int32 
// Returns:
//   int32  
func (instance *HtmlTableLoadOptionCollection) Add_String_Int_Int(tableid string, targetsheetindex int32, originalsheetindex int32)  (int32,  error)  {
	
	CGoReturnPtr := C.HtmlTableLoadOptionCollection_Add_String_Integer_Integer( instance.ptr, C.CString(tableid), C.int(targetsheetindex), C.int(originalsheetindex))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Returns:
//   int32  
func (instance *HtmlTableLoadOptionCollection) GetCount()  (int32,  error)  {
	
	CGoReturnPtr := C.HtmlTableLoadOptionCollection_GetCount( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}



func DeleteHtmlTableLoadOptionCollection(htmltableloadoptioncollection *HtmlTableLoadOptionCollection){
	runtime.SetFinalizer(htmltableloadoptioncollection, nil)
	C.Delete_HtmlTableLoadOptionCollection(htmltableloadoptioncollection.ptr)
	htmltableloadoptioncollection.ptr = nil
}

// Class Hyperlink 

// Encapsulates the object that represents a hyperlink.
type Hyperlink struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *Hyperlink) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.Hyperlink_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents the address of a hyperlink.
// Returns:
//   string  
func (instance *Hyperlink) GetAddress()  (string,  error)  {
	
	CGoReturnPtr := C.Hyperlink_GetAddress( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents the address of a hyperlink.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *Hyperlink) SetAddress(value string)  error {
	
	CGoReturnPtr := C.Hyperlink_SetAddress( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents the text to be displayed for the specified hyperlink. The default value is the address of the hyperlink.
// Returns:
//   string  
func (instance *Hyperlink) GetTextToDisplay()  (string,  error)  {
	
	CGoReturnPtr := C.Hyperlink_GetTextToDisplay( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents the text to be displayed for the specified hyperlink. The default value is the address of the hyperlink.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *Hyperlink) SetTextToDisplay(value string)  error {
	
	CGoReturnPtr := C.Hyperlink_SetTextToDisplay( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the range of hyperlink.
// Returns:
//   CellArea  
func (instance *Hyperlink) GetArea()  (*CellArea,  error)  {
	
	CGoReturnPtr := C.Hyperlink_GetArea( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &CellArea{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteCellArea) 

	return result, nil 
}
// Returns or sets the ScreenTip text for the specified hyperlink.
// Returns:
//   string  
func (instance *Hyperlink) GetScreenTip()  (string,  error)  {
	
	CGoReturnPtr := C.Hyperlink_GetScreenTip( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Returns or sets the ScreenTip text for the specified hyperlink.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *Hyperlink) SetScreenTip(value string)  error {
	
	CGoReturnPtr := C.Hyperlink_SetScreenTip( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the link type.
// Returns:
//   int32  
func (instance *Hyperlink) GetLinkType()  (TargetModeType,  error)  {
	
	CGoReturnPtr := C.Hyperlink_GetLinkType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToTargetModeType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Deletes this hyperlink
// Returns:
//   void  
func (instance *Hyperlink) Delete()  error {
	
	CGoReturnPtr := C.Hyperlink_Delete( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}



func DeleteHyperlink(hyperlink *Hyperlink){
	runtime.SetFinalizer(hyperlink, nil)
	C.Delete_Hyperlink(hyperlink.ptr)
	hyperlink.ptr = nil
}

// Class HyperlinkCollection 

// Encapsulates a collection of <see cref="Hyperlink"/> objects.
type HyperlinkCollection struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *HyperlinkCollection) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.HyperlinkCollection_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Adds a hyperlink to a specified cell or a range of cells.
// Parameters:
//   firstRow - int32 
//   firstColumn - int32 
//   totalRows - int32 
//   totalColumns - int32 
//   address - string 
// Returns:
//   int32  
func (instance *HyperlinkCollection) Add_Int_Int_Int_Int_String(firstrow int32, firstcolumn int32, totalrows int32, totalcolumns int32, address string)  (int32,  error)  {
	
	CGoReturnPtr := C.HyperlinkCollection_Add_Integer_Integer_Integer_Integer_String( instance.ptr, C.int(firstrow), C.int(firstcolumn), C.int(totalrows), C.int(totalcolumns), C.CString(address))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Adds a hyperlink to a specified cell or a range of cells.
// Parameters:
//   cellName - string 
//   totalRows - int32 
//   totalColumns - int32 
//   address - string 
// Returns:
//   int32  
func (instance *HyperlinkCollection) Add_String_Int_Int_String(cellname string, totalrows int32, totalcolumns int32, address string)  (int32,  error)  {
	
	CGoReturnPtr := C.HyperlinkCollection_Add_String_Integer_Integer_String( instance.ptr, C.CString(cellname), C.int(totalrows), C.int(totalcolumns), C.CString(address))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Adds a hyperlink to a specified cell or a range of cells.
// Parameters:
//   startCellName - string 
//   endCellName - string 
//   address - string 
//   textToDisplay - string 
//   screenTip - string 
// Returns:
//   int32  
func (instance *HyperlinkCollection) Add_String_String_String_String_String(startcellname string, endcellname string, address string, texttodisplay string, screentip string)  (int32,  error)  {
	
	CGoReturnPtr := C.HyperlinkCollection_Add_String_String_String_String_String( instance.ptr, C.CString(startcellname), C.CString(endcellname), C.CString(address), C.CString(texttodisplay), C.CString(screentip))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the <see cref="Hyperlink"/> element at the specified index.
// Parameters:
//   index - int32 
// Returns:
//   Hyperlink  
func (instance *HyperlinkCollection) Get(index int32)  (*Hyperlink,  error)  {
	
	CGoReturnPtr := C.HyperlinkCollection_Get( instance.ptr, C.int(index))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Hyperlink{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteHyperlink) 

	return result, nil 
}
// Remove the hyperlink  at the specified index in this collection.
// Parameters:
//   index - int32 
// Returns:
//   void  
func (instance *HyperlinkCollection) RemoveAt(index int32)  error {
	
	CGoReturnPtr := C.HyperlinkCollection_RemoveAt( instance.ptr, C.int(index))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Clears all hyperlinks.
// Returns:
//   void  
func (instance *HyperlinkCollection) Clear()  error {
	
	CGoReturnPtr := C.HyperlinkCollection_Clear( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Returns:
//   int32  
func (instance *HyperlinkCollection) GetCount()  (int32,  error)  {
	
	CGoReturnPtr := C.HyperlinkCollection_GetCount( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}



func DeleteHyperlinkCollection(hyperlinkcollection *HyperlinkCollection){
	runtime.SetFinalizer(hyperlinkcollection, nil)
	C.Delete_HyperlinkCollection(hyperlinkcollection.ptr)
	hyperlinkcollection.ptr = nil
}

// Class IconFilter 

// Represents icon filter.
type IconFilter struct {
	ptr unsafe.Pointer
}

// Constructs from an Object convertible to this.
// Parameters:
//   obj - Object 
func NewIconFilter(obj *Object) ( *IconFilter, error) {
	iconfilter := &IconFilter{}
	var obj_ptr unsafe.Pointer = nil
	if obj != nil {
	  obj_ptr =obj.ptr
	}

	CGoReturnPtr := C.New_IconFilter(obj_ptr)
	if CGoReturnPtr.error_no == 0 {
		iconfilter.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(iconfilter, DeleteIconFilter)
		return iconfilter, nil
	} else {
		iconfilter.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return iconfilter, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *IconFilter) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.IconFilter_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the Object.
// Returns:
//   Object  
func (instance *IconFilter) ToObject()  (*Object,  error)  {
	
	CGoReturnPtr := C.IconFilter_ToObject( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Object{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteObject) 

	return result, nil 
}
// Gets and sets which icon set is used in the filter criteria.
// Returns:
//   int32  
func (instance *IconFilter) GetIconSetType()  (IconSetType,  error)  {
	
	CGoReturnPtr := C.IconFilter_GetIconSetType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToIconSetType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets and sets which icon set is used in the filter criteria.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *IconFilter) SetIconSetType(value IconSetType)  error {
	
	CGoReturnPtr := C.IconFilter_SetIconSetType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets Zero-based index of an icon in an icon set.
// Returns:
//   int32  
func (instance *IconFilter) GetIconId()  (int32,  error)  {
	
	CGoReturnPtr := C.IconFilter_GetIconId( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets Zero-based index of an icon in an icon set.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *IconFilter) SetIconId(value int32)  error {
	
	CGoReturnPtr := C.IconFilter_SetIconId( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}



func DeleteIconFilter(iconfilter *IconFilter){
	runtime.SetFinalizer(iconfilter, nil)
	C.Delete_IconFilter(iconfilter.ptr)
	iconfilter.ptr = nil
}

// Class IconSet 

// Describe the IconSet conditional formatting rule.
// This conditional formatting rule applies icons to cells
// according to their values.
type IconSet struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *IconSet) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.IconSet_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Get the<see cref="ConditionalFormattingIcon"/> from the collection
// Returns:
//   ConditionalFormattingIconCollection  
func (instance *IconSet) GetCfIcons()  (*ConditionalFormattingIconCollection,  error)  {
	
	CGoReturnPtr := C.IconSet_GetCfIcons( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &ConditionalFormattingIconCollection{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteConditionalFormattingIconCollection) 

	return result, nil 
}
// Get the CFValueObjects instance.
// Returns:
//   ConditionalFormattingValueCollection  
func (instance *IconSet) GetCfvos()  (*ConditionalFormattingValueCollection,  error)  {
	
	CGoReturnPtr := C.IconSet_GetCfvos( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &ConditionalFormattingValueCollection{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteConditionalFormattingValueCollection) 

	return result, nil 
}
// Get or Set the icon set type to display.
// Setting the type will auto check if the current Cfvos's count is
// accord with the new type. If not accord, old Cfvos will be cleaned and
// default Cfvos will be added.
// Returns:
//   int32  
func (instance *IconSet) GetType()  (IconSetType,  error)  {
	
	CGoReturnPtr := C.IconSet_GetType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToIconSetType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Get or Set the icon set type to display.
// Setting the type will auto check if the current Cfvos's count is
// accord with the new type. If not accord, old Cfvos will be cleaned and
// default Cfvos will be added.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *IconSet) SetType(value IconSetType)  error {
	
	CGoReturnPtr := C.IconSet_SetType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether the icon set is custom.
// Default value is false.
// Returns:
//   bool  
func (instance *IconSet) IsCustom()  (bool,  error)  {
	
	CGoReturnPtr := C.IconSet_IsCustom( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Get or set the flag indicating whether to show the values of the cells on which this icon set is applied.
// Default value is true.
// Returns:
//   bool  
func (instance *IconSet) GetShowValue()  (bool,  error)  {
	
	CGoReturnPtr := C.IconSet_GetShowValue( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Get or set the flag indicating whether to show the values of the cells on which this icon set is applied.
// Default value is true.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *IconSet) SetShowValue(value bool)  error {
	
	CGoReturnPtr := C.IconSet_SetShowValue( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Get or set the flag indicating whether to reverses the default order of the icons in this icon set.
// Default value is false.
// Returns:
//   bool  
func (instance *IconSet) GetReverse()  (bool,  error)  {
	
	CGoReturnPtr := C.IconSet_GetReverse( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Get or set the flag indicating whether to reverses the default order of the icons in this icon set.
// Default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *IconSet) SetReverse(value bool)  error {
	
	CGoReturnPtr := C.IconSet_SetReverse( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}



func DeleteIconSet(iconset *IconSet){
	runtime.SetFinalizer(iconset, nil)
	C.Delete_IconSet(iconset.ptr)
	iconset.ptr = nil
}

// Class ImageSaveOptions 

// Represents image save options.
// For advanced usage, please use <see cref="WorkbookRender"/> or <see cref="SheetRender"/>.
type ImageSaveOptions struct {
	ptr unsafe.Pointer
}

// Creates the options for saving image file.
func NewImageSaveOptions() ( *ImageSaveOptions, error) {
	imagesaveoptions := &ImageSaveOptions{}
	CGoReturnPtr := C.New_ImageSaveOptions()
	if CGoReturnPtr.error_no == 0 {
		imagesaveoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(imagesaveoptions, DeleteImageSaveOptions)
		return imagesaveoptions, nil
	} else {
		imagesaveoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return imagesaveoptions, err
	}	
}
// Creates the options for saving image file.
// Parameters:
//   saveFormat - int32 
func NewImageSaveOptions_SaveFormat(saveformat SaveFormat) ( *ImageSaveOptions, error) {
	imagesaveoptions := &ImageSaveOptions{}
	CGoReturnPtr := C.New_ImageSaveOptions_SaveFormat(C.int( int32(saveformat)))
	if CGoReturnPtr.error_no == 0 {
		imagesaveoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(imagesaveoptions, DeleteImageSaveOptions)
		return imagesaveoptions, nil
	} else {
		imagesaveoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return imagesaveoptions, err
	}	
}
// Constructs from a parent object.
// Parameters:
//   src - SaveOptions 
func NewImageSaveOptions_SaveOptions(src *SaveOptions) ( *ImageSaveOptions, error) {
	imagesaveoptions := &ImageSaveOptions{}
	var src_ptr unsafe.Pointer = nil
	if src != nil {
	  src_ptr =src.ptr
	}

	CGoReturnPtr := C.New_ImageSaveOptions_SaveOptions(src_ptr)
	if CGoReturnPtr.error_no == 0 {
		imagesaveoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(imagesaveoptions, DeleteImageSaveOptions)
		return imagesaveoptions, nil
	} else {
		imagesaveoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return imagesaveoptions, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *ImageSaveOptions) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.ImageSaveOptions_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Additional image creation options.
// Returns:
//   ImageOrPrintOptions  
func (instance *ImageSaveOptions) GetImageOrPrintOptions()  (*ImageOrPrintOptions,  error)  {
	
	CGoReturnPtr := C.ImageSaveOptions_GetImageOrPrintOptions( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &ImageOrPrintOptions{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteImageOrPrintOptions) 

	return result, nil 
}
// Gets the save file format.
// Returns:
//   int32  
func (instance *ImageSaveOptions) GetSaveFormat()  (SaveFormat,  error)  {
	
	CGoReturnPtr := C.ImageSaveOptions_GetSaveFormat( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToSaveFormat(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Make the workbook empty after saving the file.
// Returns:
//   bool  
func (instance *ImageSaveOptions) GetClearData()  (bool,  error)  {
	
	CGoReturnPtr := C.ImageSaveOptions_GetClearData( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Make the workbook empty after saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *ImageSaveOptions) SetClearData(value bool)  error {
	
	CGoReturnPtr := C.ImageSaveOptions_SetClearData( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// The folder for temporary files that may be used as data cache.
// Returns:
//   string  
func (instance *ImageSaveOptions) GetCachedFileFolder()  (string,  error)  {
	
	CGoReturnPtr := C.ImageSaveOptions_GetCachedFileFolder( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// The folder for temporary files that may be used as data cache.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *ImageSaveOptions) SetCachedFileFolder(value string)  error {
	
	CGoReturnPtr := C.ImageSaveOptions_SetCachedFileFolder( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether validate merged cells before saving the file.
// Returns:
//   bool  
func (instance *ImageSaveOptions) GetValidateMergedAreas()  (bool,  error)  {
	
	CGoReturnPtr := C.ImageSaveOptions_GetValidateMergedAreas( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether validate merged cells before saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *ImageSaveOptions) SetValidateMergedAreas(value bool)  error {
	
	CGoReturnPtr := C.ImageSaveOptions_SetValidateMergedAreas( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether merge the areas of conditional formatting and validation before saving the file.
// Returns:
//   bool  
func (instance *ImageSaveOptions) GetMergeAreas()  (bool,  error)  {
	
	CGoReturnPtr := C.ImageSaveOptions_GetMergeAreas( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether merge the areas of conditional formatting and validation before saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *ImageSaveOptions) SetMergeAreas(value bool)  error {
	
	CGoReturnPtr := C.ImageSaveOptions_SetMergeAreas( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// If true and the directory does not exist, the directory will be automatically created before saving the file.
// Returns:
//   bool  
func (instance *ImageSaveOptions) GetCreateDirectory()  (bool,  error)  {
	
	CGoReturnPtr := C.ImageSaveOptions_GetCreateDirectory( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// If true and the directory does not exist, the directory will be automatically created before saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *ImageSaveOptions) SetCreateDirectory(value bool)  error {
	
	CGoReturnPtr := C.ImageSaveOptions_SetCreateDirectory( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether sorting defined names before saving file.
// Returns:
//   bool  
func (instance *ImageSaveOptions) GetSortNames()  (bool,  error)  {
	
	CGoReturnPtr := C.ImageSaveOptions_GetSortNames( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether sorting defined names before saving file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *ImageSaveOptions) SetSortNames(value bool)  error {
	
	CGoReturnPtr := C.ImageSaveOptions_SetSortNames( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether sorting external defined names before saving file.
// Returns:
//   bool  
func (instance *ImageSaveOptions) GetSortExternalNames()  (bool,  error)  {
	
	CGoReturnPtr := C.ImageSaveOptions_GetSortExternalNames( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether sorting external defined names before saving file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *ImageSaveOptions) SetSortExternalNames(value bool)  error {
	
	CGoReturnPtr := C.ImageSaveOptions_SetSortExternalNames( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether refreshing chart cache data
// Returns:
//   bool  
func (instance *ImageSaveOptions) GetRefreshChartCache()  (bool,  error)  {
	
	CGoReturnPtr := C.ImageSaveOptions_GetRefreshChartCache( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether refreshing chart cache data
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *ImageSaveOptions) SetRefreshChartCache(value bool)  error {
	
	CGoReturnPtr := C.ImageSaveOptions_SetRefreshChartCache( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Whether check restriction of excel file when user modify cells related objects.
// For example, excel does not allow inputting string value longer than 32K.
// When you input a value longer than 32K, it will be truncated.
// Returns:
//   bool  
func (instance *ImageSaveOptions) GetCheckExcelRestriction()  (bool,  error)  {
	
	CGoReturnPtr := C.ImageSaveOptions_GetCheckExcelRestriction( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Whether check restriction of excel file when user modify cells related objects.
// For example, excel does not allow inputting string value longer than 32K.
// When you input a value longer than 32K, it will be truncated.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *ImageSaveOptions) SetCheckExcelRestriction(value bool)  error {
	
	CGoReturnPtr := C.ImageSaveOptions_SetCheckExcelRestriction( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether updating smart art setting.
// The default value is false.
// Returns:
//   bool  
func (instance *ImageSaveOptions) GetUpdateSmartArt()  (bool,  error)  {
	
	CGoReturnPtr := C.ImageSaveOptions_GetUpdateSmartArt( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether updating smart art setting.
// The default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *ImageSaveOptions) SetUpdateSmartArt(value bool)  error {
	
	CGoReturnPtr := C.ImageSaveOptions_SetUpdateSmartArt( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether encrypt document properties when saving as .xls file.
// The default value is true.
// Returns:
//   bool  
func (instance *ImageSaveOptions) GetEncryptDocumentProperties()  (bool,  error)  {
	
	CGoReturnPtr := C.ImageSaveOptions_GetEncryptDocumentProperties( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether encrypt document properties when saving as .xls file.
// The default value is true.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *ImageSaveOptions) SetEncryptDocumentProperties(value bool)  error {
	
	CGoReturnPtr := C.ImageSaveOptions_SetEncryptDocumentProperties( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}


func (instance *ImageSaveOptions) ToSaveOptions() *SaveOptions {
	parentClass := &SaveOptions{}
	parentClass.ptr = instance.ptr
	return parentClass
}

func DeleteImageSaveOptions(imagesaveoptions *ImageSaveOptions){
	runtime.SetFinalizer(imagesaveoptions, nil)
	C.Delete_ImageSaveOptions(imagesaveoptions.ptr)
	imagesaveoptions.ptr = nil
}

// Class ImportTableOptions 

// Represents the options of importing data into cells.
type ImportTableOptions struct {
	ptr unsafe.Pointer
}

// Creates the default importing options.
func NewImportTableOptions() ( *ImportTableOptions, error) {
	importtableoptions := &ImportTableOptions{}
	CGoReturnPtr := C.New_ImportTableOptions()
	if CGoReturnPtr.error_no == 0 {
		importtableoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(importtableoptions, DeleteImportTableOptions)
		return importtableoptions, nil
	} else {
		importtableoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return importtableoptions, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *ImportTableOptions) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.ImportTableOptions_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether apply the style of the grid view to cells.
// Returns:
//   bool  
func (instance *ImportTableOptions) GetConvertGridStyle()  (bool,  error)  {
	
	CGoReturnPtr := C.ImportTableOptions_GetConvertGridStyle( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether apply the style of the grid view to cells.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *ImportTableOptions) SetConvertGridStyle(value bool)  error {
	
	CGoReturnPtr := C.ImportTableOptions_SetConvertGridStyle( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets a value that indicates whether the string value should be converted to numeric or date value.
// Returns:
//   bool  
func (instance *ImportTableOptions) GetConvertNumericData()  (bool,  error)  {
	
	CGoReturnPtr := C.ImportTableOptions_GetConvertNumericData( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets a value that indicates whether the string value should be converted to numeric or date value.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *ImportTableOptions) SetConvertNumericData(value bool)  error {
	
	CGoReturnPtr := C.ImportTableOptions_SetConvertNumericData( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether new rows should be added for importing data records.
// Returns:
//   bool  
func (instance *ImportTableOptions) GetInsertRows()  (bool,  error)  {
	
	CGoReturnPtr := C.ImportTableOptions_GetInsertRows( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether new rows should be added for importing data records.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *ImportTableOptions) SetInsertRows(value bool)  error {
	
	CGoReturnPtr := C.ImportTableOptions_SetInsertRows( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether shifting the first row down when inserting rows.
// Returns:
//   bool  
func (instance *ImportTableOptions) GetShiftFirstRowDown()  (bool,  error)  {
	
	CGoReturnPtr := C.ImportTableOptions_GetShiftFirstRowDown( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether shifting the first row down when inserting rows.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *ImportTableOptions) SetShiftFirstRowDown(value bool)  error {
	
	CGoReturnPtr := C.ImportTableOptions_SetShiftFirstRowDown( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether field name should be imported.
// Returns:
//   bool  
func (instance *ImportTableOptions) IsFieldNameShown()  (bool,  error)  {
	
	CGoReturnPtr := C.ImportTableOptions_IsFieldNameShown( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether field name should be imported.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *ImportTableOptions) SetIsFieldNameShown(value bool)  error {
	
	CGoReturnPtr := C.ImportTableOptions_SetIsFieldNameShown( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether exporting caption as field name
// Returns:
//   bool  
func (instance *ImportTableOptions) GetExportCaptionAsFieldName()  (bool,  error)  {
	
	CGoReturnPtr := C.ImportTableOptions_GetExportCaptionAsFieldName( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether exporting caption as field name
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *ImportTableOptions) SetExportCaptionAsFieldName(value bool)  error {
	
	CGoReturnPtr := C.ImportTableOptions_SetExportCaptionAsFieldName( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets date format string for cells with imported datetime values.
// Returns:
//   string  
func (instance *ImportTableOptions) GetDateFormat()  (string,  error)  {
	
	CGoReturnPtr := C.ImportTableOptions_GetDateFormat( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets date format string for cells with imported datetime values.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *ImportTableOptions) SetDateFormat(value string)  error {
	
	CGoReturnPtr := C.ImportTableOptions_SetDateFormat( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the number formats
// Returns:
//   []string  
func (instance *ImportTableOptions) GetNumberFormats()  ([]string,  error)  {
	
	CGoReturnPtr := C.ImportTableOptions_GetNumberFormats( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result:= make([]string, CGoReturnPtr.column_length)
	for i := 0; i < int(CGoReturnPtr.column_length); i++ {
	   offset := uintptr(C.size_t(i)) * uintptr(CGoReturnPtr.size)
	   cObject := *(*C.char)(unsafe.Pointer( uintptr( unsafe.Pointer(CGoReturnPtr.return_value)) + offset))
	   goObject :=string(cObject)
	   result[i] = goObject
	}
	 

	return result, nil 
}
// Gets or sets the number formats
// Parameters:
//   value - []string 
// Returns:
//   void  
func (instance *ImportTableOptions) SetNumberFormats(value []string)  error {
	
	vector_value := make([]*C.char, len(value))
	for i, str := range value {
	cStr := C.CString(str)
	defer C.free(unsafe.Pointer(cStr))
	vector_value[i] = cStr
	}

	CGoReturnPtr := C.ImportTableOptions_SetNumberFormats( instance.ptr, unsafe.Pointer(&vector_value[0]), C.int( len(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether the data are formulas.
// Returns:
//   []bool  
func (instance *ImportTableOptions) GetIsFormulas()  ([]bool,  error)  {
	
	CGoReturnPtr := C.ImportTableOptions_GetIsFormulas( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result:= make([]bool, CGoReturnPtr.column_length)
	for i := 0; i < int(CGoReturnPtr.column_length); i++ {
	   offset := uintptr(C.size_t(i)) * uintptr(CGoReturnPtr.size)
	   cObject := *(*C.bool)(unsafe.Pointer( uintptr( unsafe.Pointer(CGoReturnPtr.return_value)) + offset))
	   goObject :=bool(cObject)
	   result[i] = goObject
	}
	 

	return result, nil 
}
// Indicates whether the data are formulas.
// Parameters:
//   value - []bool 
// Returns:
//   void  
func (instance *ImportTableOptions) SetIsFormulas(value []bool)  error {
	
	CGoReturnPtr := C.ImportTableOptions_SetIsFormulas( instance.ptr, unsafe.Pointer(&value[0]), C.int( len(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets total row count to import from data source. -1 means all rows of given data source.
// Returns:
//   int32  
func (instance *ImportTableOptions) GetTotalRows()  (int32,  error)  {
	
	CGoReturnPtr := C.ImportTableOptions_GetTotalRows( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets total row count to import from data source. -1 means all rows of given data source.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *ImportTableOptions) SetTotalRows(value int32)  error {
	
	CGoReturnPtr := C.ImportTableOptions_SetTotalRows( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets total column count to import from data source. -1 means all rows of given data source.
// Returns:
//   int32  
func (instance *ImportTableOptions) GetTotalColumns()  (int32,  error)  {
	
	CGoReturnPtr := C.ImportTableOptions_GetTotalColumns( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets total column count to import from data source. -1 means all rows of given data source.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *ImportTableOptions) SetTotalColumns(value int32)  error {
	
	CGoReturnPtr := C.ImportTableOptions_SetTotalColumns( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the columns(0-based) to import from data source. null means all columns should be imported.
// Returns:
//   []int32_t  
func (instance *ImportTableOptions) GetColumnIndexes()  ([]int32,  error)  {
	
	CGoReturnPtr := C.ImportTableOptions_GetColumnIndexes( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result:= make([]int32, CGoReturnPtr.column_length)
	for i := 0; i < int(CGoReturnPtr.column_length); i++ {
	   offset := uintptr(C.size_t(i)) * uintptr(CGoReturnPtr.size)
	   cObject := *(*C.int)(unsafe.Pointer( uintptr( unsafe.Pointer(CGoReturnPtr.return_value)) + offset))
	   goObject :=int32(cObject)
	   result[i] = goObject
	}
	 

	return result, nil 
}
// Gets or sets the columns(0-based) to import from data source. null means all columns should be imported.
// Parameters:
//   value - []int32_t 
// Returns:
//   void  
func (instance *ImportTableOptions) SetColumnIndexes(value []int32)  error {
	
	CGoReturnPtr := C.ImportTableOptions_SetColumnIndexes( instance.ptr, unsafe.Pointer(&value[0]), C.int( len(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Default value for the value in the table is null.
// Returns:
//   []Object  
func (instance *ImportTableOptions) GetDefaultValues()  ([]Object,  error)  {
	
	CGoReturnPtr := C.ImportTableOptions_GetDefaultValues( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result:= make([]Object, CGoReturnPtr.column_length)
	for i := 0; i < int(CGoReturnPtr.column_length); i++ {
	   offset := uintptr(C.size_t(i)) * uintptr(CGoReturnPtr.size)
	   goObject := &Object{}
	   goObject.ptr =unsafe.Pointer(uintptr( unsafe.Pointer(CGoReturnPtr.return_value)) + offset)
	   result[i] = *goObject
	}
	 

	return result, nil 
}
// Default value for the value in the table is null.
// Parameters:
//   value - []Object 
// Returns:
//   void  
func (instance *ImportTableOptions) SetDefaultValues(value []interface{})  error {
	
	vector_value, value_row_length := toObjectArray(value)

	CGoReturnPtr := C.ImportTableOptions_SetDefaultValues( instance.ptr, unsafe.Pointer(&vector_value[0]), C.int( value_row_length))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether the value contains html tags.
// Returns:
//   bool  
func (instance *ImportTableOptions) IsHtmlString()  (bool,  error)  {
	
	CGoReturnPtr := C.ImportTableOptions_IsHtmlString( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether the value contains html tags.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *ImportTableOptions) SetIsHtmlString(value bool)  error {
	
	CGoReturnPtr := C.ImportTableOptions_SetIsHtmlString( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether checking merged cells.
// Returns:
//   bool  
func (instance *ImportTableOptions) GetCheckMergedCells()  (bool,  error)  {
	
	CGoReturnPtr := C.ImportTableOptions_GetCheckMergedCells( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether checking merged cells.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *ImportTableOptions) SetCheckMergedCells(value bool)  error {
	
	CGoReturnPtr := C.ImportTableOptions_SetCheckMergedCells( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}



func DeleteImportTableOptions(importtableoptions *ImportTableOptions){
	runtime.SetFinalizer(importtableoptions, nil)
	C.Delete_ImportTableOptions(importtableoptions.ptr)
	importtableoptions.ptr = nil
}

// Class IndividualFontConfigs 

// Font configs for each <see cref="Workbook"/> object.
type IndividualFontConfigs struct {
	ptr unsafe.Pointer
}

// Ctor.
func NewIndividualFontConfigs() ( *IndividualFontConfigs, error) {
	individualfontconfigs := &IndividualFontConfigs{}
	CGoReturnPtr := C.New_IndividualFontConfigs()
	if CGoReturnPtr.error_no == 0 {
		individualfontconfigs.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(individualfontconfigs, DeleteIndividualFontConfigs)
		return individualfontconfigs, nil
	} else {
		individualfontconfigs.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return individualfontconfigs, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *IndividualFontConfigs) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.IndividualFontConfigs_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Font substitute names for given original font name.
// Parameters:
//   originalFontName - string 
//   substituteFontNames - []string 
// Returns:
//   void  
func (instance *IndividualFontConfigs) SetFontSubstitutes(originalfontname string, substitutefontnames []string)  error {
	
	vector_substitutefontnames := make([]*C.char, len(substitutefontnames))
	for i, str := range substitutefontnames {
	cStr := C.CString(str)
	defer C.free(unsafe.Pointer(cStr))
	vector_substitutefontnames[i] = cStr
	}

	CGoReturnPtr := C.IndividualFontConfigs_SetFontSubstitutes( instance.ptr, C.CString(originalfontname), unsafe.Pointer(&vector_substitutefontnames[0]), C.int( len(substitutefontnames)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Returns array containing font substitute names to be used if original font is not presented.
// Parameters:
//   originalFontName - string 
// Returns:
//   []string  
func (instance *IndividualFontConfigs) GetFontSubstitutes(originalfontname string)  ([]string,  error)  {
	
	CGoReturnPtr := C.IndividualFontConfigs_GetFontSubstitutes( instance.ptr, C.CString(originalfontname))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result:= make([]string, CGoReturnPtr.column_length)
	for i := 0; i < int(CGoReturnPtr.column_length); i++ {
	   offset := uintptr(C.size_t(i)) * uintptr(CGoReturnPtr.size)
	   cObject := *(*C.char)(unsafe.Pointer( uintptr( unsafe.Pointer(CGoReturnPtr.return_value)) + offset))
	   goObject :=string(cObject)
	   result[i] = goObject
	}
	 

	return result, nil 
}
// Sets the fonts folder
// Parameters:
//   fontFolder - string 
//   recursive - bool 
// Returns:
//   void  
func (instance *IndividualFontConfigs) SetFontFolder(fontfolder string, recursive bool)  error {
	
	CGoReturnPtr := C.IndividualFontConfigs_SetFontFolder( instance.ptr, C.CString(fontfolder), C.bool(recursive))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Sets the fonts folders
// Parameters:
//   fontFolders - []string 
//   recursive - bool 
// Returns:
//   void  
func (instance *IndividualFontConfigs) SetFontFolders(fontfolders []string, recursive bool)  error {
	
	vector_fontfolders := make([]*C.char, len(fontfolders))
	for i, str := range fontfolders {
	cStr := C.CString(str)
	defer C.free(unsafe.Pointer(cStr))
	vector_fontfolders[i] = cStr
	}

	CGoReturnPtr := C.IndividualFontConfigs_SetFontFolders( instance.ptr, unsafe.Pointer(&vector_fontfolders[0]), C.int( len(fontfolders)), C.bool(recursive))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Sets the fonts sources.
// Parameters:
//   sources - []FontSourceBase 
// Returns:
//   void  
func (instance *IndividualFontConfigs) SetFontSources(sources []FontSourceBase)  error {
	
	sources_length := len(sources)
	vector_sources:= make([]unsafe.Pointer, sources_length)
	for i := 0; i < sources_length; i++ {
		vector_sources[i] = sources[i].ptr
	}


	CGoReturnPtr := C.IndividualFontConfigs_SetFontSources( instance.ptr, unsafe.Pointer(&vector_sources[0]), C.int( len(sources)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets a copy of the array that contains the list of sources
// Returns:
//   []FontSourceBase  
func (instance *IndividualFontConfigs) GetFontSources()  ([]FontSourceBase,  error)  {
	
	CGoReturnPtr := C.IndividualFontConfigs_GetFontSources( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result:= make([]FontSourceBase, CGoReturnPtr.column_length)
	for i := 0; i < int(CGoReturnPtr.column_length); i++ {
	   offset := uintptr(C.size_t(i)) * uintptr(CGoReturnPtr.size)
	   goObject := &FontSourceBase{}
	   goObject.ptr =unsafe.Pointer(uintptr( unsafe.Pointer(CGoReturnPtr.return_value)) + offset)
	   result[i] = *goObject
	}
	 

	return result, nil 
}



func DeleteIndividualFontConfigs(individualfontconfigs *IndividualFontConfigs){
	runtime.SetFinalizer(individualfontconfigs, nil)
	C.Delete_IndividualFontConfigs(individualfontconfigs.ptr)
	individualfontconfigs.ptr = nil
}

// Class InsertOptions 

// Represents the options of inserting.
type InsertOptions struct {
	ptr unsafe.Pointer
}

// Default constructor.
func NewInsertOptions() ( *InsertOptions, error) {
	insertoptions := &InsertOptions{}
	CGoReturnPtr := C.New_InsertOptions()
	if CGoReturnPtr.error_no == 0 {
		insertoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(insertoptions, DeleteInsertOptions)
		return insertoptions, nil
	} else {
		insertoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return insertoptions, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *InsertOptions) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.InsertOptions_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Returns:
//   int32  
func (instance *InsertOptions) GetCopyFormatType()  (CopyFormatType,  error)  {
	
	CGoReturnPtr := C.InsertOptions_GetCopyFormatType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToCopyFormatType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *InsertOptions) SetCopyFormatType(value CopyFormatType)  error {
	
	CGoReturnPtr := C.InsertOptions_SetCopyFormatType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates if references in other worksheets will be updated.
// Returns:
//   bool  
func (instance *InsertOptions) GetUpdateReference()  (bool,  error)  {
	
	CGoReturnPtr := C.InsertOptions_GetUpdateReference( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates if references in other worksheets will be updated.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *InsertOptions) SetUpdateReference(value bool)  error {
	
	CGoReturnPtr := C.InsertOptions_SetUpdateReference( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets/sets the monitor for tracking changes caused by the insertion.
// Returns:
//   AbstractFormulaChangeMonitor  
func (instance *InsertOptions) GetFormulaChangeMonitor()  (*AbstractFormulaChangeMonitor,  error)  {
	
	CGoReturnPtr := C.InsertOptions_GetFormulaChangeMonitor( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &AbstractFormulaChangeMonitor{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteAbstractFormulaChangeMonitor) 

	return result, nil 
}
// Gets/sets the monitor for tracking changes caused by the insertion.
// Parameters:
//   value - AbstractFormulaChangeMonitor 
// Returns:
//   void  
func (instance *InsertOptions) SetFormulaChangeMonitor(value *AbstractFormulaChangeMonitor)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.InsertOptions_SetFormulaChangeMonitor( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}



func DeleteInsertOptions(insertoptions *InsertOptions){
	runtime.SetFinalizer(insertoptions, nil)
	C.Delete_InsertOptions(insertoptions.ptr)
	insertoptions.ptr = nil
}

// Class InterruptMonitor 

// Represents all operator about the interrupt.
type InterruptMonitor struct {
	ptr unsafe.Pointer
}

// Default constructor.
func NewInterruptMonitor() ( *InterruptMonitor, error) {
	interruptmonitor := &InterruptMonitor{}
	CGoReturnPtr := C.New_InterruptMonitor()
	if CGoReturnPtr.error_no == 0 {
		interruptmonitor.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(interruptmonitor, DeleteInterruptMonitor)
		return interruptmonitor, nil
	} else {
		interruptmonitor.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return interruptmonitor, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *InterruptMonitor) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.InterruptMonitor_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Mark the monitor as requesting interruption
// Returns:
//   bool  
func (instance *InterruptMonitor) IsInterruptionRequested()  (bool,  error)  {
	
	CGoReturnPtr := C.InterruptMonitor_IsInterruptionRequested( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Interrupt the current operator.
// Returns:
//   void  
func (instance *InterruptMonitor) Interrupt()  error {
	
	CGoReturnPtr := C.InterruptMonitor_Interrupt( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}



func DeleteInterruptMonitor(interruptmonitor *InterruptMonitor){
	runtime.SetFinalizer(interruptmonitor, nil)
	C.Delete_InterruptMonitor(interruptmonitor.ptr)
	interruptmonitor.ptr = nil
}

// Class JsonLoadOptions 

// Represents the options of loading json files
type JsonLoadOptions struct {
	ptr unsafe.Pointer
}

// Creates an options of loading the file.
func NewJsonLoadOptions() ( *JsonLoadOptions, error) {
	jsonloadoptions := &JsonLoadOptions{}
	CGoReturnPtr := C.New_JsonLoadOptions()
	if CGoReturnPtr.error_no == 0 {
		jsonloadoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(jsonloadoptions, DeleteJsonLoadOptions)
		return jsonloadoptions, nil
	} else {
		jsonloadoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return jsonloadoptions, err
	}	
}
// Constructs from a parent object.
// Parameters:
//   src - LoadOptions 
func NewJsonLoadOptions_LoadOptions(src *LoadOptions) ( *JsonLoadOptions, error) {
	jsonloadoptions := &JsonLoadOptions{}
	var src_ptr unsafe.Pointer = nil
	if src != nil {
	  src_ptr =src.ptr
	}

	CGoReturnPtr := C.New_JsonLoadOptions_LoadOptions(src_ptr)
	if CGoReturnPtr.error_no == 0 {
		jsonloadoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(jsonloadoptions, DeleteJsonLoadOptions)
		return jsonloadoptions, nil
	} else {
		jsonloadoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return jsonloadoptions, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *JsonLoadOptions) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.JsonLoadOptions_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the start cell.
// Returns:
//   string  
func (instance *JsonLoadOptions) GetStartCell()  (string,  error)  {
	
	CGoReturnPtr := C.JsonLoadOptions_GetStartCell( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the start cell.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *JsonLoadOptions) SetStartCell(value string)  error {
	
	CGoReturnPtr := C.JsonLoadOptions_SetStartCell( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// The options of import json.
// Returns:
//   JsonLayoutOptions  
func (instance *JsonLoadOptions) GetLayoutOptions()  (*JsonLayoutOptions,  error)  {
	
	CGoReturnPtr := C.JsonLoadOptions_GetLayoutOptions( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &JsonLayoutOptions{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteJsonLayoutOptions) 

	return result, nil 
}
// The options of import json.
// Parameters:
//   value - JsonLayoutOptions 
// Returns:
//   void  
func (instance *JsonLoadOptions) SetLayoutOptions(value *JsonLayoutOptions)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.JsonLoadOptions_SetLayoutOptions( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether importing each attribute of JsonObject object as one worksheet when all child nodes are array nodes.
// Returns:
//   bool  
func (instance *JsonLoadOptions) GetMultipleWorksheets()  (bool,  error)  {
	
	CGoReturnPtr := C.JsonLoadOptions_GetMultipleWorksheets( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether importing each attribute of JsonObject object as one worksheet when all child nodes are array nodes.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *JsonLoadOptions) SetMultipleWorksheets(value bool)  error {
	
	CGoReturnPtr := C.JsonLoadOptions_SetMultipleWorksheets( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether keeping schema of this json.
// Returns:
//   bool  
func (instance *JsonLoadOptions) GetKeptSchema()  (bool,  error)  {
	
	CGoReturnPtr := C.JsonLoadOptions_GetKeptSchema( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether keeping schema of this json.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *JsonLoadOptions) SetKeptSchema(value bool)  error {
	
	CGoReturnPtr := C.JsonLoadOptions_SetKeptSchema( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the load format.
// Returns:
//   int32  
func (instance *JsonLoadOptions) GetLoadFormat()  (LoadFormat,  error)  {
	
	CGoReturnPtr := C.JsonLoadOptions_GetLoadFormat( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToLoadFormat(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets and set the password of the workbook.
// Returns:
//   string  
func (instance *JsonLoadOptions) GetPassword()  (string,  error)  {
	
	CGoReturnPtr := C.JsonLoadOptions_GetPassword( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and set the password of the workbook.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *JsonLoadOptions) SetPassword(value string)  error {
	
	CGoReturnPtr := C.JsonLoadOptions_SetPassword( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether parsing the formula when reading the file.
// Returns:
//   bool  
func (instance *JsonLoadOptions) GetParsingFormulaOnOpen()  (bool,  error)  {
	
	CGoReturnPtr := C.JsonLoadOptions_GetParsingFormulaOnOpen( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether parsing the formula when reading the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *JsonLoadOptions) SetParsingFormulaOnOpen(value bool)  error {
	
	CGoReturnPtr := C.JsonLoadOptions_SetParsingFormulaOnOpen( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether parsing pivot cached records when loading the file.
// The default value is false.
// Returns:
//   bool  
func (instance *JsonLoadOptions) GetParsingPivotCachedRecords()  (bool,  error)  {
	
	CGoReturnPtr := C.JsonLoadOptions_GetParsingPivotCachedRecords( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether parsing pivot cached records when loading the file.
// The default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *JsonLoadOptions) SetParsingPivotCachedRecords(value bool)  error {
	
	CGoReturnPtr := C.JsonLoadOptions_SetParsingPivotCachedRecords( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Sets the default print paper size from default printer's setting.
// Parameters:
//   type - int32 
// Returns:
//   void  
func (instance *JsonLoadOptions) SetPaperSize(type_ PaperSizeType)  error {
	
	CGoReturnPtr := C.JsonLoadOptions_SetPaperSize( instance.ptr, C.int( int32(type_)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the user interface language of the Workbook version based on CountryCode that has saved the file.
// Returns:
//   int32  
func (instance *JsonLoadOptions) GetLanguageCode()  (CountryCode,  error)  {
	
	CGoReturnPtr := C.JsonLoadOptions_GetLanguageCode( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToCountryCode(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets or sets the user interface language of the Workbook version based on CountryCode that has saved the file.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *JsonLoadOptions) SetLanguageCode(value CountryCode)  error {
	
	CGoReturnPtr := C.JsonLoadOptions_SetLanguageCode( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the regional settings used for the Workbook that will be loaded.
// Returns:
//   int32  
func (instance *JsonLoadOptions) GetRegion()  (CountryCode,  error)  {
	
	CGoReturnPtr := C.JsonLoadOptions_GetRegion( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToCountryCode(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets or sets the regional settings used for the Workbook that will be loaded.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *JsonLoadOptions) SetRegion(value CountryCode)  error {
	
	CGoReturnPtr := C.JsonLoadOptions_SetRegion( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the default style settings for initializing styles of the workbook
// Returns:
//   DefaultStyleSettings  
func (instance *JsonLoadOptions) GetDefaultStyleSettings()  (*DefaultStyleSettings,  error)  {
	
	CGoReturnPtr := C.JsonLoadOptions_GetDefaultStyleSettings( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &DefaultStyleSettings{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteDefaultStyleSettings) 

	return result, nil 
}
// Gets and sets the interrupt monitor.
// Returns:
//   AbstractInterruptMonitor  
func (instance *JsonLoadOptions) GetInterruptMonitor()  (*AbstractInterruptMonitor,  error)  {
	
	CGoReturnPtr := C.JsonLoadOptions_GetInterruptMonitor( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &AbstractInterruptMonitor{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteAbstractInterruptMonitor) 

	return result, nil 
}
// Gets and sets the interrupt monitor.
// Parameters:
//   value - AbstractInterruptMonitor 
// Returns:
//   void  
func (instance *JsonLoadOptions) SetInterruptMonitor(value *AbstractInterruptMonitor)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.JsonLoadOptions_SetInterruptMonitor( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Ignore the data which are not printed if directly printing the file
// Returns:
//   bool  
func (instance *JsonLoadOptions) GetIgnoreNotPrinted()  (bool,  error)  {
	
	CGoReturnPtr := C.JsonLoadOptions_GetIgnoreNotPrinted( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Ignore the data which are not printed if directly printing the file
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *JsonLoadOptions) SetIgnoreNotPrinted(value bool)  error {
	
	CGoReturnPtr := C.JsonLoadOptions_SetIgnoreNotPrinted( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Check whether data is valid in the template file.
// Returns:
//   bool  
func (instance *JsonLoadOptions) GetCheckDataValid()  (bool,  error)  {
	
	CGoReturnPtr := C.JsonLoadOptions_GetCheckDataValid( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Check whether data is valid in the template file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *JsonLoadOptions) SetCheckDataValid(value bool)  error {
	
	CGoReturnPtr := C.JsonLoadOptions_SetCheckDataValid( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Whether check restriction of excel file when user modify cells related objects.
// For example, excel does not allow inputting string value longer than 32K.
// When you input a value longer than 32K such as by Cell.PutValue(string), if this property is true, you will get an Exception.
// If this property is false, we will accept your input string value as the cell's value so that later
// you can output the complete string value for other file formats such as CSV.
// However, if you have set such kind of value that is invalid for excel file format,
// you should not save the workbook as excel file format later. Otherwise there may be unexpected error for the generated excel file.
// Returns:
//   bool  
func (instance *JsonLoadOptions) GetCheckExcelRestriction()  (bool,  error)  {
	
	CGoReturnPtr := C.JsonLoadOptions_GetCheckExcelRestriction( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Whether check restriction of excel file when user modify cells related objects.
// For example, excel does not allow inputting string value longer than 32K.
// When you input a value longer than 32K such as by Cell.PutValue(string), if this property is true, you will get an Exception.
// If this property is false, we will accept your input string value as the cell's value so that later
// you can output the complete string value for other file formats such as CSV.
// However, if you have set such kind of value that is invalid for excel file format,
// you should not save the workbook as excel file format later. Otherwise there may be unexpected error for the generated excel file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *JsonLoadOptions) SetCheckExcelRestriction(value bool)  error {
	
	CGoReturnPtr := C.JsonLoadOptions_SetCheckExcelRestriction( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Whether keep the unparsed data in memory for the Workbook when it is loaded from template file. Default is true.
// Returns:
//   bool  
func (instance *JsonLoadOptions) GetKeepUnparsedData()  (bool,  error)  {
	
	CGoReturnPtr := C.JsonLoadOptions_GetKeepUnparsedData( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Whether keep the unparsed data in memory for the Workbook when it is loaded from template file. Default is true.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *JsonLoadOptions) SetKeepUnparsedData(value bool)  error {
	
	CGoReturnPtr := C.JsonLoadOptions_SetKeepUnparsedData( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// The filter to denote how to load data.
// Returns:
//   LoadFilter  
func (instance *JsonLoadOptions) GetLoadFilter()  (*LoadFilter,  error)  {
	
	CGoReturnPtr := C.JsonLoadOptions_GetLoadFilter( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &LoadFilter{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteLoadFilter) 

	return result, nil 
}
// The filter to denote how to load data.
// Parameters:
//   value - LoadFilter 
// Returns:
//   void  
func (instance *JsonLoadOptions) SetLoadFilter(value *LoadFilter)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.JsonLoadOptions_SetLoadFilter( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the memory usage options.
// Returns:
//   int32  
func (instance *JsonLoadOptions) GetMemorySetting()  (MemorySetting,  error)  {
	
	CGoReturnPtr := C.JsonLoadOptions_GetMemorySetting( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToMemorySetting(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets or sets the memory usage options.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *JsonLoadOptions) SetMemorySetting(value MemorySetting)  error {
	
	CGoReturnPtr := C.JsonLoadOptions_SetMemorySetting( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the auto fitter options
// Returns:
//   AutoFitterOptions  
func (instance *JsonLoadOptions) GetAutoFitterOptions()  (*AutoFitterOptions,  error)  {
	
	CGoReturnPtr := C.JsonLoadOptions_GetAutoFitterOptions( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &AutoFitterOptions{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteAutoFitterOptions) 

	return result, nil 
}
// Gets and sets the auto fitter options
// Parameters:
//   value - AutoFitterOptions 
// Returns:
//   void  
func (instance *JsonLoadOptions) SetAutoFitterOptions(value *AutoFitterOptions)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.JsonLoadOptions_SetAutoFitterOptions( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether auto filtering the data when loading the files.
// Returns:
//   bool  
func (instance *JsonLoadOptions) GetAutoFilter()  (bool,  error)  {
	
	CGoReturnPtr := C.JsonLoadOptions_GetAutoFilter( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether auto filtering the data when loading the files.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *JsonLoadOptions) SetAutoFilter(value bool)  error {
	
	CGoReturnPtr := C.JsonLoadOptions_SetAutoFilter( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets individual font configs.
// Only works for the <see cref="Workbook"/> which uses this <see cref="LoadOptions"/> to load.
// Returns:
//   IndividualFontConfigs  
func (instance *JsonLoadOptions) GetFontConfigs()  (*IndividualFontConfigs,  error)  {
	
	CGoReturnPtr := C.JsonLoadOptions_GetFontConfigs( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &IndividualFontConfigs{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteIndividualFontConfigs) 

	return result, nil 
}
// Gets and sets individual font configs.
// Only works for the <see cref="Workbook"/> which uses this <see cref="LoadOptions"/> to load.
// Parameters:
//   value - IndividualFontConfigs 
// Returns:
//   void  
func (instance *JsonLoadOptions) SetFontConfigs(value *IndividualFontConfigs)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.JsonLoadOptions_SetFontConfigs( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether ignoring useless shapes.
// Returns:
//   bool  
func (instance *JsonLoadOptions) GetIgnoreUselessShapes()  (bool,  error)  {
	
	CGoReturnPtr := C.JsonLoadOptions_GetIgnoreUselessShapes( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether ignoring useless shapes.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *JsonLoadOptions) SetIgnoreUselessShapes(value bool)  error {
	
	CGoReturnPtr := C.JsonLoadOptions_SetIgnoreUselessShapes( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether preserve those spaces and line breaks that are padded between formula tokens
// while getting and setting formulas.
// Default value is false.
// Returns:
//   bool  
func (instance *JsonLoadOptions) GetPreservePaddingSpacesInFormula()  (bool,  error)  {
	
	CGoReturnPtr := C.JsonLoadOptions_GetPreservePaddingSpacesInFormula( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether preserve those spaces and line breaks that are padded between formula tokens
// while getting and setting formulas.
// Default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *JsonLoadOptions) SetPreservePaddingSpacesInFormula(value bool)  error {
	
	CGoReturnPtr := C.JsonLoadOptions_SetPreservePaddingSpacesInFormula( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}


func (instance *JsonLoadOptions) ToLoadOptions() *LoadOptions {
	parentClass := &LoadOptions{}
	parentClass.ptr = instance.ptr
	return parentClass
}

func DeleteJsonLoadOptions(jsonloadoptions *JsonLoadOptions){
	runtime.SetFinalizer(jsonloadoptions, nil)
	C.Delete_JsonLoadOptions(jsonloadoptions.ptr)
	jsonloadoptions.ptr = nil
}

// Class JsonSaveOptions 

// Represents the options of saving the workbook as a json file.
type JsonSaveOptions struct {
	ptr unsafe.Pointer
}

// Creates options for saving json file.
func NewJsonSaveOptions() ( *JsonSaveOptions, error) {
	jsonsaveoptions := &JsonSaveOptions{}
	CGoReturnPtr := C.New_JsonSaveOptions()
	if CGoReturnPtr.error_no == 0 {
		jsonsaveoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(jsonsaveoptions, DeleteJsonSaveOptions)
		return jsonsaveoptions, nil
	} else {
		jsonsaveoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return jsonsaveoptions, err
	}	
}
// Constructs from a parent object.
// Parameters:
//   src - SaveOptions 
func NewJsonSaveOptions_SaveOptions(src *SaveOptions) ( *JsonSaveOptions, error) {
	jsonsaveoptions := &JsonSaveOptions{}
	var src_ptr unsafe.Pointer = nil
	if src != nil {
	  src_ptr =src.ptr
	}

	CGoReturnPtr := C.New_JsonSaveOptions_SaveOptions(src_ptr)
	if CGoReturnPtr.error_no == 0 {
		jsonsaveoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(jsonsaveoptions, DeleteJsonSaveOptions)
		return jsonsaveoptions, nil
	} else {
		jsonsaveoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return jsonsaveoptions, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *JsonSaveOptions) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.JsonSaveOptions_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Exporting style pool when converting to json struct.
// Returns:
//   bool  
func (instance *JsonSaveOptions) GetExportStylePool()  (bool,  error)  {
	
	CGoReturnPtr := C.JsonSaveOptions_GetExportStylePool( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Exporting style pool when converting to json struct.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *JsonSaveOptions) SetExportStylePool(value bool)  error {
	
	CGoReturnPtr := C.JsonSaveOptions_SetExportStylePool( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents the type of exporting hyperlink to json.
// Returns:
//   int32  
func (instance *JsonSaveOptions) GetExportHyperlinkType()  (JsonExportHyperlinkType,  error)  {
	
	CGoReturnPtr := C.JsonSaveOptions_GetExportHyperlinkType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToJsonExportHyperlinkType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Represents the type of exporting hyperlink to json.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *JsonSaveOptions) SetExportHyperlinkType(value JsonExportHyperlinkType)  error {
	
	CGoReturnPtr := C.JsonSaveOptions_SetExportHyperlinkType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether skipping emtpy rows.
// Returns:
//   bool  
func (instance *JsonSaveOptions) GetSkipEmptyRows()  (bool,  error)  {
	
	CGoReturnPtr := C.JsonSaveOptions_GetSkipEmptyRows( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether skipping emtpy rows.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *JsonSaveOptions) SetSkipEmptyRows(value bool)  error {
	
	CGoReturnPtr := C.JsonSaveOptions_SetSkipEmptyRows( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents the indexes of exported sheets.
// Returns:
//   []int32_t  
func (instance *JsonSaveOptions) GetSheetIndexes()  ([]int32,  error)  {
	
	CGoReturnPtr := C.JsonSaveOptions_GetSheetIndexes( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result:= make([]int32, CGoReturnPtr.column_length)
	for i := 0; i < int(CGoReturnPtr.column_length); i++ {
	   offset := uintptr(C.size_t(i)) * uintptr(CGoReturnPtr.size)
	   cObject := *(*C.int)(unsafe.Pointer( uintptr( unsafe.Pointer(CGoReturnPtr.return_value)) + offset))
	   goObject :=int32(cObject)
	   result[i] = goObject
	}
	 

	return result, nil 
}
// Represents the indexes of exported sheets.
// Parameters:
//   value - []int32_t 
// Returns:
//   void  
func (instance *JsonSaveOptions) SetSheetIndexes(value []int32)  error {
	
	CGoReturnPtr := C.JsonSaveOptions_SetSheetIndexes( instance.ptr, unsafe.Pointer(&value[0]), C.int( len(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// The original json schema of each worksheet.
// Returns:
//   []string  
func (instance *JsonSaveOptions) GetSchemas()  ([]string,  error)  {
	
	CGoReturnPtr := C.JsonSaveOptions_GetSchemas( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result:= make([]string, CGoReturnPtr.column_length)
	for i := 0; i < int(CGoReturnPtr.column_length); i++ {
	   offset := uintptr(C.size_t(i)) * uintptr(CGoReturnPtr.size)
	   cObject := *(*C.char)(unsafe.Pointer( uintptr( unsafe.Pointer(CGoReturnPtr.return_value)) + offset))
	   goObject :=string(cObject)
	   result[i] = goObject
	}
	 

	return result, nil 
}
// The original json schema of each worksheet.
// Parameters:
//   value - []string 
// Returns:
//   void  
func (instance *JsonSaveOptions) SetSchemas(value []string)  error {
	
	vector_value := make([]*C.char, len(value))
	for i, str := range value {
	cStr := C.CString(str)
	defer C.free(unsafe.Pointer(cStr))
	vector_value[i] = cStr
	}

	CGoReturnPtr := C.JsonSaveOptions_SetSchemas( instance.ptr, unsafe.Pointer(&vector_value[0]), C.int( len(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the exporting range.
// Returns:
//   CellArea  
func (instance *JsonSaveOptions) GetExportArea()  (*CellArea,  error)  {
	
	CGoReturnPtr := C.JsonSaveOptions_GetExportArea( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &CellArea{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteCellArea) 

	return result, nil 
}
// Gets or sets the exporting range.
// Parameters:
//   value - CellArea 
// Returns:
//   void  
func (instance *JsonSaveOptions) SetExportArea(value *CellArea)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.JsonSaveOptions_SetExportArea( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether the range contains header row.
// Returns:
//   bool  
func (instance *JsonSaveOptions) GetHasHeaderRow()  (bool,  error)  {
	
	CGoReturnPtr := C.JsonSaveOptions_GetHasHeaderRow( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether the range contains header row.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *JsonSaveOptions) SetHasHeaderRow(value bool)  error {
	
	CGoReturnPtr := C.JsonSaveOptions_SetHasHeaderRow( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Exports the string value of the cells to json.
// Returns:
//   bool  
func (instance *JsonSaveOptions) GetExportAsString()  (bool,  error)  {
	
	CGoReturnPtr := C.JsonSaveOptions_GetExportAsString( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Exports the string value of the cells to json.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *JsonSaveOptions) SetExportAsString(value bool)  error {
	
	CGoReturnPtr := C.JsonSaveOptions_SetExportAsString( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates the indent.
// Returns:
//   string  
func (instance *JsonSaveOptions) GetIndent()  (string,  error)  {
	
	CGoReturnPtr := C.JsonSaveOptions_GetIndent( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates the indent.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *JsonSaveOptions) SetIndent(value string)  error {
	
	CGoReturnPtr := C.JsonSaveOptions_SetIndent( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Exported as parent-child hierarchy Json structure.
// Returns:
//   bool  
func (instance *JsonSaveOptions) GetExportNestedStructure()  (bool,  error)  {
	
	CGoReturnPtr := C.JsonSaveOptions_GetExportNestedStructure( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Exported as parent-child hierarchy Json structure.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *JsonSaveOptions) SetExportNestedStructure(value bool)  error {
	
	CGoReturnPtr := C.JsonSaveOptions_SetExportNestedStructure( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether exporting empty cells as null.
// Returns:
//   bool  
func (instance *JsonSaveOptions) GetExportEmptyCells()  (bool,  error)  {
	
	CGoReturnPtr := C.JsonSaveOptions_GetExportEmptyCells( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether exporting empty cells as null.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *JsonSaveOptions) SetExportEmptyCells(value bool)  error {
	
	CGoReturnPtr := C.JsonSaveOptions_SetExportEmptyCells( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether always exporting excel to json as object, even there is only a worksheet in the file.
// Returns:
//   bool  
func (instance *JsonSaveOptions) GetAlwaysExportAsJsonObject()  (bool,  error)  {
	
	CGoReturnPtr := C.JsonSaveOptions_GetAlwaysExportAsJsonObject( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether always exporting excel to json as object, even there is only a worksheet in the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *JsonSaveOptions) SetAlwaysExportAsJsonObject(value bool)  error {
	
	CGoReturnPtr := C.JsonSaveOptions_SetAlwaysExportAsJsonObject( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether converting to json struct of the Excel file.
// Returns:
//   bool  
func (instance *JsonSaveOptions) GetToExcelStruct()  (bool,  error)  {
	
	CGoReturnPtr := C.JsonSaveOptions_GetToExcelStruct( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether converting to json struct of the Excel file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *JsonSaveOptions) SetToExcelStruct(value bool)  error {
	
	CGoReturnPtr := C.JsonSaveOptions_SetToExcelStruct( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the save file format.
// Returns:
//   int32  
func (instance *JsonSaveOptions) GetSaveFormat()  (SaveFormat,  error)  {
	
	CGoReturnPtr := C.JsonSaveOptions_GetSaveFormat( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToSaveFormat(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Make the workbook empty after saving the file.
// Returns:
//   bool  
func (instance *JsonSaveOptions) GetClearData()  (bool,  error)  {
	
	CGoReturnPtr := C.JsonSaveOptions_GetClearData( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Make the workbook empty after saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *JsonSaveOptions) SetClearData(value bool)  error {
	
	CGoReturnPtr := C.JsonSaveOptions_SetClearData( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// The folder for temporary files that may be used as data cache.
// Returns:
//   string  
func (instance *JsonSaveOptions) GetCachedFileFolder()  (string,  error)  {
	
	CGoReturnPtr := C.JsonSaveOptions_GetCachedFileFolder( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// The folder for temporary files that may be used as data cache.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *JsonSaveOptions) SetCachedFileFolder(value string)  error {
	
	CGoReturnPtr := C.JsonSaveOptions_SetCachedFileFolder( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether validate merged cells before saving the file.
// Returns:
//   bool  
func (instance *JsonSaveOptions) GetValidateMergedAreas()  (bool,  error)  {
	
	CGoReturnPtr := C.JsonSaveOptions_GetValidateMergedAreas( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether validate merged cells before saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *JsonSaveOptions) SetValidateMergedAreas(value bool)  error {
	
	CGoReturnPtr := C.JsonSaveOptions_SetValidateMergedAreas( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether merge the areas of conditional formatting and validation before saving the file.
// Returns:
//   bool  
func (instance *JsonSaveOptions) GetMergeAreas()  (bool,  error)  {
	
	CGoReturnPtr := C.JsonSaveOptions_GetMergeAreas( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether merge the areas of conditional formatting and validation before saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *JsonSaveOptions) SetMergeAreas(value bool)  error {
	
	CGoReturnPtr := C.JsonSaveOptions_SetMergeAreas( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// If true and the directory does not exist, the directory will be automatically created before saving the file.
// Returns:
//   bool  
func (instance *JsonSaveOptions) GetCreateDirectory()  (bool,  error)  {
	
	CGoReturnPtr := C.JsonSaveOptions_GetCreateDirectory( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// If true and the directory does not exist, the directory will be automatically created before saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *JsonSaveOptions) SetCreateDirectory(value bool)  error {
	
	CGoReturnPtr := C.JsonSaveOptions_SetCreateDirectory( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether sorting defined names before saving file.
// Returns:
//   bool  
func (instance *JsonSaveOptions) GetSortNames()  (bool,  error)  {
	
	CGoReturnPtr := C.JsonSaveOptions_GetSortNames( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether sorting defined names before saving file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *JsonSaveOptions) SetSortNames(value bool)  error {
	
	CGoReturnPtr := C.JsonSaveOptions_SetSortNames( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether sorting external defined names before saving file.
// Returns:
//   bool  
func (instance *JsonSaveOptions) GetSortExternalNames()  (bool,  error)  {
	
	CGoReturnPtr := C.JsonSaveOptions_GetSortExternalNames( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether sorting external defined names before saving file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *JsonSaveOptions) SetSortExternalNames(value bool)  error {
	
	CGoReturnPtr := C.JsonSaveOptions_SetSortExternalNames( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether refreshing chart cache data
// Returns:
//   bool  
func (instance *JsonSaveOptions) GetRefreshChartCache()  (bool,  error)  {
	
	CGoReturnPtr := C.JsonSaveOptions_GetRefreshChartCache( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether refreshing chart cache data
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *JsonSaveOptions) SetRefreshChartCache(value bool)  error {
	
	CGoReturnPtr := C.JsonSaveOptions_SetRefreshChartCache( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Whether check restriction of excel file when user modify cells related objects.
// For example, excel does not allow inputting string value longer than 32K.
// When you input a value longer than 32K, it will be truncated.
// Returns:
//   bool  
func (instance *JsonSaveOptions) GetCheckExcelRestriction()  (bool,  error)  {
	
	CGoReturnPtr := C.JsonSaveOptions_GetCheckExcelRestriction( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Whether check restriction of excel file when user modify cells related objects.
// For example, excel does not allow inputting string value longer than 32K.
// When you input a value longer than 32K, it will be truncated.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *JsonSaveOptions) SetCheckExcelRestriction(value bool)  error {
	
	CGoReturnPtr := C.JsonSaveOptions_SetCheckExcelRestriction( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether updating smart art setting.
// The default value is false.
// Returns:
//   bool  
func (instance *JsonSaveOptions) GetUpdateSmartArt()  (bool,  error)  {
	
	CGoReturnPtr := C.JsonSaveOptions_GetUpdateSmartArt( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether updating smart art setting.
// The default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *JsonSaveOptions) SetUpdateSmartArt(value bool)  error {
	
	CGoReturnPtr := C.JsonSaveOptions_SetUpdateSmartArt( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether encrypt document properties when saving as .xls file.
// The default value is true.
// Returns:
//   bool  
func (instance *JsonSaveOptions) GetEncryptDocumentProperties()  (bool,  error)  {
	
	CGoReturnPtr := C.JsonSaveOptions_GetEncryptDocumentProperties( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether encrypt document properties when saving as .xls file.
// The default value is true.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *JsonSaveOptions) SetEncryptDocumentProperties(value bool)  error {
	
	CGoReturnPtr := C.JsonSaveOptions_SetEncryptDocumentProperties( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}


func (instance *JsonSaveOptions) ToSaveOptions() *SaveOptions {
	parentClass := &SaveOptions{}
	parentClass.ptr = instance.ptr
	return parentClass
}

func DeleteJsonSaveOptions(jsonsaveoptions *JsonSaveOptions){
	runtime.SetFinalizer(jsonsaveoptions, nil)
	C.Delete_JsonSaveOptions(jsonsaveoptions.ptr)
	jsonsaveoptions.ptr = nil
}

// Class License 

// Provides methods to license the component.
type License struct {
	ptr unsafe.Pointer
}

// Default constructor.
func NewLicense() ( *License, error) {
	license := &License{}
	CGoReturnPtr := C.New_License()
	if CGoReturnPtr.error_no == 0 {
		license.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(license, DeleteLicense)
		return license, nil
	} else {
		license.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return license, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *License) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.License_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Licenses the component.
// Parameters:
//   licenseName - string 
// Returns:
//   void  
func (instance *License) SetLicense_String(licensename string)  error {
	
	CGoReturnPtr := C.License_SetLicense_String( instance.ptr, C.CString(licensename))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Licenses the component.
// Parameters:
//   stream - []byte 
// Returns:
//   void  
func (instance *License) SetLicense_Stream(stream []byte)  error {
	
	CGoReturnPtr := C.License_SetLicense_Stream( instance.ptr, unsafe.Pointer(&stream[0]), C.int( len(stream)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}



func DeleteLicense(license *License){
	runtime.SetFinalizer(license, nil)
	C.Delete_License(license.ptr)
	license.ptr = nil
}

// Class LoadFilter 

// Represents the filter that provides options for loading data when loading workbook from template.
type LoadFilter struct {
	ptr unsafe.Pointer
}

// Constructs one LoadFilter with default filter options LoadDataFilterOptions::All.
func NewLoadFilter() ( *LoadFilter, error) {
	loadfilter := &LoadFilter{}
	CGoReturnPtr := C.New_LoadFilter()
	if CGoReturnPtr.error_no == 0 {
		loadfilter.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(loadfilter, DeleteLoadFilter)
		return loadfilter, nil
	} else {
		loadfilter.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return loadfilter, err
	}	
}
// Constructs one LoadFilter with given filter options.
// Parameters:
//   opts - int32 
func NewLoadFilter_LoadDataFilterOptions(opts LoadDataFilterOptions) ( *LoadFilter, error) {
	loadfilter := &LoadFilter{}
	CGoReturnPtr := C.New_LoadFilter_LoadDataFilterOptions(C.int( int32(opts)))
	if CGoReturnPtr.error_no == 0 {
		loadfilter.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(loadfilter, DeleteLoadFilter)
		return loadfilter, nil
	} else {
		loadfilter.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return loadfilter, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *LoadFilter) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.LoadFilter_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the filter options to denote what data should be loaded.
// Returns:
//   int32  
func (instance *LoadFilter) GetLoadDataFilterOptions()  (LoadDataFilterOptions,  error)  {
	
	CGoReturnPtr := C.LoadFilter_GetLoadDataFilterOptions( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToLoadDataFilterOptions(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Sets the filter options to denote what data should be loaded.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *LoadFilter) SetLoadDataFilterOptions(value LoadDataFilterOptions)  error {
	
	CGoReturnPtr := C.LoadFilter_SetLoadDataFilterOptions( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Specifies the sheets(indices) and order to be loaded.
// Default is null, that denotes to load all sheets in the default order in template file.
// If not null and some sheet's index is not in the returned array, then the sheet will not be loaded.
// Returns:
//   []int32_t  
func (instance *LoadFilter) GetSheetsInLoadingOrder()  ([]int32,  error)  {
	
	CGoReturnPtr := C.LoadFilter_GetSheetsInLoadingOrder( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result:= make([]int32, CGoReturnPtr.column_length)
	for i := 0; i < int(CGoReturnPtr.column_length); i++ {
	   offset := uintptr(C.size_t(i)) * uintptr(CGoReturnPtr.size)
	   cObject := *(*C.int)(unsafe.Pointer( uintptr( unsafe.Pointer(CGoReturnPtr.return_value)) + offset))
	   goObject :=int32(cObject)
	   result[i] = goObject
	}
	 

	return result, nil 
}
// Prepares filter options before loading given worksheet.
// User's implementation of LoadFilter can change the LoadDataFilterOptions here
// to denote how to load data for this worksheet.
// Parameters:
//   sheet - Worksheet 
// Returns:
//   void  
func (instance *LoadFilter) StartSheet(sheet *Worksheet)  error {
	
	var sheet_ptr unsafe.Pointer = nil
	if sheet != nil {
	  sheet_ptr =sheet.ptr
	}

	CGoReturnPtr := C.LoadFilter_StartSheet( instance.ptr, sheet_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}

func (loadfilter *LoadFilter) Set__loadDataFilterOptions(value int32 ) {
	C.LoadFilter_Set__loadDataFilterOptions(loadfilter.ptr, C.int( value ))
}

func (loadfilter *LoadFilter) Get__loadDataFilterOptions() (int32 , error) {
	CGoReturnPtr := C.LoadFilter_Get__loadDataFilterOptions(loadfilter.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return 0, err
	}
	result := int32(CGoReturnPtr.return_value)
	return result, nil 
}


func DeleteLoadFilter(loadfilter *LoadFilter){
	runtime.SetFinalizer(loadfilter, nil)
	C.Delete_LoadFilter(loadfilter.ptr)
	loadfilter.ptr = nil
}

// Class LoadOptions 

// Represents the options of loading the file.
type LoadOptions struct {
	ptr unsafe.Pointer
}

// Creates an options of loading the file.
func NewLoadOptions() ( *LoadOptions, error) {
	loadoptions := &LoadOptions{}
	CGoReturnPtr := C.New_LoadOptions()
	if CGoReturnPtr.error_no == 0 {
		loadoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(loadoptions, DeleteLoadOptions)
		return loadoptions, nil
	} else {
		loadoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return loadoptions, err
	}	
}
// Creates an options of loading the file.
// Parameters:
//   loadFormat - int32 
func NewLoadOptions_LoadFormat(loadformat LoadFormat) ( *LoadOptions, error) {
	loadoptions := &LoadOptions{}
	CGoReturnPtr := C.New_LoadOptions_LoadFormat(C.int( int32(loadformat)))
	if CGoReturnPtr.error_no == 0 {
		loadoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(loadoptions, DeleteLoadOptions)
		return loadoptions, nil
	} else {
		loadoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return loadoptions, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *LoadOptions) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.LoadOptions_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the load format.
// Returns:
//   int32  
func (instance *LoadOptions) GetLoadFormat()  (LoadFormat,  error)  {
	
	CGoReturnPtr := C.LoadOptions_GetLoadFormat( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToLoadFormat(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets and set the password of the workbook.
// Returns:
//   string  
func (instance *LoadOptions) GetPassword()  (string,  error)  {
	
	CGoReturnPtr := C.LoadOptions_GetPassword( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and set the password of the workbook.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *LoadOptions) SetPassword(value string)  error {
	
	CGoReturnPtr := C.LoadOptions_SetPassword( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether parsing the formula when reading the file.
// Returns:
//   bool  
func (instance *LoadOptions) GetParsingFormulaOnOpen()  (bool,  error)  {
	
	CGoReturnPtr := C.LoadOptions_GetParsingFormulaOnOpen( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether parsing the formula when reading the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *LoadOptions) SetParsingFormulaOnOpen(value bool)  error {
	
	CGoReturnPtr := C.LoadOptions_SetParsingFormulaOnOpen( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether parsing pivot cached records when loading the file.
// The default value is false.
// Returns:
//   bool  
func (instance *LoadOptions) GetParsingPivotCachedRecords()  (bool,  error)  {
	
	CGoReturnPtr := C.LoadOptions_GetParsingPivotCachedRecords( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether parsing pivot cached records when loading the file.
// The default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *LoadOptions) SetParsingPivotCachedRecords(value bool)  error {
	
	CGoReturnPtr := C.LoadOptions_SetParsingPivotCachedRecords( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Sets the default print paper size from default printer's setting.
// Parameters:
//   type - int32 
// Returns:
//   void  
func (instance *LoadOptions) SetPaperSize(type_ PaperSizeType)  error {
	
	CGoReturnPtr := C.LoadOptions_SetPaperSize( instance.ptr, C.int( int32(type_)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the user interface language of the Workbook version based on CountryCode that has saved the file.
// Returns:
//   int32  
func (instance *LoadOptions) GetLanguageCode()  (CountryCode,  error)  {
	
	CGoReturnPtr := C.LoadOptions_GetLanguageCode( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToCountryCode(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets or sets the user interface language of the Workbook version based on CountryCode that has saved the file.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *LoadOptions) SetLanguageCode(value CountryCode)  error {
	
	CGoReturnPtr := C.LoadOptions_SetLanguageCode( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the regional settings used for the Workbook that will be loaded.
// Returns:
//   int32  
func (instance *LoadOptions) GetRegion()  (CountryCode,  error)  {
	
	CGoReturnPtr := C.LoadOptions_GetRegion( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToCountryCode(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets or sets the regional settings used for the Workbook that will be loaded.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *LoadOptions) SetRegion(value CountryCode)  error {
	
	CGoReturnPtr := C.LoadOptions_SetRegion( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the default style settings for initializing styles of the workbook
// Returns:
//   DefaultStyleSettings  
func (instance *LoadOptions) GetDefaultStyleSettings()  (*DefaultStyleSettings,  error)  {
	
	CGoReturnPtr := C.LoadOptions_GetDefaultStyleSettings( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &DefaultStyleSettings{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteDefaultStyleSettings) 

	return result, nil 
}
// Gets and sets the interrupt monitor.
// Returns:
//   AbstractInterruptMonitor  
func (instance *LoadOptions) GetInterruptMonitor()  (*AbstractInterruptMonitor,  error)  {
	
	CGoReturnPtr := C.LoadOptions_GetInterruptMonitor( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &AbstractInterruptMonitor{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteAbstractInterruptMonitor) 

	return result, nil 
}
// Gets and sets the interrupt monitor.
// Parameters:
//   value - AbstractInterruptMonitor 
// Returns:
//   void  
func (instance *LoadOptions) SetInterruptMonitor(value *AbstractInterruptMonitor)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.LoadOptions_SetInterruptMonitor( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Ignore the data which are not printed if directly printing the file
// Returns:
//   bool  
func (instance *LoadOptions) GetIgnoreNotPrinted()  (bool,  error)  {
	
	CGoReturnPtr := C.LoadOptions_GetIgnoreNotPrinted( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Ignore the data which are not printed if directly printing the file
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *LoadOptions) SetIgnoreNotPrinted(value bool)  error {
	
	CGoReturnPtr := C.LoadOptions_SetIgnoreNotPrinted( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Check whether data is valid in the template file.
// Returns:
//   bool  
func (instance *LoadOptions) GetCheckDataValid()  (bool,  error)  {
	
	CGoReturnPtr := C.LoadOptions_GetCheckDataValid( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Check whether data is valid in the template file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *LoadOptions) SetCheckDataValid(value bool)  error {
	
	CGoReturnPtr := C.LoadOptions_SetCheckDataValid( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Whether check restriction of excel file when user modify cells related objects.
// For example, excel does not allow inputting string value longer than 32K.
// When you input a value longer than 32K such as by Cell.PutValue(string), if this property is true, you will get an Exception.
// If this property is false, we will accept your input string value as the cell's value so that later
// you can output the complete string value for other file formats such as CSV.
// However, if you have set such kind of value that is invalid for excel file format,
// you should not save the workbook as excel file format later. Otherwise there may be unexpected error for the generated excel file.
// Returns:
//   bool  
func (instance *LoadOptions) GetCheckExcelRestriction()  (bool,  error)  {
	
	CGoReturnPtr := C.LoadOptions_GetCheckExcelRestriction( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Whether check restriction of excel file when user modify cells related objects.
// For example, excel does not allow inputting string value longer than 32K.
// When you input a value longer than 32K such as by Cell.PutValue(string), if this property is true, you will get an Exception.
// If this property is false, we will accept your input string value as the cell's value so that later
// you can output the complete string value for other file formats such as CSV.
// However, if you have set such kind of value that is invalid for excel file format,
// you should not save the workbook as excel file format later. Otherwise there may be unexpected error for the generated excel file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *LoadOptions) SetCheckExcelRestriction(value bool)  error {
	
	CGoReturnPtr := C.LoadOptions_SetCheckExcelRestriction( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Whether keep the unparsed data in memory for the Workbook when it is loaded from template file. Default is true.
// Returns:
//   bool  
func (instance *LoadOptions) GetKeepUnparsedData()  (bool,  error)  {
	
	CGoReturnPtr := C.LoadOptions_GetKeepUnparsedData( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Whether keep the unparsed data in memory for the Workbook when it is loaded from template file. Default is true.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *LoadOptions) SetKeepUnparsedData(value bool)  error {
	
	CGoReturnPtr := C.LoadOptions_SetKeepUnparsedData( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// The filter to denote how to load data.
// Returns:
//   LoadFilter  
func (instance *LoadOptions) GetLoadFilter()  (*LoadFilter,  error)  {
	
	CGoReturnPtr := C.LoadOptions_GetLoadFilter( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &LoadFilter{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteLoadFilter) 

	return result, nil 
}
// The filter to denote how to load data.
// Parameters:
//   value - LoadFilter 
// Returns:
//   void  
func (instance *LoadOptions) SetLoadFilter(value *LoadFilter)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.LoadOptions_SetLoadFilter( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the memory usage options.
// Returns:
//   int32  
func (instance *LoadOptions) GetMemorySetting()  (MemorySetting,  error)  {
	
	CGoReturnPtr := C.LoadOptions_GetMemorySetting( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToMemorySetting(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets or sets the memory usage options.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *LoadOptions) SetMemorySetting(value MemorySetting)  error {
	
	CGoReturnPtr := C.LoadOptions_SetMemorySetting( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the auto fitter options
// Returns:
//   AutoFitterOptions  
func (instance *LoadOptions) GetAutoFitterOptions()  (*AutoFitterOptions,  error)  {
	
	CGoReturnPtr := C.LoadOptions_GetAutoFitterOptions( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &AutoFitterOptions{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteAutoFitterOptions) 

	return result, nil 
}
// Gets and sets the auto fitter options
// Parameters:
//   value - AutoFitterOptions 
// Returns:
//   void  
func (instance *LoadOptions) SetAutoFitterOptions(value *AutoFitterOptions)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.LoadOptions_SetAutoFitterOptions( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether auto filtering the data when loading the files.
// Returns:
//   bool  
func (instance *LoadOptions) GetAutoFilter()  (bool,  error)  {
	
	CGoReturnPtr := C.LoadOptions_GetAutoFilter( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether auto filtering the data when loading the files.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *LoadOptions) SetAutoFilter(value bool)  error {
	
	CGoReturnPtr := C.LoadOptions_SetAutoFilter( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets individual font configs.
// Only works for the <see cref="Workbook"/> which uses this <see cref="LoadOptions"/> to load.
// Returns:
//   IndividualFontConfigs  
func (instance *LoadOptions) GetFontConfigs()  (*IndividualFontConfigs,  error)  {
	
	CGoReturnPtr := C.LoadOptions_GetFontConfigs( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &IndividualFontConfigs{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteIndividualFontConfigs) 

	return result, nil 
}
// Gets and sets individual font configs.
// Only works for the <see cref="Workbook"/> which uses this <see cref="LoadOptions"/> to load.
// Parameters:
//   value - IndividualFontConfigs 
// Returns:
//   void  
func (instance *LoadOptions) SetFontConfigs(value *IndividualFontConfigs)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.LoadOptions_SetFontConfigs( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether ignoring useless shapes.
// Returns:
//   bool  
func (instance *LoadOptions) GetIgnoreUselessShapes()  (bool,  error)  {
	
	CGoReturnPtr := C.LoadOptions_GetIgnoreUselessShapes( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether ignoring useless shapes.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *LoadOptions) SetIgnoreUselessShapes(value bool)  error {
	
	CGoReturnPtr := C.LoadOptions_SetIgnoreUselessShapes( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether preserve those spaces and line breaks that are padded between formula tokens
// while getting and setting formulas.
// Default value is false.
// Returns:
//   bool  
func (instance *LoadOptions) GetPreservePaddingSpacesInFormula()  (bool,  error)  {
	
	CGoReturnPtr := C.LoadOptions_GetPreservePaddingSpacesInFormula( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether preserve those spaces and line breaks that are padded between formula tokens
// while getting and setting formulas.
// Default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *LoadOptions) SetPreservePaddingSpacesInFormula(value bool)  error {
	
	CGoReturnPtr := C.LoadOptions_SetPreservePaddingSpacesInFormula( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}



func DeleteLoadOptions(loadoptions *LoadOptions){
	runtime.SetFinalizer(loadoptions, nil)
	C.Delete_LoadOptions(loadoptions.ptr)
	loadoptions.ptr = nil
}

// Class MarkdownSaveOptions 

// Represents the save options for markdown.
type MarkdownSaveOptions struct {
	ptr unsafe.Pointer
}

// Creates options for saving markdown document
func NewMarkdownSaveOptions() ( *MarkdownSaveOptions, error) {
	markdownsaveoptions := &MarkdownSaveOptions{}
	CGoReturnPtr := C.New_MarkdownSaveOptions()
	if CGoReturnPtr.error_no == 0 {
		markdownsaveoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(markdownsaveoptions, DeleteMarkdownSaveOptions)
		return markdownsaveoptions, nil
	} else {
		markdownsaveoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return markdownsaveoptions, err
	}	
}
// Constructs from a parent object.
// Parameters:
//   src - SaveOptions 
func NewMarkdownSaveOptions_SaveOptions(src *SaveOptions) ( *MarkdownSaveOptions, error) {
	markdownsaveoptions := &MarkdownSaveOptions{}
	var src_ptr unsafe.Pointer = nil
	if src != nil {
	  src_ptr =src.ptr
	}

	CGoReturnPtr := C.New_MarkdownSaveOptions_SaveOptions(src_ptr)
	if CGoReturnPtr.error_no == 0 {
		markdownsaveoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(markdownsaveoptions, DeleteMarkdownSaveOptions)
		return markdownsaveoptions, nil
	} else {
		markdownsaveoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return markdownsaveoptions, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *MarkdownSaveOptions) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.MarkdownSaveOptions_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the default encoding.
// Returns:
//   int32  
func (instance *MarkdownSaveOptions) GetEncoding()  (EncodingType,  error)  {
	
	CGoReturnPtr := C.MarkdownSaveOptions_GetEncoding( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToEncodingType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets and sets the default encoding.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *MarkdownSaveOptions) SetEncoding(value EncodingType)  error {
	
	CGoReturnPtr := C.MarkdownSaveOptions_SetEncoding( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the format strategy when exporting the cell value as string.
// Returns:
//   int32  
func (instance *MarkdownSaveOptions) GetFormatStrategy()  (CellValueFormatStrategy,  error)  {
	
	CGoReturnPtr := C.MarkdownSaveOptions_GetFormatStrategy( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToCellValueFormatStrategy(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets and sets the format strategy when exporting the cell value as string.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *MarkdownSaveOptions) SetFormatStrategy(value CellValueFormatStrategy)  error {
	
	CGoReturnPtr := C.MarkdownSaveOptions_SetFormatStrategy( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the line separator.
// Returns:
//   string  
func (instance *MarkdownSaveOptions) GetLineSeparator()  (string,  error)  {
	
	CGoReturnPtr := C.MarkdownSaveOptions_GetLineSeparator( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the line separator.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *MarkdownSaveOptions) SetLineSeparator(value string)  error {
	
	CGoReturnPtr := C.MarkdownSaveOptions_SetLineSeparator( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets how set the header of the table.
// Returns:
//   int32  
func (instance *MarkdownSaveOptions) GetTableHeaderType()  (MarkdownTableHeaderType,  error)  {
	
	CGoReturnPtr := C.MarkdownSaveOptions_GetTableHeaderType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToMarkdownTableHeaderType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets and sets how set the header of the table.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *MarkdownSaveOptions) SetTableHeaderType(value MarkdownTableHeaderType)  error {
	
	CGoReturnPtr := C.MarkdownSaveOptions_SetTableHeaderType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the sheets to render. Default is all visible sheets in the workbook: <see cref="Aspose.Cells.Rendering.SheetSet.Active"/>.
// Returns:
//   SheetSet  
func (instance *MarkdownSaveOptions) GetSheetSet()  (*SheetSet,  error)  {
	
	CGoReturnPtr := C.MarkdownSaveOptions_GetSheetSet( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &SheetSet{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteSheetSet) 

	return result, nil 
}
// Gets or sets the sheets to render. Default is all visible sheets in the workbook: <see cref="Aspose.Cells.Rendering.SheetSet.Active"/>.
// Parameters:
//   value - SheetSet 
// Returns:
//   void  
func (instance *MarkdownSaveOptions) SetSheetSet(value *SheetSet)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.MarkdownSaveOptions_SetSheetSet( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Get the ImageOrPrintOptions object before exporting
// Returns:
//   ImageOrPrintOptions  
func (instance *MarkdownSaveOptions) GetImageOptions()  (*ImageOrPrintOptions,  error)  {
	
	CGoReturnPtr := C.MarkdownSaveOptions_GetImageOptions( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &ImageOrPrintOptions{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteImageOrPrintOptions) 

	return result, nil 
}
// Specifies whether images are saved in Base64 format to Markdown.
// Returns:
//   bool  
func (instance *MarkdownSaveOptions) GetExportImagesAsBase64()  (bool,  error)  {
	
	CGoReturnPtr := C.MarkdownSaveOptions_GetExportImagesAsBase64( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Specifies whether images are saved in Base64 format to Markdown.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *MarkdownSaveOptions) SetExportImagesAsBase64(value bool)  error {
	
	CGoReturnPtr := C.MarkdownSaveOptions_SetExportImagesAsBase64( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the save file format.
// Returns:
//   int32  
func (instance *MarkdownSaveOptions) GetSaveFormat()  (SaveFormat,  error)  {
	
	CGoReturnPtr := C.MarkdownSaveOptions_GetSaveFormat( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToSaveFormat(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Make the workbook empty after saving the file.
// Returns:
//   bool  
func (instance *MarkdownSaveOptions) GetClearData()  (bool,  error)  {
	
	CGoReturnPtr := C.MarkdownSaveOptions_GetClearData( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Make the workbook empty after saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *MarkdownSaveOptions) SetClearData(value bool)  error {
	
	CGoReturnPtr := C.MarkdownSaveOptions_SetClearData( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// The folder for temporary files that may be used as data cache.
// Returns:
//   string  
func (instance *MarkdownSaveOptions) GetCachedFileFolder()  (string,  error)  {
	
	CGoReturnPtr := C.MarkdownSaveOptions_GetCachedFileFolder( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// The folder for temporary files that may be used as data cache.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *MarkdownSaveOptions) SetCachedFileFolder(value string)  error {
	
	CGoReturnPtr := C.MarkdownSaveOptions_SetCachedFileFolder( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether validate merged cells before saving the file.
// Returns:
//   bool  
func (instance *MarkdownSaveOptions) GetValidateMergedAreas()  (bool,  error)  {
	
	CGoReturnPtr := C.MarkdownSaveOptions_GetValidateMergedAreas( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether validate merged cells before saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *MarkdownSaveOptions) SetValidateMergedAreas(value bool)  error {
	
	CGoReturnPtr := C.MarkdownSaveOptions_SetValidateMergedAreas( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether merge the areas of conditional formatting and validation before saving the file.
// Returns:
//   bool  
func (instance *MarkdownSaveOptions) GetMergeAreas()  (bool,  error)  {
	
	CGoReturnPtr := C.MarkdownSaveOptions_GetMergeAreas( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether merge the areas of conditional formatting and validation before saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *MarkdownSaveOptions) SetMergeAreas(value bool)  error {
	
	CGoReturnPtr := C.MarkdownSaveOptions_SetMergeAreas( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// If true and the directory does not exist, the directory will be automatically created before saving the file.
// Returns:
//   bool  
func (instance *MarkdownSaveOptions) GetCreateDirectory()  (bool,  error)  {
	
	CGoReturnPtr := C.MarkdownSaveOptions_GetCreateDirectory( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// If true and the directory does not exist, the directory will be automatically created before saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *MarkdownSaveOptions) SetCreateDirectory(value bool)  error {
	
	CGoReturnPtr := C.MarkdownSaveOptions_SetCreateDirectory( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether sorting defined names before saving file.
// Returns:
//   bool  
func (instance *MarkdownSaveOptions) GetSortNames()  (bool,  error)  {
	
	CGoReturnPtr := C.MarkdownSaveOptions_GetSortNames( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether sorting defined names before saving file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *MarkdownSaveOptions) SetSortNames(value bool)  error {
	
	CGoReturnPtr := C.MarkdownSaveOptions_SetSortNames( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether sorting external defined names before saving file.
// Returns:
//   bool  
func (instance *MarkdownSaveOptions) GetSortExternalNames()  (bool,  error)  {
	
	CGoReturnPtr := C.MarkdownSaveOptions_GetSortExternalNames( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether sorting external defined names before saving file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *MarkdownSaveOptions) SetSortExternalNames(value bool)  error {
	
	CGoReturnPtr := C.MarkdownSaveOptions_SetSortExternalNames( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether refreshing chart cache data
// Returns:
//   bool  
func (instance *MarkdownSaveOptions) GetRefreshChartCache()  (bool,  error)  {
	
	CGoReturnPtr := C.MarkdownSaveOptions_GetRefreshChartCache( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether refreshing chart cache data
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *MarkdownSaveOptions) SetRefreshChartCache(value bool)  error {
	
	CGoReturnPtr := C.MarkdownSaveOptions_SetRefreshChartCache( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Whether check restriction of excel file when user modify cells related objects.
// For example, excel does not allow inputting string value longer than 32K.
// When you input a value longer than 32K, it will be truncated.
// Returns:
//   bool  
func (instance *MarkdownSaveOptions) GetCheckExcelRestriction()  (bool,  error)  {
	
	CGoReturnPtr := C.MarkdownSaveOptions_GetCheckExcelRestriction( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Whether check restriction of excel file when user modify cells related objects.
// For example, excel does not allow inputting string value longer than 32K.
// When you input a value longer than 32K, it will be truncated.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *MarkdownSaveOptions) SetCheckExcelRestriction(value bool)  error {
	
	CGoReturnPtr := C.MarkdownSaveOptions_SetCheckExcelRestriction( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether updating smart art setting.
// The default value is false.
// Returns:
//   bool  
func (instance *MarkdownSaveOptions) GetUpdateSmartArt()  (bool,  error)  {
	
	CGoReturnPtr := C.MarkdownSaveOptions_GetUpdateSmartArt( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether updating smart art setting.
// The default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *MarkdownSaveOptions) SetUpdateSmartArt(value bool)  error {
	
	CGoReturnPtr := C.MarkdownSaveOptions_SetUpdateSmartArt( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether encrypt document properties when saving as .xls file.
// The default value is true.
// Returns:
//   bool  
func (instance *MarkdownSaveOptions) GetEncryptDocumentProperties()  (bool,  error)  {
	
	CGoReturnPtr := C.MarkdownSaveOptions_GetEncryptDocumentProperties( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether encrypt document properties when saving as .xls file.
// The default value is true.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *MarkdownSaveOptions) SetEncryptDocumentProperties(value bool)  error {
	
	CGoReturnPtr := C.MarkdownSaveOptions_SetEncryptDocumentProperties( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}


func (instance *MarkdownSaveOptions) ToSaveOptions() *SaveOptions {
	parentClass := &SaveOptions{}
	parentClass.ptr = instance.ptr
	return parentClass
}

func DeleteMarkdownSaveOptions(markdownsaveoptions *MarkdownSaveOptions){
	runtime.SetFinalizer(markdownsaveoptions, nil)
	C.Delete_MarkdownSaveOptions(markdownsaveoptions.ptr)
	markdownsaveoptions.ptr = nil
}

// Class MemoryFontSource 

// Represents the single TrueType font file stored in memory.
type MemoryFontSource struct {
	ptr unsafe.Pointer
}

// Ctor.
// Parameters:
//   fontData - []byte 
func NewMemoryFontSource_Stream(fontdata []byte) ( *MemoryFontSource, error) {
	memoryfontsource := &MemoryFontSource{}
	CGoReturnPtr := C.New_MemoryFontSource_Stream(unsafe.Pointer(&fontdata[0]), C.int( len(fontdata)))
	if CGoReturnPtr.error_no == 0 {
		memoryfontsource.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(memoryfontsource, DeleteMemoryFontSource)
		return memoryfontsource, nil
	} else {
		memoryfontsource.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return memoryfontsource, err
	}	
}
// Constructs from a parent object.
// Parameters:
//   src - FontSourceBase 
func NewMemoryFontSource_FontSourceBase(src *FontSourceBase) ( *MemoryFontSource, error) {
	memoryfontsource := &MemoryFontSource{}
	var src_ptr unsafe.Pointer = nil
	if src != nil {
	  src_ptr =src.ptr
	}

	CGoReturnPtr := C.New_MemoryFontSource_FontSourceBase(src_ptr)
	if CGoReturnPtr.error_no == 0 {
		memoryfontsource.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(memoryfontsource, DeleteMemoryFontSource)
		return memoryfontsource, nil
	} else {
		memoryfontsource.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return memoryfontsource, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *MemoryFontSource) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.MemoryFontSource_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Binary font data.
// Returns:
//   []byte  
func (instance *MemoryFontSource) GetFontData()  ([]byte,  error)  {
	
	CGoReturnPtr := C.MemoryFontSource_GetFontData( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := C.GoBytes(unsafe.Pointer(CGoReturnPtr.return_value), C.int(CGoReturnPtr.column_length))
	 

	return result, nil 
}
// Returns the type of the font source.
// Returns:
//   int32  
func (instance *MemoryFontSource) GetType()  (FontSourceType,  error)  {
	
	CGoReturnPtr := C.MemoryFontSource_GetType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToFontSourceType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}


func (instance *MemoryFontSource) ToFontSourceBase() *FontSourceBase {
	parentClass := &FontSourceBase{}
	parentClass.ptr = instance.ptr
	return parentClass
}

func DeleteMemoryFontSource(memoryfontsource *MemoryFontSource){
	runtime.SetFinalizer(memoryfontsource, nil)
	C.Delete_MemoryFontSource(memoryfontsource.ptr)
	memoryfontsource.ptr = nil
}

// Class MultipleFilterCollection 

// Represents the multiple filter collection.
type MultipleFilterCollection struct {
	ptr unsafe.Pointer
}

// Constructs one new instance.
func NewMultipleFilterCollection() ( *MultipleFilterCollection, error) {
	multiplefiltercollection := &MultipleFilterCollection{}
	CGoReturnPtr := C.New_MultipleFilterCollection()
	if CGoReturnPtr.error_no == 0 {
		multiplefiltercollection.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(multiplefiltercollection, DeleteMultipleFilterCollection)
		return multiplefiltercollection, nil
	} else {
		multiplefiltercollection.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return multiplefiltercollection, err
	}	
}
// Constructs from an Object convertible to this.
// Parameters:
//   obj - Object 
func NewMultipleFilterCollection_Object(obj *Object) ( *MultipleFilterCollection, error) {
	multiplefiltercollection := &MultipleFilterCollection{}
	var obj_ptr unsafe.Pointer = nil
	if obj != nil {
	  obj_ptr =obj.ptr
	}

	CGoReturnPtr := C.New_MultipleFilterCollection_Object(obj_ptr)
	if CGoReturnPtr.error_no == 0 {
		multiplefiltercollection.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(multiplefiltercollection, DeleteMultipleFilterCollection)
		return multiplefiltercollection, nil
	} else {
		multiplefiltercollection.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return multiplefiltercollection, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *MultipleFilterCollection) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.MultipleFilterCollection_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the Object.
// Returns:
//   Object  
func (instance *MultipleFilterCollection) ToObject()  (*Object,  error)  {
	
	CGoReturnPtr := C.MultipleFilterCollection_ToObject( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Object{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteObject) 

	return result, nil 
}
// Indicates whether to filter by blank.
// Returns:
//   bool  
func (instance *MultipleFilterCollection) GetMatchBlank()  (bool,  error)  {
	
	CGoReturnPtr := C.MultipleFilterCollection_GetMatchBlank( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether to filter by blank.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *MultipleFilterCollection) SetMatchBlank(value bool)  error {
	
	CGoReturnPtr := C.MultipleFilterCollection_SetMatchBlank( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// DateTimeGroupItem or a simple object.
// Parameters:
//   index - int32 
// Returns:
//   Object  
func (instance *MultipleFilterCollection) Get(index int32)  (*Object,  error)  {
	
	CGoReturnPtr := C.MultipleFilterCollection_Get( instance.ptr, C.int(index))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Object{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteObject) 

	return result, nil 
}
// Adds string filter.
// Parameters:
//   filter - string 
// Returns:
//   void  
func (instance *MultipleFilterCollection) Add(filter string)  error {
	
	CGoReturnPtr := C.MultipleFilterCollection_Add( instance.ptr, C.CString(filter))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Returns:
//   int32  
func (instance *MultipleFilterCollection) GetCount()  (int32,  error)  {
	
	CGoReturnPtr := C.MultipleFilterCollection_GetCount( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}



func DeleteMultipleFilterCollection(multiplefiltercollection *MultipleFilterCollection){
	runtime.SetFinalizer(multiplefiltercollection, nil)
	C.Delete_MultipleFilterCollection(multiplefiltercollection.ptr)
	multiplefiltercollection.ptr = nil
}

// Class Name 

// Represents a defined name for a range of cells.
type Name struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *Name) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.Name_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the comment of the name.
// Only applies for Excel 2007 or higher versions.
// Returns:
//   string  
func (instance *Name) GetComment()  (string,  error)  {
	
	CGoReturnPtr := C.Name_GetComment( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the comment of the name.
// Only applies for Excel 2007 or higher versions.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *Name) SetComment(value string)  error {
	
	CGoReturnPtr := C.Name_SetComment( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the name text of the object.
// Returns:
//   string  
func (instance *Name) GetText()  (string,  error)  {
	
	CGoReturnPtr := C.Name_GetText( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the name text of the object.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *Name) SetText(value string)  error {
	
	CGoReturnPtr := C.Name_SetText( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the name  full text of the object with the scope setting.
// Returns:
//   string  
func (instance *Name) GetFullText()  (string,  error)  {
	
	CGoReturnPtr := C.Name_GetFullText( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Returns or sets the formula that the name is defined to refer to, beginning with an equal sign.
// Returns:
//   string  
func (instance *Name) GetRefersTo()  (string,  error)  {
	
	CGoReturnPtr := C.Name_GetRefersTo( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Returns or sets the formula that the name is defined to refer to, beginning with an equal sign.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *Name) SetRefersTo_String(value string)  error {
	
	CGoReturnPtr := C.Name_SetRefersTo_String( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets a R1C1 reference of the <see cref="Name"/>.
// Returns:
//   string  
func (instance *Name) GetR1C1RefersTo()  (string,  error)  {
	
	CGoReturnPtr := C.Name_GetR1C1RefersTo( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets a R1C1 reference of the <see cref="Name"/>.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *Name) SetR1C1RefersTo(value string)  error {
	
	CGoReturnPtr := C.Name_SetR1C1RefersTo( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Get the reference of this Name.
// Parameters:
//   isR1C1 - bool 
//   isLocal - bool 
// Returns:
//   string  
func (instance *Name) GetRefersTo_Bool_Bool(isr1c1 bool, islocal bool)  (string,  error)  {
	
	CGoReturnPtr := C.Name_GetRefersTo_Boolean_Boolean( instance.ptr, C.bool(isr1c1), C.bool(islocal))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Get the reference of this Name based on specified cell.
// Parameters:
//   isR1C1 - bool 
//   isLocal - bool 
//   row - int32 
//   column - int32 
// Returns:
//   string  
func (instance *Name) GetRefersTo_Bool_Bool_Int_Int(isr1c1 bool, islocal bool, row int32, column int32)  (string,  error)  {
	
	CGoReturnPtr := C.Name_GetRefersTo_Boolean_Boolean_Integer_Integer( instance.ptr, C.bool(isr1c1), C.bool(islocal), C.int(row), C.int(column))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Set the reference of this Name.
// Parameters:
//   refersTo - string 
//   isR1C1 - bool 
//   isLocal - bool 
// Returns:
//   void  
func (instance *Name) SetRefersTo_String_Bool_Bool(refersto string, isr1c1 bool, islocal bool)  error {
	
	CGoReturnPtr := C.Name_SetRefersTo_String_Boolean_Boolean( instance.ptr, C.CString(refersto), C.bool(isr1c1), C.bool(islocal))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether this name is referred by other formulas.
// Returns:
//   bool  
func (instance *Name) IsReferred()  (bool,  error)  {
	
	CGoReturnPtr := C.Name_IsReferred( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether the name is visible.
// Returns:
//   bool  
func (instance *Name) IsVisible()  (bool,  error)  {
	
	CGoReturnPtr := C.Name_IsVisible( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether the name is visible.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Name) SetIsVisible(value bool)  error {
	
	CGoReturnPtr := C.Name_SetIsVisible( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates this name belongs to Workbook or Worksheet.
// 0 = Global name, otherwise index to sheet (one-based)
// Returns:
//   int32  
func (instance *Name) GetSheetIndex()  (int32,  error)  {
	
	CGoReturnPtr := C.Name_GetSheetIndex( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates this name belongs to Workbook or Worksheet.
// 0 = Global name, otherwise index to sheet (one-based)
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *Name) SetSheetIndex(value int32)  error {
	
	CGoReturnPtr := C.Name_SetSheetIndex( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Returns a string represents the current Range object.
// Returns:
//   string  
func (instance *Name) ToString()  (string,  error)  {
	
	CGoReturnPtr := C.Name_ToString( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets all ranges referred by this name.
// Returns:
//   []Range  
func (instance *Name) GetRanges()  ([]Range,  error)  {
	
	CGoReturnPtr := C.Name_GetRanges( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result:= make([]Range, CGoReturnPtr.column_length)
	for i := 0; i < int(CGoReturnPtr.column_length); i++ {
	   offset := uintptr(C.size_t(i)) * uintptr(CGoReturnPtr.size)
	   goObject := &Range{}
	   goObject.ptr =unsafe.Pointer(uintptr( unsafe.Pointer(CGoReturnPtr.return_value)) + offset)
	   result[i] = *goObject
	}
	 

	return result, nil 
}
// Gets all ranges referred by this name.
// Parameters:
//   recalculate - bool 
// Returns:
//   []Range  
func (instance *Name) GetRanges_Bool(recalculate bool)  ([]Range,  error)  {
	
	CGoReturnPtr := C.Name_GetRanges_Boolean( instance.ptr, C.bool(recalculate))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result:= make([]Range, CGoReturnPtr.column_length)
	for i := 0; i < int(CGoReturnPtr.column_length); i++ {
	   offset := uintptr(C.size_t(i)) * uintptr(CGoReturnPtr.size)
	   goObject := &Range{}
	   goObject.ptr =unsafe.Pointer(uintptr( unsafe.Pointer(CGoReturnPtr.return_value)) + offset)
	   result[i] = *goObject
	}
	 

	return result, nil 
}
// Gets all references referred by this name.
// Parameters:
//   recalculate - bool 
// Returns:
//   []ReferredArea  
func (instance *Name) GetReferredAreas(recalculate bool)  ([]ReferredArea,  error)  {
	
	CGoReturnPtr := C.Name_GetReferredAreas( instance.ptr, C.bool(recalculate))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result:= make([]ReferredArea, CGoReturnPtr.column_length)
	for i := 0; i < int(CGoReturnPtr.column_length); i++ {
	   offset := uintptr(C.size_t(i)) * uintptr(CGoReturnPtr.size)
	   goObject := &ReferredArea{}
	   goObject.ptr =unsafe.Pointer(uintptr( unsafe.Pointer(CGoReturnPtr.return_value)) + offset)
	   result[i] = *goObject
	}
	 

	return result, nil 
}
// Gets the range if this name refers to a range.
// Returns:
//   Range  
func (instance *Name) GetRange()  (*Range,  error)  {
	
	CGoReturnPtr := C.Name_GetRange( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Range{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteRange) 

	return result, nil 
}
// Gets the range if this name refers to a range
// Parameters:
//   recalculate - bool 
// Returns:
//   Range  
func (instance *Name) GetRange_Bool(recalculate bool)  (*Range,  error)  {
	
	CGoReturnPtr := C.Name_GetRange_Boolean( instance.ptr, C.bool(recalculate))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Range{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteRange) 

	return result, nil 
}
// Gets the range if this name refers to a range.
// If the reference of this name is not absolute, the range may be different for different cell.
// Parameters:
//   sheetIndex - int32 
//   row - int32 
//   column - int32 
// Returns:
//   Range  
func (instance *Name) GetRange_Int_Int_Int(sheetindex int32, row int32, column int32)  (*Range,  error)  {
	
	CGoReturnPtr := C.Name_GetRange_Integer_Integer_Integer( instance.ptr, C.int(sheetindex), C.int(row), C.int(column))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Range{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteRange) 

	return result, nil 
}



func DeleteName(name *Name){
	runtime.SetFinalizer(name, nil)
	C.Delete_Name(name.ptr)
	name.ptr = nil
}

// Class NameCollection 

// Represents a collection of all the <see cref="Name"/> objects in the spreadsheet.
type NameCollection struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *NameCollection) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.NameCollection_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Defines a new name.
// Parameters:
//   text - string 
// Returns:
//   int32  
func (instance *NameCollection) Add(text string)  (int32,  error)  {
	
	CGoReturnPtr := C.NameCollection_Add( instance.ptr, C.CString(text))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the <see cref="Name"/> element at the specified index.
// Parameters:
//   index - int32 
// Returns:
//   Name  
func (instance *NameCollection) Get_Int(index int32)  (*Name,  error)  {
	
	CGoReturnPtr := C.NameCollection_Get_Integer( instance.ptr, C.int(index))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Name{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteName) 

	return result, nil 
}
// Gets all defined name by scope.
// Parameters:
//   type - int32 
//   sheetIndex - int32 
// Returns:
//   []Name  
func (instance *NameCollection) Filter(type_ NameScopeType, sheetindex int32)  ([]Name,  error)  {
	
	CGoReturnPtr := C.NameCollection_Filter( instance.ptr, C.int( int32(type_)), C.int(sheetindex))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result:= make([]Name, CGoReturnPtr.column_length)
	for i := 0; i < int(CGoReturnPtr.column_length); i++ {
	   offset := uintptr(C.size_t(i)) * uintptr(CGoReturnPtr.size)
	   goObject := &Name{}
	   goObject.ptr =unsafe.Pointer(uintptr( unsafe.Pointer(CGoReturnPtr.return_value)) + offset)
	   result[i] = *goObject
	}
	 

	return result, nil 
}
// Gets the <see cref="Name"/> element with the specified name.
// Parameters:
//   text - string 
// Returns:
//   Name  
func (instance *NameCollection) Get_String(text string)  (*Name,  error)  {
	
	CGoReturnPtr := C.NameCollection_Get_String( instance.ptr, C.CString(text))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Name{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteName) 

	return result, nil 
}
// Remove an array of name
// Parameters:
//   names - []string 
// Returns:
//   void  
func (instance *NameCollection) Remove_stringArray(names []string)  error {
	
	vector_names := make([]*C.char, len(names))
	for i, str := range names {
	cStr := C.CString(str)
	defer C.free(unsafe.Pointer(cStr))
	vector_names[i] = cStr
	}

	CGoReturnPtr := C.NameCollection_Remove_U16StringArray( instance.ptr, unsafe.Pointer(&vector_names[0]), C.int( len(names)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Remove the name.
// Parameters:
//   text - string 
// Returns:
//   void  
func (instance *NameCollection) Remove_String(text string)  error {
	
	CGoReturnPtr := C.NameCollection_Remove_String( instance.ptr, C.CString(text))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Remove the name at the specific index.
// Parameters:
//   index - int32 
// Returns:
//   void  
func (instance *NameCollection) RemoveAt(index int32)  error {
	
	CGoReturnPtr := C.NameCollection_RemoveAt( instance.ptr, C.int(index))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Remove all defined names which are not referenced by the formulas and data source.
// If the defined name is referred, we only set Name.ReferTo as null and hide them.
// Returns:
//   void  
func (instance *NameCollection) Clear()  error {
	
	CGoReturnPtr := C.NameCollection_Clear( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Remove the duplicate defined names
// Returns:
//   void  
func (instance *NameCollection) RemoveDuplicateNames()  error {
	
	CGoReturnPtr := C.NameCollection_RemoveDuplicateNames( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Sorts defined names.
// Returns:
//   void  
func (instance *NameCollection) Sort()  error {
	
	CGoReturnPtr := C.NameCollection_Sort( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Returns:
//   int32  
func (instance *NameCollection) GetCount()  (int32,  error)  {
	
	CGoReturnPtr := C.NameCollection_GetCount( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}



func DeleteNameCollection(namecollection *NameCollection){
	runtime.SetFinalizer(namecollection, nil)
	C.Delete_NameCollection(namecollection.ptr)
	namecollection.ptr = nil
}

// Class NegativeBarFormat 

// Represents the color settings of the data bars for negative values that are defined by a data bar conditional formatting rule.
type NegativeBarFormat struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *NegativeBarFormat) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.NegativeBarFormat_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets a FormatColor object that you can use to specify the border color for negative data bars.
// Returns:
//   Color  
func (instance *NegativeBarFormat) GetBorderColor()  (*Color,  error)  {
	
	CGoReturnPtr := C.NegativeBarFormat_GetBorderColor( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Gets or sets a FormatColor object that you can use to specify the border color for negative data bars.
// Parameters:
//   value - Color 
// Returns:
//   void  
func (instance *NegativeBarFormat) SetBorderColor(value *Color)  error {
	
	CGoReturnPtr := C.NegativeBarFormat_SetBorderColor( instance.ptr, value.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets whether to use the same border color as positive data bars.
// Returns:
//   int32  
func (instance *NegativeBarFormat) GetBorderColorType()  (DataBarNegativeColorType,  error)  {
	
	CGoReturnPtr := C.NegativeBarFormat_GetBorderColorType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToDataBarNegativeColorType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets whether to use the same border color as positive data bars.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *NegativeBarFormat) SetBorderColorType(value DataBarNegativeColorType)  error {
	
	CGoReturnPtr := C.NegativeBarFormat_SetBorderColorType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets a FormatColor object that you can use to specify the fill color for negative data bars.
// Returns:
//   Color  
func (instance *NegativeBarFormat) GetColor()  (*Color,  error)  {
	
	CGoReturnPtr := C.NegativeBarFormat_GetColor( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Gets or sets a FormatColor object that you can use to specify the fill color for negative data bars.
// Parameters:
//   value - Color 
// Returns:
//   void  
func (instance *NegativeBarFormat) SetColor(value *Color)  error {
	
	CGoReturnPtr := C.NegativeBarFormat_SetColor( instance.ptr, value.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets whether to use the same fill color as positive data bars.
// Returns:
//   int32  
func (instance *NegativeBarFormat) GetColorType()  (DataBarNegativeColorType,  error)  {
	
	CGoReturnPtr := C.NegativeBarFormat_GetColorType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToDataBarNegativeColorType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets or sets whether to use the same fill color as positive data bars.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *NegativeBarFormat) SetColorType(value DataBarNegativeColorType)  error {
	
	CGoReturnPtr := C.NegativeBarFormat_SetColorType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}



func DeleteNegativeBarFormat(negativebarformat *NegativeBarFormat){
	runtime.SetFinalizer(negativebarformat, nil)
	C.Delete_NegativeBarFormat(negativebarformat.ptr)
	negativebarformat.ptr = nil
}

// Class Object 

// Object class.
type Object struct {
	ptr unsafe.Pointer
}

// Default constructor. Constructs an empty object.
func NewObject() ( *Object, error) {
	object := &Object{}
	CGoReturnPtr := C.New_Object()
	if CGoReturnPtr.error_no == 0 {
		object.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(object, DeleteObject)
		return object, nil
	} else {
		object.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return object, err
	}	
}
// Constructs from a bool value.
// Parameters:
//   value - bool 
func NewObject_Bool(value bool) ( *Object, error) {
	object := &Object{}
	CGoReturnPtr := C.New_Object_Boolean(C.bool(value))
	if CGoReturnPtr.error_no == 0 {
		object.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(object, DeleteObject)
		return object, nil
	} else {
		object.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return object, err
	}	
}
// Constructs from an int8_t value.
// Parameters:
//   value - int8 
func NewObject_Integer8(value int8) ( *Object, error) {
	object := &Object{}
	CGoReturnPtr := C.New_Object_Integer8(C.schar(value))
	if CGoReturnPtr.error_no == 0 {
		object.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(object, DeleteObject)
		return object, nil
	} else {
		object.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return object, err
	}	
}
// Constructs from an uint8_t value.
// Parameters:
//   value - byte 
func NewObject_Byte(value byte) ( *Object, error) {
	object := &Object{}
	CGoReturnPtr := C.New_Object_Byte(C.uint8_t(value))
	if CGoReturnPtr.error_no == 0 {
		object.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(object, DeleteObject)
		return object, nil
	} else {
		object.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return object, err
	}	
}
// Constructs from an int16_t value.
// Parameters:
//   value - int16 
func NewObject_Int16(value int16) ( *Object, error) {
	object := &Object{}
	CGoReturnPtr := C.New_Object_Integer16(C.short(value))
	if CGoReturnPtr.error_no == 0 {
		object.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(object, DeleteObject)
		return object, nil
	} else {
		object.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return object, err
	}	
}
// Constructs from an uint16_t value.
// Parameters:
//   value - uint16 
func NewObject_UInteger16(value uint16) ( *Object, error) {
	object := &Object{}
	CGoReturnPtr := C.New_Object_UInteger16(C.ushort(value))
	if CGoReturnPtr.error_no == 0 {
		object.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(object, DeleteObject)
		return object, nil
	} else {
		object.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return object, err
	}	
}
// Constructs from an int32_t value.
// Parameters:
//   value - int32 
func NewObject_Int(value int32) ( *Object, error) {
	object := &Object{}
	CGoReturnPtr := C.New_Object_Integer(C.int(value))
	if CGoReturnPtr.error_no == 0 {
		object.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(object, DeleteObject)
		return object, nil
	} else {
		object.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return object, err
	}	
}
// Constructs from an uint32_t value.
// Parameters:
//   value - uint32 
func NewObject_UInteger(value uint32) ( *Object, error) {
	object := &Object{}
	CGoReturnPtr := C.New_Object_UInteger(C.uint(value))
	if CGoReturnPtr.error_no == 0 {
		object.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(object, DeleteObject)
		return object, nil
	} else {
		object.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return object, err
	}	
}
// Constructs from an int64_t value.
// Parameters:
//   value - int64 
func NewObject_Int64(value int64) ( *Object, error) {
	object := &Object{}
	CGoReturnPtr := C.New_Object_Long(C.long(value))
	if CGoReturnPtr.error_no == 0 {
		object.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(object, DeleteObject)
		return object, nil
	} else {
		object.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return object, err
	}	
}
// Constructs from an uint64_t value.
// Parameters:
//   value - uint64 
func NewObject_ULong(value uint64) ( *Object, error) {
	object := &Object{}
	CGoReturnPtr := C.New_Object_ULong(C.ulong(value))
	if CGoReturnPtr.error_no == 0 {
		object.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(object, DeleteObject)
		return object, nil
	} else {
		object.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return object, err
	}	
}
// Constructs from a float value.
// Parameters:
//   value - float32 
func NewObject_Float(value float32) ( *Object, error) {
	object := &Object{}
	CGoReturnPtr := C.New_Object_Floating(C.float(value))
	if CGoReturnPtr.error_no == 0 {
		object.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(object, DeleteObject)
		return object, nil
	} else {
		object.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return object, err
	}	
}
// Constructs from a double value.
// Parameters:
//   value - float64 
func NewObject_Double(value float64) ( *Object, error) {
	object := &Object{}
	CGoReturnPtr := C.New_Object_Double(C.double(value))
	if CGoReturnPtr.error_no == 0 {
		object.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(object, DeleteObject)
		return object, nil
	} else {
		object.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return object, err
	}	
}
// Constructs from a Date value.
// Parameters:
//   value - Date 
func NewObject_Date(value time.Time) ( *Object, error) {
	object := &Object{}
	time_value := C.Get_Date( C.int(value.Year()), C.int(value.Month()) , C.int(value.Day()) , C.int(value.Hour()) , C.int(value.Minute()) , C.int(value.Second())  )

	CGoReturnPtr := C.New_Object_Date(time_value)
	C.Delete_GetDate( time_value)

	if CGoReturnPtr.error_no == 0 {
		object.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(object, DeleteObject)
		return object, nil
	} else {
		object.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return object, err
	}	
}
// Constructs from a Color value.
// Parameters:
//   value - Color 
func NewObject_Color(value *Color) ( *Object, error) {
	object := &Object{}
	CGoReturnPtr := C.New_Object_Color(value.ptr)
	if CGoReturnPtr.error_no == 0 {
		object.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(object, DeleteObject)
		return object, nil
	} else {
		object.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return object, err
	}	
}
// Constructs from U16String value.
// Parameters:
//   value - string 
func NewObject_String(value string) ( *Object, error) {
	object := &Object{}
	CGoReturnPtr := C.New_Object_String(C.CString(value))
	if CGoReturnPtr.error_no == 0 {
		object.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(object, DeleteObject)
		return object, nil
	} else {
		object.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return object, err
	}	
}
// Constructs from a Range value.
// Parameters:
//   value - Range 
func NewObject_Range(value *Range) ( *Object, error) {
	object := &Object{}
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.New_Object_Range(value_ptr)
	if CGoReturnPtr.error_no == 0 {
		object.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(object, DeleteObject)
		return object, nil
	} else {
		object.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return object, err
	}	
}
// Constructs from a one-dimensional array.
// Parameters:
//   value - []Object 
func NewObject_ObjectArray(value []interface{}) ( *Object, error) {
	object := &Object{}
	vector_value, value_row_length := toObjectArray(value)

	CGoReturnPtr := C.New_Object_ObjectArray(unsafe.Pointer(&vector_value[0]), C.int(value_row_length))
	if CGoReturnPtr.error_no == 0 {
		object.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(object, DeleteObject)
		return object, nil
	} else {
		object.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return object, err
	}	
}
// Constructs from a two-dimensional array.
// Parameters:
//   value - []Vector<Object> 
func NewObject_Object2Array(value [][]interface{}) ( *Object, error) {
	object := &Object{}
	vector_value, value_row_length, value_column_length := toObject2Array(value)

	CGoReturnPtr := C.New_Object_Object2Array(unsafe.Pointer(&vector_value[0]), C.int(value_row_length), C.int( value_column_length))
	if CGoReturnPtr.error_no == 0 {
		object.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(object, DeleteObject)
		return object, nil
	} else {
		object.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return object, err
	}	
}

// Gets the ObjectType of the object.
// Returns:
//   int32  
func (instance *Object) GetType()  (ObjectType,  error)  {
	
	CGoReturnPtr := C.Object_GetType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToObjectType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets the NumberType of the object.
// Returns:
//   void  
func (instance *Object) GetNumberType()  error {
	
	CGoReturnPtr := C.Object_GetNumberType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Checks whether the object is a bool value.
// Returns:
//   bool  
func (instance *Object) IsBool()  (bool,  error)  {
	
	CGoReturnPtr := C.Object_IsBool( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Checks whether the object is a number value.
// Returns:
//   bool  
func (instance *Object) IsNumber()  (bool,  error)  {
	
	CGoReturnPtr := C.Object_IsNumber( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Checks whether the object is an int32_t value.
// Returns:
//   bool  
func (instance *Object) IsInt32()  (bool,  error)  {
	
	CGoReturnPtr := C.Object_IsInt32( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Checks whether the object is a double value.
// Returns:
//   bool  
func (instance *Object) IsDouble()  (bool,  error)  {
	
	CGoReturnPtr := C.Object_IsDouble( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Checks whether the object is null.
// Returns:
//   bool  
func (instance *Object) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.Object_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Checks whether the object is a Date value.
// Returns:
//   bool  
func (instance *Object) IsDate()  (bool,  error)  {
	
	CGoReturnPtr := C.Object_IsDate( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Checks whether the object is a Color value.
// Returns:
//   bool  
func (instance *Object) IsColor()  (bool,  error)  {
	
	CGoReturnPtr := C.Object_IsColor( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Checks whether the object is a String value.
// Returns:
//   bool  
func (instance *Object) IsString()  (bool,  error)  {
	
	CGoReturnPtr := C.Object_IsString( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Checks whether the object is a Range pointer.
// Returns:
//   bool  
func (instance *Object) IsRange()  (bool,  error)  {
	
	CGoReturnPtr := C.Object_IsRange( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Checks whether the object is a ReferredArea pointer.
// Returns:
//   bool  
func (instance *Object) IsReferredArea()  (bool,  error)  {
	
	CGoReturnPtr := C.Object_IsReferredArea( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Checks whether the object is a one-dimensional array.
// Returns:
//   bool  
func (instance *Object) IsArray1D()  (bool,  error)  {
	
	CGoReturnPtr := C.Object_IsArray1D( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Checks whether the object is a two-dimensional array.
// Returns:
//   bool  
func (instance *Object) IsArray2D()  (bool,  error)  {
	
	CGoReturnPtr := C.Object_IsArray2D( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Checks whether the object is an object pointer.
// Returns:
//   bool  
func (instance *Object) IsObject()  (bool,  error)  {
	
	CGoReturnPtr := C.Object_IsObject( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the bool value.
// Returns:
//   bool  
func (instance *Object) ToBool()  (bool,  error)  {
	
	CGoReturnPtr := C.Object_ToBool( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the int8_t value.
// Returns:
//   int8  
func (instance *Object) ToInt8()  (int8,  error)  {
	
	CGoReturnPtr := C.Object_ToInt8( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int8(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the uint8_t value.
// Returns:
//   byte  
func (instance *Object) ToUInt8()  (byte,  error)  {
	
	CGoReturnPtr := C.Object_ToUInt8( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := byte(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the int16_t value.
// Returns:
//   int16  
func (instance *Object) ToInt16()  (int16,  error)  {
	
	CGoReturnPtr := C.Object_ToInt16( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int16(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the uint16_t value.
// Returns:
//   uint16  
func (instance *Object) ToUInt16()  (uint16,  error)  {
	
	CGoReturnPtr := C.Object_ToUInt16( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := uint16(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the int32_t value.
// Returns:
//   int32  
func (instance *Object) ToInt32()  (int32,  error)  {
	
	CGoReturnPtr := C.Object_ToInt32( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the uint32_t value.
// Returns:
//   uint32  
func (instance *Object) ToUInt32()  (uint32,  error)  {
	
	CGoReturnPtr := C.Object_ToUInt32( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := uint32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the int64_t value.
// Returns:
//   int64  
func (instance *Object) ToInt64()  (int64,  error)  {
	
	CGoReturnPtr := C.Object_ToInt64( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int64(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the uint64_t value.
// Returns:
//   uint64  
func (instance *Object) ToUInt64()  (uint64,  error)  {
	
	CGoReturnPtr := C.Object_ToUInt64( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := uint64(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the float value.
// Returns:
//   float32  
func (instance *Object) ToFloat()  (float32,  error)  {
	
	CGoReturnPtr := C.Object_ToFloat( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := float32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the double value.
// Returns:
//   float64  
func (instance *Object) ToDouble()  (float64,  error)  {
	
	CGoReturnPtr := C.Object_ToDouble( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := float64(CGoReturnPtr.return_value) 

	return result, nil 
}
// Converts the object to an int32_t value, if object is number type.
// Returns:
//   int32  
func (instance *Object) AsInt32()  (int32,  error)  {
	
	CGoReturnPtr := C.Object_AsInt32( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Converts the object to a double value, if object is number type.
// Returns:
//   float64  
func (instance *Object) AsDouble()  (float64,  error)  {
	
	CGoReturnPtr := C.Object_AsDouble( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := float64(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the String value.
// Returns:
//   string  
func (instance *Object) ToString()  (string,  error)  {
	
	CGoReturnPtr := C.Object_ToString( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the Date value.
// Returns:
//   Date  
func (instance *Object) ToDate()  (time.Time,  error)  {
	
	CGoReturnPtr := C.Object_ToDate( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  time.Unix(0, 0), err
	}
	result := time.Date(int( C.Date_Get_year(CGoReturnPtr.return_value).return_value ),time.Month(int( C.Date_Get_month(CGoReturnPtr.return_value).return_value)),int( C.Date_Get_day(CGoReturnPtr.return_value).return_value),int(  C.Date_Get_hour(CGoReturnPtr.return_value).return_value),int( C.Date_Get_minute(CGoReturnPtr.return_value).return_value),int(  C.Date_Get_second(CGoReturnPtr.return_value).return_value), 0, time.UTC) 

	return result, nil 
}
// Gets the Color value.
// Returns:
//   Color  
func (instance *Object) ToColor()  (*Color,  error)  {
	
	CGoReturnPtr := C.Object_ToColor( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Gets the Range value.
// Returns:
//   Range  
func (instance *Object) ToRange()  (*Range,  error)  {
	
	CGoReturnPtr := C.Object_ToRange( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Range{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteRange) 

	return result, nil 
}
// Gets the ReferredArea value.
// Returns:
//   ReferredArea  
func (instance *Object) ToReferredArea()  (*ReferredArea,  error)  {
	
	CGoReturnPtr := C.Object_ToReferredArea( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &ReferredArea{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteReferredArea) 

	return result, nil 
}
// Gets the one-dimensional array value.
// Returns:
//   []Object  
func (instance *Object) ToArray1D()  ([]Object,  error)  {
	
	CGoReturnPtr := C.Object_ToArray1D( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result:= make([]Object, CGoReturnPtr.column_length)
	for i := 0; i < int(CGoReturnPtr.column_length); i++ {
	   offset := uintptr(C.size_t(i)) * uintptr(CGoReturnPtr.size)
	   goObject := &Object{}
	   goObject.ptr =unsafe.Pointer(uintptr( unsafe.Pointer(CGoReturnPtr.return_value)) + offset)
	   result[i] = *goObject
	}
	 

	return result, nil 
}
// Gets the two-dimensional array value.
// Returns:
//   []Vector<Object>  
func (instance *Object) ToArray2D()  ([][]Object,  error)  {
	
	CGoReturnPtr := C.Object_ToArray2D( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result:= make([][]Object, CGoReturnPtr.row_length)
	for i := 0; i < int(CGoReturnPtr.row_length); i++ {
	result[i] = make([]Object, int(CGoReturnPtr.column_length))
	}
	for i := 0; i < int(CGoReturnPtr.row_length); i++ {
	for j := 0; j < int(CGoReturnPtr.column_length); j++ {
	   offset := uintptr(C.size_t(i) * C.size_t(int(CGoReturnPtr.column_length))  +  C.size_t(j)  ) * uintptr(CGoReturnPtr.size) 
	   goObject := &Object{}
	   goObject.ptr =unsafe.Pointer(uintptr( unsafe.Pointer(CGoReturnPtr.return_value)) + offset)
	   result[i][j] = *goObject
	}
	}
	 

	return result, nil 
}



func DeleteObject(object *Object){
	runtime.SetFinalizer(object, nil)
	C.Delete_Object(object.ptr)
	object.ptr = nil
}

// Class OdsLoadOptions 

// Represents the options of loading ods file.
type OdsLoadOptions struct {
	ptr unsafe.Pointer
}

// Represents the options of loading ods file.
func NewOdsLoadOptions() ( *OdsLoadOptions, error) {
	odsloadoptions := &OdsLoadOptions{}
	CGoReturnPtr := C.New_OdsLoadOptions()
	if CGoReturnPtr.error_no == 0 {
		odsloadoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(odsloadoptions, DeleteOdsLoadOptions)
		return odsloadoptions, nil
	} else {
		odsloadoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return odsloadoptions, err
	}	
}
// Represents the options of loading ods file.
// Parameters:
//   type - int32 
func NewOdsLoadOptions_LoadFormat(type_ LoadFormat) ( *OdsLoadOptions, error) {
	odsloadoptions := &OdsLoadOptions{}
	CGoReturnPtr := C.New_OdsLoadOptions_LoadFormat(C.int( int32(type_)))
	if CGoReturnPtr.error_no == 0 {
		odsloadoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(odsloadoptions, DeleteOdsLoadOptions)
		return odsloadoptions, nil
	} else {
		odsloadoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return odsloadoptions, err
	}	
}
// Constructs from a parent object.
// Parameters:
//   src - LoadOptions 
func NewOdsLoadOptions_LoadOptions(src *LoadOptions) ( *OdsLoadOptions, error) {
	odsloadoptions := &OdsLoadOptions{}
	var src_ptr unsafe.Pointer = nil
	if src != nil {
	  src_ptr =src.ptr
	}

	CGoReturnPtr := C.New_OdsLoadOptions_LoadOptions(src_ptr)
	if CGoReturnPtr.error_no == 0 {
		odsloadoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(odsloadoptions, DeleteOdsLoadOptions)
		return odsloadoptions, nil
	} else {
		odsloadoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return odsloadoptions, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *OdsLoadOptions) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.OdsLoadOptions_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether applying the default style of the Excel to hyperlink.
// Returns:
//   bool  
func (instance *OdsLoadOptions) GetApplyExcelDefaultStyleToHyperlink()  (bool,  error)  {
	
	CGoReturnPtr := C.OdsLoadOptions_GetApplyExcelDefaultStyleToHyperlink( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether applying the default style of the Excel to hyperlink.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *OdsLoadOptions) SetApplyExcelDefaultStyleToHyperlink(value bool)  error {
	
	CGoReturnPtr := C.OdsLoadOptions_SetApplyExcelDefaultStyleToHyperlink( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether refresh pivot tables when loading file.
// Returns:
//   bool  
func (instance *OdsLoadOptions) GetRefreshPivotTables()  (bool,  error)  {
	
	CGoReturnPtr := C.OdsLoadOptions_GetRefreshPivotTables( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether refresh pivot tables when loading file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *OdsLoadOptions) SetRefreshPivotTables(value bool)  error {
	
	CGoReturnPtr := C.OdsLoadOptions_SetRefreshPivotTables( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether the pivot table is classic.
// Returns:
//   bool  
func (instance *OdsLoadOptions) IsClassicPivotTable()  (bool,  error)  {
	
	CGoReturnPtr := C.OdsLoadOptions_IsClassicPivotTable( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether the pivot table is classic.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *OdsLoadOptions) SetIsClassicPivotTable(value bool)  error {
	
	CGoReturnPtr := C.OdsLoadOptions_SetIsClassicPivotTable( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the load format.
// Returns:
//   int32  
func (instance *OdsLoadOptions) GetLoadFormat()  (LoadFormat,  error)  {
	
	CGoReturnPtr := C.OdsLoadOptions_GetLoadFormat( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToLoadFormat(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets and set the password of the workbook.
// Returns:
//   string  
func (instance *OdsLoadOptions) GetPassword()  (string,  error)  {
	
	CGoReturnPtr := C.OdsLoadOptions_GetPassword( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and set the password of the workbook.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *OdsLoadOptions) SetPassword(value string)  error {
	
	CGoReturnPtr := C.OdsLoadOptions_SetPassword( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether parsing the formula when reading the file.
// Returns:
//   bool  
func (instance *OdsLoadOptions) GetParsingFormulaOnOpen()  (bool,  error)  {
	
	CGoReturnPtr := C.OdsLoadOptions_GetParsingFormulaOnOpen( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether parsing the formula when reading the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *OdsLoadOptions) SetParsingFormulaOnOpen(value bool)  error {
	
	CGoReturnPtr := C.OdsLoadOptions_SetParsingFormulaOnOpen( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether parsing pivot cached records when loading the file.
// The default value is false.
// Returns:
//   bool  
func (instance *OdsLoadOptions) GetParsingPivotCachedRecords()  (bool,  error)  {
	
	CGoReturnPtr := C.OdsLoadOptions_GetParsingPivotCachedRecords( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether parsing pivot cached records when loading the file.
// The default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *OdsLoadOptions) SetParsingPivotCachedRecords(value bool)  error {
	
	CGoReturnPtr := C.OdsLoadOptions_SetParsingPivotCachedRecords( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Sets the default print paper size from default printer's setting.
// Parameters:
//   type - int32 
// Returns:
//   void  
func (instance *OdsLoadOptions) SetPaperSize(type_ PaperSizeType)  error {
	
	CGoReturnPtr := C.OdsLoadOptions_SetPaperSize( instance.ptr, C.int( int32(type_)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the user interface language of the Workbook version based on CountryCode that has saved the file.
// Returns:
//   int32  
func (instance *OdsLoadOptions) GetLanguageCode()  (CountryCode,  error)  {
	
	CGoReturnPtr := C.OdsLoadOptions_GetLanguageCode( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToCountryCode(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets or sets the user interface language of the Workbook version based on CountryCode that has saved the file.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *OdsLoadOptions) SetLanguageCode(value CountryCode)  error {
	
	CGoReturnPtr := C.OdsLoadOptions_SetLanguageCode( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the regional settings used for the Workbook that will be loaded.
// Returns:
//   int32  
func (instance *OdsLoadOptions) GetRegion()  (CountryCode,  error)  {
	
	CGoReturnPtr := C.OdsLoadOptions_GetRegion( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToCountryCode(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets or sets the regional settings used for the Workbook that will be loaded.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *OdsLoadOptions) SetRegion(value CountryCode)  error {
	
	CGoReturnPtr := C.OdsLoadOptions_SetRegion( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the default style settings for initializing styles of the workbook
// Returns:
//   DefaultStyleSettings  
func (instance *OdsLoadOptions) GetDefaultStyleSettings()  (*DefaultStyleSettings,  error)  {
	
	CGoReturnPtr := C.OdsLoadOptions_GetDefaultStyleSettings( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &DefaultStyleSettings{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteDefaultStyleSettings) 

	return result, nil 
}
// Gets and sets the interrupt monitor.
// Returns:
//   AbstractInterruptMonitor  
func (instance *OdsLoadOptions) GetInterruptMonitor()  (*AbstractInterruptMonitor,  error)  {
	
	CGoReturnPtr := C.OdsLoadOptions_GetInterruptMonitor( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &AbstractInterruptMonitor{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteAbstractInterruptMonitor) 

	return result, nil 
}
// Gets and sets the interrupt monitor.
// Parameters:
//   value - AbstractInterruptMonitor 
// Returns:
//   void  
func (instance *OdsLoadOptions) SetInterruptMonitor(value *AbstractInterruptMonitor)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.OdsLoadOptions_SetInterruptMonitor( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Ignore the data which are not printed if directly printing the file
// Returns:
//   bool  
func (instance *OdsLoadOptions) GetIgnoreNotPrinted()  (bool,  error)  {
	
	CGoReturnPtr := C.OdsLoadOptions_GetIgnoreNotPrinted( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Ignore the data which are not printed if directly printing the file
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *OdsLoadOptions) SetIgnoreNotPrinted(value bool)  error {
	
	CGoReturnPtr := C.OdsLoadOptions_SetIgnoreNotPrinted( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Check whether data is valid in the template file.
// Returns:
//   bool  
func (instance *OdsLoadOptions) GetCheckDataValid()  (bool,  error)  {
	
	CGoReturnPtr := C.OdsLoadOptions_GetCheckDataValid( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Check whether data is valid in the template file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *OdsLoadOptions) SetCheckDataValid(value bool)  error {
	
	CGoReturnPtr := C.OdsLoadOptions_SetCheckDataValid( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Whether check restriction of excel file when user modify cells related objects.
// For example, excel does not allow inputting string value longer than 32K.
// When you input a value longer than 32K such as by Cell.PutValue(string), if this property is true, you will get an Exception.
// If this property is false, we will accept your input string value as the cell's value so that later
// you can output the complete string value for other file formats such as CSV.
// However, if you have set such kind of value that is invalid for excel file format,
// you should not save the workbook as excel file format later. Otherwise there may be unexpected error for the generated excel file.
// Returns:
//   bool  
func (instance *OdsLoadOptions) GetCheckExcelRestriction()  (bool,  error)  {
	
	CGoReturnPtr := C.OdsLoadOptions_GetCheckExcelRestriction( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Whether check restriction of excel file when user modify cells related objects.
// For example, excel does not allow inputting string value longer than 32K.
// When you input a value longer than 32K such as by Cell.PutValue(string), if this property is true, you will get an Exception.
// If this property is false, we will accept your input string value as the cell's value so that later
// you can output the complete string value for other file formats such as CSV.
// However, if you have set such kind of value that is invalid for excel file format,
// you should not save the workbook as excel file format later. Otherwise there may be unexpected error for the generated excel file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *OdsLoadOptions) SetCheckExcelRestriction(value bool)  error {
	
	CGoReturnPtr := C.OdsLoadOptions_SetCheckExcelRestriction( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Whether keep the unparsed data in memory for the Workbook when it is loaded from template file. Default is true.
// Returns:
//   bool  
func (instance *OdsLoadOptions) GetKeepUnparsedData()  (bool,  error)  {
	
	CGoReturnPtr := C.OdsLoadOptions_GetKeepUnparsedData( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Whether keep the unparsed data in memory for the Workbook when it is loaded from template file. Default is true.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *OdsLoadOptions) SetKeepUnparsedData(value bool)  error {
	
	CGoReturnPtr := C.OdsLoadOptions_SetKeepUnparsedData( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// The filter to denote how to load data.
// Returns:
//   LoadFilter  
func (instance *OdsLoadOptions) GetLoadFilter()  (*LoadFilter,  error)  {
	
	CGoReturnPtr := C.OdsLoadOptions_GetLoadFilter( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &LoadFilter{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteLoadFilter) 

	return result, nil 
}
// The filter to denote how to load data.
// Parameters:
//   value - LoadFilter 
// Returns:
//   void  
func (instance *OdsLoadOptions) SetLoadFilter(value *LoadFilter)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.OdsLoadOptions_SetLoadFilter( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the memory usage options.
// Returns:
//   int32  
func (instance *OdsLoadOptions) GetMemorySetting()  (MemorySetting,  error)  {
	
	CGoReturnPtr := C.OdsLoadOptions_GetMemorySetting( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToMemorySetting(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets or sets the memory usage options.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *OdsLoadOptions) SetMemorySetting(value MemorySetting)  error {
	
	CGoReturnPtr := C.OdsLoadOptions_SetMemorySetting( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the auto fitter options
// Returns:
//   AutoFitterOptions  
func (instance *OdsLoadOptions) GetAutoFitterOptions()  (*AutoFitterOptions,  error)  {
	
	CGoReturnPtr := C.OdsLoadOptions_GetAutoFitterOptions( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &AutoFitterOptions{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteAutoFitterOptions) 

	return result, nil 
}
// Gets and sets the auto fitter options
// Parameters:
//   value - AutoFitterOptions 
// Returns:
//   void  
func (instance *OdsLoadOptions) SetAutoFitterOptions(value *AutoFitterOptions)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.OdsLoadOptions_SetAutoFitterOptions( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether auto filtering the data when loading the files.
// Returns:
//   bool  
func (instance *OdsLoadOptions) GetAutoFilter()  (bool,  error)  {
	
	CGoReturnPtr := C.OdsLoadOptions_GetAutoFilter( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether auto filtering the data when loading the files.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *OdsLoadOptions) SetAutoFilter(value bool)  error {
	
	CGoReturnPtr := C.OdsLoadOptions_SetAutoFilter( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets individual font configs.
// Only works for the <see cref="Workbook"/> which uses this <see cref="LoadOptions"/> to load.
// Returns:
//   IndividualFontConfigs  
func (instance *OdsLoadOptions) GetFontConfigs()  (*IndividualFontConfigs,  error)  {
	
	CGoReturnPtr := C.OdsLoadOptions_GetFontConfigs( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &IndividualFontConfigs{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteIndividualFontConfigs) 

	return result, nil 
}
// Gets and sets individual font configs.
// Only works for the <see cref="Workbook"/> which uses this <see cref="LoadOptions"/> to load.
// Parameters:
//   value - IndividualFontConfigs 
// Returns:
//   void  
func (instance *OdsLoadOptions) SetFontConfigs(value *IndividualFontConfigs)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.OdsLoadOptions_SetFontConfigs( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether ignoring useless shapes.
// Returns:
//   bool  
func (instance *OdsLoadOptions) GetIgnoreUselessShapes()  (bool,  error)  {
	
	CGoReturnPtr := C.OdsLoadOptions_GetIgnoreUselessShapes( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether ignoring useless shapes.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *OdsLoadOptions) SetIgnoreUselessShapes(value bool)  error {
	
	CGoReturnPtr := C.OdsLoadOptions_SetIgnoreUselessShapes( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether preserve those spaces and line breaks that are padded between formula tokens
// while getting and setting formulas.
// Default value is false.
// Returns:
//   bool  
func (instance *OdsLoadOptions) GetPreservePaddingSpacesInFormula()  (bool,  error)  {
	
	CGoReturnPtr := C.OdsLoadOptions_GetPreservePaddingSpacesInFormula( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether preserve those spaces and line breaks that are padded between formula tokens
// while getting and setting formulas.
// Default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *OdsLoadOptions) SetPreservePaddingSpacesInFormula(value bool)  error {
	
	CGoReturnPtr := C.OdsLoadOptions_SetPreservePaddingSpacesInFormula( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}


func (instance *OdsLoadOptions) ToLoadOptions() *LoadOptions {
	parentClass := &LoadOptions{}
	parentClass.ptr = instance.ptr
	return parentClass
}

func DeleteOdsLoadOptions(odsloadoptions *OdsLoadOptions){
	runtime.SetFinalizer(odsloadoptions, nil)
	C.Delete_OdsLoadOptions(odsloadoptions.ptr)
	odsloadoptions.ptr = nil
}

// Class OdsSaveOptions 

// Represents the options of saving ods file.
type OdsSaveOptions struct {
	ptr unsafe.Pointer
}

// Creates the options of saving ods file.
func NewOdsSaveOptions() ( *OdsSaveOptions, error) {
	odssaveoptions := &OdsSaveOptions{}
	CGoReturnPtr := C.New_OdsSaveOptions()
	if CGoReturnPtr.error_no == 0 {
		odssaveoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(odssaveoptions, DeleteOdsSaveOptions)
		return odssaveoptions, nil
	} else {
		odssaveoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return odssaveoptions, err
	}	
}
// Creates the options of saving ods file.
// Parameters:
//   saveFormat - int32 
func NewOdsSaveOptions_SaveFormat(saveformat SaveFormat) ( *OdsSaveOptions, error) {
	odssaveoptions := &OdsSaveOptions{}
	CGoReturnPtr := C.New_OdsSaveOptions_SaveFormat(C.int( int32(saveformat)))
	if CGoReturnPtr.error_no == 0 {
		odssaveoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(odssaveoptions, DeleteOdsSaveOptions)
		return odssaveoptions, nil
	} else {
		odssaveoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return odssaveoptions, err
	}	
}
// Constructs from a parent object.
// Parameters:
//   src - SaveOptions 
func NewOdsSaveOptions_SaveOptions(src *SaveOptions) ( *OdsSaveOptions, error) {
	odssaveoptions := &OdsSaveOptions{}
	var src_ptr unsafe.Pointer = nil
	if src != nil {
	  src_ptr =src.ptr
	}

	CGoReturnPtr := C.New_OdsSaveOptions_SaveOptions(src_ptr)
	if CGoReturnPtr.error_no == 0 {
		odssaveoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(odssaveoptions, DeleteOdsSaveOptions)
		return odssaveoptions, nil
	} else {
		odssaveoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return odssaveoptions, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *OdsSaveOptions) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.OdsSaveOptions_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the generator of the ods file.
// Returns:
//   int32  
func (instance *OdsSaveOptions) GetGeneratorType()  (OdsGeneratorType,  error)  {
	
	CGoReturnPtr := C.OdsSaveOptions_GetGeneratorType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToOdsGeneratorType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets and sets the generator of the ods file.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *OdsSaveOptions) SetGeneratorType(value OdsGeneratorType)  error {
	
	CGoReturnPtr := C.OdsSaveOptions_SetGeneratorType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the ODF version.
// Returns:
//   int32  
func (instance *OdsSaveOptions) GetOdfStrictVersion()  (OpenDocumentFormatVersionType,  error)  {
	
	CGoReturnPtr := C.OdsSaveOptions_GetOdfStrictVersion( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToOpenDocumentFormatVersionType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets and sets the ODF version.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *OdsSaveOptions) SetOdfStrictVersion(value OpenDocumentFormatVersionType)  error {
	
	CGoReturnPtr := C.OdsSaveOptions_SetOdfStrictVersion( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether saving pivot tables.
// Returns:
//   bool  
func (instance *OdsSaveOptions) GetIgnorePivotTables()  (bool,  error)  {
	
	CGoReturnPtr := C.OdsSaveOptions_GetIgnorePivotTables( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether saving pivot tables.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *OdsSaveOptions) SetIgnorePivotTables(value bool)  error {
	
	CGoReturnPtr := C.OdsSaveOptions_SetIgnorePivotTables( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the save file format.
// Returns:
//   int32  
func (instance *OdsSaveOptions) GetSaveFormat()  (SaveFormat,  error)  {
	
	CGoReturnPtr := C.OdsSaveOptions_GetSaveFormat( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToSaveFormat(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Make the workbook empty after saving the file.
// Returns:
//   bool  
func (instance *OdsSaveOptions) GetClearData()  (bool,  error)  {
	
	CGoReturnPtr := C.OdsSaveOptions_GetClearData( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Make the workbook empty after saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *OdsSaveOptions) SetClearData(value bool)  error {
	
	CGoReturnPtr := C.OdsSaveOptions_SetClearData( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// The folder for temporary files that may be used as data cache.
// Returns:
//   string  
func (instance *OdsSaveOptions) GetCachedFileFolder()  (string,  error)  {
	
	CGoReturnPtr := C.OdsSaveOptions_GetCachedFileFolder( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// The folder for temporary files that may be used as data cache.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *OdsSaveOptions) SetCachedFileFolder(value string)  error {
	
	CGoReturnPtr := C.OdsSaveOptions_SetCachedFileFolder( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether validate merged cells before saving the file.
// Returns:
//   bool  
func (instance *OdsSaveOptions) GetValidateMergedAreas()  (bool,  error)  {
	
	CGoReturnPtr := C.OdsSaveOptions_GetValidateMergedAreas( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether validate merged cells before saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *OdsSaveOptions) SetValidateMergedAreas(value bool)  error {
	
	CGoReturnPtr := C.OdsSaveOptions_SetValidateMergedAreas( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether merge the areas of conditional formatting and validation before saving the file.
// Returns:
//   bool  
func (instance *OdsSaveOptions) GetMergeAreas()  (bool,  error)  {
	
	CGoReturnPtr := C.OdsSaveOptions_GetMergeAreas( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether merge the areas of conditional formatting and validation before saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *OdsSaveOptions) SetMergeAreas(value bool)  error {
	
	CGoReturnPtr := C.OdsSaveOptions_SetMergeAreas( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// If true and the directory does not exist, the directory will be automatically created before saving the file.
// Returns:
//   bool  
func (instance *OdsSaveOptions) GetCreateDirectory()  (bool,  error)  {
	
	CGoReturnPtr := C.OdsSaveOptions_GetCreateDirectory( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// If true and the directory does not exist, the directory will be automatically created before saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *OdsSaveOptions) SetCreateDirectory(value bool)  error {
	
	CGoReturnPtr := C.OdsSaveOptions_SetCreateDirectory( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether sorting defined names before saving file.
// Returns:
//   bool  
func (instance *OdsSaveOptions) GetSortNames()  (bool,  error)  {
	
	CGoReturnPtr := C.OdsSaveOptions_GetSortNames( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether sorting defined names before saving file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *OdsSaveOptions) SetSortNames(value bool)  error {
	
	CGoReturnPtr := C.OdsSaveOptions_SetSortNames( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether sorting external defined names before saving file.
// Returns:
//   bool  
func (instance *OdsSaveOptions) GetSortExternalNames()  (bool,  error)  {
	
	CGoReturnPtr := C.OdsSaveOptions_GetSortExternalNames( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether sorting external defined names before saving file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *OdsSaveOptions) SetSortExternalNames(value bool)  error {
	
	CGoReturnPtr := C.OdsSaveOptions_SetSortExternalNames( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether refreshing chart cache data
// Returns:
//   bool  
func (instance *OdsSaveOptions) GetRefreshChartCache()  (bool,  error)  {
	
	CGoReturnPtr := C.OdsSaveOptions_GetRefreshChartCache( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether refreshing chart cache data
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *OdsSaveOptions) SetRefreshChartCache(value bool)  error {
	
	CGoReturnPtr := C.OdsSaveOptions_SetRefreshChartCache( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Whether check restriction of excel file when user modify cells related objects.
// For example, excel does not allow inputting string value longer than 32K.
// When you input a value longer than 32K, it will be truncated.
// Returns:
//   bool  
func (instance *OdsSaveOptions) GetCheckExcelRestriction()  (bool,  error)  {
	
	CGoReturnPtr := C.OdsSaveOptions_GetCheckExcelRestriction( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Whether check restriction of excel file when user modify cells related objects.
// For example, excel does not allow inputting string value longer than 32K.
// When you input a value longer than 32K, it will be truncated.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *OdsSaveOptions) SetCheckExcelRestriction(value bool)  error {
	
	CGoReturnPtr := C.OdsSaveOptions_SetCheckExcelRestriction( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether updating smart art setting.
// The default value is false.
// Returns:
//   bool  
func (instance *OdsSaveOptions) GetUpdateSmartArt()  (bool,  error)  {
	
	CGoReturnPtr := C.OdsSaveOptions_GetUpdateSmartArt( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether updating smart art setting.
// The default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *OdsSaveOptions) SetUpdateSmartArt(value bool)  error {
	
	CGoReturnPtr := C.OdsSaveOptions_SetUpdateSmartArt( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether encrypt document properties when saving as .xls file.
// The default value is true.
// Returns:
//   bool  
func (instance *OdsSaveOptions) GetEncryptDocumentProperties()  (bool,  error)  {
	
	CGoReturnPtr := C.OdsSaveOptions_GetEncryptDocumentProperties( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether encrypt document properties when saving as .xls file.
// The default value is true.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *OdsSaveOptions) SetEncryptDocumentProperties(value bool)  error {
	
	CGoReturnPtr := C.OdsSaveOptions_SetEncryptDocumentProperties( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}


func (instance *OdsSaveOptions) ToSaveOptions() *SaveOptions {
	parentClass := &SaveOptions{}
	parentClass.ptr = instance.ptr
	return parentClass
}

func DeleteOdsSaveOptions(odssaveoptions *OdsSaveOptions){
	runtime.SetFinalizer(odssaveoptions, nil)
	C.Delete_OdsSaveOptions(odssaveoptions.ptr)
	odssaveoptions.ptr = nil
}

// Class OoxmlSaveOptions 

// Represents the options of saving office open xml file.
type OoxmlSaveOptions struct {
	ptr unsafe.Pointer
}

// Creates the options for saving office open xml file.
func NewOoxmlSaveOptions() ( *OoxmlSaveOptions, error) {
	ooxmlsaveoptions := &OoxmlSaveOptions{}
	CGoReturnPtr := C.New_OoxmlSaveOptions()
	if CGoReturnPtr.error_no == 0 {
		ooxmlsaveoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(ooxmlsaveoptions, DeleteOoxmlSaveOptions)
		return ooxmlsaveoptions, nil
	} else {
		ooxmlsaveoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return ooxmlsaveoptions, err
	}	
}
// Creates the options for saving office open xml file.
// Parameters:
//   saveFormat - int32 
func NewOoxmlSaveOptions_SaveFormat(saveformat SaveFormat) ( *OoxmlSaveOptions, error) {
	ooxmlsaveoptions := &OoxmlSaveOptions{}
	CGoReturnPtr := C.New_OoxmlSaveOptions_SaveFormat(C.int( int32(saveformat)))
	if CGoReturnPtr.error_no == 0 {
		ooxmlsaveoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(ooxmlsaveoptions, DeleteOoxmlSaveOptions)
		return ooxmlsaveoptions, nil
	} else {
		ooxmlsaveoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return ooxmlsaveoptions, err
	}	
}
// Constructs from a parent object.
// Parameters:
//   src - SaveOptions 
func NewOoxmlSaveOptions_SaveOptions(src *SaveOptions) ( *OoxmlSaveOptions, error) {
	ooxmlsaveoptions := &OoxmlSaveOptions{}
	var src_ptr unsafe.Pointer = nil
	if src != nil {
	  src_ptr =src.ptr
	}

	CGoReturnPtr := C.New_OoxmlSaveOptions_SaveOptions(src_ptr)
	if CGoReturnPtr.error_no == 0 {
		ooxmlsaveoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(ooxmlsaveoptions, DeleteOoxmlSaveOptions)
		return ooxmlsaveoptions, nil
	} else {
		ooxmlsaveoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return ooxmlsaveoptions, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *OoxmlSaveOptions) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.OoxmlSaveOptions_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates if export cell name to Excel2007 .xlsx (.xlsm, .xltx, .xltm) file.
// If the output file may be accessed by SQL Server DTS, this value must be true.
// Setting the value to false will highly increase the performance and reduce the file size when creating large file.
// Default value is true.
// Returns:
//   bool  
func (instance *OoxmlSaveOptions) GetExportCellName()  (bool,  error)  {
	
	CGoReturnPtr := C.OoxmlSaveOptions_GetExportCellName( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates if export cell name to Excel2007 .xlsx (.xlsm, .xltx, .xltm) file.
// If the output file may be accessed by SQL Server DTS, this value must be true.
// Setting the value to false will highly increase the performance and reduce the file size when creating large file.
// Default value is true.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *OoxmlSaveOptions) SetExportCellName(value bool)  error {
	
	CGoReturnPtr := C.OoxmlSaveOptions_SetExportCellName( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether update scaling factor before saving the file
// if the PageSetup.FitToPagesWide and PageSetup.FitToPagesTall properties control how the worksheet is scaled.
// Returns:
//   bool  
func (instance *OoxmlSaveOptions) GetUpdateZoom()  (bool,  error)  {
	
	CGoReturnPtr := C.OoxmlSaveOptions_GetUpdateZoom( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether update scaling factor before saving the file
// if the PageSetup.FitToPagesWide and PageSetup.FitToPagesTall properties control how the worksheet is scaled.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *OoxmlSaveOptions) SetUpdateZoom(value bool)  error {
	
	CGoReturnPtr := C.OoxmlSaveOptions_SetUpdateZoom( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Always use ZIP64 extensions when writing zip archives, even when unnecessary.
// Returns:
//   bool  
func (instance *OoxmlSaveOptions) GetEnableZip64()  (bool,  error)  {
	
	CGoReturnPtr := C.OoxmlSaveOptions_GetEnableZip64( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Always use ZIP64 extensions when writing zip archives, even when unnecessary.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *OoxmlSaveOptions) SetEnableZip64(value bool)  error {
	
	CGoReturnPtr := C.OoxmlSaveOptions_SetEnableZip64( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether embedding Ooxml files of OleObject as ole object.
// Returns:
//   bool  
func (instance *OoxmlSaveOptions) GetEmbedOoxmlAsOleObject()  (bool,  error)  {
	
	CGoReturnPtr := C.OoxmlSaveOptions_GetEmbedOoxmlAsOleObject( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether embedding Ooxml files of OleObject as ole object.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *OoxmlSaveOptions) SetEmbedOoxmlAsOleObject(value bool)  error {
	
	CGoReturnPtr := C.OoxmlSaveOptions_SetEmbedOoxmlAsOleObject( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the compression type for ooxml file.
// Returns:
//   int32  
func (instance *OoxmlSaveOptions) GetCompressionType()  (OoxmlCompressionType,  error)  {
	
	CGoReturnPtr := C.OoxmlSaveOptions_GetCompressionType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToOoxmlCompressionType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets and sets the compression type for ooxml file.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *OoxmlSaveOptions) SetCompressionType(value OoxmlCompressionType)  error {
	
	CGoReturnPtr := C.OoxmlSaveOptions_SetCompressionType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether to make the xls more compatible with WPS.
// Returns:
//   bool  
func (instance *OoxmlSaveOptions) GetWpsCompatibility()  (bool,  error)  {
	
	CGoReturnPtr := C.OoxmlSaveOptions_GetWpsCompatibility( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether to make the xls more compatible with WPS.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *OoxmlSaveOptions) SetWpsCompatibility(value bool)  error {
	
	CGoReturnPtr := C.OoxmlSaveOptions_SetWpsCompatibility( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the save file format.
// Returns:
//   int32  
func (instance *OoxmlSaveOptions) GetSaveFormat()  (SaveFormat,  error)  {
	
	CGoReturnPtr := C.OoxmlSaveOptions_GetSaveFormat( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToSaveFormat(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Make the workbook empty after saving the file.
// Returns:
//   bool  
func (instance *OoxmlSaveOptions) GetClearData()  (bool,  error)  {
	
	CGoReturnPtr := C.OoxmlSaveOptions_GetClearData( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Make the workbook empty after saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *OoxmlSaveOptions) SetClearData(value bool)  error {
	
	CGoReturnPtr := C.OoxmlSaveOptions_SetClearData( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// The folder for temporary files that may be used as data cache.
// Returns:
//   string  
func (instance *OoxmlSaveOptions) GetCachedFileFolder()  (string,  error)  {
	
	CGoReturnPtr := C.OoxmlSaveOptions_GetCachedFileFolder( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// The folder for temporary files that may be used as data cache.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *OoxmlSaveOptions) SetCachedFileFolder(value string)  error {
	
	CGoReturnPtr := C.OoxmlSaveOptions_SetCachedFileFolder( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether validate merged cells before saving the file.
// Returns:
//   bool  
func (instance *OoxmlSaveOptions) GetValidateMergedAreas()  (bool,  error)  {
	
	CGoReturnPtr := C.OoxmlSaveOptions_GetValidateMergedAreas( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether validate merged cells before saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *OoxmlSaveOptions) SetValidateMergedAreas(value bool)  error {
	
	CGoReturnPtr := C.OoxmlSaveOptions_SetValidateMergedAreas( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether merge the areas of conditional formatting and validation before saving the file.
// Returns:
//   bool  
func (instance *OoxmlSaveOptions) GetMergeAreas()  (bool,  error)  {
	
	CGoReturnPtr := C.OoxmlSaveOptions_GetMergeAreas( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether merge the areas of conditional formatting and validation before saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *OoxmlSaveOptions) SetMergeAreas(value bool)  error {
	
	CGoReturnPtr := C.OoxmlSaveOptions_SetMergeAreas( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// If true and the directory does not exist, the directory will be automatically created before saving the file.
// Returns:
//   bool  
func (instance *OoxmlSaveOptions) GetCreateDirectory()  (bool,  error)  {
	
	CGoReturnPtr := C.OoxmlSaveOptions_GetCreateDirectory( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// If true and the directory does not exist, the directory will be automatically created before saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *OoxmlSaveOptions) SetCreateDirectory(value bool)  error {
	
	CGoReturnPtr := C.OoxmlSaveOptions_SetCreateDirectory( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether sorting defined names before saving file.
// Returns:
//   bool  
func (instance *OoxmlSaveOptions) GetSortNames()  (bool,  error)  {
	
	CGoReturnPtr := C.OoxmlSaveOptions_GetSortNames( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether sorting defined names before saving file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *OoxmlSaveOptions) SetSortNames(value bool)  error {
	
	CGoReturnPtr := C.OoxmlSaveOptions_SetSortNames( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether sorting external defined names before saving file.
// Returns:
//   bool  
func (instance *OoxmlSaveOptions) GetSortExternalNames()  (bool,  error)  {
	
	CGoReturnPtr := C.OoxmlSaveOptions_GetSortExternalNames( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether sorting external defined names before saving file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *OoxmlSaveOptions) SetSortExternalNames(value bool)  error {
	
	CGoReturnPtr := C.OoxmlSaveOptions_SetSortExternalNames( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether refreshing chart cache data
// Returns:
//   bool  
func (instance *OoxmlSaveOptions) GetRefreshChartCache()  (bool,  error)  {
	
	CGoReturnPtr := C.OoxmlSaveOptions_GetRefreshChartCache( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether refreshing chart cache data
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *OoxmlSaveOptions) SetRefreshChartCache(value bool)  error {
	
	CGoReturnPtr := C.OoxmlSaveOptions_SetRefreshChartCache( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Whether check restriction of excel file when user modify cells related objects.
// For example, excel does not allow inputting string value longer than 32K.
// When you input a value longer than 32K, it will be truncated.
// Returns:
//   bool  
func (instance *OoxmlSaveOptions) GetCheckExcelRestriction()  (bool,  error)  {
	
	CGoReturnPtr := C.OoxmlSaveOptions_GetCheckExcelRestriction( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Whether check restriction of excel file when user modify cells related objects.
// For example, excel does not allow inputting string value longer than 32K.
// When you input a value longer than 32K, it will be truncated.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *OoxmlSaveOptions) SetCheckExcelRestriction(value bool)  error {
	
	CGoReturnPtr := C.OoxmlSaveOptions_SetCheckExcelRestriction( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether updating smart art setting.
// The default value is false.
// Returns:
//   bool  
func (instance *OoxmlSaveOptions) GetUpdateSmartArt()  (bool,  error)  {
	
	CGoReturnPtr := C.OoxmlSaveOptions_GetUpdateSmartArt( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether updating smart art setting.
// The default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *OoxmlSaveOptions) SetUpdateSmartArt(value bool)  error {
	
	CGoReturnPtr := C.OoxmlSaveOptions_SetUpdateSmartArt( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether encrypt document properties when saving as .xls file.
// The default value is true.
// Returns:
//   bool  
func (instance *OoxmlSaveOptions) GetEncryptDocumentProperties()  (bool,  error)  {
	
	CGoReturnPtr := C.OoxmlSaveOptions_GetEncryptDocumentProperties( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether encrypt document properties when saving as .xls file.
// The default value is true.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *OoxmlSaveOptions) SetEncryptDocumentProperties(value bool)  error {
	
	CGoReturnPtr := C.OoxmlSaveOptions_SetEncryptDocumentProperties( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}


func (instance *OoxmlSaveOptions) ToSaveOptions() *SaveOptions {
	parentClass := &SaveOptions{}
	parentClass.ptr = instance.ptr
	return parentClass
}

func DeleteOoxmlSaveOptions(ooxmlsaveoptions *OoxmlSaveOptions){
	runtime.SetFinalizer(ooxmlsaveoptions, nil)
	C.Delete_OoxmlSaveOptions(ooxmlsaveoptions.ptr)
	ooxmlsaveoptions.ptr = nil
}

// Class Outline 

// Represents an outline on a worksheet.
type Outline struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *Outline) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.Outline_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates if the summary row will be positioned below the detail rows in the outline.
// Returns:
//   bool  
func (instance *Outline) GetSummaryRowBelow()  (bool,  error)  {
	
	CGoReturnPtr := C.Outline_GetSummaryRowBelow( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates if the summary row will be positioned below the detail rows in the outline.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Outline) SetSummaryRowBelow(value bool)  error {
	
	CGoReturnPtr := C.Outline_SetSummaryRowBelow( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates if the summary column will be positioned to the right of the detail columns in the outline.
// Returns:
//   bool  
func (instance *Outline) GetSummaryColumnRight()  (bool,  error)  {
	
	CGoReturnPtr := C.Outline_GetSummaryColumnRight( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates if the summary column will be positioned to the right of the detail columns in the outline.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Outline) SetSummaryColumnRight(value bool)  error {
	
	CGoReturnPtr := C.Outline_SetSummaryColumnRight( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}



func DeleteOutline(outline *Outline){
	runtime.SetFinalizer(outline, nil)
	C.Delete_Outline(outline.ptr)
	outline.ptr = nil
}

// Class PageSetup 

// Encapsulates the object that represents the page setup description.
// The PageSetup object contains all page setup options.
type PageSetup struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *PageSetup) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.PageSetup_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the background of ODS.
// Returns:
//   OdsPageBackground  
func (instance *PageSetup) GetODSPageBackground()  (*OdsPageBackground,  error)  {
	
	CGoReturnPtr := C.PageSetup_GetODSPageBackground( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &OdsPageBackground{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteOdsPageBackground) 

	return result, nil 
}
// Copies the setting of the page setup.
// Parameters:
//   source - PageSetup 
//   copyOptions - CopyOptions 
// Returns:
//   void  
func (instance *PageSetup) Copy(source *PageSetup, copyoptions *CopyOptions)  error {
	
	var source_ptr unsafe.Pointer = nil
	if source != nil {
	  source_ptr =source.ptr
	}
	var copyoptions_ptr unsafe.Pointer = nil
	if copyoptions != nil {
	  copyoptions_ptr =copyoptions.ptr
	}

	CGoReturnPtr := C.PageSetup_Copy( instance.ptr, source_ptr, copyoptions_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents the range to be printed.
// Returns:
//   string  
func (instance *PageSetup) GetPrintArea()  (string,  error)  {
	
	CGoReturnPtr := C.PageSetup_GetPrintArea( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents the range to be printed.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *PageSetup) SetPrintArea(value string)  error {
	
	CGoReturnPtr := C.PageSetup_SetPrintArea( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents the columns that contain the cells to be repeated on the left side of each page.
// Returns:
//   string  
func (instance *PageSetup) GetPrintTitleColumns()  (string,  error)  {
	
	CGoReturnPtr := C.PageSetup_GetPrintTitleColumns( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents the columns that contain the cells to be repeated on the left side of each page.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *PageSetup) SetPrintTitleColumns(value string)  error {
	
	CGoReturnPtr := C.PageSetup_SetPrintTitleColumns( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents the rows that contain the cells to be repeated at the top of each page.
// Returns:
//   string  
func (instance *PageSetup) GetPrintTitleRows()  (string,  error)  {
	
	CGoReturnPtr := C.PageSetup_GetPrintTitleRows( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents the rows that contain the cells to be repeated at the top of each page.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *PageSetup) SetPrintTitleRows(value string)  error {
	
	CGoReturnPtr := C.PageSetup_SetPrintTitleRows( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents if elements of the document will be printed in black and white.
// Returns:
//   bool  
func (instance *PageSetup) GetBlackAndWhite()  (bool,  error)  {
	
	CGoReturnPtr := C.PageSetup_GetBlackAndWhite( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents if elements of the document will be printed in black and white.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PageSetup) SetBlackAndWhite(value bool)  error {
	
	CGoReturnPtr := C.PageSetup_SetBlackAndWhite( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represent if the sheet is printed centered horizontally.
// Returns:
//   bool  
func (instance *PageSetup) GetCenterHorizontally()  (bool,  error)  {
	
	CGoReturnPtr := C.PageSetup_GetCenterHorizontally( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represent if the sheet is printed centered horizontally.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PageSetup) SetCenterHorizontally(value bool)  error {
	
	CGoReturnPtr := C.PageSetup_SetCenterHorizontally( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represent if the sheet is printed centered vertically.
// Returns:
//   bool  
func (instance *PageSetup) GetCenterVertically()  (bool,  error)  {
	
	CGoReturnPtr := C.PageSetup_GetCenterVertically( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represent if the sheet is printed centered vertically.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PageSetup) SetCenterVertically(value bool)  error {
	
	CGoReturnPtr := C.PageSetup_SetCenterVertically( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents if the sheet will be printed without graphics.
// Returns:
//   bool  
func (instance *PageSetup) GetPrintDraft()  (bool,  error)  {
	
	CGoReturnPtr := C.PageSetup_GetPrintDraft( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents if the sheet will be printed without graphics.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PageSetup) SetPrintDraft(value bool)  error {
	
	CGoReturnPtr := C.PageSetup_SetPrintDraft( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents the distance from the bottom of the page to the footer, in unit of centimeters.
// Returns:
//   float64  
func (instance *PageSetup) GetFooterMargin()  (float64,  error)  {
	
	CGoReturnPtr := C.PageSetup_GetFooterMargin( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := float64(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents the distance from the bottom of the page to the footer, in unit of centimeters.
// Parameters:
//   value - float64 
// Returns:
//   void  
func (instance *PageSetup) SetFooterMargin(value float64)  error {
	
	CGoReturnPtr := C.PageSetup_SetFooterMargin( instance.ptr, C.double(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents the distance from the bottom of the page to the footer, in unit of inches.
// Returns:
//   float64  
func (instance *PageSetup) GetFooterMarginInch()  (float64,  error)  {
	
	CGoReturnPtr := C.PageSetup_GetFooterMarginInch( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := float64(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents the distance from the bottom of the page to the footer, in unit of inches.
// Parameters:
//   value - float64 
// Returns:
//   void  
func (instance *PageSetup) SetFooterMarginInch(value float64)  error {
	
	CGoReturnPtr := C.PageSetup_SetFooterMarginInch( instance.ptr, C.double(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents the distance from the top of the page to the header, in unit of centimeters.
// Returns:
//   float64  
func (instance *PageSetup) GetHeaderMargin()  (float64,  error)  {
	
	CGoReturnPtr := C.PageSetup_GetHeaderMargin( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := float64(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents the distance from the top of the page to the header, in unit of centimeters.
// Parameters:
//   value - float64 
// Returns:
//   void  
func (instance *PageSetup) SetHeaderMargin(value float64)  error {
	
	CGoReturnPtr := C.PageSetup_SetHeaderMargin( instance.ptr, C.double(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents the distance from the top of the page to the header, in unit of inches.
// Returns:
//   float64  
func (instance *PageSetup) GetHeaderMarginInch()  (float64,  error)  {
	
	CGoReturnPtr := C.PageSetup_GetHeaderMarginInch( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := float64(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents the distance from the top of the page to the header, in unit of inches.
// Parameters:
//   value - float64 
// Returns:
//   void  
func (instance *PageSetup) SetHeaderMarginInch(value float64)  error {
	
	CGoReturnPtr := C.PageSetup_SetHeaderMarginInch( instance.ptr, C.double(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the settings of the default printer.
// Returns:
//   []byte  
func (instance *PageSetup) GetPrinterSettings()  ([]byte,  error)  {
	
	CGoReturnPtr := C.PageSetup_GetPrinterSettings( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := C.GoBytes(unsafe.Pointer(CGoReturnPtr.return_value), C.int(CGoReturnPtr.column_length))
	 

	return result, nil 
}
// Gets and sets the settings of the default printer.
// Parameters:
//   value - []byte 
// Returns:
//   void  
func (instance *PageSetup) SetPrinterSettings(value []byte)  error {
	
	CGoReturnPtr := C.PageSetup_SetPrinterSettings( instance.ptr, unsafe.Pointer(&value[0]), C.int( len(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents the size of the left margin, in unit of centimeters.
// Returns:
//   float64  
func (instance *PageSetup) GetLeftMargin()  (float64,  error)  {
	
	CGoReturnPtr := C.PageSetup_GetLeftMargin( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := float64(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents the size of the left margin, in unit of centimeters.
// Parameters:
//   value - float64 
// Returns:
//   void  
func (instance *PageSetup) SetLeftMargin(value float64)  error {
	
	CGoReturnPtr := C.PageSetup_SetLeftMargin( instance.ptr, C.double(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents the size of the left margin, in unit of inches.
// Returns:
//   float64  
func (instance *PageSetup) GetLeftMarginInch()  (float64,  error)  {
	
	CGoReturnPtr := C.PageSetup_GetLeftMarginInch( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := float64(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents the size of the left margin, in unit of inches.
// Parameters:
//   value - float64 
// Returns:
//   void  
func (instance *PageSetup) SetLeftMarginInch(value float64)  error {
	
	CGoReturnPtr := C.PageSetup_SetLeftMarginInch( instance.ptr, C.double(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents the size of the right margin, in unit of centimeters.
// Returns:
//   float64  
func (instance *PageSetup) GetRightMargin()  (float64,  error)  {
	
	CGoReturnPtr := C.PageSetup_GetRightMargin( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := float64(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents the size of the right margin, in unit of centimeters.
// Parameters:
//   value - float64 
// Returns:
//   void  
func (instance *PageSetup) SetRightMargin(value float64)  error {
	
	CGoReturnPtr := C.PageSetup_SetRightMargin( instance.ptr, C.double(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents the size of the right margin, in unit of inches.
// Returns:
//   float64  
func (instance *PageSetup) GetRightMarginInch()  (float64,  error)  {
	
	CGoReturnPtr := C.PageSetup_GetRightMarginInch( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := float64(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents the size of the right margin, in unit of inches.
// Parameters:
//   value - float64 
// Returns:
//   void  
func (instance *PageSetup) SetRightMarginInch(value float64)  error {
	
	CGoReturnPtr := C.PageSetup_SetRightMarginInch( instance.ptr, C.double(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents the size of the top margin, in unit of centimeters.
// Returns:
//   float64  
func (instance *PageSetup) GetTopMargin()  (float64,  error)  {
	
	CGoReturnPtr := C.PageSetup_GetTopMargin( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := float64(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents the size of the top margin, in unit of centimeters.
// Parameters:
//   value - float64 
// Returns:
//   void  
func (instance *PageSetup) SetTopMargin(value float64)  error {
	
	CGoReturnPtr := C.PageSetup_SetTopMargin( instance.ptr, C.double(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents the size of the top margin, in unit of inches.
// Returns:
//   float64  
func (instance *PageSetup) GetTopMarginInch()  (float64,  error)  {
	
	CGoReturnPtr := C.PageSetup_GetTopMarginInch( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := float64(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents the size of the top margin, in unit of inches.
// Parameters:
//   value - float64 
// Returns:
//   void  
func (instance *PageSetup) SetTopMarginInch(value float64)  error {
	
	CGoReturnPtr := C.PageSetup_SetTopMarginInch( instance.ptr, C.double(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents the size of the bottom margin, in unit of centimeters.
// Returns:
//   float64  
func (instance *PageSetup) GetBottomMargin()  (float64,  error)  {
	
	CGoReturnPtr := C.PageSetup_GetBottomMargin( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := float64(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents the size of the bottom margin, in unit of centimeters.
// Parameters:
//   value - float64 
// Returns:
//   void  
func (instance *PageSetup) SetBottomMargin(value float64)  error {
	
	CGoReturnPtr := C.PageSetup_SetBottomMargin( instance.ptr, C.double(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents the size of the bottom margin, in unit of inches.
// Returns:
//   float64  
func (instance *PageSetup) GetBottomMarginInch()  (float64,  error)  {
	
	CGoReturnPtr := C.PageSetup_GetBottomMarginInch( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := float64(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents the size of the bottom margin, in unit of inches.
// Parameters:
//   value - float64 
// Returns:
//   void  
func (instance *PageSetup) SetBottomMarginInch(value float64)  error {
	
	CGoReturnPtr := C.PageSetup_SetBottomMarginInch( instance.ptr, C.double(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents the first page number that will be used when this sheet is printed.
// Returns:
//   int32  
func (instance *PageSetup) GetFirstPageNumber()  (int32,  error)  {
	
	CGoReturnPtr := C.PageSetup_GetFirstPageNumber( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents the first page number that will be used when this sheet is printed.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *PageSetup) SetFirstPageNumber(value int32)  error {
	
	CGoReturnPtr := C.PageSetup_SetFirstPageNumber( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Sets the number of pages the worksheet will be scaled to when it's printed.
// Parameters:
//   wide - int32 
//   tall - int32 
// Returns:
//   void  
func (instance *PageSetup) SetFitToPages(wide int32, tall int32)  error {
	
	CGoReturnPtr := C.PageSetup_SetFitToPages( instance.ptr, C.int(wide), C.int(tall))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents  the number of pages tall the worksheet will be scaled to when it's printed.
// The default value is 1.
// Returns:
//   int32  
func (instance *PageSetup) GetFitToPagesTall()  (int32,  error)  {
	
	CGoReturnPtr := C.PageSetup_GetFitToPagesTall( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents  the number of pages tall the worksheet will be scaled to when it's printed.
// The default value is 1.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *PageSetup) SetFitToPagesTall(value int32)  error {
	
	CGoReturnPtr := C.PageSetup_SetFitToPagesTall( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents the number of pages wide the worksheet will be scaled to when it's printed.
// The default value is 1.
// Returns:
//   int32  
func (instance *PageSetup) GetFitToPagesWide()  (int32,  error)  {
	
	CGoReturnPtr := C.PageSetup_GetFitToPagesWide( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents the number of pages wide the worksheet will be scaled to when it's printed.
// The default value is 1.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *PageSetup) SetFitToPagesWide(value int32)  error {
	
	CGoReturnPtr := C.PageSetup_SetFitToPagesWide( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// If this property is False, the FitToPagesWide and FitToPagesTall properties control how the worksheet is scaled.
// Returns:
//   bool  
func (instance *PageSetup) IsPercentScale()  (bool,  error)  {
	
	CGoReturnPtr := C.PageSetup_IsPercentScale( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// If this property is False, the FitToPagesWide and FitToPagesTall properties control how the worksheet is scaled.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PageSetup) SetIsPercentScale(value bool)  error {
	
	CGoReturnPtr := C.PageSetup_SetIsPercentScale( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents the order that Microsoft Excel uses to number pages when printing a large worksheet.
// Returns:
//   int32  
func (instance *PageSetup) GetOrder()  (PrintOrderType,  error)  {
	
	CGoReturnPtr := C.PageSetup_GetOrder( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToPrintOrderType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Represents the order that Microsoft Excel uses to number pages when printing a large worksheet.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *PageSetup) SetOrder(value PrintOrderType)  error {
	
	CGoReturnPtr := C.PageSetup_SetOrder( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether the paper size is automatic.
// Returns:
//   bool  
func (instance *PageSetup) IsAutomaticPaperSize()  (bool,  error)  {
	
	CGoReturnPtr := C.PageSetup_IsAutomaticPaperSize( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents the size of the paper.
// Returns:
//   int32  
func (instance *PageSetup) GetPaperSize()  (PaperSizeType,  error)  {
	
	CGoReturnPtr := C.PageSetup_GetPaperSize( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToPaperSizeType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Represents the size of the paper.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *PageSetup) SetPaperSize(value PaperSizeType)  error {
	
	CGoReturnPtr := C.PageSetup_SetPaperSize( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the width of the paper in unit of inches, considered page orientation.
// Returns:
//   float64  
func (instance *PageSetup) GetPaperWidth()  (float64,  error)  {
	
	CGoReturnPtr := C.PageSetup_GetPaperWidth( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := float64(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the height of the paper in unit of inches , considered page orientation.
// Returns:
//   float64  
func (instance *PageSetup) GetPaperHeight()  (float64,  error)  {
	
	CGoReturnPtr := C.PageSetup_GetPaperHeight( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := float64(CGoReturnPtr.return_value) 

	return result, nil 
}
// Sets the custom paper size, in unit of inches.
// Parameters:
//   width - float64 
//   height - float64 
// Returns:
//   void  
func (instance *PageSetup) CustomPaperSize(width float64, height float64)  error {
	
	CGoReturnPtr := C.PageSetup_CustomPaperSize( instance.ptr, C.double(width), C.double(height))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents page print orientation.
// Returns:
//   int32  
func (instance *PageSetup) GetOrientation()  (PageOrientationType,  error)  {
	
	CGoReturnPtr := C.PageSetup_GetOrientation( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToPageOrientationType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Represents page print orientation.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *PageSetup) SetOrientation(value PageOrientationType)  error {
	
	CGoReturnPtr := C.PageSetup_SetOrientation( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents the way comments are printed with the sheet.
// Returns:
//   int32  
func (instance *PageSetup) GetPrintComments()  (PrintCommentsType,  error)  {
	
	CGoReturnPtr := C.PageSetup_GetPrintComments( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToPrintCommentsType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Represents the way comments are printed with the sheet.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *PageSetup) SetPrintComments(value PrintCommentsType)  error {
	
	CGoReturnPtr := C.PageSetup_SetPrintComments( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Specifies the type of print error displayed.
// Returns:
//   int32  
func (instance *PageSetup) GetPrintErrors()  (PrintErrorsType,  error)  {
	
	CGoReturnPtr := C.PageSetup_GetPrintErrors( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToPrintErrorsType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Specifies the type of print error displayed.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *PageSetup) SetPrintErrors(value PrintErrorsType)  error {
	
	CGoReturnPtr := C.PageSetup_SetPrintErrors( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents if row and column headings are printed with this page.
// Returns:
//   bool  
func (instance *PageSetup) GetPrintHeadings()  (bool,  error)  {
	
	CGoReturnPtr := C.PageSetup_GetPrintHeadings( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents if row and column headings are printed with this page.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PageSetup) SetPrintHeadings(value bool)  error {
	
	CGoReturnPtr := C.PageSetup_SetPrintHeadings( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents if cell gridlines are printed on the page.
// Returns:
//   bool  
func (instance *PageSetup) GetPrintGridlines()  (bool,  error)  {
	
	CGoReturnPtr := C.PageSetup_GetPrintGridlines( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents if cell gridlines are printed on the page.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PageSetup) SetPrintGridlines(value bool)  error {
	
	CGoReturnPtr := C.PageSetup_SetPrintGridlines( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents the scaling factor in percent. It should be between 10 and 400.
// Returns:
//   int32  
func (instance *PageSetup) GetZoom()  (int32,  error)  {
	
	CGoReturnPtr := C.PageSetup_GetZoom( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents the scaling factor in percent. It should be between 10 and 400.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *PageSetup) SetZoom(value int32)  error {
	
	CGoReturnPtr := C.PageSetup_SetZoom( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether the first the page number is automatically assigned.
// Returns:
//   bool  
func (instance *PageSetup) IsAutoFirstPageNumber()  (bool,  error)  {
	
	CGoReturnPtr := C.PageSetup_IsAutoFirstPageNumber( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether the first the page number is automatically assigned.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PageSetup) SetIsAutoFirstPageNumber(value bool)  error {
	
	CGoReturnPtr := C.PageSetup_SetIsAutoFirstPageNumber( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents the print quality.
// Returns:
//   int32  
func (instance *PageSetup) GetPrintQuality()  (int32,  error)  {
	
	CGoReturnPtr := C.PageSetup_GetPrintQuality( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents the print quality.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *PageSetup) SetPrintQuality(value int32)  error {
	
	CGoReturnPtr := C.PageSetup_SetPrintQuality( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Get and sets number of copies to print.
// Returns:
//   int32  
func (instance *PageSetup) GetPrintCopies()  (int32,  error)  {
	
	CGoReturnPtr := C.PageSetup_GetPrintCopies( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Get and sets number of copies to print.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *PageSetup) SetPrintCopies(value int32)  error {
	
	CGoReturnPtr := C.PageSetup_SetPrintCopies( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Clears header and footer setting.
// Returns:
//   void  
func (instance *PageSetup) ClearHeaderFooter()  error {
	
	CGoReturnPtr := C.PageSetup_ClearHeaderFooter( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets a script formatting the header of an Excel file.
// Parameters:
//   section - int32 
// Returns:
//   string  
func (instance *PageSetup) GetHeader(section int32)  (string,  error)  {
	
	CGoReturnPtr := C.PageSetup_GetHeader( instance.ptr, C.int(section))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets all commands of header or footer.
// Parameters:
//   headerFooterScript - string 
// Returns:
//   []HeaderFooterCommand  
func (instance *PageSetup) GetCommands(headerfooterscript string)  ([]HeaderFooterCommand,  error)  {
	
	CGoReturnPtr := C.PageSetup_GetCommands( instance.ptr, C.CString(headerfooterscript))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result:= make([]HeaderFooterCommand, CGoReturnPtr.column_length)
	for i := 0; i < int(CGoReturnPtr.column_length); i++ {
	   offset := uintptr(C.size_t(i)) * uintptr(CGoReturnPtr.size)
	   goObject := &HeaderFooterCommand{}
	   goObject.ptr =unsafe.Pointer(uintptr( unsafe.Pointer(CGoReturnPtr.return_value)) + offset)
	   result[i] = *goObject
	}
	 

	return result, nil 
}
// Gets a script formatting the footer of an Excel file.
// Parameters:
//   section - int32 
// Returns:
//   string  
func (instance *PageSetup) GetFooter(section int32)  (string,  error)  {
	
	CGoReturnPtr := C.PageSetup_GetFooter( instance.ptr, C.int(section))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Sets a script formatting the header of an Excel file.
// Parameters:
//   section - int32 
//   headerScript - string 
// Returns:
//   void  
func (instance *PageSetup) SetHeader(section int32, headerscript string)  error {
	
	CGoReturnPtr := C.PageSetup_SetHeader( instance.ptr, C.int(section), C.CString(headerscript))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Sets a script formatting the footer of an Excel file.
// Parameters:
//   section - int32 
//   footerScript - string 
// Returns:
//   void  
func (instance *PageSetup) SetFooter(section int32, footerscript string)  error {
	
	CGoReturnPtr := C.PageSetup_SetFooter( instance.ptr, C.int(section), C.CString(footerscript))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Sets a script formatting the even page header of an Excel file.
// Only effect in Excel 2007 when IsHFDiffOddEven is true.
// Parameters:
//   section - int32 
//   headerScript - string 
// Returns:
//   void  
func (instance *PageSetup) SetEvenHeader(section int32, headerscript string)  error {
	
	CGoReturnPtr := C.PageSetup_SetEvenHeader( instance.ptr, C.int(section), C.CString(headerscript))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets a script formatting the even header of an Excel file.
// Parameters:
//   section - int32 
// Returns:
//   string  
func (instance *PageSetup) GetEvenHeader(section int32)  (string,  error)  {
	
	CGoReturnPtr := C.PageSetup_GetEvenHeader( instance.ptr, C.int(section))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Sets a script formatting the even page footer of an Excel file.
// Only effect in Excel 2007 when IsHFDiffOddEven is true.
// Parameters:
//   section - int32 
//   footerScript - string 
// Returns:
//   void  
func (instance *PageSetup) SetEvenFooter(section int32, footerscript string)  error {
	
	CGoReturnPtr := C.PageSetup_SetEvenFooter( instance.ptr, C.int(section), C.CString(footerscript))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets a script formatting the even footer of an Excel file.
// Parameters:
//   section - int32 
// Returns:
//   string  
func (instance *PageSetup) GetEvenFooter(section int32)  (string,  error)  {
	
	CGoReturnPtr := C.PageSetup_GetEvenFooter( instance.ptr, C.int(section))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Sets a script formatting the first page header of an Excel file.
// Only effect in Excel 2007 when IsHFDiffFirst is true.
// Parameters:
//   section - int32 
//   headerScript - string 
// Returns:
//   void  
func (instance *PageSetup) SetFirstPageHeader(section int32, headerscript string)  error {
	
	CGoReturnPtr := C.PageSetup_SetFirstPageHeader( instance.ptr, C.int(section), C.CString(headerscript))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets a script formatting the first page header of an Excel file.
// Parameters:
//   section - int32 
// Returns:
//   string  
func (instance *PageSetup) GetFirstPageHeader(section int32)  (string,  error)  {
	
	CGoReturnPtr := C.PageSetup_GetFirstPageHeader( instance.ptr, C.int(section))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Sets a script formatting the first page footer of an Excel file.
// Parameters:
//   section - int32 
//   footerScript - string 
// Returns:
//   void  
func (instance *PageSetup) SetFirstPageFooter(section int32, footerscript string)  error {
	
	CGoReturnPtr := C.PageSetup_SetFirstPageFooter( instance.ptr, C.int(section), C.CString(footerscript))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets a script formatting the first page footer of an Excel file.
// Parameters:
//   section - int32 
// Returns:
//   string  
func (instance *PageSetup) GetFirstPageFooter(section int32)  (string,  error)  {
	
	CGoReturnPtr := C.PageSetup_GetFirstPageFooter( instance.ptr, C.int(section))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// True means that the header/footer of the odd pages is different with odd pages.
// Returns:
//   bool  
func (instance *PageSetup) IsHFDiffOddEven()  (bool,  error)  {
	
	CGoReturnPtr := C.PageSetup_IsHFDiffOddEven( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// True means that the header/footer of the odd pages is different with odd pages.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PageSetup) SetIsHFDiffOddEven(value bool)  error {
	
	CGoReturnPtr := C.PageSetup_SetIsHFDiffOddEven( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// True means that the header/footer of the first page is different with other pages.
// Returns:
//   bool  
func (instance *PageSetup) IsHFDiffFirst()  (bool,  error)  {
	
	CGoReturnPtr := C.PageSetup_IsHFDiffFirst( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// True means that the header/footer of the first page is different with other pages.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PageSetup) SetIsHFDiffFirst(value bool)  error {
	
	CGoReturnPtr := C.PageSetup_SetIsHFDiffFirst( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether header and footer are scaled with document scaling.
// Only applies for Excel 2007.
// Returns:
//   bool  
func (instance *PageSetup) IsHFScaleWithDoc()  (bool,  error)  {
	
	CGoReturnPtr := C.PageSetup_IsHFScaleWithDoc( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether header and footer are scaled with document scaling.
// Only applies for Excel 2007.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PageSetup) SetIsHFScaleWithDoc(value bool)  error {
	
	CGoReturnPtr := C.PageSetup_SetIsHFScaleWithDoc( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether header and footer margins are aligned with the page margins.
// If this property is true, the left header and footer will be aligned with the left margin,
// and the right header and footer will be aligned with the right margin.
// This option is enabled by default.
// Returns:
//   bool  
func (instance *PageSetup) IsHFAlignMargins()  (bool,  error)  {
	
	CGoReturnPtr := C.PageSetup_IsHFAlignMargins( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether header and footer margins are aligned with the page margins.
// If this property is true, the left header and footer will be aligned with the left margin,
// and the right header and footer will be aligned with the right margin.
// This option is enabled by default.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PageSetup) SetIsHFAlignMargins(value bool)  error {
	
	CGoReturnPtr := C.PageSetup_SetIsHFAlignMargins( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Sets an image in the header of a worksheet.
// Parameters:
//   section - int32 
//   headerPicture - []byte 
// Returns:
//   Picture  
func (instance *PageSetup) SetHeaderPicture(section int32, headerpicture []byte)  (*Picture,  error)  {
	
	CGoReturnPtr := C.PageSetup_SetHeaderPicture( instance.ptr, C.int(section), unsafe.Pointer(&headerpicture[0]), C.int( len(headerpicture)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Picture{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeletePicture) 

	return result, nil 
}
// Sets an image in the footer of a worksheet.
// Parameters:
//   section - int32 
//   footerPicture - []byte 
// Returns:
//   Picture  
func (instance *PageSetup) SetFooterPicture(section int32, footerpicture []byte)  (*Picture,  error)  {
	
	CGoReturnPtr := C.PageSetup_SetFooterPicture( instance.ptr, C.int(section), unsafe.Pointer(&footerpicture[0]), C.int( len(footerpicture)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Picture{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeletePicture) 

	return result, nil 
}
// Sets an image in the header/footer of a worksheet.
// Parameters:
//   isFirst - bool 
//   isEven - bool 
//   isHeader - bool 
//   section - int32 
//   imageData - []byte 
// Returns:
//   Picture  
func (instance *PageSetup) SetPicture(isfirst bool, iseven bool, isheader bool, section int32, imagedata []byte)  (*Picture,  error)  {
	
	CGoReturnPtr := C.PageSetup_SetPicture( instance.ptr, C.bool(isfirst), C.bool(iseven), C.bool(isheader), C.int(section), unsafe.Pointer(&imagedata[0]), C.int( len(imagedata)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Picture{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeletePicture) 

	return result, nil 
}
// Gets the <see cref="Picture"/> object of the header / footer.
// Parameters:
//   isHeader - bool 
//   section - int32 
// Returns:
//   Picture  
func (instance *PageSetup) GetPicture_Bool_Int(isheader bool, section int32)  (*Picture,  error)  {
	
	CGoReturnPtr := C.PageSetup_GetPicture_Boolean_Integer( instance.ptr, C.bool(isheader), C.int(section))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Picture{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeletePicture) 

	return result, nil 
}
// Gets the <see cref="Picture"/> object of the header / footer.
// Parameters:
//   isFirst - bool 
//   isEven - bool 
//   isHeader - bool 
//   section - int32 
// Returns:
//   Picture  
func (instance *PageSetup) GetPicture_Bool_Bool_Bool_Int(isfirst bool, iseven bool, isheader bool, section int32)  (*Picture,  error)  {
	
	CGoReturnPtr := C.PageSetup_GetPicture_Boolean_Boolean_Boolean_Integer( instance.ptr, C.bool(isfirst), C.bool(iseven), C.bool(isheader), C.int(section))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Picture{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeletePicture) 

	return result, nil 
}



func DeletePageSetup(pagesetup *PageSetup){
	runtime.SetFinalizer(pagesetup, nil)
	C.Delete_PageSetup(pagesetup.ptr)
	pagesetup.ptr = nil
}

// Class PaginatedSaveOptions 

// Represents the options for pagination.
type PaginatedSaveOptions struct {
	ptr unsafe.Pointer
}

// Constructs from a parent object.
// Parameters:
//   src - SaveOptions 
func NewPaginatedSaveOptions(src *SaveOptions) ( *PaginatedSaveOptions, error) {
	paginatedsaveoptions := &PaginatedSaveOptions{}
	var src_ptr unsafe.Pointer = nil
	if src != nil {
	  src_ptr =src.ptr
	}

	CGoReturnPtr := C.New_PaginatedSaveOptions(src_ptr)
	if CGoReturnPtr.error_no == 0 {
		paginatedsaveoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(paginatedsaveoptions, DeletePaginatedSaveOptions)
		return paginatedsaveoptions, nil
	} else {
		paginatedsaveoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return paginatedsaveoptions, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *PaginatedSaveOptions) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.PaginatedSaveOptions_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// When characters in the Excel are Unicode and not be set with correct font in cell style,
// They may appear as block in pdf,image.
// Set the DefaultFont such as MingLiu or MS Gothic to show these characters.
// If this property is not set, Aspose.Cells will use system default font to show these unicode characters.
// Returns:
//   string  
func (instance *PaginatedSaveOptions) GetDefaultFont()  (string,  error)  {
	
	CGoReturnPtr := C.PaginatedSaveOptions_GetDefaultFont( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// When characters in the Excel are Unicode and not be set with correct font in cell style,
// They may appear as block in pdf,image.
// Set the DefaultFont such as MingLiu or MS Gothic to show these characters.
// If this property is not set, Aspose.Cells will use system default font to show these unicode characters.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *PaginatedSaveOptions) SetDefaultFont(value string)  error {
	
	CGoReturnPtr := C.PaginatedSaveOptions_SetDefaultFont( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// When characters in the Excel are Unicode and not be set with correct font in cell style,
// They may appear as block in pdf,image.
// Set this to true to try to use workbook's default font to show these characters first.
// Returns:
//   bool  
func (instance *PaginatedSaveOptions) GetCheckWorkbookDefaultFont()  (bool,  error)  {
	
	CGoReturnPtr := C.PaginatedSaveOptions_GetCheckWorkbookDefaultFont( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// When characters in the Excel are Unicode and not be set with correct font in cell style,
// They may appear as block in pdf,image.
// Set this to true to try to use workbook's default font to show these characters first.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PaginatedSaveOptions) SetCheckWorkbookDefaultFont(value bool)  error {
	
	CGoReturnPtr := C.PaginatedSaveOptions_SetCheckWorkbookDefaultFont( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether to check font compatibility for every character in text.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PaginatedSaveOptions) SetCheckFontCompatibility(value bool)  error {
	
	CGoReturnPtr := C.PaginatedSaveOptions_SetCheckFontCompatibility( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether to check font compatibility for every character in text.
// Returns:
//   bool  
func (instance *PaginatedSaveOptions) GetCheckFontCompatibility()  (bool,  error)  {
	
	CGoReturnPtr := C.PaginatedSaveOptions_GetCheckFontCompatibility( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether to only substitute the font of character when the cell font is not compatibility for it.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PaginatedSaveOptions) SetIsFontSubstitutionCharGranularity(value bool)  error {
	
	CGoReturnPtr := C.PaginatedSaveOptions_SetIsFontSubstitutionCharGranularity( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether to only substitute the font of character when the cell font is not compatibility for it.
// Returns:
//   bool  
func (instance *PaginatedSaveOptions) IsFontSubstitutionCharGranularity()  (bool,  error)  {
	
	CGoReturnPtr := C.PaginatedSaveOptions_IsFontSubstitutionCharGranularity( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// If OnePagePerSheet is true , all content of one sheet will output to only one page in result.
// The paper size of pagesetup will be invalid, and the other settings of pagesetup
// will still take effect.
// Returns:
//   bool  
func (instance *PaginatedSaveOptions) GetOnePagePerSheet()  (bool,  error)  {
	
	CGoReturnPtr := C.PaginatedSaveOptions_GetOnePagePerSheet( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// If OnePagePerSheet is true , all content of one sheet will output to only one page in result.
// The paper size of pagesetup will be invalid, and the other settings of pagesetup
// will still take effect.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PaginatedSaveOptions) SetOnePagePerSheet(value bool)  error {
	
	CGoReturnPtr := C.PaginatedSaveOptions_SetOnePagePerSheet( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// If AllColumnsInOnePagePerSheet is true , all column content of one sheet will output to only one page in result.
// The width of paper size of pagesetup will be ignored, and the other settings of pagesetup
// will still take effect.
// Returns:
//   bool  
func (instance *PaginatedSaveOptions) GetAllColumnsInOnePagePerSheet()  (bool,  error)  {
	
	CGoReturnPtr := C.PaginatedSaveOptions_GetAllColumnsInOnePagePerSheet( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// If AllColumnsInOnePagePerSheet is true , all column content of one sheet will output to only one page in result.
// The width of paper size of pagesetup will be ignored, and the other settings of pagesetup
// will still take effect.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PaginatedSaveOptions) SetAllColumnsInOnePagePerSheet(value bool)  error {
	
	CGoReturnPtr := C.PaginatedSaveOptions_SetAllColumnsInOnePagePerSheet( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates if you need to hide the error while rendering.
// The error can be error in shape, image, chart rendering, etc.
// Returns:
//   bool  
func (instance *PaginatedSaveOptions) GetIgnoreError()  (bool,  error)  {
	
	CGoReturnPtr := C.PaginatedSaveOptions_GetIgnoreError( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates if you need to hide the error while rendering.
// The error can be error in shape, image, chart rendering, etc.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PaginatedSaveOptions) SetIgnoreError(value bool)  error {
	
	CGoReturnPtr := C.PaginatedSaveOptions_SetIgnoreError( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether to output a blank page when there is nothing to print.
// Returns:
//   bool  
func (instance *PaginatedSaveOptions) GetOutputBlankPageWhenNothingToPrint()  (bool,  error)  {
	
	CGoReturnPtr := C.PaginatedSaveOptions_GetOutputBlankPageWhenNothingToPrint( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether to output a blank page when there is nothing to print.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PaginatedSaveOptions) SetOutputBlankPageWhenNothingToPrint(value bool)  error {
	
	CGoReturnPtr := C.PaginatedSaveOptions_SetOutputBlankPageWhenNothingToPrint( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the 0-based index of the first page to save.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *PaginatedSaveOptions) SetPageIndex(value int32)  error {
	
	CGoReturnPtr := C.PaginatedSaveOptions_SetPageIndex( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the 0-based index of the first page to save.
// Returns:
//   int32  
func (instance *PaginatedSaveOptions) GetPageIndex()  (int32,  error)  {
	
	CGoReturnPtr := C.PaginatedSaveOptions_GetPageIndex( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets the number of pages to save.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *PaginatedSaveOptions) SetPageCount(value int32)  error {
	
	CGoReturnPtr := C.PaginatedSaveOptions_SetPageCount( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the number of pages to save.
// Returns:
//   int32  
func (instance *PaginatedSaveOptions) GetPageCount()  (int32,  error)  {
	
	CGoReturnPtr := C.PaginatedSaveOptions_GetPageCount( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates which pages will not be printed.
// Returns:
//   int32  
func (instance *PaginatedSaveOptions) GetPrintingPageType()  (PrintingPageType,  error)  {
	
	CGoReturnPtr := C.PaginatedSaveOptions_GetPrintingPageType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToPrintingPageType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Indicates which pages will not be printed.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *PaginatedSaveOptions) SetPrintingPageType(value PrintingPageType)  error {
	
	CGoReturnPtr := C.PaginatedSaveOptions_SetPrintingPageType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets gridline type.
// Returns:
//   int32  
func (instance *PaginatedSaveOptions) GetGridlineType()  (GridlineType,  error)  {
	
	CGoReturnPtr := C.PaginatedSaveOptions_GetGridlineType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToGridlineType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets or sets gridline type.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *PaginatedSaveOptions) SetGridlineType(value GridlineType)  error {
	
	CGoReturnPtr := C.PaginatedSaveOptions_SetGridlineType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets gridline color.
// Returns:
//   Color  
func (instance *PaginatedSaveOptions) GetGridlineColor()  (*Color,  error)  {
	
	CGoReturnPtr := C.PaginatedSaveOptions_GetGridlineColor( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Gets or sets gridline color.
// Parameters:
//   value - Color 
// Returns:
//   void  
func (instance *PaginatedSaveOptions) SetGridlineColor(value *Color)  error {
	
	CGoReturnPtr := C.PaginatedSaveOptions_SetGridlineColor( instance.ptr, value.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets displaying text type when the text width is larger than cell width.
// Returns:
//   int32  
func (instance *PaginatedSaveOptions) GetTextCrossType()  (TextCrossType,  error)  {
	
	CGoReturnPtr := C.PaginatedSaveOptions_GetTextCrossType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToTextCrossType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets or sets displaying text type when the text width is larger than cell width.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *PaginatedSaveOptions) SetTextCrossType(value TextCrossType)  error {
	
	CGoReturnPtr := C.PaginatedSaveOptions_SetTextCrossType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets default edit language.
// Returns:
//   int32  
func (instance *PaginatedSaveOptions) GetDefaultEditLanguage()  (DefaultEditLanguage,  error)  {
	
	CGoReturnPtr := C.PaginatedSaveOptions_GetDefaultEditLanguage( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToDefaultEditLanguage(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets or sets default edit language.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *PaginatedSaveOptions) SetDefaultEditLanguage(value DefaultEditLanguage)  error {
	
	CGoReturnPtr := C.PaginatedSaveOptions_SetDefaultEditLanguage( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the sheets to render. Default is all visible sheets in the workbook: <see cref="Aspose.Cells.Rendering.SheetSet.Visible"/>.
// Returns:
//   SheetSet  
func (instance *PaginatedSaveOptions) GetSheetSet()  (*SheetSet,  error)  {
	
	CGoReturnPtr := C.PaginatedSaveOptions_GetSheetSet( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &SheetSet{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteSheetSet) 

	return result, nil 
}
// Gets or sets the sheets to render. Default is all visible sheets in the workbook: <see cref="Aspose.Cells.Rendering.SheetSet.Visible"/>.
// Parameters:
//   value - SheetSet 
// Returns:
//   void  
func (instance *PaginatedSaveOptions) SetSheetSet(value *SheetSet)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.PaginatedSaveOptions_SetSheetSet( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Implements this interface to get DrawObject and Bound when rendering.
// Returns:
//   DrawObjectEventHandler  
func (instance *PaginatedSaveOptions) GetDrawObjectEventHandler()  (*DrawObjectEventHandler,  error)  {
	
	CGoReturnPtr := C.PaginatedSaveOptions_GetDrawObjectEventHandler( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &DrawObjectEventHandler{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteDrawObjectEventHandler) 

	return result, nil 
}
// Implements this interface to get DrawObject and Bound when rendering.
// Parameters:
//   value - DrawObjectEventHandler 
// Returns:
//   void  
func (instance *PaginatedSaveOptions) SetDrawObjectEventHandler(value *DrawObjectEventHandler)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.PaginatedSaveOptions_SetDrawObjectEventHandler( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Setting for rendering Emf metafile.
// Returns:
//   int32  
func (instance *PaginatedSaveOptions) GetEmfRenderSetting()  (EmfRenderSetting,  error)  {
	
	CGoReturnPtr := C.PaginatedSaveOptions_GetEmfRenderSetting( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToEmfRenderSetting(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Setting for rendering Emf metafile.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *PaginatedSaveOptions) SetEmfRenderSetting(value EmfRenderSetting)  error {
	
	CGoReturnPtr := C.PaginatedSaveOptions_SetEmfRenderSetting( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets custom settings during rendering.
// Returns:
//   CustomRenderSettings  
func (instance *PaginatedSaveOptions) GetCustomRenderSettings()  (*CustomRenderSettings,  error)  {
	
	CGoReturnPtr := C.PaginatedSaveOptions_GetCustomRenderSettings( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &CustomRenderSettings{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteCustomRenderSettings) 

	return result, nil 
}
// Gets or sets custom settings during rendering.
// Parameters:
//   value - CustomRenderSettings 
// Returns:
//   void  
func (instance *PaginatedSaveOptions) SetCustomRenderSettings(value *CustomRenderSettings)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.PaginatedSaveOptions_SetCustomRenderSettings( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the save file format.
// Returns:
//   int32  
func (instance *PaginatedSaveOptions) GetSaveFormat()  (SaveFormat,  error)  {
	
	CGoReturnPtr := C.PaginatedSaveOptions_GetSaveFormat( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToSaveFormat(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Make the workbook empty after saving the file.
// Returns:
//   bool  
func (instance *PaginatedSaveOptions) GetClearData()  (bool,  error)  {
	
	CGoReturnPtr := C.PaginatedSaveOptions_GetClearData( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Make the workbook empty after saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PaginatedSaveOptions) SetClearData(value bool)  error {
	
	CGoReturnPtr := C.PaginatedSaveOptions_SetClearData( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// The folder for temporary files that may be used as data cache.
// Returns:
//   string  
func (instance *PaginatedSaveOptions) GetCachedFileFolder()  (string,  error)  {
	
	CGoReturnPtr := C.PaginatedSaveOptions_GetCachedFileFolder( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// The folder for temporary files that may be used as data cache.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *PaginatedSaveOptions) SetCachedFileFolder(value string)  error {
	
	CGoReturnPtr := C.PaginatedSaveOptions_SetCachedFileFolder( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether validate merged cells before saving the file.
// Returns:
//   bool  
func (instance *PaginatedSaveOptions) GetValidateMergedAreas()  (bool,  error)  {
	
	CGoReturnPtr := C.PaginatedSaveOptions_GetValidateMergedAreas( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether validate merged cells before saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PaginatedSaveOptions) SetValidateMergedAreas(value bool)  error {
	
	CGoReturnPtr := C.PaginatedSaveOptions_SetValidateMergedAreas( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether merge the areas of conditional formatting and validation before saving the file.
// Returns:
//   bool  
func (instance *PaginatedSaveOptions) GetMergeAreas()  (bool,  error)  {
	
	CGoReturnPtr := C.PaginatedSaveOptions_GetMergeAreas( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether merge the areas of conditional formatting and validation before saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PaginatedSaveOptions) SetMergeAreas(value bool)  error {
	
	CGoReturnPtr := C.PaginatedSaveOptions_SetMergeAreas( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// If true and the directory does not exist, the directory will be automatically created before saving the file.
// Returns:
//   bool  
func (instance *PaginatedSaveOptions) GetCreateDirectory()  (bool,  error)  {
	
	CGoReturnPtr := C.PaginatedSaveOptions_GetCreateDirectory( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// If true and the directory does not exist, the directory will be automatically created before saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PaginatedSaveOptions) SetCreateDirectory(value bool)  error {
	
	CGoReturnPtr := C.PaginatedSaveOptions_SetCreateDirectory( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether sorting defined names before saving file.
// Returns:
//   bool  
func (instance *PaginatedSaveOptions) GetSortNames()  (bool,  error)  {
	
	CGoReturnPtr := C.PaginatedSaveOptions_GetSortNames( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether sorting defined names before saving file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PaginatedSaveOptions) SetSortNames(value bool)  error {
	
	CGoReturnPtr := C.PaginatedSaveOptions_SetSortNames( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether sorting external defined names before saving file.
// Returns:
//   bool  
func (instance *PaginatedSaveOptions) GetSortExternalNames()  (bool,  error)  {
	
	CGoReturnPtr := C.PaginatedSaveOptions_GetSortExternalNames( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether sorting external defined names before saving file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PaginatedSaveOptions) SetSortExternalNames(value bool)  error {
	
	CGoReturnPtr := C.PaginatedSaveOptions_SetSortExternalNames( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether refreshing chart cache data
// Returns:
//   bool  
func (instance *PaginatedSaveOptions) GetRefreshChartCache()  (bool,  error)  {
	
	CGoReturnPtr := C.PaginatedSaveOptions_GetRefreshChartCache( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether refreshing chart cache data
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PaginatedSaveOptions) SetRefreshChartCache(value bool)  error {
	
	CGoReturnPtr := C.PaginatedSaveOptions_SetRefreshChartCache( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Whether check restriction of excel file when user modify cells related objects.
// For example, excel does not allow inputting string value longer than 32K.
// When you input a value longer than 32K, it will be truncated.
// Returns:
//   bool  
func (instance *PaginatedSaveOptions) GetCheckExcelRestriction()  (bool,  error)  {
	
	CGoReturnPtr := C.PaginatedSaveOptions_GetCheckExcelRestriction( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Whether check restriction of excel file when user modify cells related objects.
// For example, excel does not allow inputting string value longer than 32K.
// When you input a value longer than 32K, it will be truncated.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PaginatedSaveOptions) SetCheckExcelRestriction(value bool)  error {
	
	CGoReturnPtr := C.PaginatedSaveOptions_SetCheckExcelRestriction( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether updating smart art setting.
// The default value is false.
// Returns:
//   bool  
func (instance *PaginatedSaveOptions) GetUpdateSmartArt()  (bool,  error)  {
	
	CGoReturnPtr := C.PaginatedSaveOptions_GetUpdateSmartArt( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether updating smart art setting.
// The default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PaginatedSaveOptions) SetUpdateSmartArt(value bool)  error {
	
	CGoReturnPtr := C.PaginatedSaveOptions_SetUpdateSmartArt( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether encrypt document properties when saving as .xls file.
// The default value is true.
// Returns:
//   bool  
func (instance *PaginatedSaveOptions) GetEncryptDocumentProperties()  (bool,  error)  {
	
	CGoReturnPtr := C.PaginatedSaveOptions_GetEncryptDocumentProperties( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether encrypt document properties when saving as .xls file.
// The default value is true.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PaginatedSaveOptions) SetEncryptDocumentProperties(value bool)  error {
	
	CGoReturnPtr := C.PaginatedSaveOptions_SetEncryptDocumentProperties( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}


func (instance *PaginatedSaveOptions) ToSaveOptions() *SaveOptions {
	parentClass := &SaveOptions{}
	parentClass.ptr = instance.ptr
	return parentClass
}

func DeletePaginatedSaveOptions(paginatedsaveoptions *PaginatedSaveOptions){
	runtime.SetFinalizer(paginatedsaveoptions, nil)
	C.Delete_PaginatedSaveOptions(paginatedsaveoptions.ptr)
	paginatedsaveoptions.ptr = nil
}

// Class PaneCollection 

// Represents all Pane objects shown in the specified window.
type PaneCollection struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *PaneCollection) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.PaneCollection_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the first visible row of the bottom pane.
// Returns:
//   int32  
func (instance *PaneCollection) GetFirstVisibleRowOfBottomPane()  (int32,  error)  {
	
	CGoReturnPtr := C.PaneCollection_GetFirstVisibleRowOfBottomPane( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the first visible row of the bottom pane.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *PaneCollection) SetFirstVisibleRowOfBottomPane(value int32)  error {
	
	CGoReturnPtr := C.PaneCollection_SetFirstVisibleRowOfBottomPane( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the first visible column of the right pane.
// Returns:
//   int32  
func (instance *PaneCollection) GetFirstVisibleColumnOfRightPane()  (int32,  error)  {
	
	CGoReturnPtr := C.PaneCollection_GetFirstVisibleColumnOfRightPane( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the first visible column of the right pane.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *PaneCollection) SetFirstVisibleColumnOfRightPane(value int32)  error {
	
	CGoReturnPtr := C.PaneCollection_SetFirstVisibleColumnOfRightPane( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the active pane.
// Returns:
//   int32  
func (instance *PaneCollection) GetAcitvePaneType()  (RectangleAlignmentType,  error)  {
	
	CGoReturnPtr := C.PaneCollection_GetAcitvePaneType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToRectangleAlignmentType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets and sets the active pane.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *PaneCollection) SetAcitvePaneType(value RectangleAlignmentType)  error {
	
	CGoReturnPtr := C.PaneCollection_SetAcitvePaneType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}



func DeletePaneCollection(panecollection *PaneCollection){
	runtime.SetFinalizer(panecollection, nil)
	C.Delete_PaneCollection(panecollection.ptr)
	panecollection.ptr = nil
}

// Class PasteOptions 

// Represents the paste special options.
type PasteOptions struct {
	ptr unsafe.Pointer
}

// Default constructor.
func NewPasteOptions() ( *PasteOptions, error) {
	pasteoptions := &PasteOptions{}
	CGoReturnPtr := C.New_PasteOptions()
	if CGoReturnPtr.error_no == 0 {
		pasteoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(pasteoptions, DeletePasteOptions)
		return pasteoptions, nil
	} else {
		pasteoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return pasteoptions, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *PasteOptions) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.PasteOptions_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// The paste special type.
// Returns:
//   int32  
func (instance *PasteOptions) GetPasteType()  (PasteType,  error)  {
	
	CGoReturnPtr := C.PasteOptions_GetPasteType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToPasteType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// The paste special type.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *PasteOptions) SetPasteType(value PasteType)  error {
	
	CGoReturnPtr := C.PasteOptions_SetPasteType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether skips blank cells.
// Returns:
//   bool  
func (instance *PasteOptions) GetSkipBlanks()  (bool,  error)  {
	
	CGoReturnPtr := C.PasteOptions_GetSkipBlanks( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether skips blank cells.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PasteOptions) SetSkipBlanks(value bool)  error {
	
	CGoReturnPtr := C.PasteOptions_SetSkipBlanks( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// True means only copying visible cells.
// Returns:
//   bool  
func (instance *PasteOptions) GetOnlyVisibleCells()  (bool,  error)  {
	
	CGoReturnPtr := C.PasteOptions_GetOnlyVisibleCells( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// True means only copying visible cells.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PasteOptions) SetOnlyVisibleCells(value bool)  error {
	
	CGoReturnPtr := C.PasteOptions_SetOnlyVisibleCells( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// True to transpose rows and columns when the range is pasted. The default value is False.
// Returns:
//   bool  
func (instance *PasteOptions) GetTranspose()  (bool,  error)  {
	
	CGoReturnPtr := C.PasteOptions_GetTranspose( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// True to transpose rows and columns when the range is pasted. The default value is False.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PasteOptions) SetTranspose(value bool)  error {
	
	CGoReturnPtr := C.PasteOptions_SetTranspose( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the operation type when pasting range.
// Returns:
//   int32  
func (instance *PasteOptions) GetOperationType()  (PasteOperationType,  error)  {
	
	CGoReturnPtr := C.PasteOptions_GetOperationType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToPasteOperationType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets and sets the operation type when pasting range.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *PasteOptions) SetOperationType(value PasteOperationType)  error {
	
	CGoReturnPtr := C.PasteOptions_SetOperationType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Ingore links to the original file.
// Returns:
//   bool  
func (instance *PasteOptions) GetIgnoreLinksToOriginalFile()  (bool,  error)  {
	
	CGoReturnPtr := C.PasteOptions_GetIgnoreLinksToOriginalFile( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Ingore links to the original file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PasteOptions) SetIgnoreLinksToOriginalFile(value bool)  error {
	
	CGoReturnPtr := C.PasteOptions_SetIgnoreLinksToOriginalFile( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}



func DeletePasteOptions(pasteoptions *PasteOptions){
	runtime.SetFinalizer(pasteoptions, nil)
	C.Delete_PasteOptions(pasteoptions.ptr)
	pasteoptions.ptr = nil
}

// Class PclSaveOptions 

// Represents the options for saving Pcl file.
type PclSaveOptions struct {
	ptr unsafe.Pointer
}

// Creates the options for saving pdf file.
func NewPclSaveOptions() ( *PclSaveOptions, error) {
	pclsaveoptions := &PclSaveOptions{}
	CGoReturnPtr := C.New_PclSaveOptions()
	if CGoReturnPtr.error_no == 0 {
		pclsaveoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(pclsaveoptions, DeletePclSaveOptions)
		return pclsaveoptions, nil
	} else {
		pclsaveoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return pclsaveoptions, err
	}	
}
// Constructs from a parent object.
// Parameters:
//   src - PaginatedSaveOptions 
func NewPclSaveOptions_PaginatedSaveOptions(src *PaginatedSaveOptions) ( *PclSaveOptions, error) {
	pclsaveoptions := &PclSaveOptions{}
	var src_ptr unsafe.Pointer = nil
	if src != nil {
	  src_ptr =src.ptr
	}

	CGoReturnPtr := C.New_PclSaveOptions_PaginatedSaveOptions(src_ptr)
	if CGoReturnPtr.error_no == 0 {
		pclsaveoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(pclsaveoptions, DeletePclSaveOptions)
		return pclsaveoptions, nil
	} else {
		pclsaveoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return pclsaveoptions, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *PclSaveOptions) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.PclSaveOptions_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether to embed font into the output Pcl file.
// Returns:
//   bool  
func (instance *PclSaveOptions) GetEmbedFont()  (bool,  error)  {
	
	CGoReturnPtr := C.PclSaveOptions_GetEmbedFont( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether to embed font into the output Pcl file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PclSaveOptions) SetEmbedFont(value bool)  error {
	
	CGoReturnPtr := C.PclSaveOptions_SetEmbedFont( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Adds information about font that is already added to the printer by manufacturer.
// Parameters:
//   fontFullName - string 
//   fontPclName - string 
// Returns:
//   void  
func (instance *PclSaveOptions) AddPrinterFont(fontfullname string, fontpclname string)  error {
	
	CGoReturnPtr := C.PclSaveOptions_AddPrinterFont( instance.ptr, C.CString(fontfullname), C.CString(fontpclname))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// When characters in the Excel are Unicode and not be set with correct font in cell style,
// They may appear as block in pdf,image.
// Set the DefaultFont such as MingLiu or MS Gothic to show these characters.
// If this property is not set, Aspose.Cells will use system default font to show these unicode characters.
// Returns:
//   string  
func (instance *PclSaveOptions) GetDefaultFont()  (string,  error)  {
	
	CGoReturnPtr := C.PclSaveOptions_GetDefaultFont( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// When characters in the Excel are Unicode and not be set with correct font in cell style,
// They may appear as block in pdf,image.
// Set the DefaultFont such as MingLiu or MS Gothic to show these characters.
// If this property is not set, Aspose.Cells will use system default font to show these unicode characters.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *PclSaveOptions) SetDefaultFont(value string)  error {
	
	CGoReturnPtr := C.PclSaveOptions_SetDefaultFont( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// When characters in the Excel are Unicode and not be set with correct font in cell style,
// They may appear as block in pdf,image.
// Set this to true to try to use workbook's default font to show these characters first.
// Returns:
//   bool  
func (instance *PclSaveOptions) GetCheckWorkbookDefaultFont()  (bool,  error)  {
	
	CGoReturnPtr := C.PclSaveOptions_GetCheckWorkbookDefaultFont( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// When characters in the Excel are Unicode and not be set with correct font in cell style,
// They may appear as block in pdf,image.
// Set this to true to try to use workbook's default font to show these characters first.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PclSaveOptions) SetCheckWorkbookDefaultFont(value bool)  error {
	
	CGoReturnPtr := C.PclSaveOptions_SetCheckWorkbookDefaultFont( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether to check font compatibility for every character in text.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PclSaveOptions) SetCheckFontCompatibility(value bool)  error {
	
	CGoReturnPtr := C.PclSaveOptions_SetCheckFontCompatibility( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether to check font compatibility for every character in text.
// Returns:
//   bool  
func (instance *PclSaveOptions) GetCheckFontCompatibility()  (bool,  error)  {
	
	CGoReturnPtr := C.PclSaveOptions_GetCheckFontCompatibility( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether to only substitute the font of character when the cell font is not compatibility for it.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PclSaveOptions) SetIsFontSubstitutionCharGranularity(value bool)  error {
	
	CGoReturnPtr := C.PclSaveOptions_SetIsFontSubstitutionCharGranularity( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether to only substitute the font of character when the cell font is not compatibility for it.
// Returns:
//   bool  
func (instance *PclSaveOptions) IsFontSubstitutionCharGranularity()  (bool,  error)  {
	
	CGoReturnPtr := C.PclSaveOptions_IsFontSubstitutionCharGranularity( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// If OnePagePerSheet is true , all content of one sheet will output to only one page in result.
// The paper size of pagesetup will be invalid, and the other settings of pagesetup
// will still take effect.
// Returns:
//   bool  
func (instance *PclSaveOptions) GetOnePagePerSheet()  (bool,  error)  {
	
	CGoReturnPtr := C.PclSaveOptions_GetOnePagePerSheet( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// If OnePagePerSheet is true , all content of one sheet will output to only one page in result.
// The paper size of pagesetup will be invalid, and the other settings of pagesetup
// will still take effect.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PclSaveOptions) SetOnePagePerSheet(value bool)  error {
	
	CGoReturnPtr := C.PclSaveOptions_SetOnePagePerSheet( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// If AllColumnsInOnePagePerSheet is true , all column content of one sheet will output to only one page in result.
// The width of paper size of pagesetup will be ignored, and the other settings of pagesetup
// will still take effect.
// Returns:
//   bool  
func (instance *PclSaveOptions) GetAllColumnsInOnePagePerSheet()  (bool,  error)  {
	
	CGoReturnPtr := C.PclSaveOptions_GetAllColumnsInOnePagePerSheet( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// If AllColumnsInOnePagePerSheet is true , all column content of one sheet will output to only one page in result.
// The width of paper size of pagesetup will be ignored, and the other settings of pagesetup
// will still take effect.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PclSaveOptions) SetAllColumnsInOnePagePerSheet(value bool)  error {
	
	CGoReturnPtr := C.PclSaveOptions_SetAllColumnsInOnePagePerSheet( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates if you need to hide the error while rendering.
// The error can be error in shape, image, chart rendering, etc.
// Returns:
//   bool  
func (instance *PclSaveOptions) GetIgnoreError()  (bool,  error)  {
	
	CGoReturnPtr := C.PclSaveOptions_GetIgnoreError( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates if you need to hide the error while rendering.
// The error can be error in shape, image, chart rendering, etc.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PclSaveOptions) SetIgnoreError(value bool)  error {
	
	CGoReturnPtr := C.PclSaveOptions_SetIgnoreError( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether to output a blank page when there is nothing to print.
// Returns:
//   bool  
func (instance *PclSaveOptions) GetOutputBlankPageWhenNothingToPrint()  (bool,  error)  {
	
	CGoReturnPtr := C.PclSaveOptions_GetOutputBlankPageWhenNothingToPrint( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether to output a blank page when there is nothing to print.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PclSaveOptions) SetOutputBlankPageWhenNothingToPrint(value bool)  error {
	
	CGoReturnPtr := C.PclSaveOptions_SetOutputBlankPageWhenNothingToPrint( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the 0-based index of the first page to save.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *PclSaveOptions) SetPageIndex(value int32)  error {
	
	CGoReturnPtr := C.PclSaveOptions_SetPageIndex( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the 0-based index of the first page to save.
// Returns:
//   int32  
func (instance *PclSaveOptions) GetPageIndex()  (int32,  error)  {
	
	CGoReturnPtr := C.PclSaveOptions_GetPageIndex( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets the number of pages to save.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *PclSaveOptions) SetPageCount(value int32)  error {
	
	CGoReturnPtr := C.PclSaveOptions_SetPageCount( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the number of pages to save.
// Returns:
//   int32  
func (instance *PclSaveOptions) GetPageCount()  (int32,  error)  {
	
	CGoReturnPtr := C.PclSaveOptions_GetPageCount( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates which pages will not be printed.
// Returns:
//   int32  
func (instance *PclSaveOptions) GetPrintingPageType()  (PrintingPageType,  error)  {
	
	CGoReturnPtr := C.PclSaveOptions_GetPrintingPageType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToPrintingPageType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Indicates which pages will not be printed.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *PclSaveOptions) SetPrintingPageType(value PrintingPageType)  error {
	
	CGoReturnPtr := C.PclSaveOptions_SetPrintingPageType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets gridline type.
// Returns:
//   int32  
func (instance *PclSaveOptions) GetGridlineType()  (GridlineType,  error)  {
	
	CGoReturnPtr := C.PclSaveOptions_GetGridlineType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToGridlineType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets or sets gridline type.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *PclSaveOptions) SetGridlineType(value GridlineType)  error {
	
	CGoReturnPtr := C.PclSaveOptions_SetGridlineType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets gridline color.
// Returns:
//   Color  
func (instance *PclSaveOptions) GetGridlineColor()  (*Color,  error)  {
	
	CGoReturnPtr := C.PclSaveOptions_GetGridlineColor( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Gets or sets gridline color.
// Parameters:
//   value - Color 
// Returns:
//   void  
func (instance *PclSaveOptions) SetGridlineColor(value *Color)  error {
	
	CGoReturnPtr := C.PclSaveOptions_SetGridlineColor( instance.ptr, value.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets displaying text type when the text width is larger than cell width.
// Returns:
//   int32  
func (instance *PclSaveOptions) GetTextCrossType()  (TextCrossType,  error)  {
	
	CGoReturnPtr := C.PclSaveOptions_GetTextCrossType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToTextCrossType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets or sets displaying text type when the text width is larger than cell width.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *PclSaveOptions) SetTextCrossType(value TextCrossType)  error {
	
	CGoReturnPtr := C.PclSaveOptions_SetTextCrossType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets default edit language.
// Returns:
//   int32  
func (instance *PclSaveOptions) GetDefaultEditLanguage()  (DefaultEditLanguage,  error)  {
	
	CGoReturnPtr := C.PclSaveOptions_GetDefaultEditLanguage( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToDefaultEditLanguage(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets or sets default edit language.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *PclSaveOptions) SetDefaultEditLanguage(value DefaultEditLanguage)  error {
	
	CGoReturnPtr := C.PclSaveOptions_SetDefaultEditLanguage( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the sheets to render. Default is all visible sheets in the workbook: <see cref="Aspose.Cells.Rendering.SheetSet.Visible"/>.
// Returns:
//   SheetSet  
func (instance *PclSaveOptions) GetSheetSet()  (*SheetSet,  error)  {
	
	CGoReturnPtr := C.PclSaveOptions_GetSheetSet( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &SheetSet{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteSheetSet) 

	return result, nil 
}
// Gets or sets the sheets to render. Default is all visible sheets in the workbook: <see cref="Aspose.Cells.Rendering.SheetSet.Visible"/>.
// Parameters:
//   value - SheetSet 
// Returns:
//   void  
func (instance *PclSaveOptions) SetSheetSet(value *SheetSet)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.PclSaveOptions_SetSheetSet( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Implements this interface to get DrawObject and Bound when rendering.
// Returns:
//   DrawObjectEventHandler  
func (instance *PclSaveOptions) GetDrawObjectEventHandler()  (*DrawObjectEventHandler,  error)  {
	
	CGoReturnPtr := C.PclSaveOptions_GetDrawObjectEventHandler( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &DrawObjectEventHandler{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteDrawObjectEventHandler) 

	return result, nil 
}
// Implements this interface to get DrawObject and Bound when rendering.
// Parameters:
//   value - DrawObjectEventHandler 
// Returns:
//   void  
func (instance *PclSaveOptions) SetDrawObjectEventHandler(value *DrawObjectEventHandler)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.PclSaveOptions_SetDrawObjectEventHandler( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Setting for rendering Emf metafile.
// Returns:
//   int32  
func (instance *PclSaveOptions) GetEmfRenderSetting()  (EmfRenderSetting,  error)  {
	
	CGoReturnPtr := C.PclSaveOptions_GetEmfRenderSetting( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToEmfRenderSetting(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Setting for rendering Emf metafile.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *PclSaveOptions) SetEmfRenderSetting(value EmfRenderSetting)  error {
	
	CGoReturnPtr := C.PclSaveOptions_SetEmfRenderSetting( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets custom settings during rendering.
// Returns:
//   CustomRenderSettings  
func (instance *PclSaveOptions) GetCustomRenderSettings()  (*CustomRenderSettings,  error)  {
	
	CGoReturnPtr := C.PclSaveOptions_GetCustomRenderSettings( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &CustomRenderSettings{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteCustomRenderSettings) 

	return result, nil 
}
// Gets or sets custom settings during rendering.
// Parameters:
//   value - CustomRenderSettings 
// Returns:
//   void  
func (instance *PclSaveOptions) SetCustomRenderSettings(value *CustomRenderSettings)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.PclSaveOptions_SetCustomRenderSettings( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the save file format.
// Returns:
//   int32  
func (instance *PclSaveOptions) GetSaveFormat()  (SaveFormat,  error)  {
	
	CGoReturnPtr := C.PclSaveOptions_GetSaveFormat( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToSaveFormat(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Make the workbook empty after saving the file.
// Returns:
//   bool  
func (instance *PclSaveOptions) GetClearData()  (bool,  error)  {
	
	CGoReturnPtr := C.PclSaveOptions_GetClearData( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Make the workbook empty after saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PclSaveOptions) SetClearData(value bool)  error {
	
	CGoReturnPtr := C.PclSaveOptions_SetClearData( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// The folder for temporary files that may be used as data cache.
// Returns:
//   string  
func (instance *PclSaveOptions) GetCachedFileFolder()  (string,  error)  {
	
	CGoReturnPtr := C.PclSaveOptions_GetCachedFileFolder( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// The folder for temporary files that may be used as data cache.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *PclSaveOptions) SetCachedFileFolder(value string)  error {
	
	CGoReturnPtr := C.PclSaveOptions_SetCachedFileFolder( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether validate merged cells before saving the file.
// Returns:
//   bool  
func (instance *PclSaveOptions) GetValidateMergedAreas()  (bool,  error)  {
	
	CGoReturnPtr := C.PclSaveOptions_GetValidateMergedAreas( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether validate merged cells before saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PclSaveOptions) SetValidateMergedAreas(value bool)  error {
	
	CGoReturnPtr := C.PclSaveOptions_SetValidateMergedAreas( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether merge the areas of conditional formatting and validation before saving the file.
// Returns:
//   bool  
func (instance *PclSaveOptions) GetMergeAreas()  (bool,  error)  {
	
	CGoReturnPtr := C.PclSaveOptions_GetMergeAreas( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether merge the areas of conditional formatting and validation before saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PclSaveOptions) SetMergeAreas(value bool)  error {
	
	CGoReturnPtr := C.PclSaveOptions_SetMergeAreas( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// If true and the directory does not exist, the directory will be automatically created before saving the file.
// Returns:
//   bool  
func (instance *PclSaveOptions) GetCreateDirectory()  (bool,  error)  {
	
	CGoReturnPtr := C.PclSaveOptions_GetCreateDirectory( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// If true and the directory does not exist, the directory will be automatically created before saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PclSaveOptions) SetCreateDirectory(value bool)  error {
	
	CGoReturnPtr := C.PclSaveOptions_SetCreateDirectory( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether sorting defined names before saving file.
// Returns:
//   bool  
func (instance *PclSaveOptions) GetSortNames()  (bool,  error)  {
	
	CGoReturnPtr := C.PclSaveOptions_GetSortNames( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether sorting defined names before saving file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PclSaveOptions) SetSortNames(value bool)  error {
	
	CGoReturnPtr := C.PclSaveOptions_SetSortNames( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether sorting external defined names before saving file.
// Returns:
//   bool  
func (instance *PclSaveOptions) GetSortExternalNames()  (bool,  error)  {
	
	CGoReturnPtr := C.PclSaveOptions_GetSortExternalNames( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether sorting external defined names before saving file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PclSaveOptions) SetSortExternalNames(value bool)  error {
	
	CGoReturnPtr := C.PclSaveOptions_SetSortExternalNames( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether refreshing chart cache data
// Returns:
//   bool  
func (instance *PclSaveOptions) GetRefreshChartCache()  (bool,  error)  {
	
	CGoReturnPtr := C.PclSaveOptions_GetRefreshChartCache( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether refreshing chart cache data
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PclSaveOptions) SetRefreshChartCache(value bool)  error {
	
	CGoReturnPtr := C.PclSaveOptions_SetRefreshChartCache( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Whether check restriction of excel file when user modify cells related objects.
// For example, excel does not allow inputting string value longer than 32K.
// When you input a value longer than 32K, it will be truncated.
// Returns:
//   bool  
func (instance *PclSaveOptions) GetCheckExcelRestriction()  (bool,  error)  {
	
	CGoReturnPtr := C.PclSaveOptions_GetCheckExcelRestriction( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Whether check restriction of excel file when user modify cells related objects.
// For example, excel does not allow inputting string value longer than 32K.
// When you input a value longer than 32K, it will be truncated.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PclSaveOptions) SetCheckExcelRestriction(value bool)  error {
	
	CGoReturnPtr := C.PclSaveOptions_SetCheckExcelRestriction( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether updating smart art setting.
// The default value is false.
// Returns:
//   bool  
func (instance *PclSaveOptions) GetUpdateSmartArt()  (bool,  error)  {
	
	CGoReturnPtr := C.PclSaveOptions_GetUpdateSmartArt( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether updating smart art setting.
// The default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PclSaveOptions) SetUpdateSmartArt(value bool)  error {
	
	CGoReturnPtr := C.PclSaveOptions_SetUpdateSmartArt( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether encrypt document properties when saving as .xls file.
// The default value is true.
// Returns:
//   bool  
func (instance *PclSaveOptions) GetEncryptDocumentProperties()  (bool,  error)  {
	
	CGoReturnPtr := C.PclSaveOptions_GetEncryptDocumentProperties( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether encrypt document properties when saving as .xls file.
// The default value is true.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PclSaveOptions) SetEncryptDocumentProperties(value bool)  error {
	
	CGoReturnPtr := C.PclSaveOptions_SetEncryptDocumentProperties( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}


func (instance *PclSaveOptions) ToPaginatedSaveOptions() *PaginatedSaveOptions {
	parentClass := &PaginatedSaveOptions{}
	parentClass.ptr = instance.ptr
	return parentClass
}
func (instance *PclSaveOptions) ToSaveOptions() *SaveOptions {
	parentClass := &SaveOptions{}
	parentClass.ptr = instance.ptr
	return parentClass
}

func DeletePclSaveOptions(pclsaveoptions *PclSaveOptions){
	runtime.SetFinalizer(pclsaveoptions, nil)
	C.Delete_PclSaveOptions(pclsaveoptions.ptr)
	pclsaveoptions.ptr = nil
}

// Class PdfSaveOptions 

// Represents the options for saving pdf file.
type PdfSaveOptions struct {
	ptr unsafe.Pointer
}

// Creates the options for saving pdf file.
func NewPdfSaveOptions() ( *PdfSaveOptions, error) {
	pdfsaveoptions := &PdfSaveOptions{}
	CGoReturnPtr := C.New_PdfSaveOptions()
	if CGoReturnPtr.error_no == 0 {
		pdfsaveoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(pdfsaveoptions, DeletePdfSaveOptions)
		return pdfsaveoptions, nil
	} else {
		pdfsaveoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return pdfsaveoptions, err
	}	
}
// Constructs from a parent object.
// Parameters:
//   src - PaginatedSaveOptions 
func NewPdfSaveOptions_PaginatedSaveOptions(src *PaginatedSaveOptions) ( *PdfSaveOptions, error) {
	pdfsaveoptions := &PdfSaveOptions{}
	var src_ptr unsafe.Pointer = nil
	if src != nil {
	  src_ptr =src.ptr
	}

	CGoReturnPtr := C.New_PdfSaveOptions_PaginatedSaveOptions(src_ptr)
	if CGoReturnPtr.error_no == 0 {
		pdfsaveoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(pdfsaveoptions, DeletePdfSaveOptions)
		return pdfsaveoptions, nil
	} else {
		pdfsaveoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return pdfsaveoptions, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *PdfSaveOptions) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.PdfSaveOptions_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// True to embed true type fonts.
// Affects only ASCII characters 32-127.
// Fonts for character codes greater than 127 are always embedded.
// Fonts are always embedded for PDF/A-1a, PDF/A-1b standard.
// Default is true.
// Returns:
//   bool  
func (instance *PdfSaveOptions) GetEmbedStandardWindowsFonts()  (bool,  error)  {
	
	CGoReturnPtr := C.PdfSaveOptions_GetEmbedStandardWindowsFonts( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// True to embed true type fonts.
// Affects only ASCII characters 32-127.
// Fonts for character codes greater than 127 are always embedded.
// Fonts are always embedded for PDF/A-1a, PDF/A-1b standard.
// Default is true.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PdfSaveOptions) SetEmbedStandardWindowsFonts(value bool)  error {
	
	CGoReturnPtr := C.PdfSaveOptions_SetEmbedStandardWindowsFonts( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the <see cref ="PdfBookmarkEntry">PdfBookmarkEntry</see> object.
// Returns:
//   PdfBookmarkEntry  
func (instance *PdfSaveOptions) GetBookmark()  (*PdfBookmarkEntry,  error)  {
	
	CGoReturnPtr := C.PdfSaveOptions_GetBookmark( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &PdfBookmarkEntry{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeletePdfBookmarkEntry) 

	return result, nil 
}
// Gets and sets the <see cref ="PdfBookmarkEntry">PdfBookmarkEntry</see> object.
// Parameters:
//   value - PdfBookmarkEntry 
// Returns:
//   void  
func (instance *PdfSaveOptions) SetBookmark(value *PdfBookmarkEntry)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.PdfSaveOptions_SetBookmark( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the PDF standards compliance level for output documents.
// Returns:
//   int32  
func (instance *PdfSaveOptions) GetCompliance()  (PdfCompliance,  error)  {
	
	CGoReturnPtr := C.PdfSaveOptions_GetCompliance( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToPdfCompliance(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets or sets the PDF standards compliance level for output documents.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *PdfSaveOptions) SetCompliance(value PdfCompliance)  error {
	
	CGoReturnPtr := C.PdfSaveOptions_SetCompliance( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Set this options, when security is need in xls2pdf result.
// Returns:
//   PdfSecurityOptions  
func (instance *PdfSaveOptions) GetSecurityOptions()  (*PdfSecurityOptions,  error)  {
	
	CGoReturnPtr := C.PdfSaveOptions_GetSecurityOptions( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &PdfSecurityOptions{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeletePdfSecurityOptions) 

	return result, nil 
}
// Set this options, when security is need in xls2pdf result.
// Parameters:
//   value - PdfSecurityOptions 
// Returns:
//   void  
func (instance *PdfSaveOptions) SetSecurityOptions(value *PdfSecurityOptions)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.PdfSaveOptions_SetSecurityOptions( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether to calculate formulas before saving pdf file.
// Returns:
//   bool  
func (instance *PdfSaveOptions) GetCalculateFormula()  (bool,  error)  {
	
	CGoReturnPtr := C.PdfSaveOptions_GetCalculateFormula( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether to calculate formulas before saving pdf file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PdfSaveOptions) SetCalculateFormula(value bool)  error {
	
	CGoReturnPtr := C.PdfSaveOptions_SetCalculateFormula( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicate the compression algorithm
// Returns:
//   int32  
func (instance *PdfSaveOptions) GetPdfCompression()  (PdfCompressionCore,  error)  {
	
	CGoReturnPtr := C.PdfSaveOptions_GetPdfCompression( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToPdfCompressionCore(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Indicate the compression algorithm
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *PdfSaveOptions) SetPdfCompression(value PdfCompressionCore)  error {
	
	CGoReturnPtr := C.PdfSaveOptions_SetPdfCompression( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Sets desired PPI(pixels per inch) of resample images and jpeg quality.
// All images will be converted to JPEG with the specified quality setting,
// and images that are greater than the specified PPI (pixels per inch) will be resampled.
// Parameters:
//   desiredPPI - int32 
//   jpegQuality - int32 
// Returns:
//   void  
func (instance *PdfSaveOptions) SetImageResample(desiredppi int32, jpegquality int32)  error {
	
	CGoReturnPtr := C.PdfSaveOptions_SetImageResample( instance.ptr, C.int(desiredppi), C.int(jpegquality))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the time of generating the pdf document.
// Returns:
//   Date  
func (instance *PdfSaveOptions) GetCreatedTime()  (time.Time,  error)  {
	
	CGoReturnPtr := C.PdfSaveOptions_GetCreatedTime( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  time.Unix(0, 0), err
	}
	result := time.Date(int( C.Date_Get_year(CGoReturnPtr.return_value).return_value ),time.Month(int( C.Date_Get_month(CGoReturnPtr.return_value).return_value)),int( C.Date_Get_day(CGoReturnPtr.return_value).return_value),int(  C.Date_Get_hour(CGoReturnPtr.return_value).return_value),int( C.Date_Get_minute(CGoReturnPtr.return_value).return_value),int(  C.Date_Get_second(CGoReturnPtr.return_value).return_value), 0, time.UTC) 

	return result, nil 
}
// Gets and sets the time of generating the pdf document.
// Parameters:
//   value - Date 
// Returns:
//   void  
func (instance *PdfSaveOptions) SetCreatedTime(value time.Time)  error {
	
	time_value := C.Get_Date( C.int(value.Year()), C.int(value.Month()) , C.int(value.Day()) , C.int(value.Hour()) , C.int(value.Minute()) , C.int(value.Second())  )

	CGoReturnPtr := C.PdfSaveOptions_SetCreatedTime( instance.ptr, time_value)
	C.Delete_GetDate( time_value)

	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets producer of generated pdf document.
// Returns:
//   string  
func (instance *PdfSaveOptions) GetProducer()  (string,  error)  {
	
	CGoReturnPtr := C.PdfSaveOptions_GetProducer( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets producer of generated pdf document.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *PdfSaveOptions) SetProducer(value string)  error {
	
	CGoReturnPtr := C.PdfSaveOptions_SetProducer( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets pdf optimization type.
// Returns:
//   int32  
func (instance *PdfSaveOptions) GetOptimizationType()  (PdfOptimizationType,  error)  {
	
	CGoReturnPtr := C.PdfSaveOptions_GetOptimizationType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToPdfOptimizationType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets and sets pdf optimization type.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *PdfSaveOptions) SetOptimizationType(value PdfOptimizationType)  error {
	
	CGoReturnPtr := C.PdfSaveOptions_SetOptimizationType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets a value determining the way <see cref="CustomDocumentPropertyCollection"/> are exported to PDF file. Default value is None.
// Returns:
//   int32  
func (instance *PdfSaveOptions) GetCustomPropertiesExport()  (PdfCustomPropertiesExport,  error)  {
	
	CGoReturnPtr := C.PdfSaveOptions_GetCustomPropertiesExport( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToPdfCustomPropertiesExport(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets or sets a value determining the way <see cref="CustomDocumentPropertyCollection"/> are exported to PDF file. Default value is None.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *PdfSaveOptions) SetCustomPropertiesExport(value PdfCustomPropertiesExport)  error {
	
	CGoReturnPtr := C.PdfSaveOptions_SetCustomPropertiesExport( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether to export document structure.
// Returns:
//   bool  
func (instance *PdfSaveOptions) GetExportDocumentStructure()  (bool,  error)  {
	
	CGoReturnPtr := C.PdfSaveOptions_GetExportDocumentStructure( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether to export document structure.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PdfSaveOptions) SetExportDocumentStructure(value bool)  error {
	
	CGoReturnPtr := C.PdfSaveOptions_SetExportDocumentStructure( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether the window's title bar should display the document title.
// Returns:
//   bool  
func (instance *PdfSaveOptions) GetDisplayDocTitle()  (bool,  error)  {
	
	CGoReturnPtr := C.PdfSaveOptions_GetDisplayDocTitle( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether the window's title bar should display the document title.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PdfSaveOptions) SetDisplayDocTitle(value bool)  error {
	
	CGoReturnPtr := C.PdfSaveOptions_SetDisplayDocTitle( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets embedded font encoding in pdf.
// Returns:
//   int32  
func (instance *PdfSaveOptions) GetFontEncoding()  (PdfFontEncoding,  error)  {
	
	CGoReturnPtr := C.PdfSaveOptions_GetFontEncoding( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToPdfFontEncoding(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets or sets embedded font encoding in pdf.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *PdfSaveOptions) SetFontEncoding(value PdfFontEncoding)  error {
	
	CGoReturnPtr := C.PdfSaveOptions_SetFontEncoding( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets watermark to output.
// Returns:
//   RenderingWatermark  
func (instance *PdfSaveOptions) GetWatermark()  (*RenderingWatermark,  error)  {
	
	CGoReturnPtr := C.PdfSaveOptions_GetWatermark( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &RenderingWatermark{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteRenderingWatermark) 

	return result, nil 
}
// Gets or sets watermark to output.
// Parameters:
//   value - RenderingWatermark 
// Returns:
//   void  
func (instance *PdfSaveOptions) SetWatermark(value *RenderingWatermark)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.PdfSaveOptions_SetWatermark( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether to embed attachment for Ole objects in Excel.
// Returns:
//   bool  
func (instance *PdfSaveOptions) GetEmbedAttachments()  (bool,  error)  {
	
	CGoReturnPtr := C.PdfSaveOptions_GetEmbedAttachments( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether to embed attachment for Ole objects in Excel.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PdfSaveOptions) SetEmbedAttachments(value bool)  error {
	
	CGoReturnPtr := C.PdfSaveOptions_SetEmbedAttachments( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// When characters in the Excel are Unicode and not be set with correct font in cell style,
// They may appear as block in pdf,image.
// Set the DefaultFont such as MingLiu or MS Gothic to show these characters.
// If this property is not set, Aspose.Cells will use system default font to show these unicode characters.
// Returns:
//   string  
func (instance *PdfSaveOptions) GetDefaultFont()  (string,  error)  {
	
	CGoReturnPtr := C.PdfSaveOptions_GetDefaultFont( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// When characters in the Excel are Unicode and not be set with correct font in cell style,
// They may appear as block in pdf,image.
// Set the DefaultFont such as MingLiu or MS Gothic to show these characters.
// If this property is not set, Aspose.Cells will use system default font to show these unicode characters.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *PdfSaveOptions) SetDefaultFont(value string)  error {
	
	CGoReturnPtr := C.PdfSaveOptions_SetDefaultFont( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// When characters in the Excel are Unicode and not be set with correct font in cell style,
// They may appear as block in pdf,image.
// Set this to true to try to use workbook's default font to show these characters first.
// Returns:
//   bool  
func (instance *PdfSaveOptions) GetCheckWorkbookDefaultFont()  (bool,  error)  {
	
	CGoReturnPtr := C.PdfSaveOptions_GetCheckWorkbookDefaultFont( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// When characters in the Excel are Unicode and not be set with correct font in cell style,
// They may appear as block in pdf,image.
// Set this to true to try to use workbook's default font to show these characters first.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PdfSaveOptions) SetCheckWorkbookDefaultFont(value bool)  error {
	
	CGoReturnPtr := C.PdfSaveOptions_SetCheckWorkbookDefaultFont( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether to check font compatibility for every character in text.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PdfSaveOptions) SetCheckFontCompatibility(value bool)  error {
	
	CGoReturnPtr := C.PdfSaveOptions_SetCheckFontCompatibility( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether to check font compatibility for every character in text.
// Returns:
//   bool  
func (instance *PdfSaveOptions) GetCheckFontCompatibility()  (bool,  error)  {
	
	CGoReturnPtr := C.PdfSaveOptions_GetCheckFontCompatibility( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether to only substitute the font of character when the cell font is not compatibility for it.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PdfSaveOptions) SetIsFontSubstitutionCharGranularity(value bool)  error {
	
	CGoReturnPtr := C.PdfSaveOptions_SetIsFontSubstitutionCharGranularity( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether to only substitute the font of character when the cell font is not compatibility for it.
// Returns:
//   bool  
func (instance *PdfSaveOptions) IsFontSubstitutionCharGranularity()  (bool,  error)  {
	
	CGoReturnPtr := C.PdfSaveOptions_IsFontSubstitutionCharGranularity( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// If OnePagePerSheet is true , all content of one sheet will output to only one page in result.
// The paper size of pagesetup will be invalid, and the other settings of pagesetup
// will still take effect.
// Returns:
//   bool  
func (instance *PdfSaveOptions) GetOnePagePerSheet()  (bool,  error)  {
	
	CGoReturnPtr := C.PdfSaveOptions_GetOnePagePerSheet( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// If OnePagePerSheet is true , all content of one sheet will output to only one page in result.
// The paper size of pagesetup will be invalid, and the other settings of pagesetup
// will still take effect.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PdfSaveOptions) SetOnePagePerSheet(value bool)  error {
	
	CGoReturnPtr := C.PdfSaveOptions_SetOnePagePerSheet( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// If AllColumnsInOnePagePerSheet is true , all column content of one sheet will output to only one page in result.
// The width of paper size of pagesetup will be ignored, and the other settings of pagesetup
// will still take effect.
// Returns:
//   bool  
func (instance *PdfSaveOptions) GetAllColumnsInOnePagePerSheet()  (bool,  error)  {
	
	CGoReturnPtr := C.PdfSaveOptions_GetAllColumnsInOnePagePerSheet( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// If AllColumnsInOnePagePerSheet is true , all column content of one sheet will output to only one page in result.
// The width of paper size of pagesetup will be ignored, and the other settings of pagesetup
// will still take effect.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PdfSaveOptions) SetAllColumnsInOnePagePerSheet(value bool)  error {
	
	CGoReturnPtr := C.PdfSaveOptions_SetAllColumnsInOnePagePerSheet( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates if you need to hide the error while rendering.
// The error can be error in shape, image, chart rendering, etc.
// Returns:
//   bool  
func (instance *PdfSaveOptions) GetIgnoreError()  (bool,  error)  {
	
	CGoReturnPtr := C.PdfSaveOptions_GetIgnoreError( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates if you need to hide the error while rendering.
// The error can be error in shape, image, chart rendering, etc.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PdfSaveOptions) SetIgnoreError(value bool)  error {
	
	CGoReturnPtr := C.PdfSaveOptions_SetIgnoreError( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether to output a blank page when there is nothing to print.
// Returns:
//   bool  
func (instance *PdfSaveOptions) GetOutputBlankPageWhenNothingToPrint()  (bool,  error)  {
	
	CGoReturnPtr := C.PdfSaveOptions_GetOutputBlankPageWhenNothingToPrint( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether to output a blank page when there is nothing to print.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PdfSaveOptions) SetOutputBlankPageWhenNothingToPrint(value bool)  error {
	
	CGoReturnPtr := C.PdfSaveOptions_SetOutputBlankPageWhenNothingToPrint( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the 0-based index of the first page to save.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *PdfSaveOptions) SetPageIndex(value int32)  error {
	
	CGoReturnPtr := C.PdfSaveOptions_SetPageIndex( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the 0-based index of the first page to save.
// Returns:
//   int32  
func (instance *PdfSaveOptions) GetPageIndex()  (int32,  error)  {
	
	CGoReturnPtr := C.PdfSaveOptions_GetPageIndex( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets the number of pages to save.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *PdfSaveOptions) SetPageCount(value int32)  error {
	
	CGoReturnPtr := C.PdfSaveOptions_SetPageCount( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the number of pages to save.
// Returns:
//   int32  
func (instance *PdfSaveOptions) GetPageCount()  (int32,  error)  {
	
	CGoReturnPtr := C.PdfSaveOptions_GetPageCount( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates which pages will not be printed.
// Returns:
//   int32  
func (instance *PdfSaveOptions) GetPrintingPageType()  (PrintingPageType,  error)  {
	
	CGoReturnPtr := C.PdfSaveOptions_GetPrintingPageType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToPrintingPageType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Indicates which pages will not be printed.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *PdfSaveOptions) SetPrintingPageType(value PrintingPageType)  error {
	
	CGoReturnPtr := C.PdfSaveOptions_SetPrintingPageType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets gridline type.
// Returns:
//   int32  
func (instance *PdfSaveOptions) GetGridlineType()  (GridlineType,  error)  {
	
	CGoReturnPtr := C.PdfSaveOptions_GetGridlineType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToGridlineType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets or sets gridline type.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *PdfSaveOptions) SetGridlineType(value GridlineType)  error {
	
	CGoReturnPtr := C.PdfSaveOptions_SetGridlineType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets gridline color.
// Returns:
//   Color  
func (instance *PdfSaveOptions) GetGridlineColor()  (*Color,  error)  {
	
	CGoReturnPtr := C.PdfSaveOptions_GetGridlineColor( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Gets or sets gridline color.
// Parameters:
//   value - Color 
// Returns:
//   void  
func (instance *PdfSaveOptions) SetGridlineColor(value *Color)  error {
	
	CGoReturnPtr := C.PdfSaveOptions_SetGridlineColor( instance.ptr, value.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets displaying text type when the text width is larger than cell width.
// Returns:
//   int32  
func (instance *PdfSaveOptions) GetTextCrossType()  (TextCrossType,  error)  {
	
	CGoReturnPtr := C.PdfSaveOptions_GetTextCrossType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToTextCrossType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets or sets displaying text type when the text width is larger than cell width.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *PdfSaveOptions) SetTextCrossType(value TextCrossType)  error {
	
	CGoReturnPtr := C.PdfSaveOptions_SetTextCrossType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets default edit language.
// Returns:
//   int32  
func (instance *PdfSaveOptions) GetDefaultEditLanguage()  (DefaultEditLanguage,  error)  {
	
	CGoReturnPtr := C.PdfSaveOptions_GetDefaultEditLanguage( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToDefaultEditLanguage(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets or sets default edit language.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *PdfSaveOptions) SetDefaultEditLanguage(value DefaultEditLanguage)  error {
	
	CGoReturnPtr := C.PdfSaveOptions_SetDefaultEditLanguage( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the sheets to render. Default is all visible sheets in the workbook: <see cref="Aspose.Cells.Rendering.SheetSet.Visible"/>.
// Returns:
//   SheetSet  
func (instance *PdfSaveOptions) GetSheetSet()  (*SheetSet,  error)  {
	
	CGoReturnPtr := C.PdfSaveOptions_GetSheetSet( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &SheetSet{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteSheetSet) 

	return result, nil 
}
// Gets or sets the sheets to render. Default is all visible sheets in the workbook: <see cref="Aspose.Cells.Rendering.SheetSet.Visible"/>.
// Parameters:
//   value - SheetSet 
// Returns:
//   void  
func (instance *PdfSaveOptions) SetSheetSet(value *SheetSet)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.PdfSaveOptions_SetSheetSet( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Implements this interface to get DrawObject and Bound when rendering.
// Returns:
//   DrawObjectEventHandler  
func (instance *PdfSaveOptions) GetDrawObjectEventHandler()  (*DrawObjectEventHandler,  error)  {
	
	CGoReturnPtr := C.PdfSaveOptions_GetDrawObjectEventHandler( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &DrawObjectEventHandler{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteDrawObjectEventHandler) 

	return result, nil 
}
// Implements this interface to get DrawObject and Bound when rendering.
// Parameters:
//   value - DrawObjectEventHandler 
// Returns:
//   void  
func (instance *PdfSaveOptions) SetDrawObjectEventHandler(value *DrawObjectEventHandler)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.PdfSaveOptions_SetDrawObjectEventHandler( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Setting for rendering Emf metafile.
// Returns:
//   int32  
func (instance *PdfSaveOptions) GetEmfRenderSetting()  (EmfRenderSetting,  error)  {
	
	CGoReturnPtr := C.PdfSaveOptions_GetEmfRenderSetting( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToEmfRenderSetting(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Setting for rendering Emf metafile.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *PdfSaveOptions) SetEmfRenderSetting(value EmfRenderSetting)  error {
	
	CGoReturnPtr := C.PdfSaveOptions_SetEmfRenderSetting( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets custom settings during rendering.
// Returns:
//   CustomRenderSettings  
func (instance *PdfSaveOptions) GetCustomRenderSettings()  (*CustomRenderSettings,  error)  {
	
	CGoReturnPtr := C.PdfSaveOptions_GetCustomRenderSettings( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &CustomRenderSettings{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteCustomRenderSettings) 

	return result, nil 
}
// Gets or sets custom settings during rendering.
// Parameters:
//   value - CustomRenderSettings 
// Returns:
//   void  
func (instance *PdfSaveOptions) SetCustomRenderSettings(value *CustomRenderSettings)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.PdfSaveOptions_SetCustomRenderSettings( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the save file format.
// Returns:
//   int32  
func (instance *PdfSaveOptions) GetSaveFormat()  (SaveFormat,  error)  {
	
	CGoReturnPtr := C.PdfSaveOptions_GetSaveFormat( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToSaveFormat(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Make the workbook empty after saving the file.
// Returns:
//   bool  
func (instance *PdfSaveOptions) GetClearData()  (bool,  error)  {
	
	CGoReturnPtr := C.PdfSaveOptions_GetClearData( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Make the workbook empty after saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PdfSaveOptions) SetClearData(value bool)  error {
	
	CGoReturnPtr := C.PdfSaveOptions_SetClearData( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// The folder for temporary files that may be used as data cache.
// Returns:
//   string  
func (instance *PdfSaveOptions) GetCachedFileFolder()  (string,  error)  {
	
	CGoReturnPtr := C.PdfSaveOptions_GetCachedFileFolder( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// The folder for temporary files that may be used as data cache.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *PdfSaveOptions) SetCachedFileFolder(value string)  error {
	
	CGoReturnPtr := C.PdfSaveOptions_SetCachedFileFolder( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether validate merged cells before saving the file.
// Returns:
//   bool  
func (instance *PdfSaveOptions) GetValidateMergedAreas()  (bool,  error)  {
	
	CGoReturnPtr := C.PdfSaveOptions_GetValidateMergedAreas( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether validate merged cells before saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PdfSaveOptions) SetValidateMergedAreas(value bool)  error {
	
	CGoReturnPtr := C.PdfSaveOptions_SetValidateMergedAreas( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether merge the areas of conditional formatting and validation before saving the file.
// Returns:
//   bool  
func (instance *PdfSaveOptions) GetMergeAreas()  (bool,  error)  {
	
	CGoReturnPtr := C.PdfSaveOptions_GetMergeAreas( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether merge the areas of conditional formatting and validation before saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PdfSaveOptions) SetMergeAreas(value bool)  error {
	
	CGoReturnPtr := C.PdfSaveOptions_SetMergeAreas( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// If true and the directory does not exist, the directory will be automatically created before saving the file.
// Returns:
//   bool  
func (instance *PdfSaveOptions) GetCreateDirectory()  (bool,  error)  {
	
	CGoReturnPtr := C.PdfSaveOptions_GetCreateDirectory( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// If true and the directory does not exist, the directory will be automatically created before saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PdfSaveOptions) SetCreateDirectory(value bool)  error {
	
	CGoReturnPtr := C.PdfSaveOptions_SetCreateDirectory( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether sorting defined names before saving file.
// Returns:
//   bool  
func (instance *PdfSaveOptions) GetSortNames()  (bool,  error)  {
	
	CGoReturnPtr := C.PdfSaveOptions_GetSortNames( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether sorting defined names before saving file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PdfSaveOptions) SetSortNames(value bool)  error {
	
	CGoReturnPtr := C.PdfSaveOptions_SetSortNames( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether sorting external defined names before saving file.
// Returns:
//   bool  
func (instance *PdfSaveOptions) GetSortExternalNames()  (bool,  error)  {
	
	CGoReturnPtr := C.PdfSaveOptions_GetSortExternalNames( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether sorting external defined names before saving file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PdfSaveOptions) SetSortExternalNames(value bool)  error {
	
	CGoReturnPtr := C.PdfSaveOptions_SetSortExternalNames( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether refreshing chart cache data
// Returns:
//   bool  
func (instance *PdfSaveOptions) GetRefreshChartCache()  (bool,  error)  {
	
	CGoReturnPtr := C.PdfSaveOptions_GetRefreshChartCache( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether refreshing chart cache data
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PdfSaveOptions) SetRefreshChartCache(value bool)  error {
	
	CGoReturnPtr := C.PdfSaveOptions_SetRefreshChartCache( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Whether check restriction of excel file when user modify cells related objects.
// For example, excel does not allow inputting string value longer than 32K.
// When you input a value longer than 32K, it will be truncated.
// Returns:
//   bool  
func (instance *PdfSaveOptions) GetCheckExcelRestriction()  (bool,  error)  {
	
	CGoReturnPtr := C.PdfSaveOptions_GetCheckExcelRestriction( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Whether check restriction of excel file when user modify cells related objects.
// For example, excel does not allow inputting string value longer than 32K.
// When you input a value longer than 32K, it will be truncated.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PdfSaveOptions) SetCheckExcelRestriction(value bool)  error {
	
	CGoReturnPtr := C.PdfSaveOptions_SetCheckExcelRestriction( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether updating smart art setting.
// The default value is false.
// Returns:
//   bool  
func (instance *PdfSaveOptions) GetUpdateSmartArt()  (bool,  error)  {
	
	CGoReturnPtr := C.PdfSaveOptions_GetUpdateSmartArt( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether updating smart art setting.
// The default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PdfSaveOptions) SetUpdateSmartArt(value bool)  error {
	
	CGoReturnPtr := C.PdfSaveOptions_SetUpdateSmartArt( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether encrypt document properties when saving as .xls file.
// The default value is true.
// Returns:
//   bool  
func (instance *PdfSaveOptions) GetEncryptDocumentProperties()  (bool,  error)  {
	
	CGoReturnPtr := C.PdfSaveOptions_GetEncryptDocumentProperties( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether encrypt document properties when saving as .xls file.
// The default value is true.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PdfSaveOptions) SetEncryptDocumentProperties(value bool)  error {
	
	CGoReturnPtr := C.PdfSaveOptions_SetEncryptDocumentProperties( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}


func (instance *PdfSaveOptions) ToPaginatedSaveOptions() *PaginatedSaveOptions {
	parentClass := &PaginatedSaveOptions{}
	parentClass.ptr = instance.ptr
	return parentClass
}
func (instance *PdfSaveOptions) ToSaveOptions() *SaveOptions {
	parentClass := &SaveOptions{}
	parentClass.ptr = instance.ptr
	return parentClass
}

func DeletePdfSaveOptions(pdfsaveoptions *PdfSaveOptions){
	runtime.SetFinalizer(pdfsaveoptions, nil)
	C.Delete_PdfSaveOptions(pdfsaveoptions.ptr)
	pdfsaveoptions.ptr = nil
}

// Class PptxSaveOptions 

// Represents the pptx save options.
type PptxSaveOptions struct {
	ptr unsafe.Pointer
}

// Represents the pptx save options.
func NewPptxSaveOptions() ( *PptxSaveOptions, error) {
	pptxsaveoptions := &PptxSaveOptions{}
	CGoReturnPtr := C.New_PptxSaveOptions()
	if CGoReturnPtr.error_no == 0 {
		pptxsaveoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(pptxsaveoptions, DeletePptxSaveOptions)
		return pptxsaveoptions, nil
	} else {
		pptxsaveoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return pptxsaveoptions, err
	}	
}
// Represents options of saving .pptx file.
// Parameters:
//   saveAsImage - bool 
func NewPptxSaveOptions_Bool(saveasimage bool) ( *PptxSaveOptions, error) {
	pptxsaveoptions := &PptxSaveOptions{}
	CGoReturnPtr := C.New_PptxSaveOptions_Boolean(C.bool(saveasimage))
	if CGoReturnPtr.error_no == 0 {
		pptxsaveoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(pptxsaveoptions, DeletePptxSaveOptions)
		return pptxsaveoptions, nil
	} else {
		pptxsaveoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return pptxsaveoptions, err
	}	
}
// Constructs from a parent object.
// Parameters:
//   src - PaginatedSaveOptions 
func NewPptxSaveOptions_PaginatedSaveOptions(src *PaginatedSaveOptions) ( *PptxSaveOptions, error) {
	pptxsaveoptions := &PptxSaveOptions{}
	var src_ptr unsafe.Pointer = nil
	if src != nil {
	  src_ptr =src.ptr
	}

	CGoReturnPtr := C.New_PptxSaveOptions_PaginatedSaveOptions(src_ptr)
	if CGoReturnPtr.error_no == 0 {
		pptxsaveoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(pptxsaveoptions, DeletePptxSaveOptions)
		return pptxsaveoptions, nil
	} else {
		pptxsaveoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return pptxsaveoptions, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *PptxSaveOptions) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.PptxSaveOptions_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Inidicates whether ignoring hidden rows when converting Excel to PowerPoint.
// Returns:
//   bool  
func (instance *PptxSaveOptions) GetIgnoreHiddenRows()  (bool,  error)  {
	
	CGoReturnPtr := C.PptxSaveOptions_GetIgnoreHiddenRows( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Inidicates whether ignoring hidden rows when converting Excel to PowerPoint.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PptxSaveOptions) SetIgnoreHiddenRows(value bool)  error {
	
	CGoReturnPtr := C.PptxSaveOptions_SetIgnoreHiddenRows( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents what type of line needs to be adjusted size of font if height of row is small.
// Returns:
//   int32  
func (instance *PptxSaveOptions) GetAdjustFontSizeForRowType()  (AdjustFontSizeForRowType,  error)  {
	
	CGoReturnPtr := C.PptxSaveOptions_GetAdjustFontSizeForRowType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToAdjustFontSizeForRowType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Represents what type of line needs to be adjusted size of font if height of row is small.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *PptxSaveOptions) SetAdjustFontSizeForRowType(value AdjustFontSizeForRowType)  error {
	
	CGoReturnPtr := C.PptxSaveOptions_SetAdjustFontSizeForRowType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the display type when exporting to PowerPoint.
// The default exporting type is working as printing.
// Returns:
//   int32  
func (instance *PptxSaveOptions) GetExportViewType()  (SlideViewType,  error)  {
	
	CGoReturnPtr := C.PptxSaveOptions_GetExportViewType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToSlideViewType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets and sets the display type when exporting to PowerPoint.
// The default exporting type is working as printing.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *PptxSaveOptions) SetExportViewType(value SlideViewType)  error {
	
	CGoReturnPtr := C.PptxSaveOptions_SetExportViewType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// When characters in the Excel are Unicode and not be set with correct font in cell style,
// They may appear as block in pdf,image.
// Set the DefaultFont such as MingLiu or MS Gothic to show these characters.
// If this property is not set, Aspose.Cells will use system default font to show these unicode characters.
// Returns:
//   string  
func (instance *PptxSaveOptions) GetDefaultFont()  (string,  error)  {
	
	CGoReturnPtr := C.PptxSaveOptions_GetDefaultFont( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// When characters in the Excel are Unicode and not be set with correct font in cell style,
// They may appear as block in pdf,image.
// Set the DefaultFont such as MingLiu or MS Gothic to show these characters.
// If this property is not set, Aspose.Cells will use system default font to show these unicode characters.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *PptxSaveOptions) SetDefaultFont(value string)  error {
	
	CGoReturnPtr := C.PptxSaveOptions_SetDefaultFont( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// When characters in the Excel are Unicode and not be set with correct font in cell style,
// They may appear as block in pdf,image.
// Set this to true to try to use workbook's default font to show these characters first.
// Returns:
//   bool  
func (instance *PptxSaveOptions) GetCheckWorkbookDefaultFont()  (bool,  error)  {
	
	CGoReturnPtr := C.PptxSaveOptions_GetCheckWorkbookDefaultFont( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// When characters in the Excel are Unicode and not be set with correct font in cell style,
// They may appear as block in pdf,image.
// Set this to true to try to use workbook's default font to show these characters first.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PptxSaveOptions) SetCheckWorkbookDefaultFont(value bool)  error {
	
	CGoReturnPtr := C.PptxSaveOptions_SetCheckWorkbookDefaultFont( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether to check font compatibility for every character in text.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PptxSaveOptions) SetCheckFontCompatibility(value bool)  error {
	
	CGoReturnPtr := C.PptxSaveOptions_SetCheckFontCompatibility( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether to check font compatibility for every character in text.
// Returns:
//   bool  
func (instance *PptxSaveOptions) GetCheckFontCompatibility()  (bool,  error)  {
	
	CGoReturnPtr := C.PptxSaveOptions_GetCheckFontCompatibility( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether to only substitute the font of character when the cell font is not compatibility for it.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PptxSaveOptions) SetIsFontSubstitutionCharGranularity(value bool)  error {
	
	CGoReturnPtr := C.PptxSaveOptions_SetIsFontSubstitutionCharGranularity( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether to only substitute the font of character when the cell font is not compatibility for it.
// Returns:
//   bool  
func (instance *PptxSaveOptions) IsFontSubstitutionCharGranularity()  (bool,  error)  {
	
	CGoReturnPtr := C.PptxSaveOptions_IsFontSubstitutionCharGranularity( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// If OnePagePerSheet is true , all content of one sheet will output to only one page in result.
// The paper size of pagesetup will be invalid, and the other settings of pagesetup
// will still take effect.
// Returns:
//   bool  
func (instance *PptxSaveOptions) GetOnePagePerSheet()  (bool,  error)  {
	
	CGoReturnPtr := C.PptxSaveOptions_GetOnePagePerSheet( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// If OnePagePerSheet is true , all content of one sheet will output to only one page in result.
// The paper size of pagesetup will be invalid, and the other settings of pagesetup
// will still take effect.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PptxSaveOptions) SetOnePagePerSheet(value bool)  error {
	
	CGoReturnPtr := C.PptxSaveOptions_SetOnePagePerSheet( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// If AllColumnsInOnePagePerSheet is true , all column content of one sheet will output to only one page in result.
// The width of paper size of pagesetup will be ignored, and the other settings of pagesetup
// will still take effect.
// Returns:
//   bool  
func (instance *PptxSaveOptions) GetAllColumnsInOnePagePerSheet()  (bool,  error)  {
	
	CGoReturnPtr := C.PptxSaveOptions_GetAllColumnsInOnePagePerSheet( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// If AllColumnsInOnePagePerSheet is true , all column content of one sheet will output to only one page in result.
// The width of paper size of pagesetup will be ignored, and the other settings of pagesetup
// will still take effect.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PptxSaveOptions) SetAllColumnsInOnePagePerSheet(value bool)  error {
	
	CGoReturnPtr := C.PptxSaveOptions_SetAllColumnsInOnePagePerSheet( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates if you need to hide the error while rendering.
// The error can be error in shape, image, chart rendering, etc.
// Returns:
//   bool  
func (instance *PptxSaveOptions) GetIgnoreError()  (bool,  error)  {
	
	CGoReturnPtr := C.PptxSaveOptions_GetIgnoreError( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates if you need to hide the error while rendering.
// The error can be error in shape, image, chart rendering, etc.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PptxSaveOptions) SetIgnoreError(value bool)  error {
	
	CGoReturnPtr := C.PptxSaveOptions_SetIgnoreError( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether to output a blank page when there is nothing to print.
// Returns:
//   bool  
func (instance *PptxSaveOptions) GetOutputBlankPageWhenNothingToPrint()  (bool,  error)  {
	
	CGoReturnPtr := C.PptxSaveOptions_GetOutputBlankPageWhenNothingToPrint( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether to output a blank page when there is nothing to print.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PptxSaveOptions) SetOutputBlankPageWhenNothingToPrint(value bool)  error {
	
	CGoReturnPtr := C.PptxSaveOptions_SetOutputBlankPageWhenNothingToPrint( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the 0-based index of the first page to save.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *PptxSaveOptions) SetPageIndex(value int32)  error {
	
	CGoReturnPtr := C.PptxSaveOptions_SetPageIndex( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the 0-based index of the first page to save.
// Returns:
//   int32  
func (instance *PptxSaveOptions) GetPageIndex()  (int32,  error)  {
	
	CGoReturnPtr := C.PptxSaveOptions_GetPageIndex( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets the number of pages to save.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *PptxSaveOptions) SetPageCount(value int32)  error {
	
	CGoReturnPtr := C.PptxSaveOptions_SetPageCount( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the number of pages to save.
// Returns:
//   int32  
func (instance *PptxSaveOptions) GetPageCount()  (int32,  error)  {
	
	CGoReturnPtr := C.PptxSaveOptions_GetPageCount( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates which pages will not be printed.
// Returns:
//   int32  
func (instance *PptxSaveOptions) GetPrintingPageType()  (PrintingPageType,  error)  {
	
	CGoReturnPtr := C.PptxSaveOptions_GetPrintingPageType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToPrintingPageType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Indicates which pages will not be printed.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *PptxSaveOptions) SetPrintingPageType(value PrintingPageType)  error {
	
	CGoReturnPtr := C.PptxSaveOptions_SetPrintingPageType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets gridline type.
// Returns:
//   int32  
func (instance *PptxSaveOptions) GetGridlineType()  (GridlineType,  error)  {
	
	CGoReturnPtr := C.PptxSaveOptions_GetGridlineType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToGridlineType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets or sets gridline type.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *PptxSaveOptions) SetGridlineType(value GridlineType)  error {
	
	CGoReturnPtr := C.PptxSaveOptions_SetGridlineType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets gridline color.
// Returns:
//   Color  
func (instance *PptxSaveOptions) GetGridlineColor()  (*Color,  error)  {
	
	CGoReturnPtr := C.PptxSaveOptions_GetGridlineColor( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Gets or sets gridline color.
// Parameters:
//   value - Color 
// Returns:
//   void  
func (instance *PptxSaveOptions) SetGridlineColor(value *Color)  error {
	
	CGoReturnPtr := C.PptxSaveOptions_SetGridlineColor( instance.ptr, value.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets displaying text type when the text width is larger than cell width.
// Returns:
//   int32  
func (instance *PptxSaveOptions) GetTextCrossType()  (TextCrossType,  error)  {
	
	CGoReturnPtr := C.PptxSaveOptions_GetTextCrossType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToTextCrossType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets or sets displaying text type when the text width is larger than cell width.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *PptxSaveOptions) SetTextCrossType(value TextCrossType)  error {
	
	CGoReturnPtr := C.PptxSaveOptions_SetTextCrossType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets default edit language.
// Returns:
//   int32  
func (instance *PptxSaveOptions) GetDefaultEditLanguage()  (DefaultEditLanguage,  error)  {
	
	CGoReturnPtr := C.PptxSaveOptions_GetDefaultEditLanguage( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToDefaultEditLanguage(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets or sets default edit language.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *PptxSaveOptions) SetDefaultEditLanguage(value DefaultEditLanguage)  error {
	
	CGoReturnPtr := C.PptxSaveOptions_SetDefaultEditLanguage( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the sheets to render. Default is all visible sheets in the workbook: <see cref="Aspose.Cells.Rendering.SheetSet.Visible"/>.
// Returns:
//   SheetSet  
func (instance *PptxSaveOptions) GetSheetSet()  (*SheetSet,  error)  {
	
	CGoReturnPtr := C.PptxSaveOptions_GetSheetSet( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &SheetSet{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteSheetSet) 

	return result, nil 
}
// Gets or sets the sheets to render. Default is all visible sheets in the workbook: <see cref="Aspose.Cells.Rendering.SheetSet.Visible"/>.
// Parameters:
//   value - SheetSet 
// Returns:
//   void  
func (instance *PptxSaveOptions) SetSheetSet(value *SheetSet)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.PptxSaveOptions_SetSheetSet( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Implements this interface to get DrawObject and Bound when rendering.
// Returns:
//   DrawObjectEventHandler  
func (instance *PptxSaveOptions) GetDrawObjectEventHandler()  (*DrawObjectEventHandler,  error)  {
	
	CGoReturnPtr := C.PptxSaveOptions_GetDrawObjectEventHandler( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &DrawObjectEventHandler{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteDrawObjectEventHandler) 

	return result, nil 
}
// Implements this interface to get DrawObject and Bound when rendering.
// Parameters:
//   value - DrawObjectEventHandler 
// Returns:
//   void  
func (instance *PptxSaveOptions) SetDrawObjectEventHandler(value *DrawObjectEventHandler)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.PptxSaveOptions_SetDrawObjectEventHandler( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Setting for rendering Emf metafile.
// Returns:
//   int32  
func (instance *PptxSaveOptions) GetEmfRenderSetting()  (EmfRenderSetting,  error)  {
	
	CGoReturnPtr := C.PptxSaveOptions_GetEmfRenderSetting( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToEmfRenderSetting(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Setting for rendering Emf metafile.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *PptxSaveOptions) SetEmfRenderSetting(value EmfRenderSetting)  error {
	
	CGoReturnPtr := C.PptxSaveOptions_SetEmfRenderSetting( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets custom settings during rendering.
// Returns:
//   CustomRenderSettings  
func (instance *PptxSaveOptions) GetCustomRenderSettings()  (*CustomRenderSettings,  error)  {
	
	CGoReturnPtr := C.PptxSaveOptions_GetCustomRenderSettings( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &CustomRenderSettings{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteCustomRenderSettings) 

	return result, nil 
}
// Gets or sets custom settings during rendering.
// Parameters:
//   value - CustomRenderSettings 
// Returns:
//   void  
func (instance *PptxSaveOptions) SetCustomRenderSettings(value *CustomRenderSettings)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.PptxSaveOptions_SetCustomRenderSettings( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the save file format.
// Returns:
//   int32  
func (instance *PptxSaveOptions) GetSaveFormat()  (SaveFormat,  error)  {
	
	CGoReturnPtr := C.PptxSaveOptions_GetSaveFormat( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToSaveFormat(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Make the workbook empty after saving the file.
// Returns:
//   bool  
func (instance *PptxSaveOptions) GetClearData()  (bool,  error)  {
	
	CGoReturnPtr := C.PptxSaveOptions_GetClearData( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Make the workbook empty after saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PptxSaveOptions) SetClearData(value bool)  error {
	
	CGoReturnPtr := C.PptxSaveOptions_SetClearData( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// The folder for temporary files that may be used as data cache.
// Returns:
//   string  
func (instance *PptxSaveOptions) GetCachedFileFolder()  (string,  error)  {
	
	CGoReturnPtr := C.PptxSaveOptions_GetCachedFileFolder( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// The folder for temporary files that may be used as data cache.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *PptxSaveOptions) SetCachedFileFolder(value string)  error {
	
	CGoReturnPtr := C.PptxSaveOptions_SetCachedFileFolder( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether validate merged cells before saving the file.
// Returns:
//   bool  
func (instance *PptxSaveOptions) GetValidateMergedAreas()  (bool,  error)  {
	
	CGoReturnPtr := C.PptxSaveOptions_GetValidateMergedAreas( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether validate merged cells before saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PptxSaveOptions) SetValidateMergedAreas(value bool)  error {
	
	CGoReturnPtr := C.PptxSaveOptions_SetValidateMergedAreas( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether merge the areas of conditional formatting and validation before saving the file.
// Returns:
//   bool  
func (instance *PptxSaveOptions) GetMergeAreas()  (bool,  error)  {
	
	CGoReturnPtr := C.PptxSaveOptions_GetMergeAreas( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether merge the areas of conditional formatting and validation before saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PptxSaveOptions) SetMergeAreas(value bool)  error {
	
	CGoReturnPtr := C.PptxSaveOptions_SetMergeAreas( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// If true and the directory does not exist, the directory will be automatically created before saving the file.
// Returns:
//   bool  
func (instance *PptxSaveOptions) GetCreateDirectory()  (bool,  error)  {
	
	CGoReturnPtr := C.PptxSaveOptions_GetCreateDirectory( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// If true and the directory does not exist, the directory will be automatically created before saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PptxSaveOptions) SetCreateDirectory(value bool)  error {
	
	CGoReturnPtr := C.PptxSaveOptions_SetCreateDirectory( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether sorting defined names before saving file.
// Returns:
//   bool  
func (instance *PptxSaveOptions) GetSortNames()  (bool,  error)  {
	
	CGoReturnPtr := C.PptxSaveOptions_GetSortNames( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether sorting defined names before saving file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PptxSaveOptions) SetSortNames(value bool)  error {
	
	CGoReturnPtr := C.PptxSaveOptions_SetSortNames( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether sorting external defined names before saving file.
// Returns:
//   bool  
func (instance *PptxSaveOptions) GetSortExternalNames()  (bool,  error)  {
	
	CGoReturnPtr := C.PptxSaveOptions_GetSortExternalNames( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether sorting external defined names before saving file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PptxSaveOptions) SetSortExternalNames(value bool)  error {
	
	CGoReturnPtr := C.PptxSaveOptions_SetSortExternalNames( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether refreshing chart cache data
// Returns:
//   bool  
func (instance *PptxSaveOptions) GetRefreshChartCache()  (bool,  error)  {
	
	CGoReturnPtr := C.PptxSaveOptions_GetRefreshChartCache( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether refreshing chart cache data
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PptxSaveOptions) SetRefreshChartCache(value bool)  error {
	
	CGoReturnPtr := C.PptxSaveOptions_SetRefreshChartCache( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Whether check restriction of excel file when user modify cells related objects.
// For example, excel does not allow inputting string value longer than 32K.
// When you input a value longer than 32K, it will be truncated.
// Returns:
//   bool  
func (instance *PptxSaveOptions) GetCheckExcelRestriction()  (bool,  error)  {
	
	CGoReturnPtr := C.PptxSaveOptions_GetCheckExcelRestriction( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Whether check restriction of excel file when user modify cells related objects.
// For example, excel does not allow inputting string value longer than 32K.
// When you input a value longer than 32K, it will be truncated.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PptxSaveOptions) SetCheckExcelRestriction(value bool)  error {
	
	CGoReturnPtr := C.PptxSaveOptions_SetCheckExcelRestriction( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether updating smart art setting.
// The default value is false.
// Returns:
//   bool  
func (instance *PptxSaveOptions) GetUpdateSmartArt()  (bool,  error)  {
	
	CGoReturnPtr := C.PptxSaveOptions_GetUpdateSmartArt( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether updating smart art setting.
// The default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PptxSaveOptions) SetUpdateSmartArt(value bool)  error {
	
	CGoReturnPtr := C.PptxSaveOptions_SetUpdateSmartArt( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether encrypt document properties when saving as .xls file.
// The default value is true.
// Returns:
//   bool  
func (instance *PptxSaveOptions) GetEncryptDocumentProperties()  (bool,  error)  {
	
	CGoReturnPtr := C.PptxSaveOptions_GetEncryptDocumentProperties( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether encrypt document properties when saving as .xls file.
// The default value is true.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *PptxSaveOptions) SetEncryptDocumentProperties(value bool)  error {
	
	CGoReturnPtr := C.PptxSaveOptions_SetEncryptDocumentProperties( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}


func (instance *PptxSaveOptions) ToPaginatedSaveOptions() *PaginatedSaveOptions {
	parentClass := &PaginatedSaveOptions{}
	parentClass.ptr = instance.ptr
	return parentClass
}
func (instance *PptxSaveOptions) ToSaveOptions() *SaveOptions {
	parentClass := &SaveOptions{}
	parentClass.ptr = instance.ptr
	return parentClass
}

func DeletePptxSaveOptions(pptxsaveoptions *PptxSaveOptions){
	runtime.SetFinalizer(pptxsaveoptions, nil)
	C.Delete_PptxSaveOptions(pptxsaveoptions.ptr)
	pptxsaveoptions.ptr = nil
}

// Class ProtectedRange 

// A specified range to be allowed to edit when the sheet protection is ON.
type ProtectedRange struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *ProtectedRange) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.ProtectedRange_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the Range title. This is used as a descriptor, not as a named range definition.
// Returns:
//   string  
func (instance *ProtectedRange) GetName()  (string,  error)  {
	
	CGoReturnPtr := C.ProtectedRange_GetName( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the Range title. This is used as a descriptor, not as a named range definition.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *ProtectedRange) SetName(value string)  error {
	
	CGoReturnPtr := C.ProtectedRange_SetName( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the <see cref="CellArea"/> object represents the cell area to be protected.
// Returns:
//   CellArea  
func (instance *ProtectedRange) GetCellArea()  (*CellArea,  error)  {
	
	CGoReturnPtr := C.ProtectedRange_GetCellArea( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &CellArea{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteCellArea) 

	return result, nil 
}
// Gets all referred areas.
// Returns:
//   []CellArea  
func (instance *ProtectedRange) GetAreas()  ([]CellArea,  error)  {
	
	CGoReturnPtr := C.ProtectedRange_GetAreas( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result:= make([]CellArea, CGoReturnPtr.column_length)
	for i := 0; i < int(CGoReturnPtr.column_length); i++ {
	   offset := uintptr(C.size_t(i)) * uintptr(CGoReturnPtr.size)
	   goObject := &CellArea{}
	   goObject.ptr =unsafe.Pointer(uintptr( unsafe.Pointer(CGoReturnPtr.return_value)) + offset)
	   result[i] = *goObject
	}
	 

	return result, nil 
}
// Adds a referred area to this
// Parameters:
//   startRow - int32 
//   startColumn - int32 
//   endRow - int32 
//   endColumn - int32 
// Returns:
//   void  
func (instance *ProtectedRange) AddArea(startrow int32, startcolumn int32, endrow int32, endcolumn int32)  error {
	
	CGoReturnPtr := C.ProtectedRange_AddArea( instance.ptr, C.int(startrow), C.int(startcolumn), C.int(endrow), C.int(endcolumn))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether the worksheets is protected with password.
// Returns:
//   bool  
func (instance *ProtectedRange) IsProtectedWithPassword()  (bool,  error)  {
	
	CGoReturnPtr := C.ProtectedRange_IsProtectedWithPassword( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents the password to protect the range.
// Returns:
//   string  
func (instance *ProtectedRange) GetPassword()  (string,  error)  {
	
	CGoReturnPtr := C.ProtectedRange_GetPassword( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents the password to protect the range.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *ProtectedRange) SetPassword(value string)  error {
	
	CGoReturnPtr := C.ProtectedRange_SetPassword( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// The security descriptor defines user accounts who may edit this range without providing a password to access the range.
// Returns:
//   string  
func (instance *ProtectedRange) GetSecurityDescriptor()  (string,  error)  {
	
	CGoReturnPtr := C.ProtectedRange_GetSecurityDescriptor( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// The security descriptor defines user accounts who may edit this range without providing a password to access the range.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *ProtectedRange) SetSecurityDescriptor(value string)  error {
	
	CGoReturnPtr := C.ProtectedRange_SetSecurityDescriptor( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}



func DeleteProtectedRange(protectedrange *ProtectedRange){
	runtime.SetFinalizer(protectedrange, nil)
	C.Delete_ProtectedRange(protectedrange.ptr)
	protectedrange.ptr = nil
}

// Class ProtectedRangeCollection 

// Encapsulates a collection of <see cref="ProtectedRange"/> objects.
type ProtectedRangeCollection struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *ProtectedRangeCollection) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.ProtectedRangeCollection_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the <see cref="ProtectedRange"/> element at the specified index.
// Parameters:
//   index - int32 
// Returns:
//   ProtectedRange  
func (instance *ProtectedRangeCollection) Get(index int32)  (*ProtectedRange,  error)  {
	
	CGoReturnPtr := C.ProtectedRangeCollection_Get( instance.ptr, C.int(index))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &ProtectedRange{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteProtectedRange) 

	return result, nil 
}
// Adds a <see cref="ProtectedRange"/> item to the collection.
// Parameters:
//   name - string 
//   startRow - int32 
//   startColumn - int32 
//   endRow - int32 
//   endColumn - int32 
// Returns:
//   int32  
func (instance *ProtectedRangeCollection) Add(name string, startrow int32, startcolumn int32, endrow int32, endcolumn int32)  (int32,  error)  {
	
	CGoReturnPtr := C.ProtectedRangeCollection_Add( instance.ptr, C.CString(name), C.int(startrow), C.int(startcolumn), C.int(endrow), C.int(endcolumn))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Returns:
//   int32  
func (instance *ProtectedRangeCollection) GetCount()  (int32,  error)  {
	
	CGoReturnPtr := C.ProtectedRangeCollection_GetCount( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}



func DeleteProtectedRangeCollection(protectedrangecollection *ProtectedRangeCollection){
	runtime.SetFinalizer(protectedrangecollection, nil)
	C.Delete_ProtectedRangeCollection(protectedrangecollection.ptr)
	protectedrangecollection.ptr = nil
}

// Class Protection 

// Represents the various types of protection options available for a worksheet.
type Protection struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *Protection) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.Protection_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Copy protection info.
// Parameters:
//   source - Protection 
// Returns:
//   void  
func (instance *Protection) Copy(source *Protection)  error {
	
	var source_ptr unsafe.Pointer = nil
	if source != nil {
	  source_ptr =source.ptr
	}

	CGoReturnPtr := C.Protection_Copy( instance.ptr, source_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents if the deletion of columns is allowed on a protected worksheet.
// Returns:
//   bool  
func (instance *Protection) GetAllowDeletingColumn()  (bool,  error)  {
	
	CGoReturnPtr := C.Protection_GetAllowDeletingColumn( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents if the deletion of columns is allowed on a protected worksheet.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Protection) SetAllowDeletingColumn(value bool)  error {
	
	CGoReturnPtr := C.Protection_SetAllowDeletingColumn( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents if the deletion of rows is allowed on a protected worksheet.
// Returns:
//   bool  
func (instance *Protection) GetAllowDeletingRow()  (bool,  error)  {
	
	CGoReturnPtr := C.Protection_GetAllowDeletingRow( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents if the deletion of rows is allowed on a protected worksheet.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Protection) SetAllowDeletingRow(value bool)  error {
	
	CGoReturnPtr := C.Protection_SetAllowDeletingRow( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents if the user is allowed to make use of an AutoFilter that was created before the sheet was protected.
// Returns:
//   bool  
func (instance *Protection) GetAllowFiltering()  (bool,  error)  {
	
	CGoReturnPtr := C.Protection_GetAllowFiltering( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents if the user is allowed to make use of an AutoFilter that was created before the sheet was protected.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Protection) SetAllowFiltering(value bool)  error {
	
	CGoReturnPtr := C.Protection_SetAllowFiltering( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents if the formatting of cells is allowed on a protected worksheet.
// Returns:
//   bool  
func (instance *Protection) GetAllowFormattingCell()  (bool,  error)  {
	
	CGoReturnPtr := C.Protection_GetAllowFormattingCell( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents if the formatting of cells is allowed on a protected worksheet.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Protection) SetAllowFormattingCell(value bool)  error {
	
	CGoReturnPtr := C.Protection_SetAllowFormattingCell( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents if the formatting of columns is allowed on a protected worksheet
// Returns:
//   bool  
func (instance *Protection) GetAllowFormattingColumn()  (bool,  error)  {
	
	CGoReturnPtr := C.Protection_GetAllowFormattingColumn( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents if the formatting of columns is allowed on a protected worksheet
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Protection) SetAllowFormattingColumn(value bool)  error {
	
	CGoReturnPtr := C.Protection_SetAllowFormattingColumn( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents if the formatting of rows is allowed on a protected worksheet
// Returns:
//   bool  
func (instance *Protection) GetAllowFormattingRow()  (bool,  error)  {
	
	CGoReturnPtr := C.Protection_GetAllowFormattingRow( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents if the formatting of rows is allowed on a protected worksheet
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Protection) SetAllowFormattingRow(value bool)  error {
	
	CGoReturnPtr := C.Protection_SetAllowFormattingRow( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents if the insertion of columns is allowed on a protected worksheet
// Returns:
//   bool  
func (instance *Protection) GetAllowInsertingColumn()  (bool,  error)  {
	
	CGoReturnPtr := C.Protection_GetAllowInsertingColumn( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents if the insertion of columns is allowed on a protected worksheet
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Protection) SetAllowInsertingColumn(value bool)  error {
	
	CGoReturnPtr := C.Protection_SetAllowInsertingColumn( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents if the insertion of hyperlinks is allowed on a protected worksheet
// Returns:
//   bool  
func (instance *Protection) GetAllowInsertingHyperlink()  (bool,  error)  {
	
	CGoReturnPtr := C.Protection_GetAllowInsertingHyperlink( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents if the insertion of hyperlinks is allowed on a protected worksheet
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Protection) SetAllowInsertingHyperlink(value bool)  error {
	
	CGoReturnPtr := C.Protection_SetAllowInsertingHyperlink( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents if the insertion of rows is allowed on a protected worksheet
// Returns:
//   bool  
func (instance *Protection) GetAllowInsertingRow()  (bool,  error)  {
	
	CGoReturnPtr := C.Protection_GetAllowInsertingRow( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents if the insertion of rows is allowed on a protected worksheet
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Protection) SetAllowInsertingRow(value bool)  error {
	
	CGoReturnPtr := C.Protection_SetAllowInsertingRow( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents if the sorting option is allowed on a protected worksheet.
// Returns:
//   bool  
func (instance *Protection) GetAllowSorting()  (bool,  error)  {
	
	CGoReturnPtr := C.Protection_GetAllowSorting( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents if the sorting option is allowed on a protected worksheet.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Protection) SetAllowSorting(value bool)  error {
	
	CGoReturnPtr := C.Protection_SetAllowSorting( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents if the user is allowed to manipulate pivot tables on a protected worksheet.
// Returns:
//   bool  
func (instance *Protection) GetAllowUsingPivotTable()  (bool,  error)  {
	
	CGoReturnPtr := C.Protection_GetAllowUsingPivotTable( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents if the user is allowed to manipulate pivot tables on a protected worksheet.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Protection) SetAllowUsingPivotTable(value bool)  error {
	
	CGoReturnPtr := C.Protection_SetAllowUsingPivotTable( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents if the user is allowed to edit contents of locked cells on a protected worksheet.
// Returns:
//   bool  
func (instance *Protection) GetAllowEditingContent()  (bool,  error)  {
	
	CGoReturnPtr := C.Protection_GetAllowEditingContent( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents if the user is allowed to edit contents of locked cells on a protected worksheet.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Protection) SetAllowEditingContent(value bool)  error {
	
	CGoReturnPtr := C.Protection_SetAllowEditingContent( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents if the user is allowed to manipulate drawing objects on a protected worksheet.
// Returns:
//   bool  
func (instance *Protection) GetAllowEditingObject()  (bool,  error)  {
	
	CGoReturnPtr := C.Protection_GetAllowEditingObject( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents if the user is allowed to manipulate drawing objects on a protected worksheet.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Protection) SetAllowEditingObject(value bool)  error {
	
	CGoReturnPtr := C.Protection_SetAllowEditingObject( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents if the user is allowed to edit scenarios on a protected worksheet.
// Returns:
//   bool  
func (instance *Protection) GetAllowEditingScenario()  (bool,  error)  {
	
	CGoReturnPtr := C.Protection_GetAllowEditingScenario( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents if the user is allowed to edit scenarios on a protected worksheet.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Protection) SetAllowEditingScenario(value bool)  error {
	
	CGoReturnPtr := C.Protection_SetAllowEditingScenario( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents if the user is allowed to select locked cells on a protected worksheet.
// Returns:
//   bool  
func (instance *Protection) GetAllowSelectingLockedCell()  (bool,  error)  {
	
	CGoReturnPtr := C.Protection_GetAllowSelectingLockedCell( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents if the user is allowed to select locked cells on a protected worksheet.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Protection) SetAllowSelectingLockedCell(value bool)  error {
	
	CGoReturnPtr := C.Protection_SetAllowSelectingLockedCell( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents if the user is allowed to select unlocked cells on a protected worksheet.
// Returns:
//   bool  
func (instance *Protection) GetAllowSelectingUnlockedCell()  (bool,  error)  {
	
	CGoReturnPtr := C.Protection_GetAllowSelectingUnlockedCell( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents if the user is allowed to select unlocked cells on a protected worksheet.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Protection) SetAllowSelectingUnlockedCell(value bool)  error {
	
	CGoReturnPtr := C.Protection_SetAllowSelectingUnlockedCell( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents the password to protect the worksheet.
// Returns:
//   string  
func (instance *Protection) GetPassword()  (string,  error)  {
	
	CGoReturnPtr := C.Protection_GetPassword( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents the password to protect the worksheet.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *Protection) SetPassword(value string)  error {
	
	CGoReturnPtr := C.Protection_SetPassword( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether the worksheets is protected with password.
// Returns:
//   bool  
func (instance *Protection) IsProtectedWithPassword()  (bool,  error)  {
	
	CGoReturnPtr := C.Protection_IsProtectedWithPassword( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Verifies password.
// Parameters:
//   password - string 
// Returns:
//   bool  
func (instance *Protection) VerifyPassword(password string)  (bool,  error)  {
	
	CGoReturnPtr := C.Protection_VerifyPassword( instance.ptr, C.CString(password))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the hash of current password.
// Returns:
//   int32  
func (instance *Protection) GetPasswordHash()  (int32,  error)  {
	
	CGoReturnPtr := C.Protection_GetPasswordHash( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}



func DeleteProtection(protection *Protection){
	runtime.SetFinalizer(protection, nil)
	C.Delete_Protection(protection.ptr)
	protection.ptr = nil
}

// Class QueryTable 

// Represents QueryTable information.
type QueryTable struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *QueryTable) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.QueryTable_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the connection id of the query table.
// Returns:
//   int32  
func (instance *QueryTable) GetConnectionId()  (int32,  error)  {
	
	CGoReturnPtr := C.QueryTable_GetConnectionId( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the relate external connection.
// Returns:
//   ExternalConnection  
func (instance *QueryTable) GetExternalConnection()  (*ExternalConnection,  error)  {
	
	CGoReturnPtr := C.QueryTable_GetExternalConnection( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &ExternalConnection{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteExternalConnection) 

	return result, nil 
}
// Gets the name of querytable.
// Returns:
//   string  
func (instance *QueryTable) GetName()  (string,  error)  {
	
	CGoReturnPtr := C.QueryTable_GetName( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the range of the result.
// Returns:
//   Range  
func (instance *QueryTable) GetResultRange()  (*Range,  error)  {
	
	CGoReturnPtr := C.QueryTable_GetResultRange( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Range{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteRange) 

	return result, nil 
}
// Returns or sets the PreserveFormatting of the object.
// Returns:
//   bool  
func (instance *QueryTable) GetPreserveFormatting()  (bool,  error)  {
	
	CGoReturnPtr := C.QueryTable_GetPreserveFormatting( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Returns or sets the PreserveFormatting of the object.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *QueryTable) SetPreserveFormatting(value bool)  error {
	
	CGoReturnPtr := C.QueryTable_SetPreserveFormatting( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Returns or sets the AdjustColumnWidth of the object.
// Returns:
//   bool  
func (instance *QueryTable) GetAdjustColumnWidth()  (bool,  error)  {
	
	CGoReturnPtr := C.QueryTable_GetAdjustColumnWidth( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Returns or sets the AdjustColumnWidth of the object.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *QueryTable) SetAdjustColumnWidth(value bool)  error {
	
	CGoReturnPtr := C.QueryTable_SetAdjustColumnWidth( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}



func DeleteQueryTable(querytable *QueryTable){
	runtime.SetFinalizer(querytable, nil)
	C.Delete_QueryTable(querytable.ptr)
	querytable.ptr = nil
}

// Class QueryTableCollection 

// A collection of <see cref="QueryTableCollection"/> objects that represent QueryTable collection information.
type QueryTableCollection struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *QueryTableCollection) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.QueryTableCollection_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the querytable by the specific index.
// Parameters:
//   index - int32 
// Returns:
//   QueryTable  
func (instance *QueryTableCollection) Get(index int32)  (*QueryTable,  error)  {
	
	CGoReturnPtr := C.QueryTableCollection_Get( instance.ptr, C.int(index))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &QueryTable{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteQueryTable) 

	return result, nil 
}
// Returns:
//   int32  
func (instance *QueryTableCollection) GetCount()  (int32,  error)  {
	
	CGoReturnPtr := C.QueryTableCollection_GetCount( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}



func DeleteQueryTableCollection(querytablecollection *QueryTableCollection){
	runtime.SetFinalizer(querytablecollection, nil)
	C.Delete_QueryTableCollection(querytablecollection.ptr)
	querytablecollection.ptr = nil
}

// Class Range 

// Encapsulates the object that represents a range of cells within a spreadsheet.
type Range struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *Range) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.Range_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Automaticall fill the target range.
// Parameters:
//   target - Range 
// Returns:
//   void  
func (instance *Range) AutoFill_Range(target *Range)  error {
	
	var target_ptr unsafe.Pointer = nil
	if target != nil {
	  target_ptr =target.ptr
	}

	CGoReturnPtr := C.Range_AutoFill_Range( instance.ptr, target_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Automaticall fill the target range.
// Parameters:
//   target - Range 
//   autoFillType - int32 
// Returns:
//   void  
func (instance *Range) AutoFill_Range_AutoFillType(target *Range, autofilltype AutoFillType)  error {
	
	var target_ptr unsafe.Pointer = nil
	if target != nil {
	  target_ptr =target.ptr
	}

	CGoReturnPtr := C.Range_AutoFill_Range_AutoFillType( instance.ptr, target_ptr, C.int( int32(autofilltype)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Returns a Range object that represents the current region.
// The current region is a range bounded by any combination of blank rows and blank columns.
// Returns:
//   Range  
func (instance *Range) GetCurrentRegion()  (*Range,  error)  {
	
	CGoReturnPtr := C.Range_GetCurrentRegion( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Range{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteRange) 

	return result, nil 
}
// Gets all hyperlink in the range.
// Returns:
//   []Hyperlink  
func (instance *Range) GetHyperlinks()  ([]Hyperlink,  error)  {
	
	CGoReturnPtr := C.Range_GetHyperlinks( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result:= make([]Hyperlink, CGoReturnPtr.column_length)
	for i := 0; i < int(CGoReturnPtr.column_length); i++ {
	   offset := uintptr(C.size_t(i)) * uintptr(CGoReturnPtr.size)
	   goObject := &Hyperlink{}
	   goObject.ptr =unsafe.Pointer(uintptr( unsafe.Pointer(CGoReturnPtr.return_value)) + offset)
	   result[i] = *goObject
	}
	 

	return result, nil 
}
// Adds a hyperlink to a specified cell or a range of cells.
// Parameters:
//   address - string 
//   textToDisplay - string 
//   screenTip - string 
// Returns:
//   Hyperlink  
func (instance *Range) AddHyperlink(address string, texttodisplay string, screentip string)  (*Hyperlink,  error)  {
	
	CGoReturnPtr := C.Range_AddHyperlink( instance.ptr, C.CString(address), C.CString(texttodisplay), C.CString(screentip))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Hyperlink{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteHyperlink) 

	return result, nil 
}
// Gets the enumerator for cells in this Range.
// Returns:
//   unsafe.Pointer  
func (instance *Range) GetEnumerator()  (*CellEnumerator,  error)  {
	
	CGoReturnPtr := C.Range_GetEnumerator( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &CellEnumerator{}
	result.ptr = CGoReturnPtr.return_value
	runtime.SetFinalizer(result, DeleteCellEnumerator)
	 

	return result, nil 
}
// Indicates whether the range is intersect.
// Parameters:
//   range - Range 
// Returns:
//   bool  
func (instance *Range) IsIntersect(range_ *Range)  (bool,  error)  {
	
	var range__ptr unsafe.Pointer = nil
	if range_ != nil {
	  range__ptr =range_.ptr
	}

	CGoReturnPtr := C.Range_IsIntersect( instance.ptr, range__ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Returns a <see cref="Range"/> object that represents the rectangular intersection of two ranges.
// Parameters:
//   range - Range 
// Returns:
//   Range  
func (instance *Range) Intersect(range_ *Range)  (*Range,  error)  {
	
	var range__ptr unsafe.Pointer = nil
	if range_ != nil {
	  range__ptr =range_.ptr
	}

	CGoReturnPtr := C.Range_Intersect( instance.ptr, range__ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Range{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteRange) 

	return result, nil 
}
// Returns the union result of two ranges.
// Parameters:
//   ranges - []Range 
// Returns:
//   UnionRange  
func (instance *Range) UnionRanges(ranges []Range)  (*UnionRange,  error)  {
	
	ranges_length := len(ranges)
	vector_ranges:= make([]unsafe.Pointer, ranges_length)
	for i := 0; i < ranges_length; i++ {
		vector_ranges[i] = ranges[i].ptr
	}


	CGoReturnPtr := C.Range_UnionRanges( instance.ptr, unsafe.Pointer(&vector_ranges[0]), C.int( len(ranges)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &UnionRange{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteUnionRange) 

	return result, nil 
}
// Gets the count of rows in the range.
// Returns:
//   int32  
func (instance *Range) GetRowCount()  (int32,  error)  {
	
	CGoReturnPtr := C.Range_GetRowCount( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the count of columns in the range.
// Returns:
//   int32  
func (instance *Range) GetColumnCount()  (int32,  error)  {
	
	CGoReturnPtr := C.Range_GetColumnCount( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets the name of the range.
// Returns:
//   string  
func (instance *Range) GetName()  (string,  error)  {
	
	CGoReturnPtr := C.Range_GetName( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets the name of the range.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *Range) SetName(value string)  error {
	
	CGoReturnPtr := C.Range_SetName( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the range's refers to.
// Returns:
//   string  
func (instance *Range) GetRefersTo()  (string,  error)  {
	
	CGoReturnPtr := C.Range_GetRefersTo( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets address of the range.
// Returns:
//   string  
func (instance *Range) GetAddress()  (string,  error)  {
	
	CGoReturnPtr := C.Range_GetAddress( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether the range contains values.
// Returns:
//   bool  
func (instance *Range) IsBlank()  (bool,  error)  {
	
	CGoReturnPtr := C.Range_IsBlank( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the distance, in points, from the left edge of column A to the left edge of the range.
// Returns:
//   float64  
func (instance *Range) GetLeft()  (float64,  error)  {
	
	CGoReturnPtr := C.Range_GetLeft( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := float64(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the distance, in points, from the top edge of row 1 to the top edge of the range.
// Returns:
//   float64  
func (instance *Range) GetTop()  (float64,  error)  {
	
	CGoReturnPtr := C.Range_GetTop( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := float64(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the width of a range in points.
// Returns:
//   float64  
func (instance *Range) GetWidth()  (float64,  error)  {
	
	CGoReturnPtr := C.Range_GetWidth( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := float64(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the width of a range in points.
// Returns:
//   float64  
func (instance *Range) GetHeight()  (float64,  error)  {
	
	CGoReturnPtr := C.Range_GetHeight( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := float64(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the index of the first row of the range.
// Returns:
//   int32  
func (instance *Range) GetFirstRow()  (int32,  error)  {
	
	CGoReturnPtr := C.Range_GetFirstRow( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the index of the first column of the range.
// Returns:
//   int32  
func (instance *Range) GetFirstColumn()  (int32,  error)  {
	
	CGoReturnPtr := C.Range_GetFirstColumn( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Combines a range of cells into a single cell.
// Returns:
//   void  
func (instance *Range) Merge()  error {
	
	CGoReturnPtr := C.Range_Merge( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Unmerges merged cells of this range.
// Returns:
//   void  
func (instance *Range) UnMerge()  error {
	
	CGoReturnPtr := C.Range_UnMerge( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Puts a value into the range, if appropriate the value will be converted to other data type and cell's number format will be reset.
// Parameters:
//   stringValue - string 
//   isConverted - bool 
//   setStyle - bool 
// Returns:
//   void  
func (instance *Range) PutValue(stringvalue string, isconverted bool, setstyle bool)  error {
	
	CGoReturnPtr := C.Range_PutValue( instance.ptr, C.CString(stringvalue), C.bool(isconverted), C.bool(setstyle))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the value of the range.
// Returns:
//   Object  
func (instance *Range) GetValue()  (*Object,  error)  {
	
	CGoReturnPtr := C.Range_GetValue( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Object{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteObject) 

	return result, nil 
}
// Gets and sets the value of the range.
// Parameters:
//   value - Object 
// Returns:
//   void  
func (instance *Range) SetValue(value *Object)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.Range_SetValue( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Apply the cell style.
// Parameters:
//   style - Style 
//   explicitFlag - bool 
// Returns:
//   void  
func (instance *Range) SetStyle_Style_Bool(style *Style, explicitflag bool)  error {
	
	var style_ptr unsafe.Pointer = nil
	if style != nil {
	  style_ptr =style.ptr
	}

	CGoReturnPtr := C.Range_SetStyle_Style_Boolean( instance.ptr, style_ptr, C.bool(explicitflag))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Applies formats for a whole range.
// Parameters:
//   style - Style 
//   flag - StyleFlag 
// Returns:
//   void  
func (instance *Range) ApplyStyle(style *Style, flag *StyleFlag)  error {
	
	var style_ptr unsafe.Pointer = nil
	if style != nil {
	  style_ptr =style.ptr
	}
	var flag_ptr unsafe.Pointer = nil
	if flag != nil {
	  flag_ptr =flag.ptr
	}

	CGoReturnPtr := C.Range_ApplyStyle( instance.ptr, style_ptr, flag_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Sets the style of the range.
// Parameters:
//   style - Style 
// Returns:
//   void  
func (instance *Range) SetStyle_Style(style *Style)  error {
	
	var style_ptr unsafe.Pointer = nil
	if style != nil {
	  style_ptr =style.ptr
	}

	CGoReturnPtr := C.Range_SetStyle_Style( instance.ptr, style_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Sets the outline borders around a range of cells with same border style and color.
// Parameters:
//   borderStyle - int32 
//   borderColor - CellsColor 
// Returns:
//   void  
func (instance *Range) SetOutlineBorders_CellBorderType_CellsColor(borderstyle CellBorderType, bordercolor *CellsColor)  error {
	
	var bordercolor_ptr unsafe.Pointer = nil
	if bordercolor != nil {
	  bordercolor_ptr =bordercolor.ptr
	}

	CGoReturnPtr := C.Range_SetOutlineBorders_CellBorderType_CellsColor( instance.ptr, C.int( int32(borderstyle)), bordercolor_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Sets the outline borders around a range of cells with same border style and color.
// Parameters:
//   borderStyle - int32 
//   borderColor - Color 
// Returns:
//   void  
func (instance *Range) SetOutlineBorders_CellBorderType_Color(borderstyle CellBorderType, bordercolor *Color)  error {
	
	CGoReturnPtr := C.Range_SetOutlineBorders_CellBorderType_Color( instance.ptr, C.int( int32(borderstyle)), bordercolor.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Sets out line borders around a range of cells.
// Parameters:
//   borderStyles - []CellBorderType 
//   borderColors - []Color 
// Returns:
//   void  
func (instance *Range) SetOutlineBorders_CellBorderTypeArray_ColorArray(borderstyles []CellBorderType, bordercolors []Color)  error {
	
	bordercolors_length := len(bordercolors)
	vector_bordercolors:= make([]unsafe.Pointer, bordercolors_length)
	for i := 0; i < bordercolors_length; i++ {
		vector_bordercolors[i] = bordercolors[i].ptr
	}


	CGoReturnPtr := C.Range_SetOutlineBorders_CellBorderTypeArray_ColorArray( instance.ptr, unsafe.Pointer(&borderstyles[0]), C.int( len(borderstyles)), unsafe.Pointer(&vector_bordercolors[0]), C.int( len(bordercolors)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Sets outline border around a range of cells.
// Parameters:
//   borderEdge - int32 
//   borderStyle - int32 
//   borderColor - CellsColor 
// Returns:
//   void  
func (instance *Range) SetOutlineBorder_BorderType_CellBorderType_CellsColor(borderedge BorderType, borderstyle CellBorderType, bordercolor *CellsColor)  error {
	
	var bordercolor_ptr unsafe.Pointer = nil
	if bordercolor != nil {
	  bordercolor_ptr =bordercolor.ptr
	}

	CGoReturnPtr := C.Range_SetOutlineBorder_BorderType_CellBorderType_CellsColor( instance.ptr, C.int( int32(borderedge)), C.int( int32(borderstyle)), bordercolor_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Sets outline border around a range of cells.
// Parameters:
//   borderEdge - int32 
//   borderStyle - int32 
//   borderColor - Color 
// Returns:
//   void  
func (instance *Range) SetOutlineBorder_BorderType_CellBorderType_Color(borderedge BorderType, borderstyle CellBorderType, bordercolor *Color)  error {
	
	CGoReturnPtr := C.Range_SetOutlineBorder_BorderType_CellBorderType_Color( instance.ptr, C.int( int32(borderedge)), C.int( int32(borderstyle)), bordercolor.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Set inside borders of the range.
// Parameters:
//   borderEdge - int32 
//   lineStyle - int32 
//   borderColor - CellsColor 
// Returns:
//   void  
func (instance *Range) SetInsideBorders(borderedge BorderType, linestyle CellBorderType, bordercolor *CellsColor)  error {
	
	var bordercolor_ptr unsafe.Pointer = nil
	if bordercolor != nil {
	  bordercolor_ptr =bordercolor.ptr
	}

	CGoReturnPtr := C.Range_SetInsideBorders( instance.ptr, C.int( int32(borderedge)), C.int( int32(linestyle)), bordercolor_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Sets or gets the column width of this range
// Returns:
//   float64  
func (instance *Range) GetColumnWidth()  (float64,  error)  {
	
	CGoReturnPtr := C.Range_GetColumnWidth( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := float64(CGoReturnPtr.return_value) 

	return result, nil 
}
// Sets or gets the column width of this range
// Parameters:
//   value - float64 
// Returns:
//   void  
func (instance *Range) SetColumnWidth(value float64)  error {
	
	CGoReturnPtr := C.Range_SetColumnWidth( instance.ptr, C.double(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Sets or gets the height of rows in this range
// Returns:
//   float64  
func (instance *Range) GetRowHeight()  (float64,  error)  {
	
	CGoReturnPtr := C.Range_GetRowHeight( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := float64(CGoReturnPtr.return_value) 

	return result, nil 
}
// Sets or gets the height of rows in this range
// Parameters:
//   value - float64 
// Returns:
//   void  
func (instance *Range) SetRowHeight(value float64)  error {
	
	CGoReturnPtr := C.Range_SetRowHeight( instance.ptr, C.double(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Move the current range to the dest range.
// Parameters:
//   destRow - int32 
//   destColumn - int32 
// Returns:
//   void  
func (instance *Range) MoveTo(destrow int32, destcolumn int32)  error {
	
	CGoReturnPtr := C.Range_MoveTo( instance.ptr, C.int(destrow), C.int(destcolumn))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Copies cell data (including formulas) from a source range.
// Parameters:
//   range - Range 
// Returns:
//   void  
func (instance *Range) CopyData(range_ *Range)  error {
	
	var range__ptr unsafe.Pointer = nil
	if range_ != nil {
	  range__ptr =range_.ptr
	}

	CGoReturnPtr := C.Range_CopyData( instance.ptr, range__ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Copies cell value from a source range.
// Parameters:
//   range - Range 
// Returns:
//   void  
func (instance *Range) CopyValue(range_ *Range)  error {
	
	var range__ptr unsafe.Pointer = nil
	if range_ != nil {
	  range__ptr =range_.ptr
	}

	CGoReturnPtr := C.Range_CopyValue( instance.ptr, range__ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Copies style settings from a source range.
// Parameters:
//   range - Range 
// Returns:
//   void  
func (instance *Range) CopyStyle(range_ *Range)  error {
	
	var range__ptr unsafe.Pointer = nil
	if range_ != nil {
	  range__ptr =range_.ptr
	}

	CGoReturnPtr := C.Range_CopyStyle( instance.ptr, range__ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Copying the range with paste special options.
// Parameters:
//   range - Range 
//   options - PasteOptions 
// Returns:
//   void  
func (instance *Range) Copy_Range_PasteOptions(range_ *Range, options *PasteOptions)  error {
	
	var range__ptr unsafe.Pointer = nil
	if range_ != nil {
	  range__ptr =range_.ptr
	}
	var options_ptr unsafe.Pointer = nil
	if options != nil {
	  options_ptr =options.ptr
	}

	CGoReturnPtr := C.Range_Copy_Range_PasteOptions( instance.ptr, range__ptr, options_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Transpose (rotate) data from rows to columns or vice versa.
// Returns:
//   void  
func (instance *Range) Transpose()  error {
	
	CGoReturnPtr := C.Range_Transpose( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Copies data (including formulas), formatting, drawing objects etc. from a source range.
// Parameters:
//   range - Range 
// Returns:
//   void  
func (instance *Range) Copy_Range(range_ *Range)  error {
	
	var range__ptr unsafe.Pointer = nil
	if range_ != nil {
	  range__ptr =range_.ptr
	}

	CGoReturnPtr := C.Range_Copy_Range( instance.ptr, range__ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets <see cref="Cell"/> object in this range.
// Parameters:
//   rowOffset - int32 
//   columnOffset - int32 
// Returns:
//   Cell  
func (instance *Range) Get(rowoffset int32, columnoffset int32)  (*Cell,  error)  {
	
	CGoReturnPtr := C.Range_Get( instance.ptr, C.int(rowoffset), C.int(columnoffset))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Cell{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteCell) 

	return result, nil 
}
// Gets <see cref="Cell"/> object or null in this range.
// Parameters:
//   rowOffset - int32 
//   columnOffset - int32 
// Returns:
//   Cell  
func (instance *Range) GetCellOrNull(rowoffset int32, columnoffset int32)  (*Cell,  error)  {
	
	CGoReturnPtr := C.Range_GetCellOrNull( instance.ptr, C.int(rowoffset), C.int(columnoffset))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Cell{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteCell) 

	return result, nil 
}
// Gets <see cref="Range"/> range by offset.
// Parameters:
//   rowOffset - int32 
//   columnOffset - int32 
// Returns:
//   Range  
func (instance *Range) GetOffset(rowoffset int32, columnoffset int32)  (*Range,  error)  {
	
	CGoReturnPtr := C.Range_GetOffset( instance.ptr, C.int(rowoffset), C.int(columnoffset))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Range{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteRange) 

	return result, nil 
}
// Gets a Range object that represents the entire column (or columns) that contains the specified range.
// Returns:
//   Range  
func (instance *Range) GetEntireColumn()  (*Range,  error)  {
	
	CGoReturnPtr := C.Range_GetEntireColumn( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Range{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteRange) 

	return result, nil 
}
// Gets a Range object that represents the entire row (or rows) that contains the specified range.
// Returns:
//   Range  
func (instance *Range) GetEntireRow()  (*Range,  error)  {
	
	CGoReturnPtr := C.Range_GetEntireRow( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Range{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteRange) 

	return result, nil 
}
// Gets the <see cref="Worksheet"/>object which contains this range.
// Returns:
//   Worksheet  
func (instance *Range) GetWorksheet()  (*Worksheet,  error)  {
	
	CGoReturnPtr := C.Range_GetWorksheet( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Worksheet{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteWorksheet) 

	return result, nil 
}
// Returns a string represents the current Range object.
// Returns:
//   string  
func (instance *Range) ToString()  (string,  error)  {
	
	CGoReturnPtr := C.Range_ToString( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Converts the range to image.
// Parameters:
//   options - ImageOrPrintOptions 
// Returns:
//   []byte  
func (instance *Range) ToImage(options *ImageOrPrintOptions)  ([]byte,  error)  {
	
	var options_ptr unsafe.Pointer = nil
	if options != nil {
	  options_ptr =options.ptr
	}

	CGoReturnPtr := C.Range_ToImage( instance.ptr, options_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := C.GoBytes(unsafe.Pointer(CGoReturnPtr.return_value), C.int(CGoReturnPtr.column_length))
	 

	return result, nil 
}
// Convert the range to JSON value.
// Parameters:
//   options - JsonSaveOptions 
// Returns:
//   string  
func (instance *Range) ToJson(options *JsonSaveOptions)  (string,  error)  {
	
	var options_ptr unsafe.Pointer = nil
	if options != nil {
	  options_ptr =options.ptr
	}

	CGoReturnPtr := C.Range_ToJson( instance.ptr, options_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Convert the range to html .
// Parameters:
//   saveOptions - HtmlSaveOptions 
// Returns:
//   []byte  
func (instance *Range) ToHtml(saveoptions *HtmlSaveOptions)  ([]byte,  error)  {
	
	var saveoptions_ptr unsafe.Pointer = nil
	if saveoptions != nil {
	  saveoptions_ptr =saveoptions.ptr
	}

	CGoReturnPtr := C.Range_ToHtml( instance.ptr, saveoptions_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := C.GoBytes(unsafe.Pointer(CGoReturnPtr.return_value), C.int(CGoReturnPtr.column_length))
	 

	return result, nil 
}
// Clears this range.
// Returns:
//   void  
func (instance *Range) Clear()  error {
	
	CGoReturnPtr := C.Range_Clear( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Clears the contents of this range.
// Returns:
//   void  
func (instance *Range) ClearContents()  error {
	
	CGoReturnPtr := C.Range_ClearContents( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Clears the formats of this range.
// Returns:
//   void  
func (instance *Range) ClearFormats()  error {
	
	CGoReturnPtr := C.Range_ClearFormats( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Clears the comments of this range.
// Returns:
//   void  
func (instance *Range) ClearComments()  error {
	
	CGoReturnPtr := C.Range_ClearComments( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Only removes hyperlinks.
// Parameters:
//   clearFormat - bool 
// Returns:
//   void  
func (instance *Range) ClearHyperlinks(clearformat bool)  error {
	
	CGoReturnPtr := C.Range_ClearHyperlinks( instance.ptr, C.bool(clearformat))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}



func DeleteRange(range_ *Range){
	runtime.SetFinalizer(range_, nil)
	C.Delete_Range(range_.ptr)
	range_.ptr = nil
}

// Class RangeCollection 

// Encapsulates a collection of <see cref="Range"/> objects.
type RangeCollection struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *RangeCollection) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.RangeCollection_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the <see cref="Range"/> element at the specified index.
// Parameters:
//   index - int32 
// Returns:
//   Range  
func (instance *RangeCollection) Get(index int32)  (*Range,  error)  {
	
	CGoReturnPtr := C.RangeCollection_Get( instance.ptr, C.int(index))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Range{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteRange) 

	return result, nil 
}
// Adds a <see cref="Range"/> item to the collection.
// Parameters:
//   range - Range 
// Returns:
//   int32  
func (instance *RangeCollection) Add(range_ *Range)  (int32,  error)  {
	
	var range__ptr unsafe.Pointer = nil
	if range_ != nil {
	  range__ptr =range_.ptr
	}

	CGoReturnPtr := C.RangeCollection_Add( instance.ptr, range__ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Returns:
//   int32  
func (instance *RangeCollection) GetCount()  (int32,  error)  {
	
	CGoReturnPtr := C.RangeCollection_GetCount( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}



func DeleteRangeCollection(rangecollection *RangeCollection){
	runtime.SetFinalizer(rangecollection, nil)
	C.Delete_RangeCollection(rangecollection.ptr)
	rangecollection.ptr = nil
}

// Class ReferredArea 

// Represents a referred area by the formula.
type ReferredArea struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *ReferredArea) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.ReferredArea_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether this is an external link.
// Returns:
//   bool  
func (instance *ReferredArea) IsExternalLink()  (bool,  error)  {
	
	CGoReturnPtr := C.ReferredArea_IsExternalLink( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Get the external file name if this is an external reference.
// Returns:
//   string  
func (instance *ReferredArea) GetExternalFileName()  (string,  error)  {
	
	CGoReturnPtr := C.ReferredArea_GetExternalFileName( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates which sheet this reference is in.
// Returns:
//   string  
func (instance *ReferredArea) GetSheetName()  (string,  error)  {
	
	CGoReturnPtr := C.ReferredArea_GetSheetName( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Names of all the worksheets this instance references to.
// Returns:
//   []string  
func (instance *ReferredArea) GetSheetNames()  ([]string,  error)  {
	
	CGoReturnPtr := C.ReferredArea_GetSheetNames( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result:= make([]string, CGoReturnPtr.column_length)
	for i := 0; i < int(CGoReturnPtr.column_length); i++ {
	   offset := uintptr(C.size_t(i)) * uintptr(CGoReturnPtr.size)
	   cObject := *(*C.char)(unsafe.Pointer( uintptr( unsafe.Pointer(CGoReturnPtr.return_value)) + offset))
	   goObject :=string(cObject)
	   result[i] = goObject
	}
	 

	return result, nil 
}
// Indicates whether this area contains all columns(entire row).
// Returns:
//   bool  
func (instance *ReferredArea) IsEntireRow()  (bool,  error)  {
	
	CGoReturnPtr := C.ReferredArea_IsEntireRow( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether this area contains all rows(entire column).
// Returns:
//   bool  
func (instance *ReferredArea) IsEntireColumn()  (bool,  error)  {
	
	CGoReturnPtr := C.ReferredArea_IsEntireColumn( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether this is an area.
// Returns:
//   bool  
func (instance *ReferredArea) IsArea()  (bool,  error)  {
	
	CGoReturnPtr := C.ReferredArea_IsArea( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// The end column of the area.
// Returns:
//   int32  
func (instance *ReferredArea) GetEndColumn()  (int32,  error)  {
	
	CGoReturnPtr := C.ReferredArea_GetEndColumn( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// The start column of the area.
// Returns:
//   int32  
func (instance *ReferredArea) GetStartColumn()  (int32,  error)  {
	
	CGoReturnPtr := C.ReferredArea_GetStartColumn( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// The end row of the area.
// Returns:
//   int32  
func (instance *ReferredArea) GetEndRow()  (int32,  error)  {
	
	CGoReturnPtr := C.ReferredArea_GetEndRow( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// The start row of the area.
// Returns:
//   int32  
func (instance *ReferredArea) GetStartRow()  (int32,  error)  {
	
	CGoReturnPtr := C.ReferredArea_GetStartRow( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets cell values in this area.
// Returns:
//   Object  
func (instance *ReferredArea) GetValues()  (*Object,  error)  {
	
	CGoReturnPtr := C.ReferredArea_GetValues( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Object{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteObject) 

	return result, nil 
}
// Gets cell values in this area.
// Parameters:
//   calculateFormulas - bool 
// Returns:
//   Object  
func (instance *ReferredArea) GetValues_Bool(calculateformulas bool)  (*Object,  error)  {
	
	CGoReturnPtr := C.ReferredArea_GetValues_Boolean( instance.ptr, C.bool(calculateformulas))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Object{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteObject) 

	return result, nil 
}
// Gets cell value with given offset from the top-left of this area.
// Parameters:
//   rowOffset - int32 
//   colOffset - int32 
// Returns:
//   Object  
func (instance *ReferredArea) GetValue_Int_Int(rowoffset int32, coloffset int32)  (*Object,  error)  {
	
	CGoReturnPtr := C.ReferredArea_GetValue_Integer_Integer( instance.ptr, C.int(rowoffset), C.int(coloffset))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Object{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteObject) 

	return result, nil 
}
// Gets cell value with given offset from the top-left of this area.
// Parameters:
//   rowOffset - int32 
//   colOffset - int32 
//   calculateFormulas - bool 
// Returns:
//   Object  
func (instance *ReferredArea) GetValue_Int_Int_Bool(rowoffset int32, coloffset int32, calculateformulas bool)  (*Object,  error)  {
	
	CGoReturnPtr := C.ReferredArea_GetValue_Integer_Integer_Boolean( instance.ptr, C.int(rowoffset), C.int(coloffset), C.bool(calculateformulas))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Object{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteObject) 

	return result, nil 
}
// Returns the reference address of this area.
// Generally it is the address of the reference which may be used in formula, such as "Sheet1!A1:C3".
// Returns:
//   string  
func (instance *ReferredArea) ToString()  (string,  error)  {
	
	CGoReturnPtr := C.ReferredArea_ToString( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}



func DeleteReferredArea(referredarea *ReferredArea){
	runtime.SetFinalizer(referredarea, nil)
	C.Delete_ReferredArea(referredarea.ptr)
	referredarea.ptr = nil
}

// Class ReferredAreaCollection 

// Represents all referred cells and areas.
type ReferredAreaCollection struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *ReferredAreaCollection) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.ReferredAreaCollection_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Parameters:
//   index - int32 
// Returns:
//   ReferredArea  
func (instance *ReferredAreaCollection) Get(index int32)  (*ReferredArea,  error)  {
	
	CGoReturnPtr := C.ReferredAreaCollection_Get( instance.ptr, C.int(index))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &ReferredArea{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteReferredArea) 

	return result, nil 
}
// Returns:
//   int32  
func (instance *ReferredAreaCollection) GetCount()  (int32,  error)  {
	
	CGoReturnPtr := C.ReferredAreaCollection_GetCount( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}



func DeleteReferredAreaCollection(referredareacollection *ReferredAreaCollection){
	runtime.SetFinalizer(referredareacollection, nil)
	C.Delete_ReferredAreaCollection(referredareacollection.ptr)
	referredareacollection.ptr = nil
}

// Class ReplaceOptions 

// Represent the replace options.
type ReplaceOptions struct {
	ptr unsafe.Pointer
}

// Default constructor.
func NewReplaceOptions() ( *ReplaceOptions, error) {
	replaceoptions := &ReplaceOptions{}
	CGoReturnPtr := C.New_ReplaceOptions()
	if CGoReturnPtr.error_no == 0 {
		replaceoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(replaceoptions, DeleteReplaceOptions)
		return replaceoptions, nil
	} else {
		replaceoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return replaceoptions, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *ReplaceOptions) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.ReplaceOptions_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates if the searched string is case sensitive.
// Returns:
//   bool  
func (instance *ReplaceOptions) GetCaseSensitive()  (bool,  error)  {
	
	CGoReturnPtr := C.ReplaceOptions_GetCaseSensitive( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates if the searched string is case sensitive.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *ReplaceOptions) SetCaseSensitive(value bool)  error {
	
	CGoReturnPtr := C.ReplaceOptions_SetCaseSensitive( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether to match entire cells contents
// Returns:
//   bool  
func (instance *ReplaceOptions) GetMatchEntireCellContents()  (bool,  error)  {
	
	CGoReturnPtr := C.ReplaceOptions_GetMatchEntireCellContents( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether to match entire cells contents
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *ReplaceOptions) SetMatchEntireCellContents(value bool)  error {
	
	CGoReturnPtr := C.ReplaceOptions_SetMatchEntireCellContents( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether the searched key is regex. If true then the searched key will be taken as regex.
// Returns:
//   bool  
func (instance *ReplaceOptions) GetRegexKey()  (bool,  error)  {
	
	CGoReturnPtr := C.ReplaceOptions_GetRegexKey( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether the searched key is regex. If true then the searched key will be taken as regex.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *ReplaceOptions) SetRegexKey(value bool)  error {
	
	CGoReturnPtr := C.ReplaceOptions_SetRegexKey( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// The rich formatted settings for the replaced text.
// Returns:
//   []FontSetting  
func (instance *ReplaceOptions) GetFontSettings()  ([]FontSetting,  error)  {
	
	CGoReturnPtr := C.ReplaceOptions_GetFontSettings( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result:= make([]FontSetting, CGoReturnPtr.column_length)
	for i := 0; i < int(CGoReturnPtr.column_length); i++ {
	   offset := uintptr(C.size_t(i)) * uintptr(CGoReturnPtr.size)
	   goObject := &FontSetting{}
	   goObject.ptr =unsafe.Pointer(uintptr( unsafe.Pointer(CGoReturnPtr.return_value)) + offset)
	   result[i] = *goObject
	}
	 

	return result, nil 
}
// The rich formatted settings for the replaced text.
// Parameters:
//   value - []FontSetting 
// Returns:
//   void  
func (instance *ReplaceOptions) SetFontSettings(value []FontSetting)  error {
	
	value_length := len(value)
	vector_value:= make([]unsafe.Pointer, value_length)
	for i := 0; i < value_length; i++ {
		vector_value[i] = value[i].ptr
	}


	CGoReturnPtr := C.ReplaceOptions_SetFontSettings( instance.ptr, unsafe.Pointer(&vector_value[0]), C.int( len(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets flags of applying font settings.
// Returns:
//   []StyleFlag  
func (instance *ReplaceOptions) GetStyleFlags()  ([]StyleFlag,  error)  {
	
	CGoReturnPtr := C.ReplaceOptions_GetStyleFlags( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result:= make([]StyleFlag, CGoReturnPtr.column_length)
	for i := 0; i < int(CGoReturnPtr.column_length); i++ {
	   offset := uintptr(C.size_t(i)) * uintptr(CGoReturnPtr.size)
	   goObject := &StyleFlag{}
	   goObject.ptr =unsafe.Pointer(uintptr( unsafe.Pointer(CGoReturnPtr.return_value)) + offset)
	   result[i] = *goObject
	}
	 

	return result, nil 
}
// Gets and sets flags of applying font settings.
// Parameters:
//   value - []StyleFlag 
// Returns:
//   void  
func (instance *ReplaceOptions) SetStyleFlags(value []StyleFlag)  error {
	
	value_length := len(value)
	vector_value:= make([]unsafe.Pointer, value_length)
	for i := 0; i < value_length; i++ {
		vector_value[i] = value[i].ptr
	}


	CGoReturnPtr := C.ReplaceOptions_SetStyleFlags( instance.ptr, unsafe.Pointer(&vector_value[0]), C.int( len(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}



func DeleteReplaceOptions(replaceoptions *ReplaceOptions){
	runtime.SetFinalizer(replaceoptions, nil)
	C.Delete_ReplaceOptions(replaceoptions.ptr)
	replaceoptions.ptr = nil
}

// Class Row 

// Represents a single row in a worksheet.
type Row struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *Row) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.Row_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Get the cell by specific index in the cells collection of this row.
// Parameters:
//   index - int32 
// Returns:
//   Cell  
func (instance *Row) GetCellByIndex(index int32)  (*Cell,  error)  {
	
	CGoReturnPtr := C.Row_GetCellByIndex( instance.ptr, C.int(index))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Cell{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteCell) 

	return result, nil 
}
// Indicates whether the row contains any data
// Returns:
//   bool  
func (instance *Row) IsBlank()  (bool,  error)  {
	
	CGoReturnPtr := C.Row_IsBlank( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the cell.
// Parameters:
//   column - int32 
// Returns:
//   Cell  
func (instance *Row) Get(column int32)  (*Cell,  error)  {
	
	CGoReturnPtr := C.Row_Get( instance.ptr, C.int(column))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Cell{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteCell) 

	return result, nil 
}
// Gets the cells enumerator
// Returns:
//   unsafe.Pointer  
func (instance *Row) GetEnumerator()  (*CellEnumerator,  error)  {
	
	CGoReturnPtr := C.Row_GetEnumerator( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &CellEnumerator{}
	result.ptr = CGoReturnPtr.return_value
	runtime.SetFinalizer(result, DeleteCellEnumerator)
	 

	return result, nil 
}
// Gets an enumerator that iterates cells through this row.
// Parameters:
//   reversed - bool 
//   sync - bool 
// Returns:
//   unsafe.Pointer  
func (instance *Row) GetEnumerator_Bool_Bool(reversed bool, sync bool)  (*CellEnumerator,  error)  {
	
	CGoReturnPtr := C.Row_GetEnumerator_Boolean_Boolean( instance.ptr, C.bool(reversed), C.bool(sync))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &CellEnumerator{}
	result.ptr = CGoReturnPtr.return_value
	runtime.SetFinalizer(result, DeleteCellEnumerator)
	 

	return result, nil 
}
// Gets the cell or null in the specific index.
// Parameters:
//   column - int32 
// Returns:
//   Cell  
func (instance *Row) GetCellOrNull(column int32)  (*Cell,  error)  {
	
	CGoReturnPtr := C.Row_GetCellOrNull( instance.ptr, C.int(column))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Cell{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteCell) 

	return result, nil 
}
// whether the row is collapsed
// Returns:
//   bool  
func (instance *Row) IsCollapsed()  (bool,  error)  {
	
	CGoReturnPtr := C.Row_IsCollapsed( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// whether the row is collapsed
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Row) SetIsCollapsed(value bool)  error {
	
	CGoReturnPtr := C.Row_SetIsCollapsed( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the row height in unit of Points.
// Returns:
//   float64  
func (instance *Row) GetHeight()  (float64,  error)  {
	
	CGoReturnPtr := C.Row_GetHeight( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := float64(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the row height in unit of Points.
// Parameters:
//   value - float64 
// Returns:
//   void  
func (instance *Row) SetHeight(value float64)  error {
	
	CGoReturnPtr := C.Row_SetHeight( instance.ptr, C.double(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether the row is hidden.
// Returns:
//   bool  
func (instance *Row) IsHidden()  (bool,  error)  {
	
	CGoReturnPtr := C.Row_IsHidden( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether the row is hidden.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Row) SetIsHidden(value bool)  error {
	
	CGoReturnPtr := C.Row_SetIsHidden( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the index of this row.
// Returns:
//   int32  
func (instance *Row) GetIndex()  (int32,  error)  {
	
	CGoReturnPtr := C.Row_GetIndex( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the group level of the row.
// Returns:
//   byte  
func (instance *Row) GetGroupLevel()  (byte,  error)  {
	
	CGoReturnPtr := C.Row_GetGroupLevel( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := byte(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the group level of the row.
// Parameters:
//   value - byte 
// Returns:
//   void  
func (instance *Row) SetGroupLevel(value byte)  error {
	
	CGoReturnPtr := C.Row_SetGroupLevel( instance.ptr, C.uint8_t(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether the row height matches current default font setting of the workbook.
// True of this property also denotes the row height is "automatic" without custom height value set by user.
// Returns:
//   bool  
func (instance *Row) IsHeightMatched()  (bool,  error)  {
	
	CGoReturnPtr := C.Row_IsHeightMatched( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether the row height matches current default font setting of the workbook.
// True of this property also denotes the row height is "automatic" without custom height value set by user.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Row) SetIsHeightMatched(value bool)  error {
	
	CGoReturnPtr := C.Row_SetIsHeightMatched( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the style of this row.
// Returns:
//   Style  
func (instance *Row) GetStyle()  (*Style,  error)  {
	
	CGoReturnPtr := C.Row_GetStyle( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Style{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteStyle) 

	return result, nil 
}
// Sets the style of this row.
// Parameters:
//   style - Style 
// Returns:
//   void  
func (instance *Row) SetStyle(style *Style)  error {
	
	var style_ptr unsafe.Pointer = nil
	if style != nil {
	  style_ptr =style.ptr
	}

	CGoReturnPtr := C.Row_SetStyle( instance.ptr, style_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether this row has custom style settings(different from the default one inherited from workbook).
// Returns:
//   bool  
func (instance *Row) GetHasCustomStyle()  (bool,  error)  {
	
	CGoReturnPtr := C.Row_GetHasCustomStyle( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Copy settings of row, such as style, height, visibility, ...etc.
// Parameters:
//   source - Row 
//   checkStyle - bool 
// Returns:
//   void  
func (instance *Row) CopySettings(source *Row, checkstyle bool)  error {
	
	var source_ptr unsafe.Pointer = nil
	if source != nil {
	  source_ptr =source.ptr
	}

	CGoReturnPtr := C.Row_CopySettings( instance.ptr, source_ptr, C.bool(checkstyle))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the first cell object in the row.
// Returns:
//   Cell  
func (instance *Row) GetFirstCell()  (*Cell,  error)  {
	
	CGoReturnPtr := C.Row_GetFirstCell( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Cell{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteCell) 

	return result, nil 
}
// Gets the first non-blank cell in the row.
// Returns:
//   Cell  
func (instance *Row) GetFirstDataCell()  (*Cell,  error)  {
	
	CGoReturnPtr := C.Row_GetFirstDataCell( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Cell{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteCell) 

	return result, nil 
}
// Gets the last cell object in the row.
// Returns:
//   Cell  
func (instance *Row) GetLastCell()  (*Cell,  error)  {
	
	CGoReturnPtr := C.Row_GetLastCell( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Cell{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteCell) 

	return result, nil 
}
// Gets the last non-blank cell in the row.
// Returns:
//   Cell  
func (instance *Row) GetLastDataCell()  (*Cell,  error)  {
	
	CGoReturnPtr := C.Row_GetLastDataCell( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Cell{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteCell) 

	return result, nil 
}
// Applies formats for a whole row.
// Parameters:
//   style - Style 
//   flag - StyleFlag 
// Returns:
//   void  
func (instance *Row) ApplyStyle(style *Style, flag *StyleFlag)  error {
	
	var style_ptr unsafe.Pointer = nil
	if style != nil {
	  style_ptr =style.ptr
	}
	var flag_ptr unsafe.Pointer = nil
	if flag != nil {
	  flag_ptr =flag.ptr
	}

	CGoReturnPtr := C.Row_ApplyStyle( instance.ptr, style_ptr, flag_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Checks whether this object refers to the same row with another.
// Parameters:
//   obj - Object 
// Returns:
//   bool  
func (instance *Row) Equals_Object(obj *Object)  (bool,  error)  {
	
	var obj_ptr unsafe.Pointer = nil
	if obj != nil {
	  obj_ptr =obj.ptr
	}

	CGoReturnPtr := C.Row_Equals_Object( instance.ptr, obj_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Checks whether this object refers to the same row with another row object.
// Parameters:
//   row - Row 
// Returns:
//   bool  
func (instance *Row) Equals_Row(row *Row)  (bool,  error)  {
	
	var row_ptr unsafe.Pointer = nil
	if row != nil {
	  row_ptr =row.ptr
	}

	CGoReturnPtr := C.Row_Equals_Row( instance.ptr, row_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}



func DeleteRow(row *Row){
	runtime.SetFinalizer(row, nil)
	C.Delete_Row(row.ptr)
	row.ptr = nil
}

// Class RowCollection 

// Collects the <see cref="Row"/> objects that represent the individual rows in a worksheet.
type RowCollection struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *RowCollection) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.RowCollection_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the number of rows in this collection.
// Returns:
//   int32  
func (instance *RowCollection) GetCount()  (int32,  error)  {
	
	CGoReturnPtr := C.RowCollection_GetCount( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets an enumerator that iterates rows through this collection
// Returns:
//   unsafe.Pointer  
func (instance *RowCollection) GetEnumerator()  (*RowEnumerator,  error)  {
	
	CGoReturnPtr := C.RowCollection_GetEnumerator( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &RowEnumerator{}
	result.ptr = CGoReturnPtr.return_value
	runtime.SetFinalizer(result, DeleteRowEnumerator)
	 

	return result, nil 
}
// Gets an enumerator that iterates rows through this collection
// Parameters:
//   reversed - bool 
//   sync - bool 
// Returns:
//   unsafe.Pointer  
func (instance *RowCollection) GetEnumerator_Bool_Bool(reversed bool, sync bool)  (*RowEnumerator,  error)  {
	
	CGoReturnPtr := C.RowCollection_GetEnumerator_Boolean_Boolean( instance.ptr, C.bool(reversed), C.bool(sync))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &RowEnumerator{}
	result.ptr = CGoReturnPtr.return_value
	runtime.SetFinalizer(result, DeleteRowEnumerator)
	 

	return result, nil 
}
// Gets the row object by the position in the list.
// Parameters:
//   index - int32 
// Returns:
//   Row  
func (instance *RowCollection) GetRowByIndex(index int32)  (*Row,  error)  {
	
	CGoReturnPtr := C.RowCollection_GetRowByIndex( instance.ptr, C.int(index))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Row{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteRow) 

	return result, nil 
}
// Gets a <see cref="Row"/> object by given row index. The Row object of given row index will be instantiated if it does not exist before.
// Parameters:
//   rowIndex - int32 
// Returns:
//   Row  
func (instance *RowCollection) Get(rowindex int32)  (*Row,  error)  {
	
	CGoReturnPtr := C.RowCollection_Get( instance.ptr, C.int(rowindex))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Row{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteRow) 

	return result, nil 
}
// Clear all rows and cells.
// Returns:
//   void  
func (instance *RowCollection) Clear()  error {
	
	CGoReturnPtr := C.RowCollection_Clear( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Remove the row item at the specified index(position) in this collection.
// Parameters:
//   index - int32 
// Returns:
//   void  
func (instance *RowCollection) RemoveAt(index int32)  error {
	
	CGoReturnPtr := C.RowCollection_RemoveAt( instance.ptr, C.int(index))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}



func DeleteRowCollection(rowcollection *RowCollection){
	runtime.SetFinalizer(rowcollection, nil)
	C.Delete_RowCollection(rowcollection.ptr)
	rowcollection.ptr = nil
}

// Class SaveOptions 

// Represents all save options
type SaveOptions struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *SaveOptions) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.SaveOptions_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the save file format.
// Returns:
//   int32  
func (instance *SaveOptions) GetSaveFormat()  (SaveFormat,  error)  {
	
	CGoReturnPtr := C.SaveOptions_GetSaveFormat( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToSaveFormat(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Make the workbook empty after saving the file.
// Returns:
//   bool  
func (instance *SaveOptions) GetClearData()  (bool,  error)  {
	
	CGoReturnPtr := C.SaveOptions_GetClearData( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Make the workbook empty after saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *SaveOptions) SetClearData(value bool)  error {
	
	CGoReturnPtr := C.SaveOptions_SetClearData( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// The folder for temporary files that may be used as data cache.
// Returns:
//   string  
func (instance *SaveOptions) GetCachedFileFolder()  (string,  error)  {
	
	CGoReturnPtr := C.SaveOptions_GetCachedFileFolder( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// The folder for temporary files that may be used as data cache.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *SaveOptions) SetCachedFileFolder(value string)  error {
	
	CGoReturnPtr := C.SaveOptions_SetCachedFileFolder( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether validate merged cells before saving the file.
// Returns:
//   bool  
func (instance *SaveOptions) GetValidateMergedAreas()  (bool,  error)  {
	
	CGoReturnPtr := C.SaveOptions_GetValidateMergedAreas( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether validate merged cells before saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *SaveOptions) SetValidateMergedAreas(value bool)  error {
	
	CGoReturnPtr := C.SaveOptions_SetValidateMergedAreas( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether merge the areas of conditional formatting and validation before saving the file.
// Returns:
//   bool  
func (instance *SaveOptions) GetMergeAreas()  (bool,  error)  {
	
	CGoReturnPtr := C.SaveOptions_GetMergeAreas( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether merge the areas of conditional formatting and validation before saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *SaveOptions) SetMergeAreas(value bool)  error {
	
	CGoReturnPtr := C.SaveOptions_SetMergeAreas( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// If true and the directory does not exist, the directory will be automatically created before saving the file.
// Returns:
//   bool  
func (instance *SaveOptions) GetCreateDirectory()  (bool,  error)  {
	
	CGoReturnPtr := C.SaveOptions_GetCreateDirectory( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// If true and the directory does not exist, the directory will be automatically created before saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *SaveOptions) SetCreateDirectory(value bool)  error {
	
	CGoReturnPtr := C.SaveOptions_SetCreateDirectory( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether sorting defined names before saving file.
// Returns:
//   bool  
func (instance *SaveOptions) GetSortNames()  (bool,  error)  {
	
	CGoReturnPtr := C.SaveOptions_GetSortNames( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether sorting defined names before saving file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *SaveOptions) SetSortNames(value bool)  error {
	
	CGoReturnPtr := C.SaveOptions_SetSortNames( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether sorting external defined names before saving file.
// Returns:
//   bool  
func (instance *SaveOptions) GetSortExternalNames()  (bool,  error)  {
	
	CGoReturnPtr := C.SaveOptions_GetSortExternalNames( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether sorting external defined names before saving file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *SaveOptions) SetSortExternalNames(value bool)  error {
	
	CGoReturnPtr := C.SaveOptions_SetSortExternalNames( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether refreshing chart cache data
// Returns:
//   bool  
func (instance *SaveOptions) GetRefreshChartCache()  (bool,  error)  {
	
	CGoReturnPtr := C.SaveOptions_GetRefreshChartCache( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether refreshing chart cache data
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *SaveOptions) SetRefreshChartCache(value bool)  error {
	
	CGoReturnPtr := C.SaveOptions_SetRefreshChartCache( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Whether check restriction of excel file when user modify cells related objects.
// For example, excel does not allow inputting string value longer than 32K.
// When you input a value longer than 32K, it will be truncated.
// Returns:
//   bool  
func (instance *SaveOptions) GetCheckExcelRestriction()  (bool,  error)  {
	
	CGoReturnPtr := C.SaveOptions_GetCheckExcelRestriction( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Whether check restriction of excel file when user modify cells related objects.
// For example, excel does not allow inputting string value longer than 32K.
// When you input a value longer than 32K, it will be truncated.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *SaveOptions) SetCheckExcelRestriction(value bool)  error {
	
	CGoReturnPtr := C.SaveOptions_SetCheckExcelRestriction( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether updating smart art setting.
// The default value is false.
// Returns:
//   bool  
func (instance *SaveOptions) GetUpdateSmartArt()  (bool,  error)  {
	
	CGoReturnPtr := C.SaveOptions_GetUpdateSmartArt( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether updating smart art setting.
// The default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *SaveOptions) SetUpdateSmartArt(value bool)  error {
	
	CGoReturnPtr := C.SaveOptions_SetUpdateSmartArt( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether encrypt document properties when saving as .xls file.
// The default value is true.
// Returns:
//   bool  
func (instance *SaveOptions) GetEncryptDocumentProperties()  (bool,  error)  {
	
	CGoReturnPtr := C.SaveOptions_GetEncryptDocumentProperties( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether encrypt document properties when saving as .xls file.
// The default value is true.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *SaveOptions) SetEncryptDocumentProperties(value bool)  error {
	
	CGoReturnPtr := C.SaveOptions_SetEncryptDocumentProperties( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}



func DeleteSaveOptions(saveoptions *SaveOptions){
	runtime.SetFinalizer(saveoptions, nil)
	C.Delete_SaveOptions(saveoptions.ptr)
	saveoptions.ptr = nil
}

// Class Scenario 

// Represents an individual scenario.
type Scenario struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *Scenario) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.Scenario_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the comment of scenario.
// Returns:
//   string  
func (instance *Scenario) GetComment()  (string,  error)  {
	
	CGoReturnPtr := C.Scenario_GetComment( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the comment of scenario.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *Scenario) SetComment(value string)  error {
	
	CGoReturnPtr := C.Scenario_SetComment( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the name of scenario.
// Returns:
//   string  
func (instance *Scenario) GetName()  (string,  error)  {
	
	CGoReturnPtr := C.Scenario_GetName( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the name of scenario.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *Scenario) SetName(value string)  error {
	
	CGoReturnPtr := C.Scenario_SetName( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets name of user who last changed the scenario.
// Returns:
//   string  
func (instance *Scenario) GetUser()  (string,  error)  {
	
	CGoReturnPtr := C.Scenario_GetUser( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether scenario is hidden.
// Returns:
//   bool  
func (instance *Scenario) IsHidden()  (bool,  error)  {
	
	CGoReturnPtr := C.Scenario_IsHidden( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether scenario is hidden.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Scenario) SetIsHidden(value bool)  error {
	
	CGoReturnPtr := C.Scenario_SetIsHidden( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether scenario is locked for editing when the sheet is protected.
// Returns:
//   bool  
func (instance *Scenario) IsLocked()  (bool,  error)  {
	
	CGoReturnPtr := C.Scenario_IsLocked( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether scenario is locked for editing when the sheet is protected.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Scenario) SetIsLocked(value bool)  error {
	
	CGoReturnPtr := C.Scenario_SetIsLocked( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the input cells of scenario.
// Returns:
//   ScenarioInputCellCollection  
func (instance *Scenario) GetInputCells()  (*ScenarioInputCellCollection,  error)  {
	
	CGoReturnPtr := C.Scenario_GetInputCells( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &ScenarioInputCellCollection{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteScenarioInputCellCollection) 

	return result, nil 
}



func DeleteScenario(scenario *Scenario){
	runtime.SetFinalizer(scenario, nil)
	C.Delete_Scenario(scenario.ptr)
	scenario.ptr = nil
}

// Class ScenarioCollection 

// Represents the list of scenarios.
type ScenarioCollection struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *ScenarioCollection) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.ScenarioCollection_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets which scenario is selected.
// Returns:
//   int32  
func (instance *ScenarioCollection) GetActiveIndex()  (int32,  error)  {
	
	CGoReturnPtr := C.ScenarioCollection_GetActiveIndex( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets which scenario is selected.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *ScenarioCollection) SetActiveIndex(value int32)  error {
	
	CGoReturnPtr := C.ScenarioCollection_SetActiveIndex( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates which scenario was last selected by the user to be run/shown.
// Returns:
//   int32  
func (instance *ScenarioCollection) GetLastSelected()  (int32,  error)  {
	
	CGoReturnPtr := C.ScenarioCollection_GetLastSelected( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates which scenario was last selected by the user to be run/shown.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *ScenarioCollection) SetLastSelected(value int32)  error {
	
	CGoReturnPtr := C.ScenarioCollection_SetLastSelected( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the <see cref="Scenario"/> object by the index.
// Parameters:
//   index - int32 
// Returns:
//   Scenario  
func (instance *ScenarioCollection) Get(index int32)  (*Scenario,  error)  {
	
	CGoReturnPtr := C.ScenarioCollection_Get( instance.ptr, C.int(index))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Scenario{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteScenario) 

	return result, nil 
}
// Adds a scenario.
// Parameters:
//   name - string 
// Returns:
//   int32  
func (instance *ScenarioCollection) Add(name string)  (int32,  error)  {
	
	CGoReturnPtr := C.ScenarioCollection_Add( instance.ptr, C.CString(name))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Returns:
//   int32  
func (instance *ScenarioCollection) GetCount()  (int32,  error)  {
	
	CGoReturnPtr := C.ScenarioCollection_GetCount( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}



func DeleteScenarioCollection(scenariocollection *ScenarioCollection){
	runtime.SetFinalizer(scenariocollection, nil)
	C.Delete_ScenarioCollection(scenariocollection.ptr)
	scenariocollection.ptr = nil
}

// Class ScenarioInputCell 

// Represents input cell for the scenario.
type ScenarioInputCell struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *ScenarioInputCell) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.ScenarioInputCell_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the row index of the input cell.
// Returns:
//   int32  
func (instance *ScenarioInputCell) GetRow()  (int32,  error)  {
	
	CGoReturnPtr := C.ScenarioInputCell_GetRow( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the column index of the input cell.
// Returns:
//   int32  
func (instance *ScenarioInputCell) GetColumn()  (int32,  error)  {
	
	CGoReturnPtr := C.ScenarioInputCell_GetColumn( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the input cell address.
// Returns:
//   string  
func (instance *ScenarioInputCell) GetName()  (string,  error)  {
	
	CGoReturnPtr := C.ScenarioInputCell_GetName( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets value of the input cell.
// Returns:
//   string  
func (instance *ScenarioInputCell) GetValue()  (string,  error)  {
	
	CGoReturnPtr := C.ScenarioInputCell_GetValue( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets value of the input cell.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *ScenarioInputCell) SetValue(value string)  error {
	
	CGoReturnPtr := C.ScenarioInputCell_SetValue( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether input cell is deleted.
// Returns:
//   bool  
func (instance *ScenarioInputCell) IsDeleted()  (bool,  error)  {
	
	CGoReturnPtr := C.ScenarioInputCell_IsDeleted( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether input cell is deleted.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *ScenarioInputCell) SetIsDeleted(value bool)  error {
	
	CGoReturnPtr := C.ScenarioInputCell_SetIsDeleted( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}



func DeleteScenarioInputCell(scenarioinputcell *ScenarioInputCell){
	runtime.SetFinalizer(scenarioinputcell, nil)
	C.Delete_ScenarioInputCell(scenarioinputcell.ptr)
	scenarioinputcell.ptr = nil
}

// Class ScenarioInputCellCollection 

// Represents the list of the scenario's input cells.
type ScenarioInputCellCollection struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *ScenarioInputCellCollection) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.ScenarioInputCellCollection_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets <see cref="ScenarioInputCell"/> by index in the list.
// Parameters:
//   index - int32 
// Returns:
//   ScenarioInputCell  
func (instance *ScenarioInputCellCollection) Get(index int32)  (*ScenarioInputCell,  error)  {
	
	CGoReturnPtr := C.ScenarioInputCellCollection_Get( instance.ptr, C.int(index))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &ScenarioInputCell{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteScenarioInputCell) 

	return result, nil 
}
// Adds an input cell.
// Parameters:
//   row - int32 
//   column - int32 
//   value - string 
// Returns:
//   int32  
func (instance *ScenarioInputCellCollection) Add(row int32, column int32, value string)  (int32,  error)  {
	
	CGoReturnPtr := C.ScenarioInputCellCollection_Add( instance.ptr, C.int(row), C.int(column), C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Returns:
//   int32  
func (instance *ScenarioInputCellCollection) GetCount()  (int32,  error)  {
	
	CGoReturnPtr := C.ScenarioInputCellCollection_GetCount( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}



func DeleteScenarioInputCellCollection(scenarioinputcellcollection *ScenarioInputCellCollection){
	runtime.SetFinalizer(scenarioinputcellcollection, nil)
	C.Delete_ScenarioInputCellCollection(scenarioinputcellcollection.ptr)
	scenarioinputcellcollection.ptr = nil
}

// Class SettableChartGlobalizationSettings 

// Implementation of PivotGlobalizationSettings that supports user to set/change pre-defined texts.
type SettableChartGlobalizationSettings struct {
	ptr unsafe.Pointer
}

// Default constructor.
func NewSettableChartGlobalizationSettings() ( *SettableChartGlobalizationSettings, error) {
	settablechartglobalizationsettings := &SettableChartGlobalizationSettings{}
	CGoReturnPtr := C.New_SettableChartGlobalizationSettings()
	if CGoReturnPtr.error_no == 0 {
		settablechartglobalizationsettings.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(settablechartglobalizationsettings, DeleteSettableChartGlobalizationSettings)
		return settablechartglobalizationsettings, nil
	} else {
		settablechartglobalizationsettings.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return settablechartglobalizationsettings, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *SettableChartGlobalizationSettings) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.SettableChartGlobalizationSettings_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the name of Series in the Chart.
// Returns:
//   string  
func (instance *SettableChartGlobalizationSettings) GetSeriesName()  (string,  error)  {
	
	CGoReturnPtr := C.SettableChartGlobalizationSettings_GetSeriesName( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Sets the name of Series in the Chart.
// Parameters:
//   name - string 
// Returns:
//   void  
func (instance *SettableChartGlobalizationSettings) SetSeriesName(name string)  error {
	
	CGoReturnPtr := C.SettableChartGlobalizationSettings_SetSeriesName( instance.ptr, C.CString(name))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the name of Chart Title.
// Returns:
//   string  
func (instance *SettableChartGlobalizationSettings) GetChartTitleName()  (string,  error)  {
	
	CGoReturnPtr := C.SettableChartGlobalizationSettings_GetChartTitleName( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Sets the name of Chart Title.
// Parameters:
//   name - string 
// Returns:
//   void  
func (instance *SettableChartGlobalizationSettings) SetChartTitleName(name string)  error {
	
	CGoReturnPtr := C.SettableChartGlobalizationSettings_SetChartTitleName( instance.ptr, C.CString(name))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the name of increase for Legend.
// Returns:
//   string  
func (instance *SettableChartGlobalizationSettings) GetLegendIncreaseName()  (string,  error)  {
	
	CGoReturnPtr := C.SettableChartGlobalizationSettings_GetLegendIncreaseName( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Sets the name of increase for Legend.
// Parameters:
//   name - string 
// Returns:
//   void  
func (instance *SettableChartGlobalizationSettings) SetLegendIncreaseName(name string)  error {
	
	CGoReturnPtr := C.SettableChartGlobalizationSettings_SetLegendIncreaseName( instance.ptr, C.CString(name))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the name of Decrease for Legend.
// Returns:
//   string  
func (instance *SettableChartGlobalizationSettings) GetLegendDecreaseName()  (string,  error)  {
	
	CGoReturnPtr := C.SettableChartGlobalizationSettings_GetLegendDecreaseName( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Sets the name of Decrease for Legend.
// Parameters:
//   name - string 
// Returns:
//   void  
func (instance *SettableChartGlobalizationSettings) SetLegendDecreaseName(name string)  error {
	
	CGoReturnPtr := C.SettableChartGlobalizationSettings_SetLegendDecreaseName( instance.ptr, C.CString(name))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the name of Total for Legend.
// Returns:
//   string  
func (instance *SettableChartGlobalizationSettings) GetLegendTotalName()  (string,  error)  {
	
	CGoReturnPtr := C.SettableChartGlobalizationSettings_GetLegendTotalName( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Sets the name of Total for Legend.
// Parameters:
//   name - string 
// Returns:
//   void  
func (instance *SettableChartGlobalizationSettings) SetLegendTotalName(name string)  error {
	
	CGoReturnPtr := C.SettableChartGlobalizationSettings_SetLegendTotalName( instance.ptr, C.CString(name))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the name of Title for Axis.
// Returns:
//   string  
func (instance *SettableChartGlobalizationSettings) GetAxisTitleName()  (string,  error)  {
	
	CGoReturnPtr := C.SettableChartGlobalizationSettings_GetAxisTitleName( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Sets the name of Title for Axis.
// Parameters:
//   name - string 
// Returns:
//   void  
func (instance *SettableChartGlobalizationSettings) SetAxisTitleName(name string)  error {
	
	CGoReturnPtr := C.SettableChartGlobalizationSettings_SetAxisTitleName( instance.ptr, C.CString(name))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the name of "Other" labels for Chart.
// Returns:
//   string  
func (instance *SettableChartGlobalizationSettings) GetOtherName()  (string,  error)  {
	
	CGoReturnPtr := C.SettableChartGlobalizationSettings_GetOtherName( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Sets the name of "Other" labels for Chart.
// Parameters:
//   name - string 
// Returns:
//   void  
func (instance *SettableChartGlobalizationSettings) SetOtherName(name string)  error {
	
	CGoReturnPtr := C.SettableChartGlobalizationSettings_SetOtherName( instance.ptr, C.CString(name))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the Name of Axis Unit.
// Parameters:
//   type - int32 
// Returns:
//   string  
func (instance *SettableChartGlobalizationSettings) GetAxisUnitName(type_ DisplayUnitType)  (string,  error)  {
	
	CGoReturnPtr := C.SettableChartGlobalizationSettings_GetAxisUnitName( instance.ptr, C.int( int32(type_)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Sets the Name of Axis Unit.
// Parameters:
//   type - int32 
//   name - string 
// Returns:
//   void  
func (instance *SettableChartGlobalizationSettings) SetAxisUnitName(type_ DisplayUnitType, name string)  error {
	
	CGoReturnPtr := C.SettableChartGlobalizationSettings_SetAxisUnitName( instance.ptr, C.int( int32(type_)), C.CString(name))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}



func DeleteSettableChartGlobalizationSettings(settablechartglobalizationsettings *SettableChartGlobalizationSettings){
	runtime.SetFinalizer(settablechartglobalizationsettings, nil)
	C.Delete_SettableChartGlobalizationSettings(settablechartglobalizationsettings.ptr)
	settablechartglobalizationsettings.ptr = nil
}

// Class SettableGlobalizationSettings 

// Implementation of GlobalizationSettings that supports user to set/change pre-defined texts.
type SettableGlobalizationSettings struct {
	ptr unsafe.Pointer
}

// Default constructor.
func NewSettableGlobalizationSettings() ( *SettableGlobalizationSettings, error) {
	settableglobalizationsettings := &SettableGlobalizationSettings{}
	CGoReturnPtr := C.New_SettableGlobalizationSettings()
	if CGoReturnPtr.error_no == 0 {
		settableglobalizationsettings.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(settableglobalizationsettings, DeleteSettableGlobalizationSettings)
		return settableglobalizationsettings, nil
	} else {
		settableglobalizationsettings.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return settableglobalizationsettings, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *SettableGlobalizationSettings) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.SettableGlobalizationSettings_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the total name of specific function.
// Parameters:
//   functionType - int32 
// Returns:
//   string  
func (instance *SettableGlobalizationSettings) GetTotalName(functiontype ConsolidationFunction)  (string,  error)  {
	
	CGoReturnPtr := C.SettableGlobalizationSettings_GetTotalName( instance.ptr, C.int( int32(functiontype)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Sets the total name of specific function.
// Parameters:
//   functionType - int32 
//   name - string 
// Returns:
//   void  
func (instance *SettableGlobalizationSettings) SetTotalName(functiontype ConsolidationFunction, name string)  error {
	
	CGoReturnPtr := C.SettableGlobalizationSettings_SetTotalName( instance.ptr, C.int( int32(functiontype)), C.CString(name))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the grand total name of the function.
// Parameters:
//   functionType - int32 
// Returns:
//   string  
func (instance *SettableGlobalizationSettings) GetGrandTotalName(functiontype ConsolidationFunction)  (string,  error)  {
	
	CGoReturnPtr := C.SettableGlobalizationSettings_GetGrandTotalName( instance.ptr, C.int( int32(functiontype)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Sets the grand total name of specific function.
// Parameters:
//   functionType - int32 
//   name - string 
// Returns:
//   void  
func (instance *SettableGlobalizationSettings) SetGrandTotalName(functiontype ConsolidationFunction, name string)  error {
	
	CGoReturnPtr := C.SettableGlobalizationSettings_SetGrandTotalName( instance.ptr, C.int( int32(functiontype)), C.CString(name))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the type name of table rows that consists of the table header.
// Default is "Headers", so in formula "#Headers" represents the table header.
// Returns:
//   string  
func (instance *SettableGlobalizationSettings) GetTableRowTypeOfHeaders()  (string,  error)  {
	
	CGoReturnPtr := C.SettableGlobalizationSettings_GetTableRowTypeOfHeaders( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Sets the type name of table rows that consists of the table header.
// Parameters:
//   name - string 
// Returns:
//   void  
func (instance *SettableGlobalizationSettings) SetTableRowTypeOfHeaders(name string)  error {
	
	CGoReturnPtr := C.SettableGlobalizationSettings_SetTableRowTypeOfHeaders( instance.ptr, C.CString(name))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the type name of table rows that consists of data region of referenced table.
// Default is "Data", so in formula "#Data" represents the data region of the table.
// Returns:
//   string  
func (instance *SettableGlobalizationSettings) GetTableRowTypeOfData()  (string,  error)  {
	
	CGoReturnPtr := C.SettableGlobalizationSettings_GetTableRowTypeOfData( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Sets the type name of table rows that consists of data region of referenced table.
// Parameters:
//   name - string 
// Returns:
//   void  
func (instance *SettableGlobalizationSettings) SetTableRowTypeOfData(name string)  error {
	
	CGoReturnPtr := C.SettableGlobalizationSettings_SetTableRowTypeOfData( instance.ptr, C.CString(name))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the type name of table rows that consists of all rows in referenced table.
// Returns:
//   string  
func (instance *SettableGlobalizationSettings) GetTableRowTypeOfAll()  (string,  error)  {
	
	CGoReturnPtr := C.SettableGlobalizationSettings_GetTableRowTypeOfAll( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Sets the type name of table rows that consists of all rows in referenced table.
// Parameters:
//   name - string 
// Returns:
//   void  
func (instance *SettableGlobalizationSettings) SetTableRowTypeOfAll(name string)  error {
	
	CGoReturnPtr := C.SettableGlobalizationSettings_SetTableRowTypeOfAll( instance.ptr, C.CString(name))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the type name of table rows that consists of the total row of referenced table.
// Returns:
//   string  
func (instance *SettableGlobalizationSettings) GetTableRowTypeOfTotals()  (string,  error)  {
	
	CGoReturnPtr := C.SettableGlobalizationSettings_GetTableRowTypeOfTotals( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Sets the type name of table rows that consists of the total row of referenced table.
// Parameters:
//   name - string 
// Returns:
//   void  
func (instance *SettableGlobalizationSettings) SetTableRowTypeOfTotals(name string)  error {
	
	CGoReturnPtr := C.SettableGlobalizationSettings_SetTableRowTypeOfTotals( instance.ptr, C.CString(name))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the type name of table rows that consists of the current row in referenced table.
// Returns:
//   string  
func (instance *SettableGlobalizationSettings) GetTableRowTypeOfCurrent()  (string,  error)  {
	
	CGoReturnPtr := C.SettableGlobalizationSettings_GetTableRowTypeOfCurrent( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Sets the type name of table rows that consists of the current row in referenced table.
// Parameters:
//   name - string 
// Returns:
//   void  
func (instance *SettableGlobalizationSettings) SetTableRowTypeOfCurrent(name string)  error {
	
	CGoReturnPtr := C.SettableGlobalizationSettings_SetTableRowTypeOfCurrent( instance.ptr, C.CString(name))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the display string value for cell's error value
// Parameters:
//   err - string 
// Returns:
//   string  
func (instance *SettableGlobalizationSettings) GetErrorValueString(err string)  (string,  error)  {
	
	CGoReturnPtr := C.SettableGlobalizationSettings_GetErrorValueString( instance.ptr, C.CString(err))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the display string value for cell's boolean value
// Parameters:
//   bv - bool 
// Returns:
//   string  
func (instance *SettableGlobalizationSettings) GetBooleanValueString(bv bool)  (string,  error)  {
	
	CGoReturnPtr := C.SettableGlobalizationSettings_GetBooleanValueString( instance.ptr, C.bool(bv))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Sets the display string value for cell's boolean value
// Parameters:
//   bv - bool 
//   name - string 
// Returns:
//   void  
func (instance *SettableGlobalizationSettings) SetBooleanValueString(bv bool, name string)  error {
	
	CGoReturnPtr := C.SettableGlobalizationSettings_SetBooleanValueString( instance.ptr, C.bool(bv), C.CString(name))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the locale dependent function name according to given standard function name.
// Parameters:
//   standardName - string 
// Returns:
//   string  
func (instance *SettableGlobalizationSettings) GetLocalFunctionName(standardname string)  (string,  error)  {
	
	CGoReturnPtr := C.SettableGlobalizationSettings_GetLocalFunctionName( instance.ptr, C.CString(standardname))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Sets the locale dependent function name corresponding to given standard function name.
// Parameters:
//   standardName - string 
//   localName - string 
//   bidirectional - bool 
// Returns:
//   void  
func (instance *SettableGlobalizationSettings) SetLocalFunctionName(standardname string, localname string, bidirectional bool)  error {
	
	CGoReturnPtr := C.SettableGlobalizationSettings_SetLocalFunctionName( instance.ptr, C.CString(standardname), C.CString(localname), C.bool(bidirectional))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the standard function name according to given locale dependent function name.
// Parameters:
//   localName - string 
// Returns:
//   string  
func (instance *SettableGlobalizationSettings) GetStandardFunctionName(localname string)  (string,  error)  {
	
	CGoReturnPtr := C.SettableGlobalizationSettings_GetStandardFunctionName( instance.ptr, C.CString(localname))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Sets the locale dependent function name according to given standard function name.
// Parameters:
//   localName - string 
//   standardName - string 
//   bidirectional - bool 
// Returns:
//   void  
func (instance *SettableGlobalizationSettings) SetStandardFunctionName(localname string, standardname string, bidirectional bool)  error {
	
	CGoReturnPtr := C.SettableGlobalizationSettings_SetStandardFunctionName( instance.ptr, C.CString(localname), C.CString(standardname), C.bool(bidirectional))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the locale dependent text for built-in Name according to given standard text.
// Parameters:
//   standardName - string 
// Returns:
//   string  
func (instance *SettableGlobalizationSettings) GetLocalBuiltInName(standardname string)  (string,  error)  {
	
	CGoReturnPtr := C.SettableGlobalizationSettings_GetLocalBuiltInName( instance.ptr, C.CString(standardname))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Sets the locale dependent text for the built-in name with given standard name text.
// Parameters:
//   standardName - string 
//   localName - string 
//   bidirectional - bool 
// Returns:
//   void  
func (instance *SettableGlobalizationSettings) SetLocalBuiltInName(standardname string, localname string, bidirectional bool)  error {
	
	CGoReturnPtr := C.SettableGlobalizationSettings_SetLocalBuiltInName( instance.ptr, C.CString(standardname), C.CString(localname), C.bool(bidirectional))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the standard text of built-in Name according to given locale dependent text.
// Parameters:
//   localName - string 
// Returns:
//   string  
func (instance *SettableGlobalizationSettings) GetStandardBuiltInName(localname string)  (string,  error)  {
	
	CGoReturnPtr := C.SettableGlobalizationSettings_GetStandardBuiltInName( instance.ptr, C.CString(localname))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Sets the locale dependent function name according to given standard function name.
// Parameters:
//   localName - string 
//   standardName - string 
//   bidirectional - bool 
// Returns:
//   void  
func (instance *SettableGlobalizationSettings) SetStandardBuiltInName(localname string, standardname string, bidirectional bool)  error {
	
	CGoReturnPtr := C.SettableGlobalizationSettings_SetStandardBuiltInName( instance.ptr, C.CString(localname), C.CString(standardname), C.bool(bidirectional))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the separator for list, parameters of function, ...etc.
// Returns:
//   byte  
func (instance *SettableGlobalizationSettings) GetListSeparator()  (byte,  error)  {
	
	CGoReturnPtr := C.SettableGlobalizationSettings_GetListSeparator( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := byte(CGoReturnPtr.return_value) 

	return result, nil 
}
// Sets the separator for list, parameters of function, ...etc.
// Parameters:
//   c - byte 
// Returns:
//   void  
func (instance *SettableGlobalizationSettings) SetListSeparator(c byte)  error {
	
	CGoReturnPtr := C.SettableGlobalizationSettings_SetListSeparator( instance.ptr, C.char(c))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the separator for rows in array data in formula.
// Returns:
//   byte  
func (instance *SettableGlobalizationSettings) GetRowSeparatorOfFormulaArray()  (byte,  error)  {
	
	CGoReturnPtr := C.SettableGlobalizationSettings_GetRowSeparatorOfFormulaArray( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := byte(CGoReturnPtr.return_value) 

	return result, nil 
}
// Sets the separator for rows in array data in formula.
// Parameters:
//   c - byte 
// Returns:
//   void  
func (instance *SettableGlobalizationSettings) SetRowSeparatorOfFormulaArray(c byte)  error {
	
	CGoReturnPtr := C.SettableGlobalizationSettings_SetRowSeparatorOfFormulaArray( instance.ptr, C.char(c))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the separator for the items in array's row data in formula.
// Returns:
//   byte  
func (instance *SettableGlobalizationSettings) GetColumnSeparatorOfFormulaArray()  (byte,  error)  {
	
	CGoReturnPtr := C.SettableGlobalizationSettings_GetColumnSeparatorOfFormulaArray( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := byte(CGoReturnPtr.return_value) 

	return result, nil 
}
// Sets the separator for the items in array's row data in formula.
// Parameters:
//   c - byte 
// Returns:
//   void  
func (instance *SettableGlobalizationSettings) SetColumnSeparatorOfFormulaArray(c byte)  error {
	
	CGoReturnPtr := C.SettableGlobalizationSettings_SetColumnSeparatorOfFormulaArray( instance.ptr, C.char(c))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets standard English font style name(Regular, Bold, Italic) for Header/Footer according to given locale font style name.
// Parameters:
//   localfontStyleName - string 
// Returns:
//   string  
func (instance *SettableGlobalizationSettings) GetStandardHeaderFooterFontStyleName(localfontstylename string)  (string,  error)  {
	
	CGoReturnPtr := C.SettableGlobalizationSettings_GetStandardHeaderFooterFontStyleName( instance.ptr, C.CString(localfontstylename))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Sets the locale dependent function name according to given standard function name.
// Parameters:
//   localfontStyleName - string 
//   standardName - string 
// Returns:
//   void  
func (instance *SettableGlobalizationSettings) SetStandardHeaderFooterFontStyleName(localfontstylename string, standardname string)  error {
	
	CGoReturnPtr := C.SettableGlobalizationSettings_SetStandardHeaderFooterFontStyleName( instance.ptr, C.CString(localfontstylename), C.CString(standardname))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the locale dependent comment title name according to comment title type.
// Parameters:
//   type - int32 
// Returns:
//   string  
func (instance *SettableGlobalizationSettings) GetCommentTitleName(type_ CommentTitleType)  (string,  error)  {
	
	CGoReturnPtr := C.SettableGlobalizationSettings_GetCommentTitleName( instance.ptr, C.int( int32(type_)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the locale dependent comment title name according to comment title type.
// Parameters:
//   type - int32 
//   name - string 
// Returns:
//   void  
func (instance *SettableGlobalizationSettings) SetCommentTitleName(type_ CommentTitleType, name string)  error {
	
	CGoReturnPtr := C.SettableGlobalizationSettings_SetCommentTitleName( instance.ptr, C.int( int32(type_)), C.CString(name))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}



func DeleteSettableGlobalizationSettings(settableglobalizationsettings *SettableGlobalizationSettings){
	runtime.SetFinalizer(settableglobalizationsettings, nil)
	C.Delete_SettableGlobalizationSettings(settableglobalizationsettings.ptr)
	settableglobalizationsettings.ptr = nil
}

// Class SettablePivotGlobalizationSettings 

// Implementation of PivotGlobalizationSettings that supports user to set/change pre-defined texts.
type SettablePivotGlobalizationSettings struct {
	ptr unsafe.Pointer
}

// Default constructor.
func NewSettablePivotGlobalizationSettings() ( *SettablePivotGlobalizationSettings, error) {
	settablepivotglobalizationsettings := &SettablePivotGlobalizationSettings{}
	CGoReturnPtr := C.New_SettablePivotGlobalizationSettings()
	if CGoReturnPtr.error_no == 0 {
		settablepivotglobalizationsettings.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(settablepivotglobalizationsettings, DeleteSettablePivotGlobalizationSettings)
		return settablepivotglobalizationsettings, nil
	} else {
		settablepivotglobalizationsettings.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return settablepivotglobalizationsettings, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *SettablePivotGlobalizationSettings) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.SettablePivotGlobalizationSettings_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the text of "Total" label in the PivotTable.
// You need to override this method when the PivotTable contains two or more PivotFields in the data area.
// Returns:
//   string  
func (instance *SettablePivotGlobalizationSettings) GetTextOfTotal()  (string,  error)  {
	
	CGoReturnPtr := C.SettablePivotGlobalizationSettings_GetTextOfTotal( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Sets the text of "Total" label in the PivotTable.
// Parameters:
//   text - string 
// Returns:
//   void  
func (instance *SettablePivotGlobalizationSettings) SetTextOfTotal(text string)  error {
	
	CGoReturnPtr := C.SettablePivotGlobalizationSettings_SetTextOfTotal( instance.ptr, C.CString(text))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the text of "Grand Total" label in the PivotTable.
// Returns:
//   string  
func (instance *SettablePivotGlobalizationSettings) GetTextOfGrandTotal()  (string,  error)  {
	
	CGoReturnPtr := C.SettablePivotGlobalizationSettings_GetTextOfGrandTotal( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Sets the text of "Grand Total" label in the PivotTable.
// Parameters:
//   text - string 
// Returns:
//   void  
func (instance *SettablePivotGlobalizationSettings) SetTextOfGrandTotal(text string)  error {
	
	CGoReturnPtr := C.SettablePivotGlobalizationSettings_SetTextOfGrandTotal( instance.ptr, C.CString(text))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the text of "(Multiple Items)" label in the PivotTable.
// Returns:
//   string  
func (instance *SettablePivotGlobalizationSettings) GetTextOfMultipleItems()  (string,  error)  {
	
	CGoReturnPtr := C.SettablePivotGlobalizationSettings_GetTextOfMultipleItems( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Sets the text of "(Multiple Items)" label in the PivotTable.
// Parameters:
//   text - string 
// Returns:
//   void  
func (instance *SettablePivotGlobalizationSettings) SetTextOfMultipleItems(text string)  error {
	
	CGoReturnPtr := C.SettablePivotGlobalizationSettings_SetTextOfMultipleItems( instance.ptr, C.CString(text))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the text of "(All)" label in the PivotTable.
// Returns:
//   string  
func (instance *SettablePivotGlobalizationSettings) GetTextOfAll()  (string,  error)  {
	
	CGoReturnPtr := C.SettablePivotGlobalizationSettings_GetTextOfAll( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Sets the text of "(All)" label in the PivotTable.
// Parameters:
//   text - string 
// Returns:
//   void  
func (instance *SettablePivotGlobalizationSettings) SetTextOfAll(text string)  error {
	
	CGoReturnPtr := C.SettablePivotGlobalizationSettings_SetTextOfAll( instance.ptr, C.CString(text))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the text for specified protected name.
// Parameters:
//   protectedName - string 
// Returns:
//   string  
func (instance *SettablePivotGlobalizationSettings) GetTextOfProtectedName(protectedname string)  (string,  error)  {
	
	CGoReturnPtr := C.SettablePivotGlobalizationSettings_GetTextOfProtectedName( instance.ptr, C.CString(protectedname))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Sets the text for specific protected name.
// Parameters:
//   protectedName - string 
//   text - string 
// Returns:
//   void  
func (instance *SettablePivotGlobalizationSettings) SetTextOfProtectedName(protectedname string, text string)  error {
	
	CGoReturnPtr := C.SettablePivotGlobalizationSettings_SetTextOfProtectedName( instance.ptr, C.CString(protectedname), C.CString(text))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the text of "Column Labels" label in the PivotTable.
// Returns:
//   string  
func (instance *SettablePivotGlobalizationSettings) GetTextOfColumnLabels()  (string,  error)  {
	
	CGoReturnPtr := C.SettablePivotGlobalizationSettings_GetTextOfColumnLabels( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the text of "Column Labels" label in the PivotTable.
// Parameters:
//   text - string 
// Returns:
//   void  
func (instance *SettablePivotGlobalizationSettings) SetTextOfColumnLabels(text string)  error {
	
	CGoReturnPtr := C.SettablePivotGlobalizationSettings_SetTextOfColumnLabels( instance.ptr, C.CString(text))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the text of "Row Labels" label in the PivotTable.
// Returns:
//   string  
func (instance *SettablePivotGlobalizationSettings) GetTextOfRowLabels()  (string,  error)  {
	
	CGoReturnPtr := C.SettablePivotGlobalizationSettings_GetTextOfRowLabels( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Sets the text of "Row Labels" label in the PivotTable.
// Parameters:
//   text - string 
// Returns:
//   void  
func (instance *SettablePivotGlobalizationSettings) SetTextOfRowLabels(text string)  error {
	
	CGoReturnPtr := C.SettablePivotGlobalizationSettings_SetTextOfRowLabels( instance.ptr, C.CString(text))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the text of "(blank)" label in the PivotTable.
// Returns:
//   string  
func (instance *SettablePivotGlobalizationSettings) GetTextOfEmptyData()  (string,  error)  {
	
	CGoReturnPtr := C.SettablePivotGlobalizationSettings_GetTextOfEmptyData( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Sets the text of "(blank)" label in the PivotTable.
// Parameters:
//   text - string 
// Returns:
//   void  
func (instance *SettablePivotGlobalizationSettings) SetTextOfEmptyData(text string)  error {
	
	CGoReturnPtr := C.SettablePivotGlobalizationSettings_SetTextOfEmptyData( instance.ptr, C.CString(text))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the the text of the value area field header in the PivotTable.
// Returns:
//   string  
func (instance *SettablePivotGlobalizationSettings) GetTextOfDataFieldHeader()  (string,  error)  {
	
	CGoReturnPtr := C.SettablePivotGlobalizationSettings_GetTextOfDataFieldHeader( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Sets the the text of the value area field header in the PivotTable.
// Parameters:
//   text - string 
// Returns:
//   void  
func (instance *SettablePivotGlobalizationSettings) SetTextOfDataFieldHeader(text string)  error {
	
	CGoReturnPtr := C.SettablePivotGlobalizationSettings_SetTextOfDataFieldHeader( instance.ptr, C.CString(text))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the text of <see cref="PivotFieldSubtotalType"/> type in the PivotTable.
// Parameters:
//   subTotalType - int32 
// Returns:
//   string  
func (instance *SettablePivotGlobalizationSettings) GetTextOfSubTotal(subtotaltype PivotFieldSubtotalType)  (string,  error)  {
	
	CGoReturnPtr := C.SettablePivotGlobalizationSettings_GetTextOfSubTotal( instance.ptr, C.int( int32(subtotaltype)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Sets the text of <see cref="PivotFieldSubtotalType"/> type in the PivotTable.
// Parameters:
//   subTotalType - int32 
//   text - string 
// Returns:
//   void  
func (instance *SettablePivotGlobalizationSettings) SetTextOfSubTotal(subtotaltype PivotFieldSubtotalType, text string)  error {
	
	CGoReturnPtr := C.SettablePivotGlobalizationSettings_SetTextOfSubTotal( instance.ptr, C.int( int32(subtotaltype)), C.CString(text))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}



func DeleteSettablePivotGlobalizationSettings(settablepivotglobalizationsettings *SettablePivotGlobalizationSettings){
	runtime.SetFinalizer(settablepivotglobalizationsettings, nil)
	C.Delete_SettablePivotGlobalizationSettings(settablepivotglobalizationsettings.ptr)
	settablepivotglobalizationsettings.ptr = nil
}

// Class SpreadsheetML2003SaveOptions 

// Represents the options for saving Excel 2003 spreadml file.
type SpreadsheetML2003SaveOptions struct {
	ptr unsafe.Pointer
}

// Creates the options for saving Excel 2003 spreadml file.
func NewSpreadsheetML2003SaveOptions() ( *SpreadsheetML2003SaveOptions, error) {
	spreadsheetml2003saveoptions := &SpreadsheetML2003SaveOptions{}
	CGoReturnPtr := C.New_SpreadsheetML2003SaveOptions()
	if CGoReturnPtr.error_no == 0 {
		spreadsheetml2003saveoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(spreadsheetml2003saveoptions, DeleteSpreadsheetML2003SaveOptions)
		return spreadsheetml2003saveoptions, nil
	} else {
		spreadsheetml2003saveoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return spreadsheetml2003saveoptions, err
	}	
}
// Constructs from a parent object.
// Parameters:
//   src - SaveOptions 
func NewSpreadsheetML2003SaveOptions_SaveOptions(src *SaveOptions) ( *SpreadsheetML2003SaveOptions, error) {
	spreadsheetml2003saveoptions := &SpreadsheetML2003SaveOptions{}
	var src_ptr unsafe.Pointer = nil
	if src != nil {
	  src_ptr =src.ptr
	}

	CGoReturnPtr := C.New_SpreadsheetML2003SaveOptions_SaveOptions(src_ptr)
	if CGoReturnPtr.error_no == 0 {
		spreadsheetml2003saveoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(spreadsheetml2003saveoptions, DeleteSpreadsheetML2003SaveOptions)
		return spreadsheetml2003saveoptions, nil
	} else {
		spreadsheetml2003saveoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return spreadsheetml2003saveoptions, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *SpreadsheetML2003SaveOptions) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.SpreadsheetML2003SaveOptions_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Causes child elements to be indented.
// Returns:
//   bool  
func (instance *SpreadsheetML2003SaveOptions) IsIndentedFormatting()  (bool,  error)  {
	
	CGoReturnPtr := C.SpreadsheetML2003SaveOptions_IsIndentedFormatting( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Causes child elements to be indented.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *SpreadsheetML2003SaveOptions) SetIsIndentedFormatting(value bool)  error {
	
	CGoReturnPtr := C.SpreadsheetML2003SaveOptions_SetIsIndentedFormatting( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Limit as xls, the max row index is 65535 and the max column index is 255.
// Returns:
//   bool  
func (instance *SpreadsheetML2003SaveOptions) GetLimitAsXls()  (bool,  error)  {
	
	CGoReturnPtr := C.SpreadsheetML2003SaveOptions_GetLimitAsXls( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Limit as xls, the max row index is 65535 and the max column index is 255.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *SpreadsheetML2003SaveOptions) SetLimitAsXls(value bool)  error {
	
	CGoReturnPtr := C.SpreadsheetML2003SaveOptions_SetLimitAsXls( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// The default value is false, it means that column index  will be ignored if the cell is contiguous to the previous cell.
// Returns:
//   bool  
func (instance *SpreadsheetML2003SaveOptions) GetExportColumnIndexOfCell()  (bool,  error)  {
	
	CGoReturnPtr := C.SpreadsheetML2003SaveOptions_GetExportColumnIndexOfCell( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// The default value is false, it means that column index  will be ignored if the cell is contiguous to the previous cell.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *SpreadsheetML2003SaveOptions) SetExportColumnIndexOfCell(value bool)  error {
	
	CGoReturnPtr := C.SpreadsheetML2003SaveOptions_SetExportColumnIndexOfCell( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the save file format.
// Returns:
//   int32  
func (instance *SpreadsheetML2003SaveOptions) GetSaveFormat()  (SaveFormat,  error)  {
	
	CGoReturnPtr := C.SpreadsheetML2003SaveOptions_GetSaveFormat( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToSaveFormat(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Make the workbook empty after saving the file.
// Returns:
//   bool  
func (instance *SpreadsheetML2003SaveOptions) GetClearData()  (bool,  error)  {
	
	CGoReturnPtr := C.SpreadsheetML2003SaveOptions_GetClearData( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Make the workbook empty after saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *SpreadsheetML2003SaveOptions) SetClearData(value bool)  error {
	
	CGoReturnPtr := C.SpreadsheetML2003SaveOptions_SetClearData( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// The folder for temporary files that may be used as data cache.
// Returns:
//   string  
func (instance *SpreadsheetML2003SaveOptions) GetCachedFileFolder()  (string,  error)  {
	
	CGoReturnPtr := C.SpreadsheetML2003SaveOptions_GetCachedFileFolder( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// The folder for temporary files that may be used as data cache.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *SpreadsheetML2003SaveOptions) SetCachedFileFolder(value string)  error {
	
	CGoReturnPtr := C.SpreadsheetML2003SaveOptions_SetCachedFileFolder( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether validate merged cells before saving the file.
// Returns:
//   bool  
func (instance *SpreadsheetML2003SaveOptions) GetValidateMergedAreas()  (bool,  error)  {
	
	CGoReturnPtr := C.SpreadsheetML2003SaveOptions_GetValidateMergedAreas( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether validate merged cells before saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *SpreadsheetML2003SaveOptions) SetValidateMergedAreas(value bool)  error {
	
	CGoReturnPtr := C.SpreadsheetML2003SaveOptions_SetValidateMergedAreas( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether merge the areas of conditional formatting and validation before saving the file.
// Returns:
//   bool  
func (instance *SpreadsheetML2003SaveOptions) GetMergeAreas()  (bool,  error)  {
	
	CGoReturnPtr := C.SpreadsheetML2003SaveOptions_GetMergeAreas( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether merge the areas of conditional formatting and validation before saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *SpreadsheetML2003SaveOptions) SetMergeAreas(value bool)  error {
	
	CGoReturnPtr := C.SpreadsheetML2003SaveOptions_SetMergeAreas( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// If true and the directory does not exist, the directory will be automatically created before saving the file.
// Returns:
//   bool  
func (instance *SpreadsheetML2003SaveOptions) GetCreateDirectory()  (bool,  error)  {
	
	CGoReturnPtr := C.SpreadsheetML2003SaveOptions_GetCreateDirectory( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// If true and the directory does not exist, the directory will be automatically created before saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *SpreadsheetML2003SaveOptions) SetCreateDirectory(value bool)  error {
	
	CGoReturnPtr := C.SpreadsheetML2003SaveOptions_SetCreateDirectory( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether sorting defined names before saving file.
// Returns:
//   bool  
func (instance *SpreadsheetML2003SaveOptions) GetSortNames()  (bool,  error)  {
	
	CGoReturnPtr := C.SpreadsheetML2003SaveOptions_GetSortNames( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether sorting defined names before saving file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *SpreadsheetML2003SaveOptions) SetSortNames(value bool)  error {
	
	CGoReturnPtr := C.SpreadsheetML2003SaveOptions_SetSortNames( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether sorting external defined names before saving file.
// Returns:
//   bool  
func (instance *SpreadsheetML2003SaveOptions) GetSortExternalNames()  (bool,  error)  {
	
	CGoReturnPtr := C.SpreadsheetML2003SaveOptions_GetSortExternalNames( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether sorting external defined names before saving file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *SpreadsheetML2003SaveOptions) SetSortExternalNames(value bool)  error {
	
	CGoReturnPtr := C.SpreadsheetML2003SaveOptions_SetSortExternalNames( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether refreshing chart cache data
// Returns:
//   bool  
func (instance *SpreadsheetML2003SaveOptions) GetRefreshChartCache()  (bool,  error)  {
	
	CGoReturnPtr := C.SpreadsheetML2003SaveOptions_GetRefreshChartCache( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether refreshing chart cache data
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *SpreadsheetML2003SaveOptions) SetRefreshChartCache(value bool)  error {
	
	CGoReturnPtr := C.SpreadsheetML2003SaveOptions_SetRefreshChartCache( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Whether check restriction of excel file when user modify cells related objects.
// For example, excel does not allow inputting string value longer than 32K.
// When you input a value longer than 32K, it will be truncated.
// Returns:
//   bool  
func (instance *SpreadsheetML2003SaveOptions) GetCheckExcelRestriction()  (bool,  error)  {
	
	CGoReturnPtr := C.SpreadsheetML2003SaveOptions_GetCheckExcelRestriction( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Whether check restriction of excel file when user modify cells related objects.
// For example, excel does not allow inputting string value longer than 32K.
// When you input a value longer than 32K, it will be truncated.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *SpreadsheetML2003SaveOptions) SetCheckExcelRestriction(value bool)  error {
	
	CGoReturnPtr := C.SpreadsheetML2003SaveOptions_SetCheckExcelRestriction( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether updating smart art setting.
// The default value is false.
// Returns:
//   bool  
func (instance *SpreadsheetML2003SaveOptions) GetUpdateSmartArt()  (bool,  error)  {
	
	CGoReturnPtr := C.SpreadsheetML2003SaveOptions_GetUpdateSmartArt( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether updating smart art setting.
// The default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *SpreadsheetML2003SaveOptions) SetUpdateSmartArt(value bool)  error {
	
	CGoReturnPtr := C.SpreadsheetML2003SaveOptions_SetUpdateSmartArt( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether encrypt document properties when saving as .xls file.
// The default value is true.
// Returns:
//   bool  
func (instance *SpreadsheetML2003SaveOptions) GetEncryptDocumentProperties()  (bool,  error)  {
	
	CGoReturnPtr := C.SpreadsheetML2003SaveOptions_GetEncryptDocumentProperties( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether encrypt document properties when saving as .xls file.
// The default value is true.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *SpreadsheetML2003SaveOptions) SetEncryptDocumentProperties(value bool)  error {
	
	CGoReturnPtr := C.SpreadsheetML2003SaveOptions_SetEncryptDocumentProperties( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}


func (instance *SpreadsheetML2003SaveOptions) ToSaveOptions() *SaveOptions {
	parentClass := &SaveOptions{}
	parentClass.ptr = instance.ptr
	return parentClass
}

func DeleteSpreadsheetML2003SaveOptions(spreadsheetml2003saveoptions *SpreadsheetML2003SaveOptions){
	runtime.SetFinalizer(spreadsheetml2003saveoptions, nil)
	C.Delete_SpreadsheetML2003SaveOptions(spreadsheetml2003saveoptions.ptr)
	spreadsheetml2003saveoptions.ptr = nil
}

// Class Style 

// Represents display style of excel document,such as font,color,alignment,border,etc.
// The Style object contains all style attributes (font, number format, alignment, and so on) as properties.
type Style struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *Style) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.Style_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the background theme color.
// Returns:
//   ThemeColor  
func (instance *Style) GetBackgroundThemeColor()  (*ThemeColor,  error)  {
	
	CGoReturnPtr := C.Style_GetBackgroundThemeColor( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &ThemeColor{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteThemeColor) 

	return result, nil 
}
// Gets and sets the background theme color.
// Parameters:
//   value - ThemeColor 
// Returns:
//   void  
func (instance *Style) SetBackgroundThemeColor(value *ThemeColor)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.Style_SetBackgroundThemeColor( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the foreground theme color.
// Returns:
//   ThemeColor  
func (instance *Style) GetForegroundThemeColor()  (*ThemeColor,  error)  {
	
	CGoReturnPtr := C.Style_GetForegroundThemeColor( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &ThemeColor{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteThemeColor) 

	return result, nil 
}
// Gets and sets the foreground theme color.
// Parameters:
//   value - ThemeColor 
// Returns:
//   void  
func (instance *Style) SetForegroundThemeColor(value *ThemeColor)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.Style_SetForegroundThemeColor( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the name of the style.
// Returns:
//   string  
func (instance *Style) GetName()  (string,  error)  {
	
	CGoReturnPtr := C.Style_GetName( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets the name of the style.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *Style) SetName(value string)  error {
	
	CGoReturnPtr := C.Style_SetName( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the cell background pattern type.
// Returns:
//   int32  
func (instance *Style) GetPattern()  (BackgroundType,  error)  {
	
	CGoReturnPtr := C.Style_GetPattern( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToBackgroundType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets or sets the cell background pattern type.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *Style) SetPattern(value BackgroundType)  error {
	
	CGoReturnPtr := C.Style_SetPattern( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Sets the background color.
// Parameters:
//   pattern - int32 
//   color1 - Color 
//   color2 - Color 
// Returns:
//   void  
func (instance *Style) SetPatternColor(pattern BackgroundType, color1 *Color, color2 *Color)  error {
	
	CGoReturnPtr := C.Style_SetPatternColor( instance.ptr, C.int( int32(pattern)), color1.ptr, color2.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the <see cref="BorderCollection"/> of the style.
// Returns:
//   BorderCollection  
func (instance *Style) GetBorders()  (*BorderCollection,  error)  {
	
	CGoReturnPtr := C.Style_GetBorders( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &BorderCollection{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteBorderCollection) 

	return result, nil 
}
// Gets or sets a style's background color.
// Returns:
//   Color  
func (instance *Style) GetBackgroundColor()  (*Color,  error)  {
	
	CGoReturnPtr := C.Style_GetBackgroundColor( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Gets or sets a style's background color.
// Parameters:
//   value - Color 
// Returns:
//   void  
func (instance *Style) SetBackgroundColor(value *Color)  error {
	
	CGoReturnPtr := C.Style_SetBackgroundColor( instance.ptr, value.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the background color with a 32-bit ARGB value.
// Returns:
//   int32  
func (instance *Style) GetBackgroundArgbColor()  (int32,  error)  {
	
	CGoReturnPtr := C.Style_GetBackgroundArgbColor( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the background color with a 32-bit ARGB value.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *Style) SetBackgroundArgbColor(value int32)  error {
	
	CGoReturnPtr := C.Style_SetBackgroundArgbColor( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets a style's foreground color.
// Returns:
//   Color  
func (instance *Style) GetForegroundColor()  (*Color,  error)  {
	
	CGoReturnPtr := C.Style_GetForegroundColor( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Gets or sets a style's foreground color.
// Parameters:
//   value - Color 
// Returns:
//   void  
func (instance *Style) SetForegroundColor(value *Color)  error {
	
	CGoReturnPtr := C.Style_SetForegroundColor( instance.ptr, value.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the foreground color with a 32-bit ARGB value.
// Returns:
//   int32  
func (instance *Style) GetForegroundArgbColor()  (int32,  error)  {
	
	CGoReturnPtr := C.Style_GetForegroundArgbColor( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the foreground color with a 32-bit ARGB value.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *Style) SetForegroundArgbColor(value int32)  error {
	
	CGoReturnPtr := C.Style_SetForegroundArgbColor( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Copies data from another style object
// Parameters:
//   style - Style 
// Returns:
//   void  
func (instance *Style) Copy(style *Style)  error {
	
	var style_ptr unsafe.Pointer = nil
	if style != nil {
	  style_ptr =style.ptr
	}

	CGoReturnPtr := C.Style_Copy( instance.ptr, style_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Checks whether there are borders have been set for the style.
// Returns:
//   bool  
func (instance *Style) GetHasBorders()  (bool,  error)  {
	
	CGoReturnPtr := C.Style_GetHasBorders( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the parent style of this style.
// Returns:
//   Style  
func (instance *Style) GetParentStyle()  (*Style,  error)  {
	
	CGoReturnPtr := C.Style_GetParentStyle( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Style{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteStyle) 

	return result, nil 
}
// Apply the named style to the styles of the cells which use this named style.
// It works like clicking the "ok" button after you finished modifying the style.
// Only applies for named style.
// Returns:
//   void  
func (instance *Style) Update()  error {
	
	CGoReturnPtr := C.Style_Update( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicate whether the number formatting should be applied.
// Returns:
//   bool  
func (instance *Style) IsNumberFormatApplied()  (bool,  error)  {
	
	CGoReturnPtr := C.Style_IsNumberFormatApplied( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicate whether the number formatting should be applied.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Style) SetIsNumberFormatApplied(value bool)  error {
	
	CGoReturnPtr := C.Style_SetIsNumberFormatApplied( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicate whether the font formatting should be applied.
// Returns:
//   bool  
func (instance *Style) IsFontApplied()  (bool,  error)  {
	
	CGoReturnPtr := C.Style_IsFontApplied( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicate whether the font formatting should be applied.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Style) SetIsFontApplied(value bool)  error {
	
	CGoReturnPtr := C.Style_SetIsFontApplied( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicate whether the alignment formatting should be applied.
// Returns:
//   bool  
func (instance *Style) IsAlignmentApplied()  (bool,  error)  {
	
	CGoReturnPtr := C.Style_IsAlignmentApplied( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicate whether the alignment formatting should be applied.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Style) SetIsAlignmentApplied(value bool)  error {
	
	CGoReturnPtr := C.Style_SetIsAlignmentApplied( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicate whether the border formatting should be applied.
// Returns:
//   bool  
func (instance *Style) IsBorderApplied()  (bool,  error)  {
	
	CGoReturnPtr := C.Style_IsBorderApplied( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicate whether the border formatting should be applied.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Style) SetIsBorderApplied(value bool)  error {
	
	CGoReturnPtr := C.Style_SetIsBorderApplied( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicate whether the fill formatting should be applied.
// Returns:
//   bool  
func (instance *Style) IsFillApplied()  (bool,  error)  {
	
	CGoReturnPtr := C.Style_IsFillApplied( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicate whether the fill formatting should be applied.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Style) SetIsFillApplied(value bool)  error {
	
	CGoReturnPtr := C.Style_SetIsFillApplied( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicate whether the protection formatting should be applied.
// Returns:
//   bool  
func (instance *Style) IsProtectionApplied()  (bool,  error)  {
	
	CGoReturnPtr := C.Style_IsProtectionApplied( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicate whether the protection formatting should be applied.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Style) SetIsProtectionApplied(value bool)  error {
	
	CGoReturnPtr := C.Style_SetIsProtectionApplied( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Checks whether the specified properties of the style have been modified.
// Used for style of ConditionalFormattings to check whether the specified properties of this style should be used when applying the ConditionalFormattings on a cell.
// Parameters:
//   modifyFlag - int32 
// Returns:
//   bool  
func (instance *Style) IsModified(modifyflag StyleModifyFlag)  (bool,  error)  {
	
	CGoReturnPtr := C.Style_IsModified( instance.ptr, C.int( int32(modifyflag)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Determines whether two Style instances are equal.
// Parameters:
//   obj - Object 
// Returns:
//   bool  
func (instance *Style) Equals(obj *Object)  (bool,  error)  {
	
	var obj_ptr unsafe.Pointer = nil
	if obj != nil {
	  obj_ptr =obj.ptr
	}

	CGoReturnPtr := C.Style_Equals( instance.ptr, obj_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Serves as a hash function for a Style object.
// Returns:
//   int32  
func (instance *Style) GetHashCode()  (int32,  error)  {
	
	CGoReturnPtr := C.Style_GetHashCode( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents the indent level for the cell or range. Can only be an integer from 0 to 250.
// Returns:
//   int32  
func (instance *Style) GetIndentLevel()  (int32,  error)  {
	
	CGoReturnPtr := C.Style_GetIndentLevel( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents the indent level for the cell or range. Can only be an integer from 0 to 250.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *Style) SetIndentLevel(value int32)  error {
	
	CGoReturnPtr := C.Style_SetIndentLevel( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets a <see cref="Font"/> object.
// Returns:
//   Font  
func (instance *Style) GetFont()  (*Font,  error)  {
	
	CGoReturnPtr := C.Style_GetFont( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Font{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteFont) 

	return result, nil 
}
// Represents text rotation angle.
// Returns:
//   int32  
func (instance *Style) GetRotationAngle()  (int32,  error)  {
	
	CGoReturnPtr := C.Style_GetRotationAngle( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents text rotation angle.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *Style) SetRotationAngle(value int32)  error {
	
	CGoReturnPtr := C.Style_SetRotationAngle( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the horizontal alignment type of the text in a cell.
// Returns:
//   int32  
func (instance *Style) GetHorizontalAlignment()  (TextAlignmentType,  error)  {
	
	CGoReturnPtr := C.Style_GetHorizontalAlignment( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToTextAlignmentType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets or sets the horizontal alignment type of the text in a cell.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *Style) SetHorizontalAlignment(value TextAlignmentType)  error {
	
	CGoReturnPtr := C.Style_SetHorizontalAlignment( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the vertical alignment type of the text in a cell.
// Returns:
//   int32  
func (instance *Style) GetVerticalAlignment()  (TextAlignmentType,  error)  {
	
	CGoReturnPtr := C.Style_GetVerticalAlignment( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToTextAlignmentType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets or sets the vertical alignment type of the text in a cell.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *Style) SetVerticalAlignment(value TextAlignmentType)  error {
	
	CGoReturnPtr := C.Style_SetVerticalAlignment( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets a value indicating whether the text within a cell is wrapped.
// Returns:
//   bool  
func (instance *Style) IsTextWrapped()  (bool,  error)  {
	
	CGoReturnPtr := C.Style_IsTextWrapped( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets a value indicating whether the text within a cell is wrapped.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Style) SetIsTextWrapped(value bool)  error {
	
	CGoReturnPtr := C.Style_SetIsTextWrapped( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the display format of numbers and dates. The formatting patterns are different for different regions.
// Returns:
//   int32  
func (instance *Style) GetNumber()  (int32,  error)  {
	
	CGoReturnPtr := C.Style_GetNumber( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets the display format of numbers and dates. The formatting patterns are different for different regions.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *Style) SetNumber(value int32)  error {
	
	CGoReturnPtr := C.Style_SetNumber( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Sets the borders of the style.
// Parameters:
//   borderType - int32 
//   borderStyle - int32 
//   borderColor - Color 
// Returns:
//   bool  
func (instance *Style) SetBorder_BorderType_CellBorderType_Color(bordertype BorderType, borderstyle CellBorderType, bordercolor *Color)  (bool,  error)  {
	
	CGoReturnPtr := C.Style_SetBorder_BorderType_CellBorderType_Color( instance.ptr, C.int( int32(bordertype)), C.int( int32(borderstyle)), bordercolor.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Sets the borders of the style.
// Parameters:
//   borderType - int32 
//   borderStyle - int32 
//   borderColor - CellsColor 
// Returns:
//   bool  
func (instance *Style) SetBorder_BorderType_CellBorderType_CellsColor(bordertype BorderType, borderstyle CellBorderType, bordercolor *CellsColor)  (bool,  error)  {
	
	var bordercolor_ptr unsafe.Pointer = nil
	if bordercolor != nil {
	  bordercolor_ptr =bordercolor.ptr
	}

	CGoReturnPtr := C.Style_SetBorder_BorderType_CellBorderType_CellsColor( instance.ptr, C.int( int32(bordertype)), C.int( int32(borderstyle)), bordercolor_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets a value indicating whether a cell can be modified or not.
// Returns:
//   bool  
func (instance *Style) IsLocked()  (bool,  error)  {
	
	CGoReturnPtr := C.Style_IsLocked( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets a value indicating whether a cell can be modified or not.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Style) SetIsLocked(value bool)  error {
	
	CGoReturnPtr := C.Style_SetIsLocked( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Sets the Custom number format string of a cell.
// Parameters:
//   custom - string 
//   builtinPreference - bool 
// Returns:
//   void  
func (instance *Style) SetCustom_String_Bool(custom string, builtinpreference bool)  error {
	
	CGoReturnPtr := C.Style_SetCustom_String_Boolean( instance.ptr, C.CString(custom), C.bool(builtinpreference))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents the custom number format string of this style object.
// If the custom number format is not set(For example, the number format is builtin), "" will be returned.
// Returns:
//   string  
func (instance *Style) GetCustom()  (string,  error)  {
	
	CGoReturnPtr := C.Style_GetCustom( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents the custom number format string of this style object.
// If the custom number format is not set(For example, the number format is builtin), "" will be returned.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *Style) SetCustom_String(value string)  error {
	
	CGoReturnPtr := C.Style_SetCustom_String( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the culture-dependent pattern string for number format.
// If no number format has been set for this object, null will be returned.
// If number format is builtin, the pattern string corresponding to the builtin number will be returned.
// Returns:
//   string  
func (instance *Style) GetCultureCustom()  (string,  error)  {
	
	CGoReturnPtr := C.Style_GetCultureCustom( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the culture-dependent pattern string for number format.
// If no number format has been set for this object, null will be returned.
// If number format is builtin, the pattern string corresponding to the builtin number will be returned.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *Style) SetCultureCustom(value string)  error {
	
	CGoReturnPtr := C.Style_SetCultureCustom( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the culture-independent pattern string for number format.
// If no number format has been set for this object, null will be returned.
// If number format is builtin, the pattern string corresponding to the builtin number will be returned.
// Returns:
//   string  
func (instance *Style) GetInvariantCustom()  (string,  error)  {
	
	CGoReturnPtr := C.Style_GetInvariantCustom( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents if the formula will be hidden when the worksheet is protected.
// Returns:
//   bool  
func (instance *Style) IsFormulaHidden()  (bool,  error)  {
	
	CGoReturnPtr := C.Style_IsFormulaHidden( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents if the formula will be hidden when the worksheet is protected.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Style) SetIsFormulaHidden(value bool)  error {
	
	CGoReturnPtr := C.Style_SetIsFormulaHidden( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents if text automatically shrinks to fit in the available column width.
// Returns:
//   bool  
func (instance *Style) GetShrinkToFit()  (bool,  error)  {
	
	CGoReturnPtr := C.Style_GetShrinkToFit( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents if text automatically shrinks to fit in the available column width.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Style) SetShrinkToFit(value bool)  error {
	
	CGoReturnPtr := C.Style_SetShrinkToFit( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents text reading order.
// Returns:
//   int32  
func (instance *Style) GetTextDirection()  (TextDirectionType,  error)  {
	
	CGoReturnPtr := C.Style_GetTextDirection( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToTextDirectionType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Represents text reading order.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *Style) SetTextDirection(value TextDirectionType)  error {
	
	CGoReturnPtr := C.Style_SetTextDirection( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates if the cells justified or distributed alignment should be used on the last line of text.
// Returns:
//   bool  
func (instance *Style) IsJustifyDistributed()  (bool,  error)  {
	
	CGoReturnPtr := C.Style_IsJustifyDistributed( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates if the cells justified or distributed alignment should be used on the last line of text.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Style) SetIsJustifyDistributed(value bool)  error {
	
	CGoReturnPtr := C.Style_SetIsJustifyDistributed( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether the cell's value starts with single quote mark.
// Returns:
//   bool  
func (instance *Style) GetQuotePrefix()  (bool,  error)  {
	
	CGoReturnPtr := C.Style_GetQuotePrefix( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether the cell's value starts with single quote mark.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Style) SetQuotePrefix(value bool)  error {
	
	CGoReturnPtr := C.Style_SetQuotePrefix( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether the cell shading is a gradient pattern.
// Returns:
//   bool  
func (instance *Style) IsGradient()  (bool,  error)  {
	
	CGoReturnPtr := C.Style_IsGradient( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether the cell shading is a gradient pattern.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Style) SetIsGradient(value bool)  error {
	
	CGoReturnPtr := C.Style_SetIsGradient( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Sets the specified fill to a two-color gradient.
// Parameters:
//   color1 - Color 
//   color2 - Color 
//   gradientStyleType - int32 
//   variant - int32 
// Returns:
//   void  
func (instance *Style) SetTwoColorGradient(color1 *Color, color2 *Color, gradientstyletype GradientStyleType, variant int32)  error {
	
	CGoReturnPtr := C.Style_SetTwoColorGradient( instance.ptr, color1.ptr, color2.ptr, C.int( int32(gradientstyletype)), C.int(variant))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Get the two-color gradient setting.
// Returns:
//   TwoColorGradient  
func (instance *Style) GetTwoColorGradientSetting()  (*TwoColorGradient,  error)  {
	
	CGoReturnPtr := C.Style_GetTwoColorGradientSetting( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &TwoColorGradient{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteTwoColorGradient) 

	return result, nil 
}
// Indicates whether the number format is a percent format.
// Returns:
//   bool  
func (instance *Style) IsPercent()  (bool,  error)  {
	
	CGoReturnPtr := C.Style_IsPercent( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether the number format is a date format.
// Returns:
//   bool  
func (instance *Style) IsDateTime()  (bool,  error)  {
	
	CGoReturnPtr := C.Style_IsDateTime( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Convert <see cref="Style"/> to JSON struct data.
// Returns:
//   string  
func (instance *Style) ToJson()  (string,  error)  {
	
	CGoReturnPtr := C.Style_ToJson( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}



func DeleteStyle(style *Style){
	runtime.SetFinalizer(style, nil)
	C.Delete_Style(style.ptr)
	style.ptr = nil
}

// Class StyleFlag 

// Represents flags which indicates applied formatting properties.
type StyleFlag struct {
	ptr unsafe.Pointer
}

// Constructs an object with all flags as false.
func NewStyleFlag() ( *StyleFlag, error) {
	styleflag := &StyleFlag{}
	CGoReturnPtr := C.New_StyleFlag()
	if CGoReturnPtr.error_no == 0 {
		styleflag.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(styleflag, DeleteStyleFlag)
		return styleflag, nil
	} else {
		styleflag.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return styleflag, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *StyleFlag) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.StyleFlag_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// All properties will be applied.
// Returns:
//   bool  
func (instance *StyleFlag) GetAll()  (bool,  error)  {
	
	CGoReturnPtr := C.StyleFlag_GetAll( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// All properties will be applied.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *StyleFlag) SetAll(value bool)  error {
	
	CGoReturnPtr := C.StyleFlag_SetAll( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// All borders settings will be applied.
// Returns:
//   bool  
func (instance *StyleFlag) GetBorders()  (bool,  error)  {
	
	CGoReturnPtr := C.StyleFlag_GetBorders( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// All borders settings will be applied.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *StyleFlag) SetBorders(value bool)  error {
	
	CGoReturnPtr := C.StyleFlag_SetBorders( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Left border settings will be applied.
// Returns:
//   bool  
func (instance *StyleFlag) GetLeftBorder()  (bool,  error)  {
	
	CGoReturnPtr := C.StyleFlag_GetLeftBorder( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Left border settings will be applied.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *StyleFlag) SetLeftBorder(value bool)  error {
	
	CGoReturnPtr := C.StyleFlag_SetLeftBorder( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Right border settings will be applied.
// Returns:
//   bool  
func (instance *StyleFlag) GetRightBorder()  (bool,  error)  {
	
	CGoReturnPtr := C.StyleFlag_GetRightBorder( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Right border settings will be applied.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *StyleFlag) SetRightBorder(value bool)  error {
	
	CGoReturnPtr := C.StyleFlag_SetRightBorder( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Top border settings will be applied.
// Returns:
//   bool  
func (instance *StyleFlag) GetTopBorder()  (bool,  error)  {
	
	CGoReturnPtr := C.StyleFlag_GetTopBorder( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Top border settings will be applied.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *StyleFlag) SetTopBorder(value bool)  error {
	
	CGoReturnPtr := C.StyleFlag_SetTopBorder( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Bottom border settings will be applied.
// Returns:
//   bool  
func (instance *StyleFlag) GetBottomBorder()  (bool,  error)  {
	
	CGoReturnPtr := C.StyleFlag_GetBottomBorder( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Bottom border settings will be applied.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *StyleFlag) SetBottomBorder(value bool)  error {
	
	CGoReturnPtr := C.StyleFlag_SetBottomBorder( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Diagonal down border settings will be applied.
// Returns:
//   bool  
func (instance *StyleFlag) GetDiagonalDownBorder()  (bool,  error)  {
	
	CGoReturnPtr := C.StyleFlag_GetDiagonalDownBorder( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Diagonal down border settings will be applied.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *StyleFlag) SetDiagonalDownBorder(value bool)  error {
	
	CGoReturnPtr := C.StyleFlag_SetDiagonalDownBorder( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Diagonal up border settings will be applied.
// Returns:
//   bool  
func (instance *StyleFlag) GetDiagonalUpBorder()  (bool,  error)  {
	
	CGoReturnPtr := C.StyleFlag_GetDiagonalUpBorder( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Diagonal up border settings will be applied.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *StyleFlag) SetDiagonalUpBorder(value bool)  error {
	
	CGoReturnPtr := C.StyleFlag_SetDiagonalUpBorder( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Font settings will be applied.
// Returns:
//   bool  
func (instance *StyleFlag) GetFont()  (bool,  error)  {
	
	CGoReturnPtr := C.StyleFlag_GetFont( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Font settings will be applied.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *StyleFlag) SetFont(value bool)  error {
	
	CGoReturnPtr := C.StyleFlag_SetFont( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Font size setting will be applied.
// Returns:
//   bool  
func (instance *StyleFlag) GetFontSize()  (bool,  error)  {
	
	CGoReturnPtr := C.StyleFlag_GetFontSize( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Font size setting will be applied.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *StyleFlag) SetFontSize(value bool)  error {
	
	CGoReturnPtr := C.StyleFlag_SetFontSize( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Font name setting will be applied.
// Returns:
//   bool  
func (instance *StyleFlag) GetFontName()  (bool,  error)  {
	
	CGoReturnPtr := C.StyleFlag_GetFontName( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Font name setting will be applied.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *StyleFlag) SetFontName(value bool)  error {
	
	CGoReturnPtr := C.StyleFlag_SetFontName( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Font color setting will be applied.
// Returns:
//   bool  
func (instance *StyleFlag) GetFontColor()  (bool,  error)  {
	
	CGoReturnPtr := C.StyleFlag_GetFontColor( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Font color setting will be applied.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *StyleFlag) SetFontColor(value bool)  error {
	
	CGoReturnPtr := C.StyleFlag_SetFontColor( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Font bold setting will be applied.
// Returns:
//   bool  
func (instance *StyleFlag) GetFontBold()  (bool,  error)  {
	
	CGoReturnPtr := C.StyleFlag_GetFontBold( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Font bold setting will be applied.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *StyleFlag) SetFontBold(value bool)  error {
	
	CGoReturnPtr := C.StyleFlag_SetFontBold( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Font italic setting will be applied.
// Returns:
//   bool  
func (instance *StyleFlag) GetFontItalic()  (bool,  error)  {
	
	CGoReturnPtr := C.StyleFlag_GetFontItalic( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Font italic setting will be applied.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *StyleFlag) SetFontItalic(value bool)  error {
	
	CGoReturnPtr := C.StyleFlag_SetFontItalic( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Font underline setting will be applied.
// Returns:
//   bool  
func (instance *StyleFlag) GetFontUnderline()  (bool,  error)  {
	
	CGoReturnPtr := C.StyleFlag_GetFontUnderline( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Font underline setting will be applied.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *StyleFlag) SetFontUnderline(value bool)  error {
	
	CGoReturnPtr := C.StyleFlag_SetFontUnderline( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Font strikeout setting will be applied.
// Returns:
//   bool  
func (instance *StyleFlag) GetFontStrike()  (bool,  error)  {
	
	CGoReturnPtr := C.StyleFlag_GetFontStrike( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Font strikeout setting will be applied.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *StyleFlag) SetFontStrike(value bool)  error {
	
	CGoReturnPtr := C.StyleFlag_SetFontStrike( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Font script setting will be applied.
// Returns:
//   bool  
func (instance *StyleFlag) GetFontScript()  (bool,  error)  {
	
	CGoReturnPtr := C.StyleFlag_GetFontScript( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Font script setting will be applied.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *StyleFlag) SetFontScript(value bool)  error {
	
	CGoReturnPtr := C.StyleFlag_SetFontScript( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Number format setting will be applied.
// Returns:
//   bool  
func (instance *StyleFlag) Get_NumberFormat()  (bool,  error)  {
	
	CGoReturnPtr := C.StyleFlag_Get_NumberFormat( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Number format setting will be applied.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *StyleFlag) SetNumberFormat(value bool)  error {
	
	CGoReturnPtr := C.StyleFlag_SetNumberFormat( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Alignment setting will be applied.
// Returns:
//   bool  
func (instance *StyleFlag) GetAlignments()  (bool,  error)  {
	
	CGoReturnPtr := C.StyleFlag_GetAlignments( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Alignment setting will be applied.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *StyleFlag) SetAlignments(value bool)  error {
	
	CGoReturnPtr := C.StyleFlag_SetAlignments( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Horizontal alignment setting will be applied.
// Returns:
//   bool  
func (instance *StyleFlag) GetHorizontalAlignment()  (bool,  error)  {
	
	CGoReturnPtr := C.StyleFlag_GetHorizontalAlignment( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Horizontal alignment setting will be applied.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *StyleFlag) SetHorizontalAlignment(value bool)  error {
	
	CGoReturnPtr := C.StyleFlag_SetHorizontalAlignment( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Vertical alignment setting will be applied.
// Returns:
//   bool  
func (instance *StyleFlag) GetVerticalAlignment()  (bool,  error)  {
	
	CGoReturnPtr := C.StyleFlag_GetVerticalAlignment( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Vertical alignment setting will be applied.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *StyleFlag) SetVerticalAlignment(value bool)  error {
	
	CGoReturnPtr := C.StyleFlag_SetVerticalAlignment( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indent level setting will be applied.
// Returns:
//   bool  
func (instance *StyleFlag) GetIndent()  (bool,  error)  {
	
	CGoReturnPtr := C.StyleFlag_GetIndent( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indent level setting will be applied.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *StyleFlag) SetIndent(value bool)  error {
	
	CGoReturnPtr := C.StyleFlag_SetIndent( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Rotation setting will be applied.
// Returns:
//   bool  
func (instance *StyleFlag) GetRotation()  (bool,  error)  {
	
	CGoReturnPtr := C.StyleFlag_GetRotation( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Rotation setting will be applied.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *StyleFlag) SetRotation(value bool)  error {
	
	CGoReturnPtr := C.StyleFlag_SetRotation( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Wrap text setting will be applied.
// Returns:
//   bool  
func (instance *StyleFlag) GetWrapText()  (bool,  error)  {
	
	CGoReturnPtr := C.StyleFlag_GetWrapText( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Wrap text setting will be applied.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *StyleFlag) SetWrapText(value bool)  error {
	
	CGoReturnPtr := C.StyleFlag_SetWrapText( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Shrink to fit setting will be applied.
// Returns:
//   bool  
func (instance *StyleFlag) GetShrinkToFit()  (bool,  error)  {
	
	CGoReturnPtr := C.StyleFlag_GetShrinkToFit( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Shrink to fit setting will be applied.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *StyleFlag) SetShrinkToFit(value bool)  error {
	
	CGoReturnPtr := C.StyleFlag_SetShrinkToFit( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Text direction setting will be applied.
// Returns:
//   bool  
func (instance *StyleFlag) GetTextDirection()  (bool,  error)  {
	
	CGoReturnPtr := C.StyleFlag_GetTextDirection( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Text direction setting will be applied.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *StyleFlag) SetTextDirection(value bool)  error {
	
	CGoReturnPtr := C.StyleFlag_SetTextDirection( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Cell shading setting will be applied.
// Returns:
//   bool  
func (instance *StyleFlag) GetCellShading()  (bool,  error)  {
	
	CGoReturnPtr := C.StyleFlag_GetCellShading( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Cell shading setting will be applied.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *StyleFlag) SetCellShading(value bool)  error {
	
	CGoReturnPtr := C.StyleFlag_SetCellShading( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Locked setting will be applied.
// Returns:
//   bool  
func (instance *StyleFlag) GetLocked()  (bool,  error)  {
	
	CGoReturnPtr := C.StyleFlag_GetLocked( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Locked setting will be applied.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *StyleFlag) SetLocked(value bool)  error {
	
	CGoReturnPtr := C.StyleFlag_SetLocked( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Hide formula setting will be applied.
// Returns:
//   bool  
func (instance *StyleFlag) GetHideFormula()  (bool,  error)  {
	
	CGoReturnPtr := C.StyleFlag_GetHideFormula( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Hide formula setting will be applied.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *StyleFlag) SetHideFormula(value bool)  error {
	
	CGoReturnPtr := C.StyleFlag_SetHideFormula( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Hide formula setting will be applied.
// Returns:
//   bool  
func (instance *StyleFlag) GetQuotePrefix()  (bool,  error)  {
	
	CGoReturnPtr := C.StyleFlag_GetQuotePrefix( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Hide formula setting will be applied.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *StyleFlag) SetQuotePrefix(value bool)  error {
	
	CGoReturnPtr := C.StyleFlag_SetQuotePrefix( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}



func DeleteStyleFlag(styleflag *StyleFlag){
	runtime.SetFinalizer(styleflag, nil)
	C.Delete_StyleFlag(styleflag.ptr)
	styleflag.ptr = nil
}

// Class SubtotalSetting 

// Represents the setting of the subtotal .
type SubtotalSetting struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *SubtotalSetting) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.SubtotalSetting_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// The field to group by, as a zero-based integer offset
// Returns:
//   int32  
func (instance *SubtotalSetting) GetGroupBy()  (int32,  error)  {
	
	CGoReturnPtr := C.SubtotalSetting_GetGroupBy( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// The subtotal function.
// Returns:
//   int32  
func (instance *SubtotalSetting) GetSubtotalFunction()  (ConsolidationFunction,  error)  {
	
	CGoReturnPtr := C.SubtotalSetting_GetSubtotalFunction( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToConsolidationFunction(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// An array of zero-based field offsets, indicating the fields to which the subtotals are added.
// Returns:
//   []int32_t  
func (instance *SubtotalSetting) GetTotalList()  ([]int32,  error)  {
	
	CGoReturnPtr := C.SubtotalSetting_GetTotalList( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result:= make([]int32, CGoReturnPtr.column_length)
	for i := 0; i < int(CGoReturnPtr.column_length); i++ {
	   offset := uintptr(C.size_t(i)) * uintptr(CGoReturnPtr.size)
	   cObject := *(*C.int)(unsafe.Pointer( uintptr( unsafe.Pointer(CGoReturnPtr.return_value)) + offset))
	   goObject :=int32(cObject)
	   result[i] = goObject
	}
	 

	return result, nil 
}
// Indicates whether add summary below data.
// Returns:
//   bool  
func (instance *SubtotalSetting) GetSummaryBelowData()  (bool,  error)  {
	
	CGoReturnPtr := C.SubtotalSetting_GetSummaryBelowData( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}



func DeleteSubtotalSetting(subtotalsetting *SubtotalSetting){
	runtime.SetFinalizer(subtotalsetting, nil)
	C.Delete_SubtotalSetting(subtotalsetting.ptr)
	subtotalsetting.ptr = nil
}

// Class SystemTimeInterruptMonitor 

// Simple implementation of <see cref="AbstractInterruptMonitor"/> by checking and comparing current system time with user specified limit.
type SystemTimeInterruptMonitor struct {
	ptr unsafe.Pointer
}

// Constructs one interruption monitor.
// Parameters:
//   terminateWithoutException - bool 
func NewSystemTimeInterruptMonitor(terminatewithoutexception bool) ( *SystemTimeInterruptMonitor, error) {
	systemtimeinterruptmonitor := &SystemTimeInterruptMonitor{}
	CGoReturnPtr := C.New_SystemTimeInterruptMonitor(C.bool(terminatewithoutexception))
	if CGoReturnPtr.error_no == 0 {
		systemtimeinterruptmonitor.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(systemtimeinterruptmonitor, DeleteSystemTimeInterruptMonitor)
		return systemtimeinterruptmonitor, nil
	} else {
		systemtimeinterruptmonitor.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return systemtimeinterruptmonitor, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *SystemTimeInterruptMonitor) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.SystemTimeInterruptMonitor_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Starts the monitor with the specified time limit. The start time to calculate time cost is just when this method is called,
// so the procedure which needs to be monitored should be started just after this call.
// Parameters:
//   msLimit - int32 
// Returns:
//   void  
func (instance *SystemTimeInterruptMonitor) StartMonitor(mslimit int32)  error {
	
	CGoReturnPtr := C.SystemTimeInterruptMonitor_StartMonitor( instance.ptr, C.int(mslimit))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// This implementation just checks whether the time cost(from the time when starting this monitor to now) is greater than user specified limit.
// Returns:
//   bool  
func (instance *SystemTimeInterruptMonitor) IsInterruptionRequested()  (bool,  error)  {
	
	CGoReturnPtr := C.SystemTimeInterruptMonitor_IsInterruptionRequested( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// See <see cref="AbstractInterruptMonitor.TerminateWithoutException"/>.
// This property is specified by user when constructing this monitor instance.
// Returns:
//   bool  
func (instance *SystemTimeInterruptMonitor) GetTerminateWithoutException()  (bool,  error)  {
	
	CGoReturnPtr := C.SystemTimeInterruptMonitor_GetTerminateWithoutException( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}



func DeleteSystemTimeInterruptMonitor(systemtimeinterruptmonitor *SystemTimeInterruptMonitor){
	runtime.SetFinalizer(systemtimeinterruptmonitor, nil)
	C.Delete_SystemTimeInterruptMonitor(systemtimeinterruptmonitor.ptr)
	systemtimeinterruptmonitor.ptr = nil
}

// Class ThemeColor 

// Represents a theme color.
type ThemeColor struct {
	ptr unsafe.Pointer
}

// Parameters:
//   type - int32 
//   tint - float64 
func NewThemeColor(type_ ThemeColorType, tint float64) ( *ThemeColor, error) {
	themecolor := &ThemeColor{}
	CGoReturnPtr := C.New_ThemeColor(C.int( int32(type_)), C.double(tint))
	if CGoReturnPtr.error_no == 0 {
		themecolor.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(themecolor, DeleteThemeColor)
		return themecolor, nil
	} else {
		themecolor.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return themecolor, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *ThemeColor) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.ThemeColor_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the theme type.
// Returns:
//   int32  
func (instance *ThemeColor) GetColorType()  (ThemeColorType,  error)  {
	
	CGoReturnPtr := C.ThemeColor_GetColorType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToThemeColorType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets and sets the theme type.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *ThemeColor) SetColorType(value ThemeColorType)  error {
	
	CGoReturnPtr := C.ThemeColor_SetColorType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the tint value.
// Returns:
//   float64  
func (instance *ThemeColor) GetTint()  (float64,  error)  {
	
	CGoReturnPtr := C.ThemeColor_GetTint( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := float64(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the tint value.
// Parameters:
//   value - float64 
// Returns:
//   void  
func (instance *ThemeColor) SetTint(value float64)  error {
	
	CGoReturnPtr := C.ThemeColor_SetTint( instance.ptr, C.double(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}



func DeleteThemeColor(themecolor *ThemeColor){
	runtime.SetFinalizer(themecolor, nil)
	C.Delete_ThemeColor(themecolor.ptr)
	themecolor.ptr = nil
}

// Class ThreadedComment 

// Represents the threaded comment.
type ThreadedComment struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *ThreadedComment) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.ThreadedComment_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the row index of the comment.
// Returns:
//   int32  
func (instance *ThreadedComment) GetRow()  (int32,  error)  {
	
	CGoReturnPtr := C.ThreadedComment_GetRow( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the column index of the comment.
// Returns:
//   int32  
func (instance *ThreadedComment) GetColumn()  (int32,  error)  {
	
	CGoReturnPtr := C.ThreadedComment_GetColumn( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the text of the comment.
// Returns:
//   string  
func (instance *ThreadedComment) GetNotes()  (string,  error)  {
	
	CGoReturnPtr := C.ThreadedComment_GetNotes( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the text of the comment.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *ThreadedComment) SetNotes(value string)  error {
	
	CGoReturnPtr := C.ThreadedComment_SetNotes( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the author of the comment.
// Returns:
//   ThreadedCommentAuthor  
func (instance *ThreadedComment) GetAuthor()  (*ThreadedCommentAuthor,  error)  {
	
	CGoReturnPtr := C.ThreadedComment_GetAuthor( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &ThreadedCommentAuthor{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteThreadedCommentAuthor) 

	return result, nil 
}
// Gets the author of the comment.
// Parameters:
//   value - ThreadedCommentAuthor 
// Returns:
//   void  
func (instance *ThreadedComment) SetAuthor(value *ThreadedCommentAuthor)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.ThreadedComment_SetAuthor( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the created time of this threaded comment.
// Returns:
//   Date  
func (instance *ThreadedComment) GetCreatedTime()  (time.Time,  error)  {
	
	CGoReturnPtr := C.ThreadedComment_GetCreatedTime( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  time.Unix(0, 0), err
	}
	result := time.Date(int( C.Date_Get_year(CGoReturnPtr.return_value).return_value ),time.Month(int( C.Date_Get_month(CGoReturnPtr.return_value).return_value)),int( C.Date_Get_day(CGoReturnPtr.return_value).return_value),int(  C.Date_Get_hour(CGoReturnPtr.return_value).return_value),int( C.Date_Get_minute(CGoReturnPtr.return_value).return_value),int(  C.Date_Get_second(CGoReturnPtr.return_value).return_value), 0, time.UTC) 

	return result, nil 
}
// Gets and sets the created time of this threaded comment.
// Parameters:
//   value - Date 
// Returns:
//   void  
func (instance *ThreadedComment) SetCreatedTime(value time.Time)  error {
	
	time_value := C.Get_Date( C.int(value.Year()), C.int(value.Month()) , C.int(value.Day()) , C.int(value.Hour()) , C.int(value.Minute()) , C.int(value.Second())  )

	CGoReturnPtr := C.ThreadedComment_SetCreatedTime( instance.ptr, time_value)
	C.Delete_GetDate( time_value)

	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}



func DeleteThreadedComment(threadedcomment *ThreadedComment){
	runtime.SetFinalizer(threadedcomment, nil)
	C.Delete_ThreadedComment(threadedcomment.ptr)
	threadedcomment.ptr = nil
}

// Class ThreadedCommentAuthor 

// Represents the person who creates the threaded comments;
type ThreadedCommentAuthor struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *ThreadedCommentAuthor) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.ThreadedCommentAuthor_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the name.
// Returns:
//   string  
func (instance *ThreadedCommentAuthor) GetName()  (string,  error)  {
	
	CGoReturnPtr := C.ThreadedCommentAuthor_GetName( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the name.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *ThreadedCommentAuthor) SetName(value string)  error {
	
	CGoReturnPtr := C.ThreadedCommentAuthor_SetName( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the id of the user.
// Returns:
//   string  
func (instance *ThreadedCommentAuthor) GetUserId()  (string,  error)  {
	
	CGoReturnPtr := C.ThreadedCommentAuthor_GetUserId( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the id of the user.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *ThreadedCommentAuthor) SetUserId(value string)  error {
	
	CGoReturnPtr := C.ThreadedCommentAuthor_SetUserId( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the id of the provider.
// Returns:
//   string  
func (instance *ThreadedCommentAuthor) GetProviderId()  (string,  error)  {
	
	CGoReturnPtr := C.ThreadedCommentAuthor_GetProviderId( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the id of the provider.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *ThreadedCommentAuthor) SetProviderId(value string)  error {
	
	CGoReturnPtr := C.ThreadedCommentAuthor_SetProviderId( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}



func DeleteThreadedCommentAuthor(threadedcommentauthor *ThreadedCommentAuthor){
	runtime.SetFinalizer(threadedcommentauthor, nil)
	C.Delete_ThreadedCommentAuthor(threadedcommentauthor.ptr)
	threadedcommentauthor.ptr = nil
}

// Class ThreadedCommentAuthorCollection 

// Represents all persons who .
type ThreadedCommentAuthorCollection struct {
	ptr unsafe.Pointer
}

// Default constructor.
func NewThreadedCommentAuthorCollection() ( *ThreadedCommentAuthorCollection, error) {
	threadedcommentauthorcollection := &ThreadedCommentAuthorCollection{}
	CGoReturnPtr := C.New_ThreadedCommentAuthorCollection()
	if CGoReturnPtr.error_no == 0 {
		threadedcommentauthorcollection.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(threadedcommentauthorcollection, DeleteThreadedCommentAuthorCollection)
		return threadedcommentauthorcollection, nil
	} else {
		threadedcommentauthorcollection.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return threadedcommentauthorcollection, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *ThreadedCommentAuthorCollection) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.ThreadedCommentAuthorCollection_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the current user.
// Returns:
//   ThreadedCommentAuthor  
func (instance *ThreadedCommentAuthorCollection) GetCurrentPerson()  (*ThreadedCommentAuthor,  error)  {
	
	CGoReturnPtr := C.ThreadedCommentAuthorCollection_GetCurrentPerson( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &ThreadedCommentAuthor{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteThreadedCommentAuthor) 

	return result, nil 
}
// Gets and sets the current user.
// Parameters:
//   value - ThreadedCommentAuthor 
// Returns:
//   void  
func (instance *ThreadedCommentAuthorCollection) SetCurrentPerson(value *ThreadedCommentAuthor)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.ThreadedCommentAuthorCollection_SetCurrentPerson( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the index of ThreadedCommentAuthor object
// Parameters:
//   author - ThreadedCommentAuthor 
// Returns:
//   int32  
func (instance *ThreadedCommentAuthorCollection) IndexOf(author *ThreadedCommentAuthor)  (int32,  error)  {
	
	var author_ptr unsafe.Pointer = nil
	if author != nil {
	  author_ptr =author.ptr
	}

	CGoReturnPtr := C.ThreadedCommentAuthorCollection_IndexOf( instance.ptr, author_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the person who create threaded comments.
// Parameters:
//   index - int32 
// Returns:
//   ThreadedCommentAuthor  
func (instance *ThreadedCommentAuthorCollection) Get_Int(index int32)  (*ThreadedCommentAuthor,  error)  {
	
	CGoReturnPtr := C.ThreadedCommentAuthorCollection_Get_Integer( instance.ptr, C.int(index))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &ThreadedCommentAuthor{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteThreadedCommentAuthor) 

	return result, nil 
}
// Gets the person who create threaded comments.
// Parameters:
//   name - string 
// Returns:
//   ThreadedCommentAuthor  
func (instance *ThreadedCommentAuthorCollection) Get_String(name string)  (*ThreadedCommentAuthor,  error)  {
	
	CGoReturnPtr := C.ThreadedCommentAuthorCollection_Get_String( instance.ptr, C.CString(name))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &ThreadedCommentAuthor{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteThreadedCommentAuthor) 

	return result, nil 
}
// Adds one thread comment person.
// Parameters:
//   name - string 
//   userId - string 
//   providerId - string 
// Returns:
//   int32  
func (instance *ThreadedCommentAuthorCollection) Add(name string, userid string, providerid string)  (int32,  error)  {
	
	CGoReturnPtr := C.ThreadedCommentAuthorCollection_Add( instance.ptr, C.CString(name), C.CString(userid), C.CString(providerid))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Returns:
//   int32  
func (instance *ThreadedCommentAuthorCollection) GetCount()  (int32,  error)  {
	
	CGoReturnPtr := C.ThreadedCommentAuthorCollection_GetCount( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}



func DeleteThreadedCommentAuthorCollection(threadedcommentauthorcollection *ThreadedCommentAuthorCollection){
	runtime.SetFinalizer(threadedcommentauthorcollection, nil)
	C.Delete_ThreadedCommentAuthorCollection(threadedcommentauthorcollection.ptr)
	threadedcommentauthorcollection.ptr = nil
}

// Class ThreadedCommentCollection 

// Represents the list of threaded comments.
type ThreadedCommentCollection struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *ThreadedCommentCollection) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.ThreadedCommentCollection_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the threaded comment by the specific index.
// Parameters:
//   index - int32 
// Returns:
//   ThreadedComment  
func (instance *ThreadedCommentCollection) Get(index int32)  (*ThreadedComment,  error)  {
	
	CGoReturnPtr := C.ThreadedCommentCollection_Get( instance.ptr, C.int(index))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &ThreadedComment{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteThreadedComment) 

	return result, nil 
}
// Adds a threaded comment;
// Parameters:
//   text - string 
//   author - ThreadedCommentAuthor 
// Returns:
//   int32  
func (instance *ThreadedCommentCollection) Add(text string, author *ThreadedCommentAuthor)  (int32,  error)  {
	
	var author_ptr unsafe.Pointer = nil
	if author != nil {
	  author_ptr =author.ptr
	}

	CGoReturnPtr := C.ThreadedCommentCollection_Add( instance.ptr, C.CString(text), author_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Returns:
//   int32  
func (instance *ThreadedCommentCollection) GetCount()  (int32,  error)  {
	
	CGoReturnPtr := C.ThreadedCommentCollection_GetCount( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}



func DeleteThreadedCommentCollection(threadedcommentcollection *ThreadedCommentCollection){
	runtime.SetFinalizer(threadedcommentcollection, nil)
	C.Delete_ThreadedCommentCollection(threadedcommentcollection.ptr)
	threadedcommentcollection.ptr = nil
}

// Class Top10 

// Describe the Top10 conditional formatting rule.
// This conditional formatting rule highlights cells whose
// values fall in the top N or bottom N bracket, as specified.
type Top10 struct {
	ptr unsafe.Pointer
}

// Default constructor.
func NewTop10() ( *Top10, error) {
	top10 := &Top10{}
	CGoReturnPtr := C.New_Top10()
	if CGoReturnPtr.error_no == 0 {
		top10.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(top10, DeleteTop10)
		return top10, nil
	} else {
		top10.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return top10, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *Top10) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.Top10_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Get or set whether a "top/bottom n" rule is a "top/bottom n percent" rule.
// Default value is false.
// Returns:
//   bool  
func (instance *Top10) IsPercent()  (bool,  error)  {
	
	CGoReturnPtr := C.Top10_IsPercent( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Get or set whether a "top/bottom n" rule is a "top/bottom n percent" rule.
// Default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Top10) SetIsPercent(value bool)  error {
	
	CGoReturnPtr := C.Top10_SetIsPercent( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Get or set whether a "top/bottom n" rule is a "bottom n" rule.
// Default value is false.
// Returns:
//   bool  
func (instance *Top10) IsBottom()  (bool,  error)  {
	
	CGoReturnPtr := C.Top10_IsBottom( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Get or set whether a "top/bottom n" rule is a "bottom n" rule.
// Default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Top10) SetIsBottom(value bool)  error {
	
	CGoReturnPtr := C.Top10_SetIsBottom( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Get or set the value of "n" in a "top/bottom n" conditional formatting rule.
// If IsPercent is true, the value must between 0 and 100.
// Otherwise it must between 0 and 1000.
// Default value is 10.
// Returns:
//   int32  
func (instance *Top10) GetRank()  (int32,  error)  {
	
	CGoReturnPtr := C.Top10_GetRank( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Get or set the value of "n" in a "top/bottom n" conditional formatting rule.
// If IsPercent is true, the value must between 0 and 100.
// Otherwise it must between 0 and 1000.
// Default value is 10.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *Top10) SetRank(value int32)  error {
	
	CGoReturnPtr := C.Top10_SetRank( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}



func DeleteTop10(top10 *Top10){
	runtime.SetFinalizer(top10, nil)
	C.Delete_Top10(top10.ptr)
	top10.ptr = nil
}

// Class Top10Filter 

// Represents the top 10 filter.
type Top10Filter struct {
	ptr unsafe.Pointer
}

// Constructs from an Object convertible to this.
// Parameters:
//   obj - Object 
func NewTop10Filter(obj *Object) ( *Top10Filter, error) {
	top10filter := &Top10Filter{}
	var obj_ptr unsafe.Pointer = nil
	if obj != nil {
	  obj_ptr =obj.ptr
	}

	CGoReturnPtr := C.New_Top10Filter(obj_ptr)
	if CGoReturnPtr.error_no == 0 {
		top10filter.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(top10filter, DeleteTop10Filter)
		return top10filter, nil
	} else {
		top10filter.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return top10filter, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *Top10Filter) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.Top10Filter_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the Object.
// Returns:
//   Object  
func (instance *Top10Filter) ToObject()  (*Object,  error)  {
	
	CGoReturnPtr := C.Top10Filter_ToObject( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Object{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteObject) 

	return result, nil 
}
// Indicates whether it's top filter.
// Returns:
//   bool  
func (instance *Top10Filter) IsTop()  (bool,  error)  {
	
	CGoReturnPtr := C.Top10Filter_IsTop( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether it's top filter.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Top10Filter) SetIsTop(value bool)  error {
	
	CGoReturnPtr := C.Top10Filter_SetIsTop( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether the items is percent.
// Returns:
//   bool  
func (instance *Top10Filter) IsPercent()  (bool,  error)  {
	
	CGoReturnPtr := C.Top10Filter_IsPercent( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether the items is percent.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Top10Filter) SetIsPercent(value bool)  error {
	
	CGoReturnPtr := C.Top10Filter_SetIsPercent( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the items of the filter.
// Returns:
//   int32  
func (instance *Top10Filter) GetItems()  (int32,  error)  {
	
	CGoReturnPtr := C.Top10Filter_GetItems( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the items of the filter.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *Top10Filter) SetItems(value int32)  error {
	
	CGoReturnPtr := C.Top10Filter_SetItems( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Returns:
//   Object  
func (instance *Top10Filter) GetCriteria()  (*Object,  error)  {
	
	CGoReturnPtr := C.Top10Filter_GetCriteria( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Object{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteObject) 

	return result, nil 
}
// Parameters:
//   value - Object 
// Returns:
//   void  
func (instance *Top10Filter) SetCriteria(value *Object)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.Top10Filter_SetCriteria( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}



func DeleteTop10Filter(top10filter *Top10Filter){
	runtime.SetFinalizer(top10filter, nil)
	C.Delete_Top10Filter(top10filter.ptr)
	top10filter.ptr = nil
}

// Class TwoColorGradient 

// Represents two color gradient.
type TwoColorGradient struct {
	ptr unsafe.Pointer
}

// Parameters:
//   color1 - Color 
//   color2 - Color 
//   gradientStyleType - int32 
//   variant - int32 
func NewTwoColorGradient(color1 *Color, color2 *Color, gradientstyletype GradientStyleType, variant int32) ( *TwoColorGradient, error) {
	twocolorgradient := &TwoColorGradient{}
	CGoReturnPtr := C.New_TwoColorGradient(color1.ptr, color2.ptr, C.int( int32(gradientstyletype)), C.int(variant))
	if CGoReturnPtr.error_no == 0 {
		twocolorgradient.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(twocolorgradient, DeleteTwoColorGradient)
		return twocolorgradient, nil
	} else {
		twocolorgradient.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return twocolorgradient, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *TwoColorGradient) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.TwoColorGradient_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the first gradient color.
// Returns:
//   Color  
func (instance *TwoColorGradient) GetColor1()  (*Color,  error)  {
	
	CGoReturnPtr := C.TwoColorGradient_GetColor1( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Gets and sets the first gradient color.
// Parameters:
//   value - Color 
// Returns:
//   void  
func (instance *TwoColorGradient) SetColor1(value *Color)  error {
	
	CGoReturnPtr := C.TwoColorGradient_SetColor1( instance.ptr, value.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the second gradient color.
// Returns:
//   Color  
func (instance *TwoColorGradient) GetColor2()  (*Color,  error)  {
	
	CGoReturnPtr := C.TwoColorGradient_GetColor2( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Gets and sets the second gradient color.
// Parameters:
//   value - Color 
// Returns:
//   void  
func (instance *TwoColorGradient) SetColor2(value *Color)  error {
	
	CGoReturnPtr := C.TwoColorGradient_SetColor2( instance.ptr, value.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets gradient shading style.
// Returns:
//   int32  
func (instance *TwoColorGradient) GetGradientStyleType()  (GradientStyleType,  error)  {
	
	CGoReturnPtr := C.TwoColorGradient_GetGradientStyleType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToGradientStyleType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets and sets gradient shading style.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *TwoColorGradient) SetGradientStyleType(value GradientStyleType)  error {
	
	CGoReturnPtr := C.TwoColorGradient_SetGradientStyleType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the gradient variant.
// Returns:
//   int32  
func (instance *TwoColorGradient) GetVariant()  (int32,  error)  {
	
	CGoReturnPtr := C.TwoColorGradient_GetVariant( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the gradient variant.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *TwoColorGradient) SetVariant(value int32)  error {
	
	CGoReturnPtr := C.TwoColorGradient_SetVariant( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}



func DeleteTwoColorGradient(twocolorgradient *TwoColorGradient){
	runtime.SetFinalizer(twocolorgradient, nil)
	C.Delete_TwoColorGradient(twocolorgradient.ptr)
	twocolorgradient.ptr = nil
}

// Class TxtLoadOptions 

// Represents the options for loading text file.
type TxtLoadOptions struct {
	ptr unsafe.Pointer
}

// Creates the options for loading text file.
func NewTxtLoadOptions() ( *TxtLoadOptions, error) {
	txtloadoptions := &TxtLoadOptions{}
	CGoReturnPtr := C.New_TxtLoadOptions()
	if CGoReturnPtr.error_no == 0 {
		txtloadoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(txtloadoptions, DeleteTxtLoadOptions)
		return txtloadoptions, nil
	} else {
		txtloadoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return txtloadoptions, err
	}	
}
// Creates the options for loading text file.
// Parameters:
//   loadFormat - int32 
func NewTxtLoadOptions_LoadFormat(loadformat LoadFormat) ( *TxtLoadOptions, error) {
	txtloadoptions := &TxtLoadOptions{}
	CGoReturnPtr := C.New_TxtLoadOptions_LoadFormat(C.int( int32(loadformat)))
	if CGoReturnPtr.error_no == 0 {
		txtloadoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(txtloadoptions, DeleteTxtLoadOptions)
		return txtloadoptions, nil
	} else {
		txtloadoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return txtloadoptions, err
	}	
}
// Constructs from a parent object.
// Parameters:
//   src - AbstractTextLoadOptions 
func NewTxtLoadOptions_AbstractTextLoadOptions(src *AbstractTextLoadOptions) ( *TxtLoadOptions, error) {
	txtloadoptions := &TxtLoadOptions{}
	var src_ptr unsafe.Pointer = nil
	if src != nil {
	  src_ptr =src.ptr
	}

	CGoReturnPtr := C.New_TxtLoadOptions_AbstractTextLoadOptions(src_ptr)
	if CGoReturnPtr.error_no == 0 {
		txtloadoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(txtloadoptions, DeleteTxtLoadOptions)
		return txtloadoptions, nil
	} else {
		txtloadoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return txtloadoptions, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *TxtLoadOptions) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.TxtLoadOptions_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets character separator of text file.
// Returns:
//   byte  
func (instance *TxtLoadOptions) GetSeparator()  (byte,  error)  {
	
	CGoReturnPtr := C.TxtLoadOptions_GetSeparator( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := byte(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets character separator of text file.
// Parameters:
//   value - byte 
// Returns:
//   void  
func (instance *TxtLoadOptions) SetSeparator(value byte)  error {
	
	CGoReturnPtr := C.TxtLoadOptions_SetSeparator( instance.ptr, C.char(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets a string value as separator.
// Returns:
//   string  
func (instance *TxtLoadOptions) GetSeparatorString()  (string,  error)  {
	
	CGoReturnPtr := C.TxtLoadOptions_GetSeparatorString( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets a string value as separator.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *TxtLoadOptions) SetSeparatorString(value string)  error {
	
	CGoReturnPtr := C.TxtLoadOptions_SetSeparatorString( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// True means that the file contains several encoding.
// Returns:
//   bool  
func (instance *TxtLoadOptions) IsMultiEncoded()  (bool,  error)  {
	
	CGoReturnPtr := C.TxtLoadOptions_IsMultiEncoded( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// True means that the file contains several encoding.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *TxtLoadOptions) SetIsMultiEncoded(value bool)  error {
	
	CGoReturnPtr := C.TxtLoadOptions_SetIsMultiEncoded( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether the text is formula if it starts with "=".
// Returns:
//   bool  
func (instance *TxtLoadOptions) GetHasFormula()  (bool,  error)  {
	
	CGoReturnPtr := C.TxtLoadOptions_GetHasFormula( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether the text is formula if it starts with "=".
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *TxtLoadOptions) SetHasFormula(value bool)  error {
	
	CGoReturnPtr := C.TxtLoadOptions_SetHasFormula( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Whether there is text qualifier for cell value. Default is true.
// Returns:
//   bool  
func (instance *TxtLoadOptions) GetHasTextQualifier()  (bool,  error)  {
	
	CGoReturnPtr := C.TxtLoadOptions_GetHasTextQualifier( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Whether there is text qualifier for cell value. Default is true.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *TxtLoadOptions) SetHasTextQualifier(value bool)  error {
	
	CGoReturnPtr := C.TxtLoadOptions_SetHasTextQualifier( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Specifies the text qualifier for cell values. Default qualifier is '"'.
// Returns:
//   byte  
func (instance *TxtLoadOptions) GetTextQualifier()  (byte,  error)  {
	
	CGoReturnPtr := C.TxtLoadOptions_GetTextQualifier( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := byte(CGoReturnPtr.return_value) 

	return result, nil 
}
// Specifies the text qualifier for cell values. Default qualifier is '"'.
// Parameters:
//   value - byte 
// Returns:
//   void  
func (instance *TxtLoadOptions) SetTextQualifier(value byte)  error {
	
	CGoReturnPtr := C.TxtLoadOptions_SetTextQualifier( instance.ptr, C.char(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Whether consecutive delimiters should be treated as one.
// Returns:
//   bool  
func (instance *TxtLoadOptions) GetTreatConsecutiveDelimitersAsOne()  (bool,  error)  {
	
	CGoReturnPtr := C.TxtLoadOptions_GetTreatConsecutiveDelimitersAsOne( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Whether consecutive delimiters should be treated as one.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *TxtLoadOptions) SetTreatConsecutiveDelimitersAsOne(value bool)  error {
	
	CGoReturnPtr := C.TxtLoadOptions_SetTreatConsecutiveDelimitersAsOne( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether the leading single quote sign should be taken as part of the value of one cell.
// Default is true. If it is false, the leading single quote will be removed from corresponding cell's value
// and <see cref="Style.QuotePrefix"/> will be set as true for the cell.
// Returns:
//   bool  
func (instance *TxtLoadOptions) GetTreatQuotePrefixAsValue()  (bool,  error)  {
	
	CGoReturnPtr := C.TxtLoadOptions_GetTreatQuotePrefixAsValue( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether the leading single quote sign should be taken as part of the value of one cell.
// Default is true. If it is false, the leading single quote will be removed from corresponding cell's value
// and <see cref="Style.QuotePrefix"/> will be set as true for the cell.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *TxtLoadOptions) SetTreatQuotePrefixAsValue(value bool)  error {
	
	CGoReturnPtr := C.TxtLoadOptions_SetTreatQuotePrefixAsValue( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Whether extends data to next sheet when the rows or columns of data exceed limit.
// Default is false.
// Returns:
//   bool  
func (instance *TxtLoadOptions) GetExtendToNextSheet()  (bool,  error)  {
	
	CGoReturnPtr := C.TxtLoadOptions_GetExtendToNextSheet( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Whether extends data to next sheet when the rows or columns of data exceed limit.
// Default is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *TxtLoadOptions) SetExtendToNextSheet(value bool)  error {
	
	CGoReturnPtr := C.TxtLoadOptions_SetExtendToNextSheet( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// The count of header rows to be repeated for extended sheets.
// Returns:
//   int32  
func (instance *TxtLoadOptions) GetHeaderRowsCount()  (int32,  error)  {
	
	CGoReturnPtr := C.TxtLoadOptions_GetHeaderRowsCount( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// The count of header rows to be repeated for extended sheets.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *TxtLoadOptions) SetHeaderRowsCount(value int32)  error {
	
	CGoReturnPtr := C.TxtLoadOptions_SetHeaderRowsCount( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// The count of header columns to be repeated for extended sheets.
// Returns:
//   int32  
func (instance *TxtLoadOptions) GetHeaderColumnsCount()  (int32,  error)  {
	
	CGoReturnPtr := C.TxtLoadOptions_GetHeaderColumnsCount( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// The count of header columns to be repeated for extended sheets.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *TxtLoadOptions) SetHeaderColumnsCount(value int32)  error {
	
	CGoReturnPtr := C.TxtLoadOptions_SetHeaderColumnsCount( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// The maximum count of rows to be imported for one sheet.
// Returns:
//   int32  
func (instance *TxtLoadOptions) GetMaxRowCount()  (int32,  error)  {
	
	CGoReturnPtr := C.TxtLoadOptions_GetMaxRowCount( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// The maximum count of rows to be imported for one sheet.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *TxtLoadOptions) SetMaxRowCount(value int32)  error {
	
	CGoReturnPtr := C.TxtLoadOptions_SetMaxRowCount( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// The maximum count of columns to be imported for one sheet.
// Returns:
//   int32  
func (instance *TxtLoadOptions) GetMaxColumnCount()  (int32,  error)  {
	
	CGoReturnPtr := C.TxtLoadOptions_GetMaxColumnCount( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// The maximum count of columns to be imported for one sheet.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *TxtLoadOptions) SetMaxColumnCount(value int32)  error {
	
	CGoReturnPtr := C.TxtLoadOptions_SetMaxColumnCount( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the default encoding. Only applies for csv file.
// Returns:
//   int32  
func (instance *TxtLoadOptions) GetEncoding()  (EncodingType,  error)  {
	
	CGoReturnPtr := C.TxtLoadOptions_GetEncoding( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToEncodingType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets and sets the default encoding. Only applies for csv file.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *TxtLoadOptions) SetEncoding(value EncodingType)  error {
	
	CGoReturnPtr := C.TxtLoadOptions_SetEncoding( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates the strategy to apply style for parsed values when converting string value to number or datetime.
// Returns:
//   int32  
func (instance *TxtLoadOptions) GetLoadStyleStrategy()  (TxtLoadStyleStrategy,  error)  {
	
	CGoReturnPtr := C.TxtLoadOptions_GetLoadStyleStrategy( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToTxtLoadStyleStrategy(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Indicates the strategy to apply style for parsed values when converting string value to number or datetime.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *TxtLoadOptions) SetLoadStyleStrategy(value TxtLoadStyleStrategy)  error {
	
	CGoReturnPtr := C.TxtLoadOptions_SetLoadStyleStrategy( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets a value that indicates whether the string in text file is converted to numeric data.
// Returns:
//   bool  
func (instance *TxtLoadOptions) GetConvertNumericData()  (bool,  error)  {
	
	CGoReturnPtr := C.TxtLoadOptions_GetConvertNumericData( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets a value that indicates whether the string in text file is converted to numeric data.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *TxtLoadOptions) SetConvertNumericData(value bool)  error {
	
	CGoReturnPtr := C.TxtLoadOptions_SetConvertNumericData( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets a value that indicates whether the string in text file is converted to date data.
// Returns:
//   bool  
func (instance *TxtLoadOptions) GetConvertDateTimeData()  (bool,  error)  {
	
	CGoReturnPtr := C.TxtLoadOptions_GetConvertDateTimeData( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets a value that indicates whether the string in text file is converted to date data.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *TxtLoadOptions) SetConvertDateTimeData(value bool)  error {
	
	CGoReturnPtr := C.TxtLoadOptions_SetConvertDateTimeData( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether not parsing a string value if the length is 15.
// Returns:
//   bool  
func (instance *TxtLoadOptions) GetKeepPrecision()  (bool,  error)  {
	
	CGoReturnPtr := C.TxtLoadOptions_GetKeepPrecision( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether not parsing a string value if the length is 15.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *TxtLoadOptions) SetKeepPrecision(value bool)  error {
	
	CGoReturnPtr := C.TxtLoadOptions_SetKeepPrecision( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the load format.
// Returns:
//   int32  
func (instance *TxtLoadOptions) GetLoadFormat()  (LoadFormat,  error)  {
	
	CGoReturnPtr := C.TxtLoadOptions_GetLoadFormat( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToLoadFormat(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets and set the password of the workbook.
// Returns:
//   string  
func (instance *TxtLoadOptions) GetPassword()  (string,  error)  {
	
	CGoReturnPtr := C.TxtLoadOptions_GetPassword( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and set the password of the workbook.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *TxtLoadOptions) SetPassword(value string)  error {
	
	CGoReturnPtr := C.TxtLoadOptions_SetPassword( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether parsing the formula when reading the file.
// Returns:
//   bool  
func (instance *TxtLoadOptions) GetParsingFormulaOnOpen()  (bool,  error)  {
	
	CGoReturnPtr := C.TxtLoadOptions_GetParsingFormulaOnOpen( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether parsing the formula when reading the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *TxtLoadOptions) SetParsingFormulaOnOpen(value bool)  error {
	
	CGoReturnPtr := C.TxtLoadOptions_SetParsingFormulaOnOpen( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether parsing pivot cached records when loading the file.
// The default value is false.
// Returns:
//   bool  
func (instance *TxtLoadOptions) GetParsingPivotCachedRecords()  (bool,  error)  {
	
	CGoReturnPtr := C.TxtLoadOptions_GetParsingPivotCachedRecords( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether parsing pivot cached records when loading the file.
// The default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *TxtLoadOptions) SetParsingPivotCachedRecords(value bool)  error {
	
	CGoReturnPtr := C.TxtLoadOptions_SetParsingPivotCachedRecords( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Sets the default print paper size from default printer's setting.
// Parameters:
//   type - int32 
// Returns:
//   void  
func (instance *TxtLoadOptions) SetPaperSize(type_ PaperSizeType)  error {
	
	CGoReturnPtr := C.TxtLoadOptions_SetPaperSize( instance.ptr, C.int( int32(type_)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the user interface language of the Workbook version based on CountryCode that has saved the file.
// Returns:
//   int32  
func (instance *TxtLoadOptions) GetLanguageCode()  (CountryCode,  error)  {
	
	CGoReturnPtr := C.TxtLoadOptions_GetLanguageCode( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToCountryCode(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets or sets the user interface language of the Workbook version based on CountryCode that has saved the file.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *TxtLoadOptions) SetLanguageCode(value CountryCode)  error {
	
	CGoReturnPtr := C.TxtLoadOptions_SetLanguageCode( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the regional settings used for the Workbook that will be loaded.
// Returns:
//   int32  
func (instance *TxtLoadOptions) GetRegion()  (CountryCode,  error)  {
	
	CGoReturnPtr := C.TxtLoadOptions_GetRegion( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToCountryCode(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets or sets the regional settings used for the Workbook that will be loaded.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *TxtLoadOptions) SetRegion(value CountryCode)  error {
	
	CGoReturnPtr := C.TxtLoadOptions_SetRegion( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the default style settings for initializing styles of the workbook
// Returns:
//   DefaultStyleSettings  
func (instance *TxtLoadOptions) GetDefaultStyleSettings()  (*DefaultStyleSettings,  error)  {
	
	CGoReturnPtr := C.TxtLoadOptions_GetDefaultStyleSettings( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &DefaultStyleSettings{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteDefaultStyleSettings) 

	return result, nil 
}
// Gets and sets the interrupt monitor.
// Returns:
//   AbstractInterruptMonitor  
func (instance *TxtLoadOptions) GetInterruptMonitor()  (*AbstractInterruptMonitor,  error)  {
	
	CGoReturnPtr := C.TxtLoadOptions_GetInterruptMonitor( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &AbstractInterruptMonitor{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteAbstractInterruptMonitor) 

	return result, nil 
}
// Gets and sets the interrupt monitor.
// Parameters:
//   value - AbstractInterruptMonitor 
// Returns:
//   void  
func (instance *TxtLoadOptions) SetInterruptMonitor(value *AbstractInterruptMonitor)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.TxtLoadOptions_SetInterruptMonitor( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Ignore the data which are not printed if directly printing the file
// Returns:
//   bool  
func (instance *TxtLoadOptions) GetIgnoreNotPrinted()  (bool,  error)  {
	
	CGoReturnPtr := C.TxtLoadOptions_GetIgnoreNotPrinted( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Ignore the data which are not printed if directly printing the file
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *TxtLoadOptions) SetIgnoreNotPrinted(value bool)  error {
	
	CGoReturnPtr := C.TxtLoadOptions_SetIgnoreNotPrinted( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Check whether data is valid in the template file.
// Returns:
//   bool  
func (instance *TxtLoadOptions) GetCheckDataValid()  (bool,  error)  {
	
	CGoReturnPtr := C.TxtLoadOptions_GetCheckDataValid( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Check whether data is valid in the template file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *TxtLoadOptions) SetCheckDataValid(value bool)  error {
	
	CGoReturnPtr := C.TxtLoadOptions_SetCheckDataValid( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Whether check restriction of excel file when user modify cells related objects.
// For example, excel does not allow inputting string value longer than 32K.
// When you input a value longer than 32K such as by Cell.PutValue(string), if this property is true, you will get an Exception.
// If this property is false, we will accept your input string value as the cell's value so that later
// you can output the complete string value for other file formats such as CSV.
// However, if you have set such kind of value that is invalid for excel file format,
// you should not save the workbook as excel file format later. Otherwise there may be unexpected error for the generated excel file.
// Returns:
//   bool  
func (instance *TxtLoadOptions) GetCheckExcelRestriction()  (bool,  error)  {
	
	CGoReturnPtr := C.TxtLoadOptions_GetCheckExcelRestriction( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Whether check restriction of excel file when user modify cells related objects.
// For example, excel does not allow inputting string value longer than 32K.
// When you input a value longer than 32K such as by Cell.PutValue(string), if this property is true, you will get an Exception.
// If this property is false, we will accept your input string value as the cell's value so that later
// you can output the complete string value for other file formats such as CSV.
// However, if you have set such kind of value that is invalid for excel file format,
// you should not save the workbook as excel file format later. Otherwise there may be unexpected error for the generated excel file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *TxtLoadOptions) SetCheckExcelRestriction(value bool)  error {
	
	CGoReturnPtr := C.TxtLoadOptions_SetCheckExcelRestriction( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Whether keep the unparsed data in memory for the Workbook when it is loaded from template file. Default is true.
// Returns:
//   bool  
func (instance *TxtLoadOptions) GetKeepUnparsedData()  (bool,  error)  {
	
	CGoReturnPtr := C.TxtLoadOptions_GetKeepUnparsedData( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Whether keep the unparsed data in memory for the Workbook when it is loaded from template file. Default is true.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *TxtLoadOptions) SetKeepUnparsedData(value bool)  error {
	
	CGoReturnPtr := C.TxtLoadOptions_SetKeepUnparsedData( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// The filter to denote how to load data.
// Returns:
//   LoadFilter  
func (instance *TxtLoadOptions) GetLoadFilter()  (*LoadFilter,  error)  {
	
	CGoReturnPtr := C.TxtLoadOptions_GetLoadFilter( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &LoadFilter{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteLoadFilter) 

	return result, nil 
}
// The filter to denote how to load data.
// Parameters:
//   value - LoadFilter 
// Returns:
//   void  
func (instance *TxtLoadOptions) SetLoadFilter(value *LoadFilter)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.TxtLoadOptions_SetLoadFilter( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the memory usage options.
// Returns:
//   int32  
func (instance *TxtLoadOptions) GetMemorySetting()  (MemorySetting,  error)  {
	
	CGoReturnPtr := C.TxtLoadOptions_GetMemorySetting( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToMemorySetting(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets or sets the memory usage options.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *TxtLoadOptions) SetMemorySetting(value MemorySetting)  error {
	
	CGoReturnPtr := C.TxtLoadOptions_SetMemorySetting( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the auto fitter options
// Returns:
//   AutoFitterOptions  
func (instance *TxtLoadOptions) GetAutoFitterOptions()  (*AutoFitterOptions,  error)  {
	
	CGoReturnPtr := C.TxtLoadOptions_GetAutoFitterOptions( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &AutoFitterOptions{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteAutoFitterOptions) 

	return result, nil 
}
// Gets and sets the auto fitter options
// Parameters:
//   value - AutoFitterOptions 
// Returns:
//   void  
func (instance *TxtLoadOptions) SetAutoFitterOptions(value *AutoFitterOptions)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.TxtLoadOptions_SetAutoFitterOptions( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether auto filtering the data when loading the files.
// Returns:
//   bool  
func (instance *TxtLoadOptions) GetAutoFilter()  (bool,  error)  {
	
	CGoReturnPtr := C.TxtLoadOptions_GetAutoFilter( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether auto filtering the data when loading the files.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *TxtLoadOptions) SetAutoFilter(value bool)  error {
	
	CGoReturnPtr := C.TxtLoadOptions_SetAutoFilter( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets individual font configs.
// Only works for the <see cref="Workbook"/> which uses this <see cref="LoadOptions"/> to load.
// Returns:
//   IndividualFontConfigs  
func (instance *TxtLoadOptions) GetFontConfigs()  (*IndividualFontConfigs,  error)  {
	
	CGoReturnPtr := C.TxtLoadOptions_GetFontConfigs( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &IndividualFontConfigs{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteIndividualFontConfigs) 

	return result, nil 
}
// Gets and sets individual font configs.
// Only works for the <see cref="Workbook"/> which uses this <see cref="LoadOptions"/> to load.
// Parameters:
//   value - IndividualFontConfigs 
// Returns:
//   void  
func (instance *TxtLoadOptions) SetFontConfigs(value *IndividualFontConfigs)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.TxtLoadOptions_SetFontConfigs( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether ignoring useless shapes.
// Returns:
//   bool  
func (instance *TxtLoadOptions) GetIgnoreUselessShapes()  (bool,  error)  {
	
	CGoReturnPtr := C.TxtLoadOptions_GetIgnoreUselessShapes( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether ignoring useless shapes.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *TxtLoadOptions) SetIgnoreUselessShapes(value bool)  error {
	
	CGoReturnPtr := C.TxtLoadOptions_SetIgnoreUselessShapes( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether preserve those spaces and line breaks that are padded between formula tokens
// while getting and setting formulas.
// Default value is false.
// Returns:
//   bool  
func (instance *TxtLoadOptions) GetPreservePaddingSpacesInFormula()  (bool,  error)  {
	
	CGoReturnPtr := C.TxtLoadOptions_GetPreservePaddingSpacesInFormula( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether preserve those spaces and line breaks that are padded between formula tokens
// while getting and setting formulas.
// Default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *TxtLoadOptions) SetPreservePaddingSpacesInFormula(value bool)  error {
	
	CGoReturnPtr := C.TxtLoadOptions_SetPreservePaddingSpacesInFormula( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}


func (instance *TxtLoadOptions) ToAbstractTextLoadOptions() *AbstractTextLoadOptions {
	parentClass := &AbstractTextLoadOptions{}
	parentClass.ptr = instance.ptr
	return parentClass
}
func (instance *TxtLoadOptions) ToLoadOptions() *LoadOptions {
	parentClass := &LoadOptions{}
	parentClass.ptr = instance.ptr
	return parentClass
}

func DeleteTxtLoadOptions(txtloadoptions *TxtLoadOptions){
	runtime.SetFinalizer(txtloadoptions, nil)
	C.Delete_TxtLoadOptions(txtloadoptions.ptr)
	txtloadoptions.ptr = nil
}

// Class TxtSaveOptions 

// Represents the save options for csv/tab delimited/other text format.
type TxtSaveOptions struct {
	ptr unsafe.Pointer
}

// Creates text file save options.
func NewTxtSaveOptions() ( *TxtSaveOptions, error) {
	txtsaveoptions := &TxtSaveOptions{}
	CGoReturnPtr := C.New_TxtSaveOptions()
	if CGoReturnPtr.error_no == 0 {
		txtsaveoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(txtsaveoptions, DeleteTxtSaveOptions)
		return txtsaveoptions, nil
	} else {
		txtsaveoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return txtsaveoptions, err
	}	
}
// Creates text file save options.
// Parameters:
//   saveFormat - int32 
func NewTxtSaveOptions_SaveFormat(saveformat SaveFormat) ( *TxtSaveOptions, error) {
	txtsaveoptions := &TxtSaveOptions{}
	CGoReturnPtr := C.New_TxtSaveOptions_SaveFormat(C.int( int32(saveformat)))
	if CGoReturnPtr.error_no == 0 {
		txtsaveoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(txtsaveoptions, DeleteTxtSaveOptions)
		return txtsaveoptions, nil
	} else {
		txtsaveoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return txtsaveoptions, err
	}	
}
// Constructs from a parent object.
// Parameters:
//   src - SaveOptions 
func NewTxtSaveOptions_SaveOptions(src *SaveOptions) ( *TxtSaveOptions, error) {
	txtsaveoptions := &TxtSaveOptions{}
	var src_ptr unsafe.Pointer = nil
	if src != nil {
	  src_ptr =src.ptr
	}

	CGoReturnPtr := C.New_TxtSaveOptions_SaveOptions(src_ptr)
	if CGoReturnPtr.error_no == 0 {
		txtsaveoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(txtsaveoptions, DeleteTxtSaveOptions)
		return txtsaveoptions, nil
	} else {
		txtsaveoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return txtsaveoptions, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *TxtSaveOptions) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.TxtSaveOptions_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets char Delimiter of text file.
// Returns:
//   byte  
func (instance *TxtSaveOptions) GetSeparator()  (byte,  error)  {
	
	CGoReturnPtr := C.TxtSaveOptions_GetSeparator( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := byte(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets char Delimiter of text file.
// Parameters:
//   value - byte 
// Returns:
//   void  
func (instance *TxtSaveOptions) SetSeparator(value byte)  error {
	
	CGoReturnPtr := C.TxtSaveOptions_SetSeparator( instance.ptr, C.char(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets a string value as separator.
// Returns:
//   string  
func (instance *TxtSaveOptions) GetSeparatorString()  (string,  error)  {
	
	CGoReturnPtr := C.TxtSaveOptions_GetSeparatorString( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets a string value as separator.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *TxtSaveOptions) SetSeparatorString(value string)  error {
	
	CGoReturnPtr := C.TxtSaveOptions_SetSeparatorString( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the default encoding.
// Returns:
//   int32  
func (instance *TxtSaveOptions) GetEncoding()  (EncodingType,  error)  {
	
	CGoReturnPtr := C.TxtSaveOptions_GetEncoding( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToEncodingType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets and sets the default encoding.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *TxtSaveOptions) SetEncoding(value EncodingType)  error {
	
	CGoReturnPtr := C.TxtSaveOptions_SetEncoding( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets how to quote values in the exported text file.
// Returns:
//   int32  
func (instance *TxtSaveOptions) GetQuoteType()  (TxtValueQuoteType,  error)  {
	
	CGoReturnPtr := C.TxtSaveOptions_GetQuoteType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToTxtValueQuoteType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets or sets how to quote values in the exported text file.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *TxtSaveOptions) SetQuoteType(value TxtValueQuoteType)  error {
	
	CGoReturnPtr := C.TxtSaveOptions_SetQuoteType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the format strategy when exporting the cell value as string.
// Returns:
//   int32  
func (instance *TxtSaveOptions) GetFormatStrategy()  (CellValueFormatStrategy,  error)  {
	
	CGoReturnPtr := C.TxtSaveOptions_GetFormatStrategy( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToCellValueFormatStrategy(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets and sets the format strategy when exporting the cell value as string.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *TxtSaveOptions) SetFormatStrategy(value CellValueFormatStrategy)  error {
	
	CGoReturnPtr := C.TxtSaveOptions_SetFormatStrategy( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether leading blank rows and columns should be trimmed like what ms excel does.
// Default is true.
// Returns:
//   bool  
func (instance *TxtSaveOptions) GetTrimLeadingBlankRowAndColumn()  (bool,  error)  {
	
	CGoReturnPtr := C.TxtSaveOptions_GetTrimLeadingBlankRowAndColumn( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether leading blank rows and columns should be trimmed like what ms excel does.
// Default is true.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *TxtSaveOptions) SetTrimLeadingBlankRowAndColumn(value bool)  error {
	
	CGoReturnPtr := C.TxtSaveOptions_SetTrimLeadingBlankRowAndColumn( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether tailing blank cells in one row should be trimmed. Default is false.
// Returns:
//   bool  
func (instance *TxtSaveOptions) GetTrimTailingBlankCells()  (bool,  error)  {
	
	CGoReturnPtr := C.TxtSaveOptions_GetTrimTailingBlankCells( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether tailing blank cells in one row should be trimmed. Default is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *TxtSaveOptions) SetTrimTailingBlankCells(value bool)  error {
	
	CGoReturnPtr := C.TxtSaveOptions_SetTrimTailingBlankCells( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether separators should be output for blank row.
// Default value is false so by default the content for blank row will be empty.
// Returns:
//   bool  
func (instance *TxtSaveOptions) GetKeepSeparatorsForBlankRow()  (bool,  error)  {
	
	CGoReturnPtr := C.TxtSaveOptions_GetKeepSeparatorsForBlankRow( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether separators should be output for blank row.
// Default value is false so by default the content for blank row will be empty.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *TxtSaveOptions) SetKeepSeparatorsForBlankRow(value bool)  error {
	
	CGoReturnPtr := C.TxtSaveOptions_SetKeepSeparatorsForBlankRow( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// The range of cells to be exported.
// Returns:
//   CellArea  
func (instance *TxtSaveOptions) GetExportArea()  (*CellArea,  error)  {
	
	CGoReturnPtr := C.TxtSaveOptions_GetExportArea( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &CellArea{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteCellArea) 

	return result, nil 
}
// The range of cells to be exported.
// Parameters:
//   value - CellArea 
// Returns:
//   void  
func (instance *TxtSaveOptions) SetExportArea(value *CellArea)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.TxtSaveOptions_SetExportArea( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether the single quote sign should be exported as part of the value of one cell
// when <see cref="Style.QuotePrefix"/> is true for it. Default is false.
// Returns:
//   bool  
func (instance *TxtSaveOptions) GetExportQuotePrefix()  (bool,  error)  {
	
	CGoReturnPtr := C.TxtSaveOptions_GetExportQuotePrefix( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether the single quote sign should be exported as part of the value of one cell
// when <see cref="Style.QuotePrefix"/> is true for it. Default is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *TxtSaveOptions) SetExportQuotePrefix(value bool)  error {
	
	CGoReturnPtr := C.TxtSaveOptions_SetExportQuotePrefix( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether exporting all sheets to the text file.
// If it is false, only export the activesheet, just like MS Excel.
// Returns:
//   bool  
func (instance *TxtSaveOptions) GetExportAllSheets()  (bool,  error)  {
	
	CGoReturnPtr := C.TxtSaveOptions_GetExportAllSheets( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether exporting all sheets to the text file.
// If it is false, only export the activesheet, just like MS Excel.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *TxtSaveOptions) SetExportAllSheets(value bool)  error {
	
	CGoReturnPtr := C.TxtSaveOptions_SetExportAllSheets( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the save file format.
// Returns:
//   int32  
func (instance *TxtSaveOptions) GetSaveFormat()  (SaveFormat,  error)  {
	
	CGoReturnPtr := C.TxtSaveOptions_GetSaveFormat( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToSaveFormat(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Make the workbook empty after saving the file.
// Returns:
//   bool  
func (instance *TxtSaveOptions) GetClearData()  (bool,  error)  {
	
	CGoReturnPtr := C.TxtSaveOptions_GetClearData( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Make the workbook empty after saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *TxtSaveOptions) SetClearData(value bool)  error {
	
	CGoReturnPtr := C.TxtSaveOptions_SetClearData( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// The folder for temporary files that may be used as data cache.
// Returns:
//   string  
func (instance *TxtSaveOptions) GetCachedFileFolder()  (string,  error)  {
	
	CGoReturnPtr := C.TxtSaveOptions_GetCachedFileFolder( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// The folder for temporary files that may be used as data cache.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *TxtSaveOptions) SetCachedFileFolder(value string)  error {
	
	CGoReturnPtr := C.TxtSaveOptions_SetCachedFileFolder( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether validate merged cells before saving the file.
// Returns:
//   bool  
func (instance *TxtSaveOptions) GetValidateMergedAreas()  (bool,  error)  {
	
	CGoReturnPtr := C.TxtSaveOptions_GetValidateMergedAreas( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether validate merged cells before saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *TxtSaveOptions) SetValidateMergedAreas(value bool)  error {
	
	CGoReturnPtr := C.TxtSaveOptions_SetValidateMergedAreas( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether merge the areas of conditional formatting and validation before saving the file.
// Returns:
//   bool  
func (instance *TxtSaveOptions) GetMergeAreas()  (bool,  error)  {
	
	CGoReturnPtr := C.TxtSaveOptions_GetMergeAreas( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether merge the areas of conditional formatting and validation before saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *TxtSaveOptions) SetMergeAreas(value bool)  error {
	
	CGoReturnPtr := C.TxtSaveOptions_SetMergeAreas( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// If true and the directory does not exist, the directory will be automatically created before saving the file.
// Returns:
//   bool  
func (instance *TxtSaveOptions) GetCreateDirectory()  (bool,  error)  {
	
	CGoReturnPtr := C.TxtSaveOptions_GetCreateDirectory( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// If true and the directory does not exist, the directory will be automatically created before saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *TxtSaveOptions) SetCreateDirectory(value bool)  error {
	
	CGoReturnPtr := C.TxtSaveOptions_SetCreateDirectory( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether sorting defined names before saving file.
// Returns:
//   bool  
func (instance *TxtSaveOptions) GetSortNames()  (bool,  error)  {
	
	CGoReturnPtr := C.TxtSaveOptions_GetSortNames( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether sorting defined names before saving file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *TxtSaveOptions) SetSortNames(value bool)  error {
	
	CGoReturnPtr := C.TxtSaveOptions_SetSortNames( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether sorting external defined names before saving file.
// Returns:
//   bool  
func (instance *TxtSaveOptions) GetSortExternalNames()  (bool,  error)  {
	
	CGoReturnPtr := C.TxtSaveOptions_GetSortExternalNames( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether sorting external defined names before saving file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *TxtSaveOptions) SetSortExternalNames(value bool)  error {
	
	CGoReturnPtr := C.TxtSaveOptions_SetSortExternalNames( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether refreshing chart cache data
// Returns:
//   bool  
func (instance *TxtSaveOptions) GetRefreshChartCache()  (bool,  error)  {
	
	CGoReturnPtr := C.TxtSaveOptions_GetRefreshChartCache( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether refreshing chart cache data
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *TxtSaveOptions) SetRefreshChartCache(value bool)  error {
	
	CGoReturnPtr := C.TxtSaveOptions_SetRefreshChartCache( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Whether check restriction of excel file when user modify cells related objects.
// For example, excel does not allow inputting string value longer than 32K.
// When you input a value longer than 32K, it will be truncated.
// Returns:
//   bool  
func (instance *TxtSaveOptions) GetCheckExcelRestriction()  (bool,  error)  {
	
	CGoReturnPtr := C.TxtSaveOptions_GetCheckExcelRestriction( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Whether check restriction of excel file when user modify cells related objects.
// For example, excel does not allow inputting string value longer than 32K.
// When you input a value longer than 32K, it will be truncated.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *TxtSaveOptions) SetCheckExcelRestriction(value bool)  error {
	
	CGoReturnPtr := C.TxtSaveOptions_SetCheckExcelRestriction( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether updating smart art setting.
// The default value is false.
// Returns:
//   bool  
func (instance *TxtSaveOptions) GetUpdateSmartArt()  (bool,  error)  {
	
	CGoReturnPtr := C.TxtSaveOptions_GetUpdateSmartArt( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether updating smart art setting.
// The default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *TxtSaveOptions) SetUpdateSmartArt(value bool)  error {
	
	CGoReturnPtr := C.TxtSaveOptions_SetUpdateSmartArt( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether encrypt document properties when saving as .xls file.
// The default value is true.
// Returns:
//   bool  
func (instance *TxtSaveOptions) GetEncryptDocumentProperties()  (bool,  error)  {
	
	CGoReturnPtr := C.TxtSaveOptions_GetEncryptDocumentProperties( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether encrypt document properties when saving as .xls file.
// The default value is true.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *TxtSaveOptions) SetEncryptDocumentProperties(value bool)  error {
	
	CGoReturnPtr := C.TxtSaveOptions_SetEncryptDocumentProperties( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}


func (instance *TxtSaveOptions) ToSaveOptions() *SaveOptions {
	parentClass := &SaveOptions{}
	parentClass.ptr = instance.ptr
	return parentClass
}

func DeleteTxtSaveOptions(txtsaveoptions *TxtSaveOptions){
	runtime.SetFinalizer(txtsaveoptions, nil)
	C.Delete_TxtSaveOptions(txtsaveoptions.ptr)
	txtsaveoptions.ptr = nil
}

// Class UnionRange 

// Represents union range.
type UnionRange struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *UnionRange) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.UnionRange_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the index of the first row of the range.
// Returns:
//   int32  
func (instance *UnionRange) GetFirstRow()  (int32,  error)  {
	
	CGoReturnPtr := C.UnionRange_GetFirstRow( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the index of the first column of the range.
// Returns:
//   int32  
func (instance *UnionRange) GetFirstColumn()  (int32,  error)  {
	
	CGoReturnPtr := C.UnionRange_GetFirstColumn( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the count of rows in the range.
// Returns:
//   int32  
func (instance *UnionRange) GetRowCount()  (int32,  error)  {
	
	CGoReturnPtr := C.UnionRange_GetRowCount( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the count of rows in the range.
// Returns:
//   int32  
func (instance *UnionRange) GetColumnCount()  (int32,  error)  {
	
	CGoReturnPtr := C.UnionRange_GetColumnCount( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Combines a range of cells into a single cell.
// Returns:
//   void  
func (instance *UnionRange) Merge()  error {
	
	CGoReturnPtr := C.UnionRange_Merge( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Unmerges merged cells of this range.
// Returns:
//   void  
func (instance *UnionRange) UnMerge()  error {
	
	CGoReturnPtr := C.UnionRange_UnMerge( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Puts a value into the range, if appropriate the value will be converted to other data type and cell's number format will be reset.
// Parameters:
//   stringValue - string 
//   isConverted - bool 
//   setStyle - bool 
// Returns:
//   void  
func (instance *UnionRange) PutValue(stringvalue string, isconverted bool, setstyle bool)  error {
	
	CGoReturnPtr := C.UnionRange_PutValue( instance.ptr, C.CString(stringvalue), C.bool(isconverted), C.bool(setstyle))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the values of the range.
// Returns:
//   Object  
func (instance *UnionRange) GetValue()  (*Object,  error)  {
	
	CGoReturnPtr := C.UnionRange_GetValue( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Object{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteObject) 

	return result, nil 
}
// Gets and sets the values of the range.
// Parameters:
//   value - Object 
// Returns:
//   void  
func (instance *UnionRange) SetValue(value *Object)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.UnionRange_SetValue( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the name of the range.
// Returns:
//   string  
func (instance *UnionRange) GetName()  (string,  error)  {
	
	CGoReturnPtr := C.UnionRange_GetName( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets the name of the range.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *UnionRange) SetName(value string)  error {
	
	CGoReturnPtr := C.UnionRange_SetName( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the range's refers to.
// Returns:
//   string  
func (instance *UnionRange) GetRefersTo()  (string,  error)  {
	
	CGoReturnPtr := C.UnionRange_GetRefersTo( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether this has range.
// Returns:
//   bool  
func (instance *UnionRange) GetHasRange()  (bool,  error)  {
	
	CGoReturnPtr := C.UnionRange_GetHasRange( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets all hyperlink in the range.
// Returns:
//   []Hyperlink  
func (instance *UnionRange) GetHyperlinks()  ([]Hyperlink,  error)  {
	
	CGoReturnPtr := C.UnionRange_GetHyperlinks( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result:= make([]Hyperlink, CGoReturnPtr.column_length)
	for i := 0; i < int(CGoReturnPtr.column_length); i++ {
	   offset := uintptr(C.size_t(i)) * uintptr(CGoReturnPtr.size)
	   goObject := &Hyperlink{}
	   goObject.ptr =unsafe.Pointer(uintptr( unsafe.Pointer(CGoReturnPtr.return_value)) + offset)
	   result[i] = *goObject
	}
	 

	return result, nil 
}
// Sets the style of the range.
// Parameters:
//   style - Style 
// Returns:
//   void  
func (instance *UnionRange) SetStyle(style *Style)  error {
	
	var style_ptr unsafe.Pointer = nil
	if style != nil {
	  style_ptr =style.ptr
	}

	CGoReturnPtr := C.UnionRange_SetStyle( instance.ptr, style_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Applies formats for a whole range.
// Parameters:
//   style - Style 
//   flag - StyleFlag 
// Returns:
//   void  
func (instance *UnionRange) ApplyStyle(style *Style, flag *StyleFlag)  error {
	
	var style_ptr unsafe.Pointer = nil
	if style != nil {
	  style_ptr =style.ptr
	}
	var flag_ptr unsafe.Pointer = nil
	if flag != nil {
	  flag_ptr =flag.ptr
	}

	CGoReturnPtr := C.UnionRange_ApplyStyle( instance.ptr, style_ptr, flag_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Copying the range with paste special options.
// Parameters:
//   range - UnionRange 
//   options - PasteOptions 
// Returns:
//   void  
func (instance *UnionRange) Copy(range_ *UnionRange, options *PasteOptions)  error {
	
	var range__ptr unsafe.Pointer = nil
	if range_ != nil {
	  range__ptr =range_.ptr
	}
	var options_ptr unsafe.Pointer = nil
	if options != nil {
	  options_ptr =options.ptr
	}

	CGoReturnPtr := C.UnionRange_Copy( instance.ptr, range__ptr, options_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the enumerator for cells in this Range.
// Returns:
//   unsafe.Pointer  
func (instance *UnionRange) GetEnumerator()  (*CellEnumerator,  error)  {
	
	CGoReturnPtr := C.UnionRange_GetEnumerator( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &CellEnumerator{}
	result.ptr = CGoReturnPtr.return_value
	runtime.SetFinalizer(result, DeleteCellEnumerator)
	 

	return result, nil 
}
// Gets all cell count in the range.
// Returns:
//   int32  
func (instance *UnionRange) GetCellCount()  (int32,  error)  {
	
	CGoReturnPtr := C.UnionRange_GetCellCount( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the count of the ranges.
// Returns:
//   int32  
func (instance *UnionRange) GetRangeCount()  (int32,  error)  {
	
	CGoReturnPtr := C.UnionRange_GetRangeCount( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets all union ranges.
// Returns:
//   []Range  
func (instance *UnionRange) GetRanges()  ([]Range,  error)  {
	
	CGoReturnPtr := C.UnionRange_GetRanges( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result:= make([]Range, CGoReturnPtr.column_length)
	for i := 0; i < int(CGoReturnPtr.column_length); i++ {
	   offset := uintptr(C.size_t(i)) * uintptr(CGoReturnPtr.size)
	   goObject := &Range{}
	   goObject.ptr =unsafe.Pointer(uintptr( unsafe.Pointer(CGoReturnPtr.return_value)) + offset)
	   result[i] = *goObject
	}
	 

	return result, nil 
}
// Sets out line borders around a range of cells.
// Parameters:
//   borderStyles - []CellBorderType 
//   borderColors - []Color 
// Returns:
//   void  
func (instance *UnionRange) SetOutlineBorders_CellBorderTypeArray_ColorArray(borderstyles []CellBorderType, bordercolors []Color)  error {
	
	bordercolors_length := len(bordercolors)
	vector_bordercolors:= make([]unsafe.Pointer, bordercolors_length)
	for i := 0; i < bordercolors_length; i++ {
		vector_bordercolors[i] = bordercolors[i].ptr
	}


	CGoReturnPtr := C.UnionRange_SetOutlineBorders_CellBorderTypeArray_ColorArray( instance.ptr, unsafe.Pointer(&borderstyles[0]), C.int( len(borderstyles)), unsafe.Pointer(&vector_bordercolors[0]), C.int( len(bordercolors)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Sets the outline borders around a range of cells with same border style and color.
// Parameters:
//   borderStyle - int32 
//   borderColor - Color 
// Returns:
//   void  
func (instance *UnionRange) SetOutlineBorders_CellBorderType_Color(borderstyle CellBorderType, bordercolor *Color)  error {
	
	CGoReturnPtr := C.UnionRange_SetOutlineBorders_CellBorderType_Color( instance.ptr, C.int( int32(borderstyle)), bordercolor.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Intersects another range.
// Parameters:
//   range - string 
// Returns:
//   UnionRange  
func (instance *UnionRange) Intersect_String(range_ string)  (*UnionRange,  error)  {
	
	CGoReturnPtr := C.UnionRange_Intersect_String( instance.ptr, C.CString(range_))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &UnionRange{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteUnionRange) 

	return result, nil 
}
// Intersects another range.
// Parameters:
//   unionRange - UnionRange 
// Returns:
//   UnionRange  
func (instance *UnionRange) Intersect_UnionRange(unionrange *UnionRange)  (*UnionRange,  error)  {
	
	var unionrange_ptr unsafe.Pointer = nil
	if unionrange != nil {
	  unionrange_ptr =unionrange.ptr
	}

	CGoReturnPtr := C.UnionRange_Intersect_UnionRange( instance.ptr, unionrange_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &UnionRange{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteUnionRange) 

	return result, nil 
}
// Intersects another range.
// Parameters:
//   ranges - []Range 
// Returns:
//   UnionRange  
func (instance *UnionRange) Intersect_RangeArray(ranges []Range)  (*UnionRange,  error)  {
	
	ranges_length := len(ranges)
	vector_ranges:= make([]unsafe.Pointer, ranges_length)
	for i := 0; i < ranges_length; i++ {
		vector_ranges[i] = ranges[i].ptr
	}


	CGoReturnPtr := C.UnionRange_Intersect_RangeArray( instance.ptr, unsafe.Pointer(&vector_ranges[0]), C.int( len(ranges)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &UnionRange{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteUnionRange) 

	return result, nil 
}
// Union another range.
// Parameters:
//   range - string 
// Returns:
//   UnionRange  
func (instance *UnionRange) Union_String(range_ string)  (*UnionRange,  error)  {
	
	CGoReturnPtr := C.UnionRange_Union_String( instance.ptr, C.CString(range_))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &UnionRange{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteUnionRange) 

	return result, nil 
}
// Union another range.
// Parameters:
//   unionRange - UnionRange 
// Returns:
//   UnionRange  
func (instance *UnionRange) Union_UnionRange(unionrange *UnionRange)  (*UnionRange,  error)  {
	
	var unionrange_ptr unsafe.Pointer = nil
	if unionrange != nil {
	  unionrange_ptr =unionrange.ptr
	}

	CGoReturnPtr := C.UnionRange_Union_UnionRange( instance.ptr, unionrange_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &UnionRange{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteUnionRange) 

	return result, nil 
}
// Union the ranges.
// Parameters:
//   ranges - []Range 
// Returns:
//   UnionRange  
func (instance *UnionRange) Union_RangeArray(ranges []Range)  (*UnionRange,  error)  {
	
	ranges_length := len(ranges)
	vector_ranges:= make([]unsafe.Pointer, ranges_length)
	for i := 0; i < ranges_length; i++ {
		vector_ranges[i] = ranges[i].ptr
	}


	CGoReturnPtr := C.UnionRange_Union_RangeArray( instance.ptr, unsafe.Pointer(&vector_ranges[0]), C.int( len(ranges)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &UnionRange{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteUnionRange) 

	return result, nil 
}



func DeleteUnionRange(unionrange *UnionRange){
	runtime.SetFinalizer(unionrange, nil)
	C.Delete_UnionRange(unionrange.ptr)
	unionrange.ptr = nil
}

// Class Validation 

// Represents data validation.settings.
type Validation struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *Validation) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.Validation_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents the operator for the data validation.
// Returns:
//   int32  
func (instance *Validation) GetOperator()  (OperatorType,  error)  {
	
	CGoReturnPtr := C.Validation_GetOperator( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToOperatorType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Represents the operator for the data validation.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *Validation) SetOperator(value OperatorType)  error {
	
	CGoReturnPtr := C.Validation_SetOperator( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents the validation alert style.
// Returns:
//   int32  
func (instance *Validation) GetAlertStyle()  (ValidationAlertType,  error)  {
	
	CGoReturnPtr := C.Validation_GetAlertStyle( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToValidationAlertType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Represents the validation alert style.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *Validation) SetAlertStyle(value ValidationAlertType)  error {
	
	CGoReturnPtr := C.Validation_SetAlertStyle( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents the data validation type.
// Returns:
//   int32  
func (instance *Validation) GetType()  (ValidationType,  error)  {
	
	CGoReturnPtr := C.Validation_GetType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToValidationType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Represents the data validation type.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *Validation) SetType(value ValidationType)  error {
	
	CGoReturnPtr := C.Validation_SetType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents the data validation input message.
// Returns:
//   string  
func (instance *Validation) GetInputMessage()  (string,  error)  {
	
	CGoReturnPtr := C.Validation_GetInputMessage( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents the data validation input message.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *Validation) SetInputMessage(value string)  error {
	
	CGoReturnPtr := C.Validation_SetInputMessage( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents the title of the data-validation input dialog box.
// Returns:
//   string  
func (instance *Validation) GetInputTitle()  (string,  error)  {
	
	CGoReturnPtr := C.Validation_GetInputTitle( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents the title of the data-validation input dialog box.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *Validation) SetInputTitle(value string)  error {
	
	CGoReturnPtr := C.Validation_SetInputTitle( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents the data validation error message.
// Returns:
//   string  
func (instance *Validation) GetErrorMessage()  (string,  error)  {
	
	CGoReturnPtr := C.Validation_GetErrorMessage( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents the data validation error message.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *Validation) SetErrorMessage(value string)  error {
	
	CGoReturnPtr := C.Validation_SetErrorMessage( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents the title of the data-validation error dialog box.
// Returns:
//   string  
func (instance *Validation) GetErrorTitle()  (string,  error)  {
	
	CGoReturnPtr := C.Validation_GetErrorTitle( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents the title of the data-validation error dialog box.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *Validation) SetErrorTitle(value string)  error {
	
	CGoReturnPtr := C.Validation_SetErrorTitle( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether the data validation input message will be displayed whenever the user selects a cell in the data validation range.
// Returns:
//   bool  
func (instance *Validation) GetShowInput()  (bool,  error)  {
	
	CGoReturnPtr := C.Validation_GetShowInput( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether the data validation input message will be displayed whenever the user selects a cell in the data validation range.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Validation) SetShowInput(value bool)  error {
	
	CGoReturnPtr := C.Validation_SetShowInput( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether the data validation error message will be displayed whenever the user enters invalid data.
// Returns:
//   bool  
func (instance *Validation) GetShowError()  (bool,  error)  {
	
	CGoReturnPtr := C.Validation_GetShowError( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether the data validation error message will be displayed whenever the user enters invalid data.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Validation) SetShowError(value bool)  error {
	
	CGoReturnPtr := C.Validation_SetShowError( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether blank values are permitted by the range data validation.
// Returns:
//   bool  
func (instance *Validation) GetIgnoreBlank()  (bool,  error)  {
	
	CGoReturnPtr := C.Validation_GetIgnoreBlank( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether blank values are permitted by the range data validation.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Validation) SetIgnoreBlank(value bool)  error {
	
	CGoReturnPtr := C.Validation_SetIgnoreBlank( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the value or expression associated with this validation.
// Parameters:
//   isR1C1 - bool 
//   isLocal - bool 
// Returns:
//   string  
func (instance *Validation) GetFormula1_Bool_Bool(isr1c1 bool, islocal bool)  (string,  error)  {
	
	CGoReturnPtr := C.Validation_GetFormula1_Boolean_Boolean( instance.ptr, C.bool(isr1c1), C.bool(islocal))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the value or expression associated with this validation.
// Parameters:
//   isR1C1 - bool 
//   isLocal - bool 
// Returns:
//   string  
func (instance *Validation) GetFormula2_Bool_Bool(isr1c1 bool, islocal bool)  (string,  error)  {
	
	CGoReturnPtr := C.Validation_GetFormula2_Boolean_Boolean( instance.ptr, C.bool(isr1c1), C.bool(islocal))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the value or expression associated with this validation for specific cell.
// Parameters:
//   isR1C1 - bool 
//   isLocal - bool 
//   row - int32 
//   column - int32 
// Returns:
//   string  
func (instance *Validation) GetFormula1_Bool_Bool_Int_Int(isr1c1 bool, islocal bool, row int32, column int32)  (string,  error)  {
	
	CGoReturnPtr := C.Validation_GetFormula1_Boolean_Boolean_Integer_Integer( instance.ptr, C.bool(isr1c1), C.bool(islocal), C.int(row), C.int(column))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the value or expression associated with this validation for specific cell.
// Parameters:
//   isR1C1 - bool 
//   isLocal - bool 
//   row - int32 
//   column - int32 
// Returns:
//   string  
func (instance *Validation) GetFormula2_Bool_Bool_Int_Int(isr1c1 bool, islocal bool, row int32, column int32)  (string,  error)  {
	
	CGoReturnPtr := C.Validation_GetFormula2_Boolean_Boolean_Integer_Integer( instance.ptr, C.bool(isr1c1), C.bool(islocal), C.int(row), C.int(column))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Sets the value or expression associated with this validation.
// Parameters:
//   formula - string 
//   isR1C1 - bool 
//   isLocal - bool 
// Returns:
//   void  
func (instance *Validation) SetFormula1_String_Bool_Bool(formula string, isr1c1 bool, islocal bool)  error {
	
	CGoReturnPtr := C.Validation_SetFormula1_String_Boolean_Boolean( instance.ptr, C.CString(formula), C.bool(isr1c1), C.bool(islocal))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Sets the value or expression associated with this validation.
// Parameters:
//   formula - string 
//   isR1C1 - bool 
//   isLocal - bool 
// Returns:
//   void  
func (instance *Validation) SetFormula2_String_Bool_Bool(formula string, isr1c1 bool, islocal bool)  error {
	
	CGoReturnPtr := C.Validation_SetFormula2_String_Boolean_Boolean( instance.ptr, C.CString(formula), C.bool(isr1c1), C.bool(islocal))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents the value or expression associated with the data validation.
// Returns:
//   string  
func (instance *Validation) GetFormula1()  (string,  error)  {
	
	CGoReturnPtr := C.Validation_GetFormula1( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents the value or expression associated with the data validation.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *Validation) SetFormula1_String(value string)  error {
	
	CGoReturnPtr := C.Validation_SetFormula1_String( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents the value or expression associated with the data validation.
// Returns:
//   string  
func (instance *Validation) GetFormula2()  (string,  error)  {
	
	CGoReturnPtr := C.Validation_GetFormula2( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents the value or expression associated with the data validation.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *Validation) SetFormula2_String(value string)  error {
	
	CGoReturnPtr := C.Validation_SetFormula2_String( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Get the value for list of the validation for the specified cell.
// Parameters:
//   row - int32 
//   column - int32 
// Returns:
//   Object  
func (instance *Validation) GetListValue(row int32, column int32)  (*Object,  error)  {
	
	CGoReturnPtr := C.Validation_GetListValue( instance.ptr, C.int(row), C.int(column))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Object{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteObject) 

	return result, nil 
}
// Represents the first value associated with the data validation.
// Returns:
//   Object  
func (instance *Validation) GetValue1()  (*Object,  error)  {
	
	CGoReturnPtr := C.Validation_GetValue1( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Object{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteObject) 

	return result, nil 
}
// Represents the first value associated with the data validation.
// Parameters:
//   value - Object 
// Returns:
//   void  
func (instance *Validation) SetValue1(value *Object)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.Validation_SetValue1( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents the second value associated with the data validation.
// Returns:
//   Object  
func (instance *Validation) GetValue2()  (*Object,  error)  {
	
	CGoReturnPtr := C.Validation_GetValue2( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Object{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteObject) 

	return result, nil 
}
// Represents the second value associated with the data validation.
// Parameters:
//   value - Object 
// Returns:
//   void  
func (instance *Validation) SetValue2(value *Object)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.Validation_SetValue2( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Get the value of validation on the specific cell.
// Parameters:
//   row - int32 
//   column - int32 
//   isValue1 - bool 
// Returns:
//   Object  
func (instance *Validation) GetValue(row int32, column int32, isvalue1 bool)  (*Object,  error)  {
	
	CGoReturnPtr := C.Validation_GetValue( instance.ptr, C.int(row), C.int(column), C.bool(isvalue1))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Object{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteObject) 

	return result, nil 
}
// Indicates whether data validation displays a drop-down list that contains acceptable values.
// Returns:
//   bool  
func (instance *Validation) GetInCellDropDown()  (bool,  error)  {
	
	CGoReturnPtr := C.Validation_GetInCellDropDown( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether data validation displays a drop-down list that contains acceptable values.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Validation) SetInCellDropDown(value bool)  error {
	
	CGoReturnPtr := C.Validation_SetInCellDropDown( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets all <see cref="CellArea"/> which contain the data validation settings.
// Returns:
//   []CellArea  
func (instance *Validation) GetAreas()  ([]CellArea,  error)  {
	
	CGoReturnPtr := C.Validation_GetAreas( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result:= make([]CellArea, CGoReturnPtr.column_length)
	for i := 0; i < int(CGoReturnPtr.column_length); i++ {
	   offset := uintptr(C.size_t(i)) * uintptr(CGoReturnPtr.size)
	   goObject := &CellArea{}
	   goObject.ptr =unsafe.Pointer(uintptr( unsafe.Pointer(CGoReturnPtr.return_value)) + offset)
	   result[i] = *goObject
	}
	 

	return result, nil 
}
// Applies the validation to the area.
// Parameters:
//   cellArea - CellArea 
// Returns:
//   void  
func (instance *Validation) AddArea_CellArea(cellarea *CellArea)  error {
	
	var cellarea_ptr unsafe.Pointer = nil
	if cellarea != nil {
	  cellarea_ptr =cellarea.ptr
	}

	CGoReturnPtr := C.Validation_AddArea_CellArea( instance.ptr, cellarea_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Applies the validation to the area.
// Parameters:
//   cellArea - CellArea 
//   checkIntersection - bool 
//   checkEdge - bool 
// Returns:
//   void  
func (instance *Validation) AddArea_CellArea_Bool_Bool(cellarea *CellArea, checkintersection bool, checkedge bool)  error {
	
	var cellarea_ptr unsafe.Pointer = nil
	if cellarea != nil {
	  cellarea_ptr =cellarea.ptr
	}

	CGoReturnPtr := C.Validation_AddArea_CellArea_Boolean_Boolean( instance.ptr, cellarea_ptr, C.bool(checkintersection), C.bool(checkedge))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Applies the validation to given areas.
// Parameters:
//   areas - []CellArea 
//   checkIntersection - bool 
//   checkEdge - bool 
// Returns:
//   void  
func (instance *Validation) AddAreas(areas []CellArea, checkintersection bool, checkedge bool)  error {
	
	areas_length := len(areas)
	vector_areas:= make([]unsafe.Pointer, areas_length)
	for i := 0; i < areas_length; i++ {
		vector_areas[i] = areas[i].ptr
	}


	CGoReturnPtr := C.Validation_AddAreas( instance.ptr, unsafe.Pointer(&vector_areas[0]), C.int( len(areas)), C.bool(checkintersection), C.bool(checkedge))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Remove the validation settings in the range.
// Parameters:
//   cellArea - CellArea 
// Returns:
//   void  
func (instance *Validation) RemoveArea(cellarea *CellArea)  error {
	
	var cellarea_ptr unsafe.Pointer = nil
	if cellarea != nil {
	  cellarea_ptr =cellarea.ptr
	}

	CGoReturnPtr := C.Validation_RemoveArea( instance.ptr, cellarea_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Removes this validation from given areas.
// Parameters:
//   areas - []CellArea 
// Returns:
//   void  
func (instance *Validation) RemoveAreas(areas []CellArea)  error {
	
	areas_length := len(areas)
	vector_areas:= make([]unsafe.Pointer, areas_length)
	for i := 0; i < areas_length; i++ {
		vector_areas[i] = areas[i].ptr
	}


	CGoReturnPtr := C.Validation_RemoveAreas( instance.ptr, unsafe.Pointer(&vector_areas[0]), C.int( len(areas)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Remove the validation settings in the cell.
// Parameters:
//   row - int32 
//   column - int32 
// Returns:
//   void  
func (instance *Validation) RemoveACell(row int32, column int32)  error {
	
	CGoReturnPtr := C.Validation_RemoveACell( instance.ptr, C.int(row), C.int(column))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Copy validation.
// Parameters:
//   source - Validation 
//   copyOption - CopyOptions 
// Returns:
//   void  
func (instance *Validation) Copy(source *Validation, copyoption *CopyOptions)  error {
	
	var source_ptr unsafe.Pointer = nil
	if source != nil {
	  source_ptr =source.ptr
	}
	var copyoption_ptr unsafe.Pointer = nil
	if copyoption != nil {
	  copyoption_ptr =copyoption.ptr
	}

	CGoReturnPtr := C.Validation_Copy( instance.ptr, source_ptr, copyoption_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}



func DeleteValidation(validation *Validation){
	runtime.SetFinalizer(validation, nil)
	C.Delete_Validation(validation.ptr)
	validation.ptr = nil
}

// Class ValidationCollection 

// Represents data validation collection.
type ValidationCollection struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *ValidationCollection) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.ValidationCollection_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Adds a data validation to the collection.
// Parameters:
//   ca - CellArea 
// Returns:
//   int32  
func (instance *ValidationCollection) Add(ca *CellArea)  (int32,  error)  {
	
	var ca_ptr unsafe.Pointer = nil
	if ca != nil {
	  ca_ptr =ca.ptr
	}

	CGoReturnPtr := C.ValidationCollection_Add( instance.ptr, ca_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the <see cref="Validation"/> element at the specified index.
// Parameters:
//   index - int32 
// Returns:
//   Validation  
func (instance *ValidationCollection) Get(index int32)  (*Validation,  error)  {
	
	CGoReturnPtr := C.ValidationCollection_Get( instance.ptr, C.int(index))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Validation{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteValidation) 

	return result, nil 
}
// Removes all validation setting on the cell.
// Parameters:
//   row - int32 
//   column - int32 
// Returns:
//   void  
func (instance *ValidationCollection) RemoveACell(row int32, column int32)  error {
	
	CGoReturnPtr := C.ValidationCollection_RemoveACell( instance.ptr, C.int(row), C.int(column))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Removes all validation setting on the range..
// Parameters:
//   ca - CellArea 
// Returns:
//   void  
func (instance *ValidationCollection) RemoveArea(ca *CellArea)  error {
	
	var ca_ptr unsafe.Pointer = nil
	if ca != nil {
	  ca_ptr =ca.ptr
	}

	CGoReturnPtr := C.ValidationCollection_RemoveArea( instance.ptr, ca_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the validation applied to given cell.
// Parameters:
//   row - int32 
//   column - int32 
// Returns:
//   Validation  
func (instance *ValidationCollection) GetValidationInCell(row int32, column int32)  (*Validation,  error)  {
	
	CGoReturnPtr := C.ValidationCollection_GetValidationInCell( instance.ptr, C.int(row), C.int(column))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Validation{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteValidation) 

	return result, nil 
}
// Returns:
//   int32  
func (instance *ValidationCollection) GetCount()  (int32,  error)  {
	
	CGoReturnPtr := C.ValidationCollection_GetCount( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}



func DeleteValidationCollection(validationcollection *ValidationCollection){
	runtime.SetFinalizer(validationcollection, nil)
	C.Delete_ValidationCollection(validationcollection.ptr)
	validationcollection.ptr = nil
}

// Class VerticalPageBreak 

// Encapsulates the object that represents a vertical page break.
type VerticalPageBreak struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *VerticalPageBreak) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.VerticalPageBreak_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the start row index of the vertical page break.
// Returns:
//   int32  
func (instance *VerticalPageBreak) GetStartRow()  (int32,  error)  {
	
	CGoReturnPtr := C.VerticalPageBreak_GetStartRow( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the end row index of the vertical page break.
// Returns:
//   int32  
func (instance *VerticalPageBreak) GetEndRow()  (int32,  error)  {
	
	CGoReturnPtr := C.VerticalPageBreak_GetEndRow( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the column index of the vertical page break.
// Returns:
//   int32  
func (instance *VerticalPageBreak) GetColumn()  (int32,  error)  {
	
	CGoReturnPtr := C.VerticalPageBreak_GetColumn( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}



func DeleteVerticalPageBreak(verticalpagebreak *VerticalPageBreak){
	runtime.SetFinalizer(verticalpagebreak, nil)
	C.Delete_VerticalPageBreak(verticalpagebreak.ptr)
	verticalpagebreak.ptr = nil
}

// Class VerticalPageBreakCollection 

// Encapsulates a collection of <see cref="VerticalPageBreak"/> objects.
type VerticalPageBreakCollection struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *VerticalPageBreakCollection) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.VerticalPageBreakCollection_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the <see cref="VerticalPageBreak"/> element at the specified index.
// Parameters:
//   index - int32 
// Returns:
//   VerticalPageBreak  
func (instance *VerticalPageBreakCollection) Get_Int(index int32)  (*VerticalPageBreak,  error)  {
	
	CGoReturnPtr := C.VerticalPageBreakCollection_Get_Integer( instance.ptr, C.int(index))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &VerticalPageBreak{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteVerticalPageBreak) 

	return result, nil 
}
// Gets the <see cref="VerticalPageBreak"/> element with the specified cell name.
// Parameters:
//   cellName - string 
// Returns:
//   VerticalPageBreak  
func (instance *VerticalPageBreakCollection) Get_String(cellname string)  (*VerticalPageBreak,  error)  {
	
	CGoReturnPtr := C.VerticalPageBreakCollection_Get_String( instance.ptr, C.CString(cellname))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &VerticalPageBreak{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteVerticalPageBreak) 

	return result, nil 
}
// Adds a vertical page break to the collection.
// Parameters:
//   startRow - int32 
//   endRow - int32 
//   column - int32 
// Returns:
//   int32  
func (instance *VerticalPageBreakCollection) Add_Int_Int_Int(startrow int32, endrow int32, column int32)  (int32,  error)  {
	
	CGoReturnPtr := C.VerticalPageBreakCollection_Add_Integer_Integer_Integer( instance.ptr, C.int(startrow), C.int(endrow), C.int(column))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Adds a vertical page break to the collection.
// Parameters:
//   column - int32 
// Returns:
//   int32  
func (instance *VerticalPageBreakCollection) Add_Int(column int32)  (int32,  error)  {
	
	CGoReturnPtr := C.VerticalPageBreakCollection_Add_Integer( instance.ptr, C.int(column))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Adds a vertical page break to the collection.
// Parameters:
//   row - int32 
//   column - int32 
// Returns:
//   int32  
func (instance *VerticalPageBreakCollection) Add_Int_Int(row int32, column int32)  (int32,  error)  {
	
	CGoReturnPtr := C.VerticalPageBreakCollection_Add_Integer_Integer( instance.ptr, C.int(row), C.int(column))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Adds a vertical page break to the collection.
// Parameters:
//   cellName - string 
// Returns:
//   int32  
func (instance *VerticalPageBreakCollection) Add_String(cellname string)  (int32,  error)  {
	
	CGoReturnPtr := C.VerticalPageBreakCollection_Add_String( instance.ptr, C.CString(cellname))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Removes the VPageBreak element at a specified name.
// Parameters:
//   index - int32 
// Returns:
//   void  
func (instance *VerticalPageBreakCollection) RemoveAt(index int32)  error {
	
	CGoReturnPtr := C.VerticalPageBreakCollection_RemoveAt( instance.ptr, C.int(index))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Returns:
//   int32  
func (instance *VerticalPageBreakCollection) GetCount()  (int32,  error)  {
	
	CGoReturnPtr := C.VerticalPageBreakCollection_GetCount( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}



func DeleteVerticalPageBreakCollection(verticalpagebreakcollection *VerticalPageBreakCollection){
	runtime.SetFinalizer(verticalpagebreakcollection, nil)
	C.Delete_VerticalPageBreakCollection(verticalpagebreakcollection.ptr)
	verticalpagebreakcollection.ptr = nil
}

// Class WarningInfo 

// Warning info
type WarningInfo struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *WarningInfo) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.WarningInfo_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Get warning type.
// Returns:
//   int32  
func (instance *WarningInfo) GetType()  (ExceptionType,  error)  {
	
	CGoReturnPtr := C.WarningInfo_GetType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToExceptionType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Get description of warning info.
// Returns:
//   string  
func (instance *WarningInfo) GetDescription()  (string,  error)  {
	
	CGoReturnPtr := C.WarningInfo_GetDescription( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// The error object.
// Returns:
//   Object  
func (instance *WarningInfo) GetErrorObject()  (*Object,  error)  {
	
	CGoReturnPtr := C.WarningInfo_GetErrorObject( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Object{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteObject) 

	return result, nil 
}
// Gets and sets the corrected object.
// Returns:
//   Object  
func (instance *WarningInfo) GetCorrectedObject()  (*Object,  error)  {
	
	CGoReturnPtr := C.WarningInfo_GetCorrectedObject( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Object{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteObject) 

	return result, nil 
}
// Gets and sets the corrected object.
// Parameters:
//   value - Object 
// Returns:
//   void  
func (instance *WarningInfo) SetCorrectedObject(value *Object)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.WarningInfo_SetCorrectedObject( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}



func DeleteWarningInfo(warninginfo *WarningInfo){
	runtime.SetFinalizer(warninginfo, nil)
	C.Delete_WarningInfo(warninginfo.ptr)
	warninginfo.ptr = nil
}

// Class Workbook 

// Represents a root object to create an Excel spreadsheet.
type Workbook struct {
	ptr unsafe.Pointer
}

// Initializes a new instance of the <see cref="Workbook"/> class.
func NewWorkbook() ( *Workbook, error) {
	workbook := &Workbook{}
	CGoReturnPtr := C.New_Workbook()
	if CGoReturnPtr.error_no == 0 {
		workbook.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(workbook, DeleteWorkbook)
		return workbook, nil
	} else {
		workbook.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return workbook, err
	}	
}
// Initializes a new instance of the <see cref="Workbook"/> class.
// Parameters:
//   fileFormatType - int32 
func NewWorkbook_FileFormatType(fileformattype FileFormatType) ( *Workbook, error) {
	workbook := &Workbook{}
	CGoReturnPtr := C.New_Workbook_FileFormatType(C.int( int32(fileformattype)))
	if CGoReturnPtr.error_no == 0 {
		workbook.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(workbook, DeleteWorkbook)
		return workbook, nil
	} else {
		workbook.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return workbook, err
	}	
}
// Initializes a new instance of the <see cref="Workbook"/> class and open a file.
// Parameters:
//   file - string 
func NewWorkbook_String(file string) ( *Workbook, error) {
	workbook := &Workbook{}
	CGoReturnPtr := C.New_Workbook_String(C.CString(file))
	if CGoReturnPtr.error_no == 0 {
		workbook.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(workbook, DeleteWorkbook)
		return workbook, nil
	} else {
		workbook.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return workbook, err
	}	
}
// Initializes a new instance of the <see cref="Workbook"/> class and open a stream.
// Parameters:
//   stream - []byte 
func NewWorkbook_Stream(stream []byte) ( *Workbook, error) {
	workbook := &Workbook{}
	CGoReturnPtr := C.New_Workbook_Stream(unsafe.Pointer(&stream[0]), C.int( len(stream)))
	if CGoReturnPtr.error_no == 0 {
		workbook.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(workbook, DeleteWorkbook)
		return workbook, nil
	} else {
		workbook.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return workbook, err
	}	
}
// Initializes a new instance of the <see cref="Workbook"/> class and open a file.
// Parameters:
//   file - string 
//   loadOptions - LoadOptions 
func NewWorkbook_String_LoadOptions(file string, loadoptions *LoadOptions) ( *Workbook, error) {
	workbook := &Workbook{}
	var loadoptions_ptr unsafe.Pointer = nil
	if loadoptions != nil {
	  loadoptions_ptr =loadoptions.ptr
	}

	CGoReturnPtr := C.New_Workbook_String_LoadOptions(C.CString(file), loadoptions_ptr)
	if CGoReturnPtr.error_no == 0 {
		workbook.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(workbook, DeleteWorkbook)
		return workbook, nil
	} else {
		workbook.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return workbook, err
	}	
}
// Initializes a new instance of the <see cref="Workbook"/> class and open stream.
// Parameters:
//   stream - []byte 
//   loadOptions - LoadOptions 
func NewWorkbook_Stream_LoadOptions(stream []byte, loadoptions *LoadOptions) ( *Workbook, error) {
	workbook := &Workbook{}
	var loadoptions_ptr unsafe.Pointer = nil
	if loadoptions != nil {
	  loadoptions_ptr =loadoptions.ptr
	}

	CGoReturnPtr := C.New_Workbook_Stream_LoadOptions(unsafe.Pointer(&stream[0]), C.int( len(stream)), loadoptions_ptr)
	if CGoReturnPtr.error_no == 0 {
		workbook.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(workbook, DeleteWorkbook)
		return workbook, nil
	} else {
		workbook.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return workbook, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *Workbook) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.Workbook_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents the workbook settings.
// Returns:
//   WorkbookSettings  
func (instance *Workbook) GetSettings()  (*WorkbookSettings,  error)  {
	
	CGoReturnPtr := C.Workbook_GetSettings( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &WorkbookSettings{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteWorkbookSettings) 

	return result, nil 
}
// Parses all formulas which have not been parsed when they were loaded from template file or set to a cell.
// Parameters:
//   ignoreError - bool 
// Returns:
//   void  
func (instance *Workbook) ParseFormulas(ignoreerror bool)  error {
	
	CGoReturnPtr := C.Workbook_ParseFormulas( instance.ptr, C.bool(ignoreerror))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Starts the session that uses caches to access data.
// Parameters:
//   opts - int32 
// Returns:
//   void  
func (instance *Workbook) StartAccessCache(opts AccessCacheOptions)  error {
	
	CGoReturnPtr := C.Workbook_StartAccessCache( instance.ptr, C.int( int32(opts)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Closes the session that uses caches to access data.
// Parameters:
//   opts - int32 
// Returns:
//   void  
func (instance *Workbook) CloseAccessCache(opts AccessCacheOptions)  error {
	
	CGoReturnPtr := C.Workbook_CloseAccessCache( instance.ptr, C.int( int32(opts)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Saves the workbook to the disk.
// Parameters:
//   fileName - string 
//   saveFormat - int32 
// Returns:
//   void  
func (instance *Workbook) Save_String_SaveFormat(filename string, saveformat SaveFormat)  error {
	
	CGoReturnPtr := C.Workbook_Save_String_SaveFormat( instance.ptr, C.CString(filename), C.int( int32(saveformat)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Save the workbook to the disk.
// Parameters:
//   fileName - string 
// Returns:
//   void  
func (instance *Workbook) Save_String(filename string)  error {
	
	CGoReturnPtr := C.Workbook_Save_String( instance.ptr, C.CString(filename))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Saves the workbook to the disk.
// Parameters:
//   fileName - string 
//   saveOptions - SaveOptions 
// Returns:
//   void  
func (instance *Workbook) Save_String_SaveOptions(filename string, saveoptions *SaveOptions)  error {
	
	var saveoptions_ptr unsafe.Pointer = nil
	if saveoptions != nil {
	  saveoptions_ptr =saveoptions.ptr
	}

	CGoReturnPtr := C.Workbook_Save_String_SaveOptions( instance.ptr, C.CString(filename), saveoptions_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Saves the workbook to the stream.
// Parameters:
//   saveFormat - int32 
// Returns:
//   []byte  
func (instance *Workbook) Save_SaveFormat(saveformat SaveFormat)  ([]byte,  error)  {
	
	CGoReturnPtr := C.Workbook_Save_SaveFormat( instance.ptr, C.int( int32(saveformat)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := C.GoBytes(unsafe.Pointer(CGoReturnPtr.return_value), C.int(CGoReturnPtr.column_length))
	 

	return result, nil 
}
// Saves the workbook to the stream.
// Parameters:
//   saveOptions - SaveOptions 
// Returns:
//   []byte  
func (instance *Workbook) Save_SaveOptions(saveoptions *SaveOptions)  ([]byte,  error)  {
	
	var saveoptions_ptr unsafe.Pointer = nil
	if saveoptions != nil {
	  saveoptions_ptr =saveoptions.ptr
	}

	CGoReturnPtr := C.Workbook_Save_SaveOptions( instance.ptr, saveoptions_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := C.GoBytes(unsafe.Pointer(CGoReturnPtr.return_value), C.int(CGoReturnPtr.column_length))
	 

	return result, nil 
}
// Saves Excel file to a MemoryStream object as an Excel97-2003 xls file and returns it.
// Returns:
//   []byte  
func (instance *Workbook) SaveToStream()  ([]byte,  error)  {
	
	CGoReturnPtr := C.Workbook_SaveToStream( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := C.GoBytes(unsafe.Pointer(CGoReturnPtr.return_value), C.int(CGoReturnPtr.column_length))
	 

	return result, nil 
}
// Gets the <see cref="WorksheetCollection"/> collection in the spreadsheet.
// Returns:
//   WorksheetCollection  
func (instance *Workbook) GetWorksheets()  (*WorksheetCollection,  error)  {
	
	CGoReturnPtr := C.Workbook_GetWorksheets( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &WorksheetCollection{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteWorksheetCollection) 

	return result, nil 
}
// Indicates whether license is set.
// Returns:
//   bool  
func (instance *Workbook) IsLicensed()  (bool,  error)  {
	
	CGoReturnPtr := C.Workbook_IsLicensed( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Remove all unused styles.
// Returns:
//   void  
func (instance *Workbook) RemoveUnusedStyles()  error {
	
	CGoReturnPtr := C.Workbook_RemoveUnusedStyles( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Creates a new style.
// Returns:
//   Style  
func (instance *Workbook) CreateStyle()  (*Style,  error)  {
	
	CGoReturnPtr := C.Workbook_CreateStyle( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Style{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteStyle) 

	return result, nil 
}
// Creates a new style.
// Parameters:
//   cloneDefaultStyle - bool 
// Returns:
//   Style  
func (instance *Workbook) CreateStyle_Bool(clonedefaultstyle bool)  (*Style,  error)  {
	
	CGoReturnPtr := C.Workbook_CreateStyle_Boolean( instance.ptr, C.bool(clonedefaultstyle))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Style{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteStyle) 

	return result, nil 
}
// Creates built-in style by given type.
// Parameters:
//   type - int32 
// Returns:
//   Style  
func (instance *Workbook) CreateBuiltinStyle(type_ BuiltinStyleType)  (*Style,  error)  {
	
	CGoReturnPtr := C.Workbook_CreateBuiltinStyle( instance.ptr, C.int( int32(type_)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Style{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteStyle) 

	return result, nil 
}
// Creates a <see cref="CellsColor"/> object.
// Returns:
//   CellsColor  
func (instance *Workbook) CreateCellsColor()  (*CellsColor,  error)  {
	
	CGoReturnPtr := C.Workbook_CreateCellsColor( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &CellsColor{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteCellsColor) 

	return result, nil 
}
// Replaces a cell's value with a new string.
// Parameters:
//   placeHolder - string 
//   newValue - string 
// Returns:
//   int32  
func (instance *Workbook) Replace_String_String(placeholder string, newvalue string)  (int32,  error)  {
	
	CGoReturnPtr := C.Workbook_Replace_String_String( instance.ptr, C.CString(placeholder), C.CString(newvalue))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Replaces a cell's value with a new integer.
// Parameters:
//   placeHolder - string 
//   newValue - int32 
// Returns:
//   int32  
func (instance *Workbook) Replace_String_Int(placeholder string, newvalue int32)  (int32,  error)  {
	
	CGoReturnPtr := C.Workbook_Replace_String_Integer( instance.ptr, C.CString(placeholder), C.int(newvalue))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Replaces a cell's value with a new double.
// Parameters:
//   placeHolder - string 
//   newValue - float64 
// Returns:
//   int32  
func (instance *Workbook) Replace_String_Double(placeholder string, newvalue float64)  (int32,  error)  {
	
	CGoReturnPtr := C.Workbook_Replace_String_Double( instance.ptr, C.CString(placeholder), C.double(newvalue))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Replaces a cell's value with a new string array.
// Parameters:
//   placeHolder - string 
//   newValues - []string 
//   isVertical - bool 
// Returns:
//   int32  
func (instance *Workbook) Replace_String_stringArray_Bool(placeholder string, newvalues []string, isvertical bool)  (int32,  error)  {
	
	vector_newvalues := make([]*C.char, len(newvalues))
	for i, str := range newvalues {
	cStr := C.CString(str)
	defer C.free(unsafe.Pointer(cStr))
	vector_newvalues[i] = cStr
	}

	CGoReturnPtr := C.Workbook_Replace_String_U16StringArray_Boolean( instance.ptr, C.CString(placeholder), unsafe.Pointer(&vector_newvalues[0]), C.int( len(newvalues)), C.bool(isvertical))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Replaces cells' values with an integer array.
// Parameters:
//   placeHolder - string 
//   newValues - []int32_t 
//   isVertical - bool 
// Returns:
//   int32  
func (instance *Workbook) Replace_String_int32Array_Bool(placeholder string, newvalues []int32, isvertical bool)  (int32,  error)  {
	
	CGoReturnPtr := C.Workbook_Replace_String_int32_tArray_Boolean( instance.ptr, C.CString(placeholder), unsafe.Pointer(&newvalues[0]), C.int( len(newvalues)), C.bool(isvertical))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Replaces cells' values with a double array.
// Parameters:
//   placeHolder - string 
//   newValues - []double 
//   isVertical - bool 
// Returns:
//   int32  
func (instance *Workbook) Replace_String_float64Array_Bool(placeholder string, newvalues []float64, isvertical bool)  (int32,  error)  {
	
	CGoReturnPtr := C.Workbook_Replace_String_doubleArray_Boolean( instance.ptr, C.CString(placeholder), unsafe.Pointer(&newvalues[0]), C.int( len(newvalues)), C.bool(isvertical))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Replaces cells' values with new data.
// Parameters:
//   boolValue - bool 
//   newValue - Object 
// Returns:
//   int32  
func (instance *Workbook) Replace_Bool_Object(boolvalue bool, newvalue *Object)  (int32,  error)  {
	
	var newvalue_ptr unsafe.Pointer = nil
	if newvalue != nil {
	  newvalue_ptr =newvalue.ptr
	}

	CGoReturnPtr := C.Workbook_Replace_Boolean_Object( instance.ptr, C.bool(boolvalue), newvalue_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Replaces cells' values with new data.
// Parameters:
//   intValue - int32 
//   newValue - Object 
// Returns:
//   int32  
func (instance *Workbook) Replace_Int_Object(intvalue int32, newvalue *Object)  (int32,  error)  {
	
	var newvalue_ptr unsafe.Pointer = nil
	if newvalue != nil {
	  newvalue_ptr =newvalue.ptr
	}

	CGoReturnPtr := C.Workbook_Replace_Integer_Object( instance.ptr, C.int(intvalue), newvalue_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Replaces a cell's value with a new string.
// Parameters:
//   placeHolder - string 
//   newValue - string 
//   options - ReplaceOptions 
// Returns:
//   int32  
func (instance *Workbook) Replace_String_String_ReplaceOptions(placeholder string, newvalue string, options *ReplaceOptions)  (int32,  error)  {
	
	var options_ptr unsafe.Pointer = nil
	if options != nil {
	  options_ptr =options.ptr
	}

	CGoReturnPtr := C.Workbook_Replace_String_String_ReplaceOptions( instance.ptr, C.CString(placeholder), C.CString(newvalue), options_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Copies another Workbook object.
// Parameters:
//   source - Workbook 
//   copyOptions - CopyOptions 
// Returns:
//   void  
func (instance *Workbook) Copy_Workbook_CopyOptions(source *Workbook, copyoptions *CopyOptions)  error {
	
	var source_ptr unsafe.Pointer = nil
	if source != nil {
	  source_ptr =source.ptr
	}
	var copyoptions_ptr unsafe.Pointer = nil
	if copyoptions != nil {
	  copyoptions_ptr =copyoptions.ptr
	}

	CGoReturnPtr := C.Workbook_Copy_Workbook_CopyOptions( instance.ptr, source_ptr, copyoptions_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Copies data from a source Workbook object.
// Parameters:
//   source - Workbook 
// Returns:
//   void  
func (instance *Workbook) Copy_Workbook(source *Workbook)  error {
	
	var source_ptr unsafe.Pointer = nil
	if source != nil {
	  source_ptr =source.ptr
	}

	CGoReturnPtr := C.Workbook_Copy_Workbook( instance.ptr, source_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Combines another Workbook object.
// Parameters:
//   secondWorkbook - Workbook 
// Returns:
//   void  
func (instance *Workbook) Combine(secondworkbook *Workbook)  error {
	
	var secondworkbook_ptr unsafe.Pointer = nil
	if secondworkbook != nil {
	  secondworkbook_ptr =secondworkbook.ptr
	}

	CGoReturnPtr := C.Workbook_Combine( instance.ptr, secondworkbook_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Returns colors in the palette for the spreadsheet.
// Returns:
//   []Color  
func (instance *Workbook) GetColors()  ([]Color,  error)  {
	
	CGoReturnPtr := C.Workbook_GetColors( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result:= make([]Color, CGoReturnPtr.column_length)
	for i := 0; i < int(CGoReturnPtr.column_length); i++ {
	   offset := uintptr(C.size_t(i)) * uintptr(CGoReturnPtr.size)
	   goObject := &Color{}
	   goObject.ptr =unsafe.Pointer(uintptr( unsafe.Pointer(CGoReturnPtr.return_value)) + offset)
	   result[i] = *goObject
	}
	 

	return result, nil 
}
// Gets the style in the style pool.
// All styles in the workbook will be gathered into a pool.
// There is only a simple reference index in the cells.
// Parameters:
//   index - int32 
// Returns:
//   Style  
func (instance *Workbook) GetStyleInPool(index int32)  (*Style,  error)  {
	
	CGoReturnPtr := C.Workbook_GetStyleInPool( instance.ptr, C.int(index))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Style{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteStyle) 

	return result, nil 
}
// Gets number of the styles in the style pool.
// Returns:
//   int32  
func (instance *Workbook) GetCountOfStylesInPool()  (int32,  error)  {
	
	CGoReturnPtr := C.Workbook_GetCountOfStylesInPool( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets all fonts in the style pool.
// Returns:
//   []Font  
func (instance *Workbook) GetFonts()  ([]Font,  error)  {
	
	CGoReturnPtr := C.Workbook_GetFonts( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result:= make([]Font, CGoReturnPtr.column_length)
	for i := 0; i < int(CGoReturnPtr.column_length); i++ {
	   offset := uintptr(C.size_t(i)) * uintptr(CGoReturnPtr.size)
	   goObject := &Font{}
	   goObject.ptr =unsafe.Pointer(uintptr( unsafe.Pointer(CGoReturnPtr.return_value)) + offset)
	   result[i] = *goObject
	}
	 

	return result, nil 
}
// Gets the named style in the style pool.
// Parameters:
//   name - string 
// Returns:
//   Style  
func (instance *Workbook) GetNamedStyle(name string)  (*Style,  error)  {
	
	CGoReturnPtr := C.Workbook_GetNamedStyle( instance.ptr, C.CString(name))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Style{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteStyle) 

	return result, nil 
}
// Merges named styles from the other Excel file.
// Parameters:
//   source - Workbook 
// Returns:
//   void  
func (instance *Workbook) MergeNamedStyles(source *Workbook)  error {
	
	var source_ptr unsafe.Pointer = nil
	if source != nil {
	  source_ptr =source.ptr
	}

	CGoReturnPtr := C.Workbook_MergeNamedStyles( instance.ptr, source_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Changes the palette for the spreadsheet in the specified index.
// Parameters:
//   color - Color 
//   index - int32 
// Returns:
//   void  
func (instance *Workbook) ChangePalette(color *Color, index int32)  error {
	
	CGoReturnPtr := C.Workbook_ChangePalette( instance.ptr, color.ptr, C.int(index))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Checks if a color is in the palette for the spreadsheet.
// Parameters:
//   color - Color 
// Returns:
//   bool  
func (instance *Workbook) IsColorInPalette(color *Color)  (bool,  error)  {
	
	CGoReturnPtr := C.Workbook_IsColorInPalette( instance.ptr, color.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Calculates the result of formulas.
// Returns:
//   void  
func (instance *Workbook) CalculateFormula()  error {
	
	CGoReturnPtr := C.Workbook_CalculateFormula( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Calculates the result of formulas.
// Parameters:
//   ignoreError - bool 
// Returns:
//   void  
func (instance *Workbook) CalculateFormula_Bool(ignoreerror bool)  error {
	
	CGoReturnPtr := C.Workbook_CalculateFormula_Boolean( instance.ptr, C.bool(ignoreerror))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Calculating formulas in this workbook.
// Parameters:
//   options - CalculationOptions 
// Returns:
//   void  
func (instance *Workbook) CalculateFormula_CalculationOptions(options *CalculationOptions)  error {
	
	var options_ptr unsafe.Pointer = nil
	if options != nil {
	  options_ptr =options.ptr
	}

	CGoReturnPtr := C.Workbook_CalculateFormula_CalculationOptions( instance.ptr, options_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Refreshes dynamic array formulas(spill into new range of neighboring cells according to current data)
// Other formulas in the workbook will not be calculated recursively even if they were used by dynamic array formulas.
// Parameters:
//   calculate - bool 
// Returns:
//   void  
func (instance *Workbook) RefreshDynamicArrayFormulas_Bool(calculate bool)  error {
	
	CGoReturnPtr := C.Workbook_RefreshDynamicArrayFormulas_Boolean( instance.ptr, C.bool(calculate))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Refreshes dynamic array formulas(spill into new range of neighboring cells according to current data)
// Parameters:
//   calculate - bool 
//   copts - CalculationOptions 
// Returns:
//   void  
func (instance *Workbook) RefreshDynamicArrayFormulas_Bool_CalculationOptions(calculate bool, copts *CalculationOptions)  error {
	
	var copts_ptr unsafe.Pointer = nil
	if copts != nil {
	  copts_ptr =copts.ptr
	}

	CGoReturnPtr := C.Workbook_RefreshDynamicArrayFormulas_Boolean_CalculationOptions( instance.ptr, C.bool(calculate), copts_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the default <see cref="Style"/> object of the workbook.
// Returns:
//   Style  
func (instance *Workbook) GetDefaultStyle()  (*Style,  error)  {
	
	CGoReturnPtr := C.Workbook_GetDefaultStyle( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Style{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteStyle) 

	return result, nil 
}
// Gets or sets the default <see cref="Style"/> object of the workbook.
// Parameters:
//   value - Style 
// Returns:
//   void  
func (instance *Workbook) SetDefaultStyle(value *Style)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.Workbook_SetDefaultStyle( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Find best matching Color in current palette.
// Parameters:
//   rawColor - Color 
// Returns:
//   Color  
func (instance *Workbook) GetMatchingColor(rawcolor *Color)  (*Color,  error)  {
	
	CGoReturnPtr := C.Workbook_GetMatchingColor( instance.ptr, rawcolor.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Indicates if this spreadsheet is digitally signed.
// Returns:
//   bool  
func (instance *Workbook) IsDigitallySigned()  (bool,  error)  {
	
	CGoReturnPtr := C.Workbook_IsDigitallySigned( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Set Encryption Options.
// Parameters:
//   encryptionType - int32 
//   keyLength - int32 
// Returns:
//   void  
func (instance *Workbook) SetEncryptionOptions(encryptiontype EncryptionType, keylength int32)  error {
	
	CGoReturnPtr := C.Workbook_SetEncryptionOptions( instance.ptr, C.int( int32(encryptiontype)), C.int(keylength))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Protects a workbook.
// Parameters:
//   protectionType - int32 
//   password - string 
// Returns:
//   void  
func (instance *Workbook) Protect(protectiontype ProtectionType, password string)  error {
	
	CGoReturnPtr := C.Workbook_Protect( instance.ptr, C.int( int32(protectiontype)), C.CString(password))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Protects a shared workbook.
// Parameters:
//   password - string 
// Returns:
//   void  
func (instance *Workbook) ProtectSharedWorkbook(password string)  error {
	
	CGoReturnPtr := C.Workbook_ProtectSharedWorkbook( instance.ptr, C.CString(password))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Unprotects a workbook.
// Parameters:
//   password - string 
// Returns:
//   void  
func (instance *Workbook) Unprotect(password string)  error {
	
	CGoReturnPtr := C.Workbook_Unprotect( instance.ptr, C.CString(password))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Unprotects a shared workbook.
// Parameters:
//   password - string 
// Returns:
//   void  
func (instance *Workbook) UnprotectSharedWorkbook(password string)  error {
	
	CGoReturnPtr := C.Workbook_UnprotectSharedWorkbook( instance.ptr, C.CString(password))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether structure or window is protected with password.
// Returns:
//   bool  
func (instance *Workbook) IsWorkbookProtectedWithPassword()  (bool,  error)  {
	
	CGoReturnPtr := C.Workbook_IsWorkbookProtectedWithPassword( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Removes VBA/macro from this spreadsheet.
// Returns:
//   void  
func (instance *Workbook) RemoveMacro()  error {
	
	CGoReturnPtr := C.Workbook_RemoveMacro( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the <see cref="VbaProject"/> in a spreadsheet.
// Returns:
//   VbaProject  
func (instance *Workbook) GetVbaProject()  (*VbaProject,  error)  {
	
	CGoReturnPtr := C.Workbook_GetVbaProject( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &VbaProject{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteVbaProject) 

	return result, nil 
}
// Removes digital signature from this spreadsheet.
// Returns:
//   void  
func (instance *Workbook) RemoveDigitalSignature()  error {
	
	CGoReturnPtr := C.Workbook_RemoveDigitalSignature( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Accepts all tracked changes in the workbook.
// Returns:
//   void  
func (instance *Workbook) AcceptAllRevisions()  error {
	
	CGoReturnPtr := C.Workbook_AcceptAllRevisions( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates if this spreadsheet contains macro/VBA.
// Returns:
//   bool  
func (instance *Workbook) GetHasMacro()  (bool,  error)  {
	
	CGoReturnPtr := C.Workbook_GetHasMacro( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets if the workbook has any tracked changes
// Returns:
//   bool  
func (instance *Workbook) GetHasRevisions()  (bool,  error)  {
	
	CGoReturnPtr := C.Workbook_GetHasRevisions( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the current file name.
// Returns:
//   string  
func (instance *Workbook) GetFileName()  (string,  error)  {
	
	CGoReturnPtr := C.Workbook_GetFileName( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the current file name.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *Workbook) SetFileName(value string)  error {
	
	CGoReturnPtr := C.Workbook_SetFileName( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets a DataSorter object to sort data.
// Returns:
//   DataSorter  
func (instance *Workbook) GetDataSorter()  (*DataSorter,  error)  {
	
	CGoReturnPtr := C.Workbook_GetDataSorter( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &DataSorter{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteDataSorter) 

	return result, nil 
}
// Gets theme color.
// Parameters:
//   type - int32 
// Returns:
//   Color  
func (instance *Workbook) GetThemeColor(type_ ThemeColorType)  (*Color,  error)  {
	
	CGoReturnPtr := C.Workbook_GetThemeColor( instance.ptr, C.int( int32(type_)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Sets the theme color
// Parameters:
//   type - int32 
//   color - Color 
// Returns:
//   void  
func (instance *Workbook) SetThemeColor(type_ ThemeColorType, color *Color)  error {
	
	CGoReturnPtr := C.Workbook_SetThemeColor( instance.ptr, C.int( int32(type_)), color.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the theme name.
// Returns:
//   string  
func (instance *Workbook) GetTheme()  (string,  error)  {
	
	CGoReturnPtr := C.Workbook_GetTheme( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Customs the theme.
// Parameters:
//   themeName - string 
//   colors - []Color 
// Returns:
//   void  
func (instance *Workbook) CustomTheme(themename string, colors []Color)  error {
	
	colors_length := len(colors)
	vector_colors:= make([]unsafe.Pointer, colors_length)
	for i := 0; i < colors_length; i++ {
		vector_colors[i] = colors[i].ptr
	}


	CGoReturnPtr := C.Workbook_CustomTheme( instance.ptr, C.CString(themename), unsafe.Pointer(&vector_colors[0]), C.int( len(colors)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Copies the theme from another workbook.
// Parameters:
//   source - Workbook 
// Returns:
//   void  
func (instance *Workbook) CopyTheme(source *Workbook)  error {
	
	var source_ptr unsafe.Pointer = nil
	if source != nil {
	  source_ptr =source.ptr
	}

	CGoReturnPtr := C.Workbook_CopyTheme( instance.ptr, source_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Updates definition of custom functions.
// Parameters:
//   definition - CustomFunctionDefinition 
// Returns:
//   void  
func (instance *Workbook) UpdateCustomFunctionDefinition(definition *CustomFunctionDefinition)  error {
	
	var definition_ptr unsafe.Pointer = nil
	if definition != nil {
	  definition_ptr =definition.ptr
	}

	CGoReturnPtr := C.Workbook_UpdateCustomFunctionDefinition( instance.ptr, definition_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// If this workbook contains external links to other data source,
// Aspose.Cells will attempt to retrieve the latest data from give sources.
// Parameters:
//   externalWorkbooks - []Workbook 
// Returns:
//   void  
func (instance *Workbook) UpdateLinkedDataSource(externalworkbooks []Workbook)  error {
	
	externalworkbooks_length := len(externalworkbooks)
	vector_externalworkbooks:= make([]unsafe.Pointer, externalworkbooks_length)
	for i := 0; i < externalworkbooks_length; i++ {
		vector_externalworkbooks[i] = externalworkbooks[i].ptr
	}


	CGoReturnPtr := C.Workbook_UpdateLinkedDataSource( instance.ptr, unsafe.Pointer(&vector_externalworkbooks[0]), C.int( len(externalworkbooks)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Returns a <see cref="DocumentProperty"/> collection that represents all the built-in document properties of the spreadsheet.
// Returns:
//   BuiltInDocumentPropertyCollection  
func (instance *Workbook) GetBuiltInDocumentProperties()  (*BuiltInDocumentPropertyCollection,  error)  {
	
	CGoReturnPtr := C.Workbook_GetBuiltInDocumentProperties( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &BuiltInDocumentPropertyCollection{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteBuiltInDocumentPropertyCollection) 

	return result, nil 
}
// Returns a <see cref="DocumentProperty"/> collection that represents all the custom document properties of the spreadsheet.
// Returns:
//   CustomDocumentPropertyCollection  
func (instance *Workbook) GetCustomDocumentProperties()  (*CustomDocumentPropertyCollection,  error)  {
	
	CGoReturnPtr := C.Workbook_GetCustomDocumentProperties( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &CustomDocumentPropertyCollection{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteCustomDocumentPropertyCollection) 

	return result, nil 
}
// Gets and sets the file format.
// Returns:
//   int32  
func (instance *Workbook) GetFileFormat()  (FileFormatType,  error)  {
	
	CGoReturnPtr := C.Workbook_GetFileFormat( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToFileFormatType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets and sets the file format.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *Workbook) SetFileFormat(value FileFormatType)  error {
	
	CGoReturnPtr := C.Workbook_SetFileFormat( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Detects whether there is custom function used in this workbook,
// such as in cell's formula, in defined names...
// Returns:
//   bool  
func (instance *Workbook) GetHasCustomFunction()  (bool,  error)  {
	
	CGoReturnPtr := C.Workbook_GetHasCustomFunction( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the interrupt monitor.
// Returns:
//   AbstractInterruptMonitor  
func (instance *Workbook) GetInterruptMonitor()  (*AbstractInterruptMonitor,  error)  {
	
	CGoReturnPtr := C.Workbook_GetInterruptMonitor( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &AbstractInterruptMonitor{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteAbstractInterruptMonitor) 

	return result, nil 
}
// Gets and sets the interrupt monitor.
// Parameters:
//   value - AbstractInterruptMonitor 
// Returns:
//   void  
func (instance *Workbook) SetInterruptMonitor_AbstractInterruptMonitor(value *AbstractInterruptMonitor)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.Workbook_SetInterruptMonitor_AbstractInterruptMonitor( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Sets the interrupt monitor.
// Parameters:
//   interruptMonitor - InterruptMonitor 
// Returns:
//   void  
func (instance *Workbook) SetInterruptMonitor_InterruptMonitor(interruptmonitor *InterruptMonitor)  error {
	
	var interruptmonitor_ptr unsafe.Pointer = nil
	if interruptmonitor != nil {
	  interruptmonitor_ptr =interruptmonitor.ptr
	}

	CGoReturnPtr := C.Workbook_SetInterruptMonitor_InterruptMonitor( instance.ptr, interruptmonitor_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the list of  <see cref="ContentTypeProperty"/> objects in the workbook.
// Returns:
//   ContentTypePropertyCollection  
func (instance *Workbook) GetContentTypeProperties()  (*ContentTypePropertyCollection,  error)  {
	
	CGoReturnPtr := C.Workbook_GetContentTypeProperties( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &ContentTypePropertyCollection{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteContentTypePropertyCollection) 

	return result, nil 
}
// Represents a Custom XML Data Storage Part (custom XML data within a package).
// Returns:
//   CustomXmlPartCollection  
func (instance *Workbook) GetCustomXmlParts()  (*CustomXmlPartCollection,  error)  {
	
	CGoReturnPtr := C.Workbook_GetCustomXmlParts( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &CustomXmlPartCollection{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteCustomXmlPartCollection) 

	return result, nil 
}
// Gets mashup data.
// Returns:
//   DataMashup  
func (instance *Workbook) GetDataMashup()  (*DataMashup,  error)  {
	
	CGoReturnPtr := C.Workbook_GetDataMashup( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &DataMashup{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteDataMashup) 

	return result, nil 
}
// Gets and sets the XML file that defines the Ribbon UI.
// Returns:
//   string  
func (instance *Workbook) GetRibbonXml()  (string,  error)  {
	
	CGoReturnPtr := C.Workbook_GetRibbonXml( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the XML file that defines the Ribbon UI.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *Workbook) SetRibbonXml(value string)  error {
	
	CGoReturnPtr := C.Workbook_SetRibbonXml( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the absolute path of the file.
// Returns:
//   string  
func (instance *Workbook) GetAbsolutePath()  (string,  error)  {
	
	CGoReturnPtr := C.Workbook_GetAbsolutePath( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the absolute path of the file.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *Workbook) SetAbsolutePath(value string)  error {
	
	CGoReturnPtr := C.Workbook_SetAbsolutePath( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the <see cref="ExternalConnection"/> collection.
// Returns:
//   ExternalConnectionCollection  
func (instance *Workbook) GetDataConnections()  (*ExternalConnectionCollection,  error)  {
	
	CGoReturnPtr := C.Workbook_GetDataConnections( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &ExternalConnectionCollection{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteExternalConnectionCollection) 

	return result, nil 
}
// Imports/Updates an XML data file into the workbook.
// Parameters:
//   url - string 
//   sheetName - string 
//   row - int32 
//   col - int32 
// Returns:
//   void  
func (instance *Workbook) ImportXml_String_String_Int_Int(url string, sheetname string, row int32, col int32)  error {
	
	CGoReturnPtr := C.Workbook_ImportXml_String_String_Integer_Integer( instance.ptr, C.CString(url), C.CString(sheetname), C.int(row), C.int(col))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Imports/Updates an XML data file into the workbook.
// Parameters:
//   stream - []byte 
//   sheetName - string 
//   row - int32 
//   col - int32 
// Returns:
//   void  
func (instance *Workbook) ImportXml_Stream_String_Int_Int(stream []byte, sheetname string, row int32, col int32)  error {
	
	CGoReturnPtr := C.Workbook_ImportXml_Stream_String_Integer_Integer( instance.ptr, unsafe.Pointer(&stream[0]), C.int( len(stream)), C.CString(sheetname), C.int(row), C.int(col))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Export XML data linked by the specified XML map.
// Parameters:
//   mapName - string 
//   path - string 
// Returns:
//   void  
func (instance *Workbook) ExportXml_String_String(mapname string, path string)  error {
	
	CGoReturnPtr := C.Workbook_ExportXml_String_String( instance.ptr, C.CString(mapname), C.CString(path))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Export XML data.
// Parameters:
//   mapName - string 
// Returns:
//   []byte  
func (instance *Workbook) ExportXml_String(mapname string)  ([]byte,  error)  {
	
	CGoReturnPtr := C.Workbook_ExportXml_String( instance.ptr, C.CString(mapname))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := C.GoBytes(unsafe.Pointer(CGoReturnPtr.return_value), C.int(CGoReturnPtr.column_length))
	 

	return result, nil 
}
// Sets digital signature to an spreadsheet file (Excel2007 and later).
// Parameters:
//   digitalSignatureCollection - DigitalSignatureCollection 
// Returns:
//   void  
func (instance *Workbook) SetDigitalSignature(digitalsignaturecollection *DigitalSignatureCollection)  error {
	
	var digitalsignaturecollection_ptr unsafe.Pointer = nil
	if digitalsignaturecollection != nil {
	  digitalsignaturecollection_ptr =digitalsignaturecollection.ptr
	}

	CGoReturnPtr := C.Workbook_SetDigitalSignature( instance.ptr, digitalsignaturecollection_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Adds digital signature to an OOXML spreadsheet file (Excel2007 and later).
// Parameters:
//   digitalSignatureCollection - DigitalSignatureCollection 
// Returns:
//   void  
func (instance *Workbook) AddDigitalSignature(digitalsignaturecollection *DigitalSignatureCollection)  error {
	
	var digitalsignaturecollection_ptr unsafe.Pointer = nil
	if digitalsignaturecollection != nil {
	  digitalsignaturecollection_ptr =digitalsignaturecollection.ptr
	}

	CGoReturnPtr := C.Workbook_AddDigitalSignature( instance.ptr, digitalsignaturecollection_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets digital signature from file.
// Returns:
//   DigitalSignatureCollection  
func (instance *Workbook) GetDigitalSignature()  (*DigitalSignatureCollection,  error)  {
	
	CGoReturnPtr := C.Workbook_GetDigitalSignature( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &DigitalSignatureCollection{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteDigitalSignatureCollection) 

	return result, nil 
}
// Removes personal information.
// Returns:
//   void  
func (instance *Workbook) RemovePersonalInformation()  error {
	
	CGoReturnPtr := C.Workbook_RemovePersonalInformation( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets data model in the workbook.
// Returns:
//   DataModel  
func (instance *Workbook) GetDataModel()  (*DataModel,  error)  {
	
	CGoReturnPtr := C.Workbook_GetDataModel( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &DataModel{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteDataModel) 

	return result, nil 
}
// Performs application-defined tasks associated with freeing, releasing, or
// resetting unmanaged resources.
// Returns:
//   void  
func (instance *Workbook) Dispose()  error {
	
	CGoReturnPtr := C.Workbook_Dispose( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}



func DeleteWorkbook(workbook *Workbook){
	runtime.SetFinalizer(workbook, nil)
	C.Delete_Workbook(workbook.ptr)
	workbook.ptr = nil
}

// Class WorkbookSettings 

// Represents all settings of the workbook.
type WorkbookSettings struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *WorkbookSettings) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.WorkbookSettings_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Releases resources.
// Returns:
//   void  
func (instance *WorkbookSettings) Dispose()  error {
	
	CGoReturnPtr := C.WorkbookSettings_Dispose( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the default theme font name.
// Parameters:
//   type - int32 
// Returns:
//   string  
func (instance *WorkbookSettings) GetThemeFont(type_ FontSchemeType)  (string,  error)  {
	
	CGoReturnPtr := C.WorkbookSettings_GetThemeFont( instance.ptr, C.int( int32(type_)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the author of the file.
// Returns:
//   string  
func (instance *WorkbookSettings) GetAuthor()  (string,  error)  {
	
	CGoReturnPtr := C.WorkbookSettings_GetAuthor( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the author of the file.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *WorkbookSettings) SetAuthor(value string)  error {
	
	CGoReturnPtr := C.WorkbookSettings_SetAuthor( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether checking custom number format when setting Style.Custom.
// Returns:
//   bool  
func (instance *WorkbookSettings) GetCheckCustomNumberFormat()  (bool,  error)  {
	
	CGoReturnPtr := C.WorkbookSettings_GetCheckCustomNumberFormat( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether checking custom number format when setting Style.Custom.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *WorkbookSettings) SetCheckCustomNumberFormat(value bool)  error {
	
	CGoReturnPtr := C.WorkbookSettings_SetCheckCustomNumberFormat( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Enable macros;
// Returns:
//   bool  
func (instance *WorkbookSettings) GetEnableMacros()  (bool,  error)  {
	
	CGoReturnPtr := C.WorkbookSettings_GetEnableMacros( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Enable macros;
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *WorkbookSettings) SetEnableMacros(value bool)  error {
	
	CGoReturnPtr := C.WorkbookSettings_SetEnableMacros( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets a value which represents if the workbook uses the 1904 date system.
// Returns:
//   bool  
func (instance *WorkbookSettings) GetDate1904()  (bool,  error)  {
	
	CGoReturnPtr := C.WorkbookSettings_GetDate1904( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets a value which represents if the workbook uses the 1904 date system.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *WorkbookSettings) SetDate1904(value bool)  error {
	
	CGoReturnPtr := C.WorkbookSettings_SetDate1904( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the protection type of the workbook.
// Returns:
//   int32  
func (instance *WorkbookSettings) GetProtectionType()  (ProtectionType,  error)  {
	
	CGoReturnPtr := C.WorkbookSettings_GetProtectionType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToProtectionType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Indicates whether and how to show objects in the workbook.
// Returns:
//   int32  
func (instance *WorkbookSettings) GetDisplayDrawingObjects()  (DisplayDrawingObjects,  error)  {
	
	CGoReturnPtr := C.WorkbookSettings_GetDisplayDrawingObjects( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToDisplayDrawingObjects(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Indicates whether and how to show objects in the workbook.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *WorkbookSettings) SetDisplayDrawingObjects(value DisplayDrawingObjects)  error {
	
	CGoReturnPtr := C.WorkbookSettings_SetDisplayDrawingObjects( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Width of worksheet tab bar (in 1/1000 of window width).
// Returns:
//   int32  
func (instance *WorkbookSettings) GetSheetTabBarWidth()  (int32,  error)  {
	
	CGoReturnPtr := C.WorkbookSettings_GetSheetTabBarWidth( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Width of worksheet tab bar (in 1/1000 of window width).
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *WorkbookSettings) SetSheetTabBarWidth(value int32)  error {
	
	CGoReturnPtr := C.WorkbookSettings_SetSheetTabBarWidth( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Get or sets a value whether the Workbook tabs are displayed.
// Returns:
//   bool  
func (instance *WorkbookSettings) GetShowTabs()  (bool,  error)  {
	
	CGoReturnPtr := C.WorkbookSettings_GetShowTabs( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Get or sets a value whether the Workbook tabs are displayed.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *WorkbookSettings) SetShowTabs(value bool)  error {
	
	CGoReturnPtr := C.WorkbookSettings_SetShowTabs( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the first visible worksheet tab.
// Returns:
//   int32  
func (instance *WorkbookSettings) GetFirstVisibleTab()  (int32,  error)  {
	
	CGoReturnPtr := C.WorkbookSettings_GetFirstVisibleTab( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets the first visible worksheet tab.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *WorkbookSettings) SetFirstVisibleTab(value int32)  error {
	
	CGoReturnPtr := C.WorkbookSettings_SetFirstVisibleTab( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets a value indicating whether the generated spreadsheet will contain a horizontal scroll bar.
// Returns:
//   bool  
func (instance *WorkbookSettings) IsHScrollBarVisible()  (bool,  error)  {
	
	CGoReturnPtr := C.WorkbookSettings_IsHScrollBarVisible( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets a value indicating whether the generated spreadsheet will contain a horizontal scroll bar.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *WorkbookSettings) SetIsHScrollBarVisible(value bool)  error {
	
	CGoReturnPtr := C.WorkbookSettings_SetIsHScrollBarVisible( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets a value indicating whether the generated spreadsheet will contain a vertical scroll bar.
// Returns:
//   bool  
func (instance *WorkbookSettings) IsVScrollBarVisible()  (bool,  error)  {
	
	CGoReturnPtr := C.WorkbookSettings_IsVScrollBarVisible( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets a value indicating whether the generated spreadsheet will contain a vertical scroll bar.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *WorkbookSettings) SetIsVScrollBarVisible(value bool)  error {
	
	CGoReturnPtr := C.WorkbookSettings_SetIsVScrollBarVisible( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets a value that indicates whether the Workbook is shared.
// Returns:
//   bool  
func (instance *WorkbookSettings) GetShared()  (bool,  error)  {
	
	CGoReturnPtr := C.WorkbookSettings_GetShared( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets a value that indicates whether the Workbook is shared.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *WorkbookSettings) SetShared(value bool)  error {
	
	CGoReturnPtr := C.WorkbookSettings_SetShared( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the user interface language of the Workbook version based on CountryCode that has saved the file.
// Returns:
//   int32  
func (instance *WorkbookSettings) GetLanguageCode()  (CountryCode,  error)  {
	
	CGoReturnPtr := C.WorkbookSettings_GetLanguageCode( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToCountryCode(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets or sets the user interface language of the Workbook version based on CountryCode that has saved the file.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *WorkbookSettings) SetLanguageCode(value CountryCode)  error {
	
	CGoReturnPtr := C.WorkbookSettings_SetLanguageCode( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the regional settings for workbook.
// Returns:
//   int32  
func (instance *WorkbookSettings) GetRegion()  (CountryCode,  error)  {
	
	CGoReturnPtr := C.WorkbookSettings_GetRegion( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToCountryCode(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets or sets the regional settings for workbook.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *WorkbookSettings) SetRegion(value CountryCode)  error {
	
	CGoReturnPtr := C.WorkbookSettings_SetRegion( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the globalization settings.
// Returns:
//   GlobalizationSettings  
func (instance *WorkbookSettings) GetGlobalizationSettings()  (*GlobalizationSettings,  error)  {
	
	CGoReturnPtr := C.WorkbookSettings_GetGlobalizationSettings( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &GlobalizationSettings{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteGlobalizationSettings) 

	return result, nil 
}
// Gets and sets the globalization settings.
// Parameters:
//   value - GlobalizationSettings 
// Returns:
//   void  
func (instance *WorkbookSettings) SetGlobalizationSettings(value *GlobalizationSettings)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.WorkbookSettings_SetGlobalizationSettings( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the decimal separator for formatting/parsing numeric values. Default is the decimal separator of current Region.
// Returns:
//   byte  
func (instance *WorkbookSettings) GetNumberDecimalSeparator()  (byte,  error)  {
	
	CGoReturnPtr := C.WorkbookSettings_GetNumberDecimalSeparator( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := byte(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets the decimal separator for formatting/parsing numeric values. Default is the decimal separator of current Region.
// Parameters:
//   value - byte 
// Returns:
//   void  
func (instance *WorkbookSettings) SetNumberDecimalSeparator(value byte)  error {
	
	CGoReturnPtr := C.WorkbookSettings_SetNumberDecimalSeparator( instance.ptr, C.char(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the character that separates groups of digits to the left of the decimal in numeric values. Default is the group separator of current Region.
// Returns:
//   byte  
func (instance *WorkbookSettings) GetNumberGroupSeparator()  (byte,  error)  {
	
	CGoReturnPtr := C.WorkbookSettings_GetNumberGroupSeparator( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := byte(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets the character that separates groups of digits to the left of the decimal in numeric values. Default is the group separator of current Region.
// Parameters:
//   value - byte 
// Returns:
//   void  
func (instance *WorkbookSettings) SetNumberGroupSeparator(value byte)  error {
	
	CGoReturnPtr := C.WorkbookSettings_SetNumberGroupSeparator( instance.ptr, C.char(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents Workbook file encryption password.
// Returns:
//   string  
func (instance *WorkbookSettings) GetPassword()  (string,  error)  {
	
	CGoReturnPtr := C.WorkbookSettings_GetPassword( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents Workbook file encryption password.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *WorkbookSettings) SetPassword(value string)  error {
	
	CGoReturnPtr := C.WorkbookSettings_SetPassword( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Provides access to the workbook write protection options.
// Returns:
//   WriteProtection  
func (instance *WorkbookSettings) GetWriteProtection()  (*WriteProtection,  error)  {
	
	CGoReturnPtr := C.WorkbookSettings_GetWriteProtection( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &WriteProtection{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteWriteProtection) 

	return result, nil 
}
// Gets a value that indicates whether a password is required to open this workbook.
// Returns:
//   bool  
func (instance *WorkbookSettings) IsEncrypted()  (bool,  error)  {
	
	CGoReturnPtr := C.WorkbookSettings_IsEncrypted( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets a value that indicates whether the structure or window of the Workbook is protected.
// Returns:
//   bool  
func (instance *WorkbookSettings) IsProtected()  (bool,  error)  {
	
	CGoReturnPtr := C.WorkbookSettings_IsProtected( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether encrypting the workbook with default password if Structure and Windows of the workbook are locked.
// Returns:
//   bool  
func (instance *WorkbookSettings) IsDefaultEncrypted()  (bool,  error)  {
	
	CGoReturnPtr := C.WorkbookSettings_IsDefaultEncrypted( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether encrypting the workbook with default password if Structure and Windows of the workbook are locked.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *WorkbookSettings) SetIsDefaultEncrypted(value bool)  error {
	
	CGoReturnPtr := C.WorkbookSettings_SetIsDefaultEncrypted( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents whether the generated spreadsheet will be opened Minimized.
// Returns:
//   bool  
func (instance *WorkbookSettings) IsMinimized()  (bool,  error)  {
	
	CGoReturnPtr := C.WorkbookSettings_IsMinimized( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents whether the generated spreadsheet will be opened Minimized.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *WorkbookSettings) SetIsMinimized(value bool)  error {
	
	CGoReturnPtr := C.WorkbookSettings_SetIsMinimized( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether this workbook is hidden.
// Returns:
//   bool  
func (instance *WorkbookSettings) IsHidden()  (bool,  error)  {
	
	CGoReturnPtr := C.WorkbookSettings_IsHidden( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether this workbook is hidden.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *WorkbookSettings) SetIsHidden(value bool)  error {
	
	CGoReturnPtr := C.WorkbookSettings_SetIsHidden( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Specifies a boolean value that indicates the application automatically compressed pictures in the workbook.
// Returns:
//   bool  
func (instance *WorkbookSettings) GetAutoCompressPictures()  (bool,  error)  {
	
	CGoReturnPtr := C.WorkbookSettings_GetAutoCompressPictures( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Specifies a boolean value that indicates the application automatically compressed pictures in the workbook.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *WorkbookSettings) SetAutoCompressPictures(value bool)  error {
	
	CGoReturnPtr := C.WorkbookSettings_SetAutoCompressPictures( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// True if personal information can be removed from the specified workbook.
// Returns:
//   bool  
func (instance *WorkbookSettings) GetRemovePersonalInformation()  (bool,  error)  {
	
	CGoReturnPtr := C.WorkbookSettings_GetRemovePersonalInformation( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// True if personal information can be removed from the specified workbook.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *WorkbookSettings) SetRemovePersonalInformation(value bool)  error {
	
	CGoReturnPtr := C.WorkbookSettings_SetRemovePersonalInformation( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets whether hide the field list for the PivotTable.
// Returns:
//   bool  
func (instance *WorkbookSettings) GetHidePivotFieldList()  (bool,  error)  {
	
	CGoReturnPtr := C.WorkbookSettings_GetHidePivotFieldList( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets whether hide the field list for the PivotTable.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *WorkbookSettings) SetHidePivotFieldList(value bool)  error {
	
	CGoReturnPtr := C.WorkbookSettings_SetHidePivotFieldList( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets how updates external links when the workbook is opened.
// Returns:
//   int32  
func (instance *WorkbookSettings) GetUpdateLinksType()  (UpdateLinksType,  error)  {
	
	CGoReturnPtr := C.WorkbookSettings_GetUpdateLinksType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToUpdateLinksType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets and sets how updates external links when the workbook is opened.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *WorkbookSettings) SetUpdateLinksType(value UpdateLinksType)  error {
	
	CGoReturnPtr := C.WorkbookSettings_SetUpdateLinksType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Set the type of  print orientation for the whole workbook.
// Parameters:
//   pageOrientationType - int32 
// Returns:
//   void  
func (instance *WorkbookSettings) SetPageOrientationType(pageorientationtype PageOrientationType)  error {
	
	CGoReturnPtr := C.WorkbookSettings_SetPageOrientationType( instance.ptr, C.int( int32(pageorientationtype)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the max row index, zero-based.
// Returns:
//   int32  
func (instance *WorkbookSettings) GetMaxRow()  (int32,  error)  {
	
	CGoReturnPtr := C.WorkbookSettings_GetMaxRow( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the max column index, zero-based.
// Returns:
//   int32  
func (instance *WorkbookSettings) GetMaxColumn()  (int32,  error)  {
	
	CGoReturnPtr := C.WorkbookSettings_GetMaxColumn( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the settings for default values of style-related properties for this workbook.
// Returns:
//   DefaultStyleSettings  
func (instance *WorkbookSettings) GetDefaultStyleSettings()  (*DefaultStyleSettings,  error)  {
	
	CGoReturnPtr := C.WorkbookSettings_GetDefaultStyleSettings( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &DefaultStyleSettings{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteDefaultStyleSettings) 

	return result, nil 
}
// The distance from the left edge of the client area to the left edge of the window, in unit of point.
// Returns:
//   float64  
func (instance *WorkbookSettings) GetWindowLeft()  (float64,  error)  {
	
	CGoReturnPtr := C.WorkbookSettings_GetWindowLeft( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := float64(CGoReturnPtr.return_value) 

	return result, nil 
}
// The distance from the left edge of the client area to the left edge of the window, in unit of point.
// Parameters:
//   value - float64 
// Returns:
//   void  
func (instance *WorkbookSettings) SetWindowLeft(value float64)  error {
	
	CGoReturnPtr := C.WorkbookSettings_SetWindowLeft( instance.ptr, C.double(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// The distance from the left edge of the client area to the left edge of the window.
// In unit of inch.
// Returns:
//   float64  
func (instance *WorkbookSettings) GetWindowLeftInch()  (float64,  error)  {
	
	CGoReturnPtr := C.WorkbookSettings_GetWindowLeftInch( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := float64(CGoReturnPtr.return_value) 

	return result, nil 
}
// The distance from the left edge of the client area to the left edge of the window.
// In unit of inch.
// Parameters:
//   value - float64 
// Returns:
//   void  
func (instance *WorkbookSettings) SetWindowLeftInch(value float64)  error {
	
	CGoReturnPtr := C.WorkbookSettings_SetWindowLeftInch( instance.ptr, C.double(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// The distance from the left edge of the client area to the left edge of the window.
// In unit of centimeter.
// Returns:
//   float64  
func (instance *WorkbookSettings) GetWindowLeftCM()  (float64,  error)  {
	
	CGoReturnPtr := C.WorkbookSettings_GetWindowLeftCM( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := float64(CGoReturnPtr.return_value) 

	return result, nil 
}
// The distance from the left edge of the client area to the left edge of the window.
// In unit of centimeter.
// Parameters:
//   value - float64 
// Returns:
//   void  
func (instance *WorkbookSettings) SetWindowLeftCM(value float64)  error {
	
	CGoReturnPtr := C.WorkbookSettings_SetWindowLeftCM( instance.ptr, C.double(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// The distance from the top edge of the client area to the top edge of the window, in unit of point.
// Returns:
//   float64  
func (instance *WorkbookSettings) GetWindowTop()  (float64,  error)  {
	
	CGoReturnPtr := C.WorkbookSettings_GetWindowTop( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := float64(CGoReturnPtr.return_value) 

	return result, nil 
}
// The distance from the top edge of the client area to the top edge of the window, in unit of point.
// Parameters:
//   value - float64 
// Returns:
//   void  
func (instance *WorkbookSettings) SetWindowTop(value float64)  error {
	
	CGoReturnPtr := C.WorkbookSettings_SetWindowTop( instance.ptr, C.double(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// The distance from the top edge of the client area to the top edge of the window, in unit of inch.
// Returns:
//   float64  
func (instance *WorkbookSettings) GetWindowTopInch()  (float64,  error)  {
	
	CGoReturnPtr := C.WorkbookSettings_GetWindowTopInch( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := float64(CGoReturnPtr.return_value) 

	return result, nil 
}
// The distance from the top edge of the client area to the top edge of the window, in unit of inch.
// Parameters:
//   value - float64 
// Returns:
//   void  
func (instance *WorkbookSettings) SetWindowTopInch(value float64)  error {
	
	CGoReturnPtr := C.WorkbookSettings_SetWindowTopInch( instance.ptr, C.double(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// The distance from the top edge of the client area to the top edge of the window, in unit of centimeter.
// Returns:
//   float64  
func (instance *WorkbookSettings) GetWindowTopCM()  (float64,  error)  {
	
	CGoReturnPtr := C.WorkbookSettings_GetWindowTopCM( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := float64(CGoReturnPtr.return_value) 

	return result, nil 
}
// The distance from the top edge of the client area to the top edge of the window, in unit of centimeter.
// Parameters:
//   value - float64 
// Returns:
//   void  
func (instance *WorkbookSettings) SetWindowTopCM(value float64)  error {
	
	CGoReturnPtr := C.WorkbookSettings_SetWindowTopCM( instance.ptr, C.double(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// The width of the window, in unit of point.
// Returns:
//   float64  
func (instance *WorkbookSettings) GetWindowWidth()  (float64,  error)  {
	
	CGoReturnPtr := C.WorkbookSettings_GetWindowWidth( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := float64(CGoReturnPtr.return_value) 

	return result, nil 
}
// The width of the window, in unit of point.
// Parameters:
//   value - float64 
// Returns:
//   void  
func (instance *WorkbookSettings) SetWindowWidth(value float64)  error {
	
	CGoReturnPtr := C.WorkbookSettings_SetWindowWidth( instance.ptr, C.double(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// The width of the window, in unit of inch.
// Returns:
//   float64  
func (instance *WorkbookSettings) GetWindowWidthInch()  (float64,  error)  {
	
	CGoReturnPtr := C.WorkbookSettings_GetWindowWidthInch( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := float64(CGoReturnPtr.return_value) 

	return result, nil 
}
// The width of the window, in unit of inch.
// Parameters:
//   value - float64 
// Returns:
//   void  
func (instance *WorkbookSettings) SetWindowWidthInch(value float64)  error {
	
	CGoReturnPtr := C.WorkbookSettings_SetWindowWidthInch( instance.ptr, C.double(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// The width of the window, in unit of centimeter.
// Returns:
//   float64  
func (instance *WorkbookSettings) GetWindowWidthCM()  (float64,  error)  {
	
	CGoReturnPtr := C.WorkbookSettings_GetWindowWidthCM( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := float64(CGoReturnPtr.return_value) 

	return result, nil 
}
// The width of the window, in unit of centimeter.
// Parameters:
//   value - float64 
// Returns:
//   void  
func (instance *WorkbookSettings) SetWindowWidthCM(value float64)  error {
	
	CGoReturnPtr := C.WorkbookSettings_SetWindowWidthCM( instance.ptr, C.double(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// The height of the window, in unit of point.
// Returns:
//   float64  
func (instance *WorkbookSettings) GetWindowHeight()  (float64,  error)  {
	
	CGoReturnPtr := C.WorkbookSettings_GetWindowHeight( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := float64(CGoReturnPtr.return_value) 

	return result, nil 
}
// The height of the window, in unit of point.
// Parameters:
//   value - float64 
// Returns:
//   void  
func (instance *WorkbookSettings) SetWindowHeight(value float64)  error {
	
	CGoReturnPtr := C.WorkbookSettings_SetWindowHeight( instance.ptr, C.double(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// The height of the window, in unit of inch.
// Returns:
//   float64  
func (instance *WorkbookSettings) GetWindowHeightInch()  (float64,  error)  {
	
	CGoReturnPtr := C.WorkbookSettings_GetWindowHeightInch( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := float64(CGoReturnPtr.return_value) 

	return result, nil 
}
// The height of the window, in unit of inch.
// Parameters:
//   value - float64 
// Returns:
//   void  
func (instance *WorkbookSettings) SetWindowHeightInch(value float64)  error {
	
	CGoReturnPtr := C.WorkbookSettings_SetWindowHeightInch( instance.ptr, C.double(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// The height of the window, in unit of centimeter.
// Returns:
//   float64  
func (instance *WorkbookSettings) GetWindowHeightCM()  (float64,  error)  {
	
	CGoReturnPtr := C.WorkbookSettings_GetWindowHeightCM( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := float64(CGoReturnPtr.return_value) 

	return result, nil 
}
// The height of the window, in unit of centimeter.
// Parameters:
//   value - float64 
// Returns:
//   void  
func (instance *WorkbookSettings) SetWindowHeightCM(value float64)  error {
	
	CGoReturnPtr := C.WorkbookSettings_SetWindowHeightCM( instance.ptr, C.double(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether update adjacent cells' border.
// Returns:
//   bool  
func (instance *WorkbookSettings) GetUpdateAdjacentCellsBorder()  (bool,  error)  {
	
	CGoReturnPtr := C.WorkbookSettings_GetUpdateAdjacentCellsBorder( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether update adjacent cells' border.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *WorkbookSettings) SetUpdateAdjacentCellsBorder(value bool)  error {
	
	CGoReturnPtr := C.WorkbookSettings_SetUpdateAdjacentCellsBorder( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the number of significant digits.
// The default value is <see cref="CellsHelper.SignificantDigits"/>.
// Returns:
//   int32  
func (instance *WorkbookSettings) GetSignificantDigits()  (int32,  error)  {
	
	CGoReturnPtr := C.WorkbookSettings_GetSignificantDigits( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the number of significant digits.
// The default value is <see cref="CellsHelper.SignificantDigits"/>.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *WorkbookSettings) SetSignificantDigits(value int32)  error {
	
	CGoReturnPtr := C.WorkbookSettings_SetSignificantDigits( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether check compatibility with earlier versions when saving workbook.
// Returns:
//   bool  
func (instance *WorkbookSettings) GetCheckCompatibility()  (bool,  error)  {
	
	CGoReturnPtr := C.WorkbookSettings_GetCheckCompatibility( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether check compatibility with earlier versions when saving workbook.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *WorkbookSettings) SetCheckCompatibility(value bool)  error {
	
	CGoReturnPtr := C.WorkbookSettings_SetCheckCompatibility( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Whether check restriction of excel file when user modify cells related objects.
// For example, excel does not allow inputting string value longer than 32K.
// When you input a value longer than 32K such as by Cell.PutValue(string), if this property is true, you will get an Exception.
// If this property is false, we will accept your input string value as the cell's value so that later
// you can output the complete string value for other file formats such as CSV.
// However, if you have set such kind of value that is invalid for excel file format,
// you should not save the workbook as excel file format later. Otherwise there may be unexpected error for the generated excel file.
// Returns:
//   bool  
func (instance *WorkbookSettings) GetCheckExcelRestriction()  (bool,  error)  {
	
	CGoReturnPtr := C.WorkbookSettings_GetCheckExcelRestriction( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Whether check restriction of excel file when user modify cells related objects.
// For example, excel does not allow inputting string value longer than 32K.
// When you input a value longer than 32K such as by Cell.PutValue(string), if this property is true, you will get an Exception.
// If this property is false, we will accept your input string value as the cell's value so that later
// you can output the complete string value for other file formats such as CSV.
// However, if you have set such kind of value that is invalid for excel file format,
// you should not save the workbook as excel file format later. Otherwise there may be unexpected error for the generated excel file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *WorkbookSettings) SetCheckExcelRestriction(value bool)  error {
	
	CGoReturnPtr := C.WorkbookSettings_SetCheckExcelRestriction( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether the file is marked for auto-recovery.
// Returns:
//   bool  
func (instance *WorkbookSettings) GetAutoRecover()  (bool,  error)  {
	
	CGoReturnPtr := C.WorkbookSettings_GetAutoRecover( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether the file is marked for auto-recovery.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *WorkbookSettings) SetAutoRecover(value bool)  error {
	
	CGoReturnPtr := C.WorkbookSettings_SetAutoRecover( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// indicates whether the application last saved the workbook file after a crash.
// Returns:
//   bool  
func (instance *WorkbookSettings) GetCrashSave()  (bool,  error)  {
	
	CGoReturnPtr := C.WorkbookSettings_GetCrashSave( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// indicates whether the application last saved the workbook file after a crash.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *WorkbookSettings) SetCrashSave(value bool)  error {
	
	CGoReturnPtr := C.WorkbookSettings_SetCrashSave( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// indicates whether the application last opened the workbook for data recovery.
// Returns:
//   bool  
func (instance *WorkbookSettings) GetDataExtractLoad()  (bool,  error)  {
	
	CGoReturnPtr := C.WorkbookSettings_GetDataExtractLoad( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// indicates whether the application last opened the workbook for data recovery.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *WorkbookSettings) SetDataExtractLoad(value bool)  error {
	
	CGoReturnPtr := C.WorkbookSettings_SetDataExtractLoad( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether the application last opened the workbook in safe or repair mode.
// Returns:
//   bool  
func (instance *WorkbookSettings) GetRepairLoad()  (bool,  error)  {
	
	CGoReturnPtr := C.WorkbookSettings_GetRepairLoad( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether the application last opened the workbook in safe or repair mode.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *WorkbookSettings) SetRepairLoad(value bool)  error {
	
	CGoReturnPtr := C.WorkbookSettings_SetRepairLoad( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Specifies the incremental public release of the application.
// Returns:
//   string  
func (instance *WorkbookSettings) GetBuildVersion()  (string,  error)  {
	
	CGoReturnPtr := C.WorkbookSettings_GetBuildVersion( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Specifies the incremental public release of the application.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *WorkbookSettings) SetBuildVersion(value string)  error {
	
	CGoReturnPtr := C.WorkbookSettings_SetBuildVersion( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the memory usage options. The new option will be taken as the default option for newly created worksheets but does not take effect for existing worksheets.
// Returns:
//   int32  
func (instance *WorkbookSettings) GetMemorySetting()  (MemorySetting,  error)  {
	
	CGoReturnPtr := C.WorkbookSettings_GetMemorySetting( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToMemorySetting(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets or sets the memory usage options. The new option will be taken as the default option for newly created worksheets but does not take effect for existing worksheets.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *WorkbookSettings) SetMemorySetting(value MemorySetting)  error {
	
	CGoReturnPtr := C.WorkbookSettings_SetMemorySetting( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the default print paper size.
// Returns:
//   int32  
func (instance *WorkbookSettings) GetPaperSize()  (PaperSizeType,  error)  {
	
	CGoReturnPtr := C.WorkbookSettings_GetPaperSize( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToPaperSizeType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets and sets the default print paper size.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *WorkbookSettings) SetPaperSize(value PaperSizeType)  error {
	
	CGoReturnPtr := C.WorkbookSettings_SetPaperSize( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the max row number of shared formula.
// Returns:
//   int32  
func (instance *WorkbookSettings) GetMaxRowsOfSharedFormula()  (int32,  error)  {
	
	CGoReturnPtr := C.WorkbookSettings_GetMaxRowsOfSharedFormula( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the max row number of shared formula.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *WorkbookSettings) SetMaxRowsOfSharedFormula(value int32)  error {
	
	CGoReturnPtr := C.WorkbookSettings_SetMaxRowsOfSharedFormula( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Specifies the OOXML version for the output document. The default value is Ecma376_2006.
// Returns:
//   int32  
func (instance *WorkbookSettings) GetCompliance()  (OoxmlCompliance,  error)  {
	
	CGoReturnPtr := C.WorkbookSettings_GetCompliance( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToOoxmlCompliance(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Specifies the OOXML version for the output document. The default value is Ecma376_2006.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *WorkbookSettings) SetCompliance(value OoxmlCompliance)  error {
	
	CGoReturnPtr := C.WorkbookSettings_SetCompliance( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether setting <see cref="Style.QuotePrefix"/> property when entering the string value(which starts  with single quote mark ) to the cell
// Returns:
//   bool  
func (instance *WorkbookSettings) GetQuotePrefixToStyle()  (bool,  error)  {
	
	CGoReturnPtr := C.WorkbookSettings_GetQuotePrefixToStyle( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether setting <see cref="Style.QuotePrefix"/> property when entering the string value(which starts  with single quote mark ) to the cell
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *WorkbookSettings) SetQuotePrefixToStyle(value bool)  error {
	
	CGoReturnPtr := C.WorkbookSettings_SetQuotePrefixToStyle( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the settings for formula-related features.
// Returns:
//   FormulaSettings  
func (instance *WorkbookSettings) GetFormulaSettings()  (*FormulaSettings,  error)  {
	
	CGoReturnPtr := C.WorkbookSettings_GetFormulaSettings( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &FormulaSettings{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteFormulaSettings) 

	return result, nil 
}
// Indicates whether datapoint properties and datalabels in all charts in this workbook follow their reference.
// Returns:
//   bool  
func (instance *WorkbookSettings) GetPropertiesFollowChartPoint()  (bool,  error)  {
	
	CGoReturnPtr := C.WorkbookSettings_GetPropertiesFollowChartPoint( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether datapoint properties and datalabels in all charts in this workbook follow their reference.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *WorkbookSettings) SetPropertiesFollowChartPoint(value bool)  error {
	
	CGoReturnPtr := C.WorkbookSettings_SetPropertiesFollowChartPoint( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether discarding editting image data.
// Returns:
//   bool  
func (instance *WorkbookSettings) GetDiscardImageEditData()  (bool,  error)  {
	
	CGoReturnPtr := C.WorkbookSettings_GetDiscardImageEditData( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether discarding editting image data.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *WorkbookSettings) SetDiscardImageEditData(value bool)  error {
	
	CGoReturnPtr := C.WorkbookSettings_SetDiscardImageEditData( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets default resolution of image.
// Returns:
//   int32  
func (instance *WorkbookSettings) GetDefaultImageResolution()  (int32,  error)  {
	
	CGoReturnPtr := C.WorkbookSettings_GetDefaultImageResolution( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets default resolution of image.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *WorkbookSettings) SetDefaultImageResolution(value int32)  error {
	
	CGoReturnPtr := C.WorkbookSettings_SetDefaultImageResolution( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}



func DeleteWorkbookSettings(workbooksettings *WorkbookSettings){
	runtime.SetFinalizer(workbooksettings, nil)
	C.Delete_WorkbookSettings(workbooksettings.ptr)
	workbooksettings.ptr = nil
}

// Class Worksheet 

// Encapsulates the object that represents a single worksheet.
type Worksheet struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *Worksheet) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.Worksheet_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Performs application-defined tasks associated with freeing, releasing, or
// resetting unmanaged resources.
// Returns:
//   void  
func (instance *Worksheet) Dispose()  error {
	
	CGoReturnPtr := C.Worksheet_Dispose( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents the various types of protection options available for a worksheet. Supports advanced protection options in ExcelXP and above version.
// Returns:
//   Protection  
func (instance *Worksheet) GetProtection()  (*Protection,  error)  {
	
	CGoReturnPtr := C.Worksheet_GetProtection( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Protection{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteProtection) 

	return result, nil 
}
// Gets and sets the unique id, it is same as {15DB5C3C-A5A1-48AF-8F25-3D86AC232D4F}.
// Returns:
//   string  
func (instance *Worksheet) GetUniqueId()  (string,  error)  {
	
	CGoReturnPtr := C.Worksheet_GetUniqueId( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the unique id, it is same as {15DB5C3C-A5A1-48AF-8F25-3D86AC232D4F}.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *Worksheet) SetUniqueId(value string)  error {
	
	CGoReturnPtr := C.Worksheet_SetUniqueId( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the window panes.
// Returns:
//   PaneCollection  
func (instance *Worksheet) GetPanes()  (*PaneCollection,  error)  {
	
	CGoReturnPtr := C.Worksheet_GetPanes( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &PaneCollection{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeletePaneCollection) 

	return result, nil 
}
// Gets the workbook object which contains this sheet.
// Returns:
//   Workbook  
func (instance *Worksheet) GetWorkbook()  (*Workbook,  error)  {
	
	CGoReturnPtr := C.Worksheet_GetWorkbook( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Workbook{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteWorkbook) 

	return result, nil 
}
// Gets the <see cref="Cells"/> collection.
// Returns:
//   Cells  
func (instance *Worksheet) GetCells()  (*Cells,  error)  {
	
	CGoReturnPtr := C.Worksheet_GetCells( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Cells{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteCells) 

	return result, nil 
}
// Gets <see cref="QueryTableCollection"/> in the worksheet.
// Returns:
//   QueryTableCollection  
func (instance *Worksheet) GetQueryTables()  (*QueryTableCollection,  error)  {
	
	CGoReturnPtr := C.Worksheet_GetQueryTables( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &QueryTableCollection{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteQueryTableCollection) 

	return result, nil 
}
// Represents worksheet type.
// Returns:
//   int32  
func (instance *Worksheet) GetType()  (SheetType,  error)  {
	
	CGoReturnPtr := C.Worksheet_GetType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToSheetType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Represents worksheet type.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *Worksheet) SetType(value SheetType)  error {
	
	CGoReturnPtr := C.Worksheet_SetType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the name of the worksheet.
// Returns:
//   string  
func (instance *Worksheet) GetName()  (string,  error)  {
	
	CGoReturnPtr := C.Worksheet_GetName( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets the name of the worksheet.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *Worksheet) SetName(value string)  error {
	
	CGoReturnPtr := C.Worksheet_SetName( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether to show formulas or their results.
// Returns:
//   bool  
func (instance *Worksheet) GetShowFormulas()  (bool,  error)  {
	
	CGoReturnPtr := C.Worksheet_GetShowFormulas( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether to show formulas or their results.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Worksheet) SetShowFormulas(value bool)  error {
	
	CGoReturnPtr := C.Worksheet_SetShowFormulas( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets a value indicating whether the gridlines are visible.Default is true.
// Returns:
//   bool  
func (instance *Worksheet) IsGridlinesVisible()  (bool,  error)  {
	
	CGoReturnPtr := C.Worksheet_IsGridlinesVisible( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets a value indicating whether the gridlines are visible.Default is true.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Worksheet) SetIsGridlinesVisible(value bool)  error {
	
	CGoReturnPtr := C.Worksheet_SetIsGridlinesVisible( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets a value indicating whether the worksheet will display row and column headers.
// Default is true.
// Returns:
//   bool  
func (instance *Worksheet) IsRowColumnHeadersVisible()  (bool,  error)  {
	
	CGoReturnPtr := C.Worksheet_IsRowColumnHeadersVisible( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets a value indicating whether the worksheet will display row and column headers.
// Default is true.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Worksheet) SetIsRowColumnHeadersVisible(value bool)  error {
	
	CGoReturnPtr := C.Worksheet_SetIsRowColumnHeadersVisible( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether the pane has horizontal or vertical splits, and whether those splits are frozen.
// Returns:
//   int32  
func (instance *Worksheet) GetPaneState()  (PaneStateType,  error)  {
	
	CGoReturnPtr := C.Worksheet_GetPaneState( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToPaneStateType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// True if zero values are displayed.
// Returns:
//   bool  
func (instance *Worksheet) GetDisplayZeros()  (bool,  error)  {
	
	CGoReturnPtr := C.Worksheet_GetDisplayZeros( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// True if zero values are displayed.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Worksheet) SetDisplayZeros(value bool)  error {
	
	CGoReturnPtr := C.Worksheet_SetDisplayZeros( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates if the specified worksheet is displayed from right to left instead of from left to right.
// Default is false.
// Returns:
//   bool  
func (instance *Worksheet) GetDisplayRightToLeft()  (bool,  error)  {
	
	CGoReturnPtr := C.Worksheet_GetDisplayRightToLeft( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates if the specified worksheet is displayed from right to left instead of from left to right.
// Default is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Worksheet) SetDisplayRightToLeft(value bool)  error {
	
	CGoReturnPtr := C.Worksheet_SetDisplayRightToLeft( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether to show outline.
// Returns:
//   bool  
func (instance *Worksheet) IsOutlineShown()  (bool,  error)  {
	
	CGoReturnPtr := C.Worksheet_IsOutlineShown( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether to show outline.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Worksheet) SetIsOutlineShown(value bool)  error {
	
	CGoReturnPtr := C.Worksheet_SetIsOutlineShown( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether this worksheet is selected when the workbook is opened.
// Returns:
//   bool  
func (instance *Worksheet) IsSelected()  (bool,  error)  {
	
	CGoReturnPtr := C.Worksheet_IsSelected( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether this worksheet is selected when the workbook is opened.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Worksheet) SetIsSelected(value bool)  error {
	
	CGoReturnPtr := C.Worksheet_SetIsSelected( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Freezes panes at the specified cell in the worksheet.
// Parameters:
//   row - int32 
//   column - int32 
//   freezedRows - int32 
//   freezedColumns - int32 
// Returns:
//   void  
func (instance *Worksheet) FreezePanes_Int_Int_Int_Int(row int32, column int32, freezedrows int32, freezedcolumns int32)  error {
	
	CGoReturnPtr := C.Worksheet_FreezePanes_Integer_Integer_Integer_Integer( instance.ptr, C.int(row), C.int(column), C.int(freezedrows), C.int(freezedcolumns))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the freeze panes.
// Parameters:
//   row - int32 
//   column - int32 
//   freezedRows - int32 
//   freezedColumns - int32 
// Returns:
//   bool  
func (instance *Worksheet) GetFreezedPanes()  (bool, int32, int32, int32, int32,  error)  {
	var row int32
	crow := (*C.int)(unsafe.Pointer(&row))
	var column int32
	ccolumn := (*C.int)(unsafe.Pointer(&column))
	var freezedrows int32
	cfreezedrows := (*C.int)(unsafe.Pointer(&freezedrows))
	var freezedcolumns int32
	cfreezedcolumns := (*C.int)(unsafe.Pointer(&freezedcolumns))
	
	CGoReturnPtr := C.Worksheet_GetFreezedPanes( instance.ptr, (crow), (ccolumn), (cfreezedrows), (cfreezedcolumns))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, 0, 0, 0, 0, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, row, column, freezedrows, freezedcolumns, nil 
}
// Splits window.
// Returns:
//   void  
func (instance *Worksheet) Split()  error {
	
	CGoReturnPtr := C.Worksheet_Split( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Freezes panes at the specified cell in the worksheet.
// Parameters:
//   cellName - string 
//   freezedRows - int32 
//   freezedColumns - int32 
// Returns:
//   void  
func (instance *Worksheet) FreezePanes_String_Int_Int(cellname string, freezedrows int32, freezedcolumns int32)  error {
	
	CGoReturnPtr := C.Worksheet_FreezePanes_String_Integer_Integer( instance.ptr, C.CString(cellname), C.int(freezedrows), C.int(freezedcolumns))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Unfreezes panes in the worksheet.
// Returns:
//   void  
func (instance *Worksheet) UnFreezePanes()  error {
	
	CGoReturnPtr := C.Worksheet_UnFreezePanes( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Removes split window.
// Returns:
//   void  
func (instance *Worksheet) RemoveSplit()  error {
	
	CGoReturnPtr := C.Worksheet_RemoveSplit( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets all pivot tables in this worksheet.
// Returns:
//   PivotTableCollection  
func (instance *Worksheet) GetPivotTables()  (*PivotTableCollection,  error)  {
	
	CGoReturnPtr := C.Worksheet_GetPivotTables( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &PivotTableCollection{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeletePivotTableCollection) 

	return result, nil 
}
// Gets all ListObjects in this worksheet.
// Returns:
//   ListObjectCollection  
func (instance *Worksheet) GetListObjects()  (*ListObjectCollection,  error)  {
	
	CGoReturnPtr := C.Worksheet_GetListObjects( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &ListObjectCollection{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteListObjectCollection) 

	return result, nil 
}
// Specifies the internal identifier for the sheet.
// Returns:
//   int32  
func (instance *Worksheet) GetTabId()  (int32,  error)  {
	
	CGoReturnPtr := C.Worksheet_GetTabId( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Specifies the internal identifier for the sheet.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *Worksheet) SetTabId(value int32)  error {
	
	CGoReturnPtr := C.Worksheet_SetTabId( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the <see cref="HorizontalPageBreakCollection"/> collection.
// Returns:
//   HorizontalPageBreakCollection  
func (instance *Worksheet) GetHorizontalPageBreaks()  (*HorizontalPageBreakCollection,  error)  {
	
	CGoReturnPtr := C.Worksheet_GetHorizontalPageBreaks( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &HorizontalPageBreakCollection{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteHorizontalPageBreakCollection) 

	return result, nil 
}
// Gets the <see cref="VerticalPageBreakCollection"/> collection.
// Returns:
//   VerticalPageBreakCollection  
func (instance *Worksheet) GetVerticalPageBreaks()  (*VerticalPageBreakCollection,  error)  {
	
	CGoReturnPtr := C.Worksheet_GetVerticalPageBreaks( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &VerticalPageBreakCollection{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteVerticalPageBreakCollection) 

	return result, nil 
}
// Adds page break.
// Parameters:
//   cellName - string 
// Returns:
//   void  
func (instance *Worksheet) AddPageBreaks(cellname string)  error {
	
	CGoReturnPtr := C.Worksheet_AddPageBreaks( instance.ptr, C.CString(cellname))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the <see cref="HyperlinkCollection"/> collection.
// Returns:
//   HyperlinkCollection  
func (instance *Worksheet) GetHyperlinks()  (*HyperlinkCollection,  error)  {
	
	CGoReturnPtr := C.Worksheet_GetHyperlinks( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &HyperlinkCollection{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteHyperlinkCollection) 

	return result, nil 
}
// Copies contents and formats from another worksheet.
// Parameters:
//   sourceSheet - Worksheet 
// Returns:
//   void  
func (instance *Worksheet) Copy_Worksheet(sourcesheet *Worksheet)  error {
	
	var sourcesheet_ptr unsafe.Pointer = nil
	if sourcesheet != nil {
	  sourcesheet_ptr =sourcesheet.ptr
	}

	CGoReturnPtr := C.Worksheet_Copy_Worksheet( instance.ptr, sourcesheet_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Copies contents and formats from another worksheet.
// Parameters:
//   sourceSheet - Worksheet 
//   copyOptions - CopyOptions 
// Returns:
//   void  
func (instance *Worksheet) Copy_Worksheet_CopyOptions(sourcesheet *Worksheet, copyoptions *CopyOptions)  error {
	
	var sourcesheet_ptr unsafe.Pointer = nil
	if sourcesheet != nil {
	  sourcesheet_ptr =sourcesheet.ptr
	}
	var copyoptions_ptr unsafe.Pointer = nil
	if copyoptions != nil {
	  copyoptions_ptr =copyoptions.ptr
	}

	CGoReturnPtr := C.Worksheet_Copy_Worksheet_CopyOptions( instance.ptr, sourcesheet_ptr, copyoptions_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Autofits the column width.
// Parameters:
//   columnIndex - int32 
//   firstRow - int32 
//   lastRow - int32 
// Returns:
//   void  
func (instance *Worksheet) AutoFitColumn_Int_Int_Int(columnindex int32, firstrow int32, lastrow int32)  error {
	
	CGoReturnPtr := C.Worksheet_AutoFitColumn_Integer_Integer_Integer( instance.ptr, C.int(columnindex), C.int(firstrow), C.int(lastrow))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Autofits all columns in this worksheet.
// Returns:
//   void  
func (instance *Worksheet) AutoFitColumns()  error {
	
	CGoReturnPtr := C.Worksheet_AutoFitColumns( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Autofits all columns in this worksheet.
// Parameters:
//   options - AutoFitterOptions 
// Returns:
//   void  
func (instance *Worksheet) AutoFitColumns_AutoFitterOptions(options *AutoFitterOptions)  error {
	
	var options_ptr unsafe.Pointer = nil
	if options != nil {
	  options_ptr =options.ptr
	}

	CGoReturnPtr := C.Worksheet_AutoFitColumns_AutoFitterOptions( instance.ptr, options_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Autofits the column width.
// Parameters:
//   columnIndex - int32 
// Returns:
//   void  
func (instance *Worksheet) AutoFitColumn_Int(columnindex int32)  error {
	
	CGoReturnPtr := C.Worksheet_AutoFitColumn_Integer( instance.ptr, C.int(columnindex))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Autofits the columns width.
// Parameters:
//   firstColumn - int32 
//   lastColumn - int32 
// Returns:
//   void  
func (instance *Worksheet) AutoFitColumns_Int_Int(firstcolumn int32, lastcolumn int32)  error {
	
	CGoReturnPtr := C.Worksheet_AutoFitColumns_Integer_Integer( instance.ptr, C.int(firstcolumn), C.int(lastcolumn))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Autofits the columns width.
// Parameters:
//   firstColumn - int32 
//   lastColumn - int32 
//   options - AutoFitterOptions 
// Returns:
//   void  
func (instance *Worksheet) AutoFitColumns_Int_Int_AutoFitterOptions(firstcolumn int32, lastcolumn int32, options *AutoFitterOptions)  error {
	
	var options_ptr unsafe.Pointer = nil
	if options != nil {
	  options_ptr =options.ptr
	}

	CGoReturnPtr := C.Worksheet_AutoFitColumns_Integer_Integer_AutoFitterOptions( instance.ptr, C.int(firstcolumn), C.int(lastcolumn), options_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Autofits the columns width.
// Parameters:
//   firstRow - int32 
//   firstColumn - int32 
//   lastRow - int32 
//   lastColumn - int32 
// Returns:
//   void  
func (instance *Worksheet) AutoFitColumns_Int_Int_Int_Int(firstrow int32, firstcolumn int32, lastrow int32, lastcolumn int32)  error {
	
	CGoReturnPtr := C.Worksheet_AutoFitColumns_Integer_Integer_Integer_Integer( instance.ptr, C.int(firstrow), C.int(firstcolumn), C.int(lastrow), C.int(lastcolumn))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Autofits the columns width.
// Parameters:
//   firstRow - int32 
//   firstColumn - int32 
//   lastRow - int32 
//   lastColumn - int32 
//   options - AutoFitterOptions 
// Returns:
//   void  
func (instance *Worksheet) AutoFitColumns_Int_Int_Int_Int_AutoFitterOptions(firstrow int32, firstcolumn int32, lastrow int32, lastcolumn int32, options *AutoFitterOptions)  error {
	
	var options_ptr unsafe.Pointer = nil
	if options != nil {
	  options_ptr =options.ptr
	}

	CGoReturnPtr := C.Worksheet_AutoFitColumns_Integer_Integer_Integer_Integer_AutoFitterOptions( instance.ptr, C.int(firstrow), C.int(firstcolumn), C.int(lastrow), C.int(lastcolumn), options_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Autofits the row height.
// Parameters:
//   rowIndex - int32 
//   firstColumn - int32 
//   lastColumn - int32 
// Returns:
//   void  
func (instance *Worksheet) AutoFitRow_Int_Int_Int(rowindex int32, firstcolumn int32, lastcolumn int32)  error {
	
	CGoReturnPtr := C.Worksheet_AutoFitRow_Integer_Integer_Integer( instance.ptr, C.int(rowindex), C.int(firstcolumn), C.int(lastcolumn))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Autofits the row height.
// Parameters:
//   rowIndex - int32 
//   firstColumn - int32 
//   lastColumn - int32 
//   options - AutoFitterOptions 
// Returns:
//   void  
func (instance *Worksheet) AutoFitRow_Int_Int_Int_AutoFitterOptions(rowindex int32, firstcolumn int32, lastcolumn int32, options *AutoFitterOptions)  error {
	
	var options_ptr unsafe.Pointer = nil
	if options != nil {
	  options_ptr =options.ptr
	}

	CGoReturnPtr := C.Worksheet_AutoFitRow_Integer_Integer_Integer_AutoFitterOptions( instance.ptr, C.int(rowindex), C.int(firstcolumn), C.int(lastcolumn), options_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Autofits all rows in this worksheet.
// Returns:
//   void  
func (instance *Worksheet) AutoFitRows()  error {
	
	CGoReturnPtr := C.Worksheet_AutoFitRows( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Autofits all rows in this worksheet.
// Parameters:
//   onlyAuto - bool 
// Returns:
//   void  
func (instance *Worksheet) AutoFitRows_Bool(onlyauto bool)  error {
	
	CGoReturnPtr := C.Worksheet_AutoFitRows_Boolean( instance.ptr, C.bool(onlyauto))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Autofits all rows in this worksheet.
// Parameters:
//   options - AutoFitterOptions 
// Returns:
//   void  
func (instance *Worksheet) AutoFitRows_AutoFitterOptions(options *AutoFitterOptions)  error {
	
	var options_ptr unsafe.Pointer = nil
	if options != nil {
	  options_ptr =options.ptr
	}

	CGoReturnPtr := C.Worksheet_AutoFitRows_AutoFitterOptions( instance.ptr, options_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Autofits row height in a range.
// Parameters:
//   startRow - int32 
//   endRow - int32 
// Returns:
//   void  
func (instance *Worksheet) AutoFitRows_Int_Int(startrow int32, endrow int32)  error {
	
	CGoReturnPtr := C.Worksheet_AutoFitRows_Integer_Integer( instance.ptr, C.int(startrow), C.int(endrow))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Autofits row height in a range.
// Parameters:
//   startRow - int32 
//   endRow - int32 
//   options - AutoFitterOptions 
// Returns:
//   void  
func (instance *Worksheet) AutoFitRows_Int_Int_AutoFitterOptions(startrow int32, endrow int32, options *AutoFitterOptions)  error {
	
	var options_ptr unsafe.Pointer = nil
	if options != nil {
	  options_ptr =options.ptr
	}

	CGoReturnPtr := C.Worksheet_AutoFitRows_Integer_Integer_AutoFitterOptions( instance.ptr, C.int(startrow), C.int(endrow), options_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Autofits row height in a rectangle range.
// Parameters:
//   startRow - int32 
//   endRow - int32 
//   startColumn - int32 
//   endColumn - int32 
// Returns:
//   void  
func (instance *Worksheet) AutoFitRow_Int_Int_Int_Int(startrow int32, endrow int32, startcolumn int32, endcolumn int32)  error {
	
	CGoReturnPtr := C.Worksheet_AutoFitRow_Integer_Integer_Integer_Integer( instance.ptr, C.int(startrow), C.int(endrow), C.int(startcolumn), C.int(endcolumn))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Autofits the row height.
// Parameters:
//   rowIndex - int32 
// Returns:
//   void  
func (instance *Worksheet) AutoFitRow_Int(rowindex int32)  error {
	
	CGoReturnPtr := C.Worksheet_AutoFitRow_Integer( instance.ptr, C.int(rowindex))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents the page setup description in this sheet.
// Returns:
//   PageSetup  
func (instance *Worksheet) GetPageSetup()  (*PageSetup,  error)  {
	
	CGoReturnPtr := C.Worksheet_GetPageSetup( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &PageSetup{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeletePageSetup) 

	return result, nil 
}
// Represents auto filter for the specified worksheet.
// Returns:
//   AutoFilter  
func (instance *Worksheet) GetAutoFilter()  (*AutoFilter,  error)  {
	
	CGoReturnPtr := C.Worksheet_GetAutoFilter( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &AutoFilter{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteAutoFilter) 

	return result, nil 
}
// Gets the settings of advanced filter.
// Returns:
//   AdvancedFilter  
func (instance *Worksheet) GetAdvancedFilter()  (*AdvancedFilter,  error)  {
	
	CGoReturnPtr := C.Worksheet_GetAdvancedFilter( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &AdvancedFilter{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteAdvancedFilter) 

	return result, nil 
}
// Filters data using complex criteria.
// Parameters:
//   isFilter - bool 
//   listRange - string 
//   criteriaRange - string 
//   copyTo - string 
//   uniqueRecordOnly - bool 
// Returns:
//   void  
func (instance *Worksheet) Advanced_Filter(isfilter bool, listrange string, criteriarange string, copyto string, uniquerecordonly bool)  error {
	
	CGoReturnPtr := C.Worksheet_Advanced_Filter( instance.ptr, C.bool(isfilter), C.CString(listrange), C.CString(criteriarange), C.CString(copyto), C.bool(uniquerecordonly))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Removes the auto filter of the worksheet.
// Returns:
//   void  
func (instance *Worksheet) RemoveAutoFilter()  error {
	
	CGoReturnPtr := C.Worksheet_RemoveAutoFilter( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether this worksheet has auto filter.
// Returns:
//   bool  
func (instance *Worksheet) GetHasAutofilter()  (bool,  error)  {
	
	CGoReturnPtr := C.Worksheet_GetHasAutofilter( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether the Transition Formula Evaluation (Lotus compatibility) option is enabled.
// Returns:
//   bool  
func (instance *Worksheet) GetTransitionEvaluation()  (bool,  error)  {
	
	CGoReturnPtr := C.Worksheet_GetTransitionEvaluation( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether the Transition Formula Evaluation (Lotus compatibility) option is enabled.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Worksheet) SetTransitionEvaluation(value bool)  error {
	
	CGoReturnPtr := C.Worksheet_SetTransitionEvaluation( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether the Transition Formula Entry (Lotus compatibility) option is enabled.
// Returns:
//   bool  
func (instance *Worksheet) GetTransitionEntry()  (bool,  error)  {
	
	CGoReturnPtr := C.Worksheet_GetTransitionEntry( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether the Transition Formula Entry (Lotus compatibility) option is enabled.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Worksheet) SetTransitionEntry(value bool)  error {
	
	CGoReturnPtr := C.Worksheet_SetTransitionEntry( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates the visible state for this sheet.
// Returns:
//   int32  
func (instance *Worksheet) GetVisibilityType()  (VisibilityType,  error)  {
	
	CGoReturnPtr := C.Worksheet_GetVisibilityType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToVisibilityType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Indicates the visible state for this sheet.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *Worksheet) SetVisibilityType(value VisibilityType)  error {
	
	CGoReturnPtr := C.Worksheet_SetVisibilityType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Sets the visible options.
// Parameters:
//   isVisible - bool 
//   ignoreError - bool 
// Returns:
//   void  
func (instance *Worksheet) SetVisible(isvisible bool, ignoreerror bool)  error {
	
	CGoReturnPtr := C.Worksheet_SetVisible( instance.ptr, C.bool(isvisible), C.bool(ignoreerror))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents if the worksheet is visible.
// Returns:
//   bool  
func (instance *Worksheet) IsVisible()  (bool,  error)  {
	
	CGoReturnPtr := C.Worksheet_IsVisible( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents if the worksheet is visible.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Worksheet) SetIsVisible(value bool)  error {
	
	CGoReturnPtr := C.Worksheet_SetIsVisible( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Selects a range.
// Parameters:
//   startRow - int32 
//   startColumn - int32 
//   totalRows - int32 
//   totalColumns - int32 
//   removeOthers - bool 
// Returns:
//   void  
func (instance *Worksheet) SelectRange(startrow int32, startcolumn int32, totalrows int32, totalcolumns int32, removeothers bool)  error {
	
	CGoReturnPtr := C.Worksheet_SelectRange( instance.ptr, C.int(startrow), C.int(startcolumn), C.int(totalrows), C.int(totalcolumns), C.bool(removeothers))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Removes all drawing objects in this worksheet.
// Returns:
//   void  
func (instance *Worksheet) RemoveAllDrawingObjects()  error {
	
	CGoReturnPtr := C.Worksheet_RemoveAllDrawingObjects( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Clears all comments in designer spreadsheet.
// Returns:
//   void  
func (instance *Worksheet) ClearComments()  error {
	
	CGoReturnPtr := C.Worksheet_ClearComments( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the sparkline groups in the worksheet.
// Returns:
//   SparklineGroupCollection  
func (instance *Worksheet) GetSparklineGroups()  (*SparklineGroupCollection,  error)  {
	
	CGoReturnPtr := C.Worksheet_GetSparklineGroups( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &SparklineGroupCollection{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteSparklineGroupCollection) 

	return result, nil 
}
// Gets a <see cref="Chart"/> collection
// Returns:
//   ChartCollection  
func (instance *Worksheet) GetCharts()  (*ChartCollection,  error)  {
	
	CGoReturnPtr := C.Worksheet_GetCharts( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &ChartCollection{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteChartCollection) 

	return result, nil 
}
// Gets the <see cref="Comment"/> collection.
// Returns:
//   CommentCollection  
func (instance *Worksheet) GetComments()  (*CommentCollection,  error)  {
	
	CGoReturnPtr := C.Worksheet_GetComments( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &CommentCollection{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteCommentCollection) 

	return result, nil 
}
// Gets a <see cref="Picture"/> collection.
// Returns:
//   PictureCollection  
func (instance *Worksheet) GetPictures()  (*PictureCollection,  error)  {
	
	CGoReturnPtr := C.Worksheet_GetPictures( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &PictureCollection{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeletePictureCollection) 

	return result, nil 
}
// Gets a <see cref="TextBox"/> collection.
// Returns:
//   TextBoxCollection  
func (instance *Worksheet) GetTextBoxes()  (*TextBoxCollection,  error)  {
	
	CGoReturnPtr := C.Worksheet_GetTextBoxes( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &TextBoxCollection{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteTextBoxCollection) 

	return result, nil 
}
// Gets a <see cref="CheckBox"/> collection.
// Returns:
//   CheckBoxCollection  
func (instance *Worksheet) GetCheckBoxes()  (*CheckBoxCollection,  error)  {
	
	CGoReturnPtr := C.Worksheet_GetCheckBoxes( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &CheckBoxCollection{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteCheckBoxCollection) 

	return result, nil 
}
// Represents a collection of <see cref="OleObject"/> in a worksheet.
// Returns:
//   OleObjectCollection  
func (instance *Worksheet) GetOleObjects()  (*OleObjectCollection,  error)  {
	
	CGoReturnPtr := C.Worksheet_GetOleObjects( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &OleObjectCollection{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteOleObjectCollection) 

	return result, nil 
}
// Returns all drawing shapes in this worksheet.
// Returns:
//   ShapeCollection  
func (instance *Worksheet) GetShapes()  (*ShapeCollection,  error)  {
	
	CGoReturnPtr := C.Worksheet_GetShapes( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &ShapeCollection{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteShapeCollection) 

	return result, nil 
}
// Get the Slicer collection in the worksheet
// Returns:
//   SlicerCollection  
func (instance *Worksheet) GetSlicers()  (*SlicerCollection,  error)  {
	
	CGoReturnPtr := C.Worksheet_GetSlicers( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &SlicerCollection{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteSlicerCollection) 

	return result, nil 
}
// Get the Timeline collection in the worksheet
// Returns:
//   TimelineCollection  
func (instance *Worksheet) GetTimelines()  (*TimelineCollection,  error)  {
	
	CGoReturnPtr := C.Worksheet_GetTimelines( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &TimelineCollection{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteTimelineCollection) 

	return result, nil 
}
// Protects worksheet.
// Parameters:
//   type - int32 
// Returns:
//   void  
func (instance *Worksheet) Protect_ProtectionType(type_ ProtectionType)  error {
	
	CGoReturnPtr := C.Worksheet_Protect_ProtectionType( instance.ptr, C.int( int32(type_)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Protects worksheet.
// Parameters:
//   type - int32 
//   password - string 
//   oldPassword - string 
// Returns:
//   void  
func (instance *Worksheet) Protect_ProtectionType_String_String(type_ ProtectionType, password string, oldpassword string)  error {
	
	CGoReturnPtr := C.Worksheet_Protect_ProtectionType_String_String( instance.ptr, C.int( int32(type_)), C.CString(password), C.CString(oldpassword))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Unprotects worksheet.
// Returns:
//   void  
func (instance *Worksheet) Unprotect()  error {
	
	CGoReturnPtr := C.Worksheet_Unprotect( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Unprotects worksheet.
// Parameters:
//   password - string 
// Returns:
//   void  
func (instance *Worksheet) Unprotect_String(password string)  error {
	
	CGoReturnPtr := C.Worksheet_Unprotect_String( instance.ptr, C.CString(password))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the index of sheet in the worksheet collection.
// Returns:
//   int32  
func (instance *Worksheet) GetIndex()  (int32,  error)  {
	
	CGoReturnPtr := C.Worksheet_GetIndex( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Moves the sheet to another location in the spreadsheet.
// Parameters:
//   index - int32 
// Returns:
//   void  
func (instance *Worksheet) MoveTo(index int32)  error {
	
	CGoReturnPtr := C.Worksheet_MoveTo( instance.ptr, C.int(index))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates if the worksheet is protected.
// Returns:
//   bool  
func (instance *Worksheet) IsProtected()  (bool,  error)  {
	
	CGoReturnPtr := C.Worksheet_IsProtected( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the data validation setting collection in the worksheet.
// Returns:
//   ValidationCollection  
func (instance *Worksheet) GetValidations()  (*ValidationCollection,  error)  {
	
	CGoReturnPtr := C.Worksheet_GetValidations( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &ValidationCollection{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteValidationCollection) 

	return result, nil 
}
// Gets the allow edit range collection in the worksheet.
// Returns:
//   ProtectedRangeCollection  
func (instance *Worksheet) GetAllowEditRanges()  (*ProtectedRangeCollection,  error)  {
	
	CGoReturnPtr := C.Worksheet_GetAllowEditRanges( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &ProtectedRangeCollection{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteProtectedRangeCollection) 

	return result, nil 
}
// Gets error check setting applied on certain ranges.
// Returns:
//   ErrorCheckOptionCollection  
func (instance *Worksheet) GetErrorCheckOptions()  (*ErrorCheckOptionCollection,  error)  {
	
	CGoReturnPtr := C.Worksheet_GetErrorCheckOptions( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &ErrorCheckOptionCollection{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteErrorCheckOptionCollection) 

	return result, nil 
}
// Gets the outline on this worksheet.
// Returns:
//   Outline  
func (instance *Worksheet) GetOutline()  (*Outline,  error)  {
	
	CGoReturnPtr := C.Worksheet_GetOutline( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Outline{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteOutline) 

	return result, nil 
}
// Represents first visible row index.
// Returns:
//   int32  
func (instance *Worksheet) GetFirstVisibleRow()  (int32,  error)  {
	
	CGoReturnPtr := C.Worksheet_GetFirstVisibleRow( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents first visible row index.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *Worksheet) SetFirstVisibleRow(value int32)  error {
	
	CGoReturnPtr := C.Worksheet_SetFirstVisibleRow( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents first visible column index.
// Returns:
//   int32  
func (instance *Worksheet) GetFirstVisibleColumn()  (int32,  error)  {
	
	CGoReturnPtr := C.Worksheet_GetFirstVisibleColumn( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents first visible column index.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *Worksheet) SetFirstVisibleColumn(value int32)  error {
	
	CGoReturnPtr := C.Worksheet_SetFirstVisibleColumn( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Replaces all cells' text with a new string.
// Parameters:
//   oldString - string 
//   newString - string 
// Returns:
//   int32  
func (instance *Worksheet) Replace(oldstring string, newstring string)  (int32,  error)  {
	
	CGoReturnPtr := C.Worksheet_Replace( instance.ptr, C.CString(oldstring), C.CString(newstring))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents the scaling factor in percentage. It should be between 10 and 400.
// Returns:
//   int32  
func (instance *Worksheet) GetZoom()  (int32,  error)  {
	
	CGoReturnPtr := C.Worksheet_GetZoom( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents the scaling factor in percentage. It should be between 10 and 400.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *Worksheet) SetZoom(value int32)  error {
	
	CGoReturnPtr := C.Worksheet_SetZoom( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the view type.
// Returns:
//   int32  
func (instance *Worksheet) GetViewType()  (ViewType,  error)  {
	
	CGoReturnPtr := C.Worksheet_GetViewType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToViewType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets and sets the view type.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *Worksheet) SetViewType(value ViewType)  error {
	
	CGoReturnPtr := C.Worksheet_SetViewType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether the specified worksheet is shown in normal view or page break preview.
// Returns:
//   bool  
func (instance *Worksheet) IsPageBreakPreview()  (bool,  error)  {
	
	CGoReturnPtr := C.Worksheet_IsPageBreakPreview( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether the specified worksheet is shown in normal view or page break preview.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Worksheet) SetIsPageBreakPreview(value bool)  error {
	
	CGoReturnPtr := C.Worksheet_SetIsPageBreakPreview( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether the ruler is visible. This property is only applied for page break preview.
// Returns:
//   bool  
func (instance *Worksheet) IsRulerVisible()  (bool,  error)  {
	
	CGoReturnPtr := C.Worksheet_IsRulerVisible( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether the ruler is visible. This property is only applied for page break preview.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *Worksheet) SetIsRulerVisible(value bool)  error {
	
	CGoReturnPtr := C.Worksheet_SetIsRulerVisible( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets selected ranges of cells in the designer spreadsheet.
// Returns:
//   []Range  
func (instance *Worksheet) GetSelectedAreas()  ([]Range,  error)  {
	
	CGoReturnPtr := C.Worksheet_GetSelectedAreas( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result:= make([]Range, CGoReturnPtr.column_length)
	for i := 0; i < int(CGoReturnPtr.column_length); i++ {
	   offset := uintptr(C.size_t(i)) * uintptr(CGoReturnPtr.size)
	   goObject := &Range{}
	   goObject.ptr =unsafe.Pointer(uintptr( unsafe.Pointer(CGoReturnPtr.return_value)) + offset)
	   result[i] = *goObject
	}
	 

	return result, nil 
}
// Represents worksheet tab color.
// Returns:
//   Color  
func (instance *Worksheet) GetTabColor()  (*Color,  error)  {
	
	CGoReturnPtr := C.Worksheet_GetTabColor( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Represents worksheet tab color.
// Parameters:
//   value - Color 
// Returns:
//   void  
func (instance *Worksheet) SetTabColor(value *Color)  error {
	
	CGoReturnPtr := C.Worksheet_SetTabColor( instance.ptr, value.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the color of gridline
// Returns:
//   Color  
func (instance *Worksheet) GetGridlineColor()  (*Color,  error)  {
	
	CGoReturnPtr := C.Worksheet_GetGridlineColor( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Gets and sets the color of gridline
// Parameters:
//   value - Color 
// Returns:
//   void  
func (instance *Worksheet) SetGridlineColor(value *Color)  error {
	
	CGoReturnPtr := C.Worksheet_SetGridlineColor( instance.ptr, value.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets worksheet code name.
// Returns:
//   string  
func (instance *Worksheet) GetCodeName()  (string,  error)  {
	
	CGoReturnPtr := C.Worksheet_GetCodeName( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets worksheet code name.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *Worksheet) SetCodeName(value string)  error {
	
	CGoReturnPtr := C.Worksheet_SetCodeName( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets worksheet background image.
// Returns:
//   []byte  
func (instance *Worksheet) GetBackgroundImage()  ([]byte,  error)  {
	
	CGoReturnPtr := C.Worksheet_GetBackgroundImage( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := C.GoBytes(unsafe.Pointer(CGoReturnPtr.return_value), C.int(CGoReturnPtr.column_length))
	 

	return result, nil 
}
// Gets and sets worksheet background image.
// Parameters:
//   value - []byte 
// Returns:
//   void  
func (instance *Worksheet) SetBackgroundImage(value []byte)  error {
	
	CGoReturnPtr := C.Worksheet_SetBackgroundImage( instance.ptr, unsafe.Pointer(&value[0]), C.int( len(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the ConditionalFormattings in the worksheet.
// Returns:
//   ConditionalFormattingCollection  
func (instance *Worksheet) GetConditionalFormattings()  (*ConditionalFormattingCollection,  error)  {
	
	CGoReturnPtr := C.Worksheet_GetConditionalFormattings( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &ConditionalFormattingCollection{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteConditionalFormattingCollection) 

	return result, nil 
}
// Gets or sets the active cell in the worksheet.
// Returns:
//   string  
func (instance *Worksheet) GetActiveCell()  (string,  error)  {
	
	CGoReturnPtr := C.Worksheet_GetActiveCell( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets the active cell in the worksheet.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *Worksheet) SetActiveCell(value string)  error {
	
	CGoReturnPtr := C.Worksheet_SetActiveCell( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets an object representing
// the identifier information associated with a worksheet.
// Returns:
//   CustomPropertyCollection  
func (instance *Worksheet) GetCustomProperties()  (*CustomPropertyCollection,  error)  {
	
	CGoReturnPtr := C.Worksheet_GetCustomProperties( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &CustomPropertyCollection{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteCustomPropertyCollection) 

	return result, nil 
}
// Gets automatic page breaks.
// Parameters:
//   options - ImageOrPrintOptions 
// Returns:
//   []CellArea  
func (instance *Worksheet) GetPrintingPageBreaks(options *ImageOrPrintOptions)  ([]CellArea,  error)  {
	
	var options_ptr unsafe.Pointer = nil
	if options != nil {
	  options_ptr =options.ptr
	}

	CGoReturnPtr := C.Worksheet_GetPrintingPageBreaks( instance.ptr, options_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result:= make([]CellArea, CGoReturnPtr.column_length)
	for i := 0; i < int(CGoReturnPtr.column_length); i++ {
	   offset := uintptr(C.size_t(i)) * uintptr(CGoReturnPtr.size)
	   goObject := &CellArea{}
	   goObject.ptr =unsafe.Pointer(uintptr( unsafe.Pointer(CGoReturnPtr.return_value)) + offset)
	   result[i] = *goObject
	}
	 

	return result, nil 
}
// Gets all <see cref="SmartTagCollection"/> objects of the worksheet.
// Returns:
//   SmartTagSetting  
func (instance *Worksheet) GetSmartTagSetting()  (*SmartTagSetting,  error)  {
	
	CGoReturnPtr := C.Worksheet_GetSmartTagSetting( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &SmartTagSetting{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteSmartTagSetting) 

	return result, nil 
}
// Returns a string represents the current Worksheet object.
// Returns:
//   string  
func (instance *Worksheet) ToString()  (string,  error)  {
	
	CGoReturnPtr := C.Worksheet_ToString( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the collection of <see cref="Scenario"/>.
// Returns:
//   ScenarioCollection  
func (instance *Worksheet) GetScenarios()  (*ScenarioCollection,  error)  {
	
	CGoReturnPtr := C.Worksheet_GetScenarios( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &ScenarioCollection{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteScenarioCollection) 

	return result, nil 
}
// Starts the session that uses caches to access the data in this worksheet.
// Parameters:
//   opts - int32 
// Returns:
//   void  
func (instance *Worksheet) StartAccessCache(opts AccessCacheOptions)  error {
	
	CGoReturnPtr := C.Worksheet_StartAccessCache( instance.ptr, C.int( int32(opts)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Closes the session that uses caches to access the data in this worksheet.
// Parameters:
//   opts - int32 
// Returns:
//   void  
func (instance *Worksheet) CloseAccessCache(opts AccessCacheOptions)  error {
	
	CGoReturnPtr := C.Worksheet_CloseAccessCache( instance.ptr, C.int( int32(opts)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Converts the formula reference style.
// Parameters:
//   formula - string 
//   toR1C1 - bool 
//   baseCellRow - int32 
//   baseCellColumn - int32 
// Returns:
//   string  
func (instance *Worksheet) ConvertFormulaReferenceStyle(formula string, tor1c1 bool, basecellrow int32, basecellcolumn int32)  (string,  error)  {
	
	CGoReturnPtr := C.Worksheet_ConvertFormulaReferenceStyle( instance.ptr, C.CString(formula), C.bool(tor1c1), C.int(basecellrow), C.int(basecellcolumn))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Calculates a formula.
// Parameters:
//   formula - string 
// Returns:
//   Object  
func (instance *Worksheet) CalculateFormula_String(formula string)  (*Object,  error)  {
	
	CGoReturnPtr := C.Worksheet_CalculateFormula_String( instance.ptr, C.CString(formula))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Object{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteObject) 

	return result, nil 
}
// Calculates a formula expression directly.
// Parameters:
//   formula - string 
//   opts - CalculationOptions 
// Returns:
//   Object  
func (instance *Worksheet) CalculateFormula_String_CalculationOptions(formula string, opts *CalculationOptions)  (*Object,  error)  {
	
	var opts_ptr unsafe.Pointer = nil
	if opts != nil {
	  opts_ptr =opts.ptr
	}

	CGoReturnPtr := C.Worksheet_CalculateFormula_String_CalculationOptions( instance.ptr, C.CString(formula), opts_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Object{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteObject) 

	return result, nil 
}
// Calculates a formula expression directly.
// Parameters:
//   formula - string 
//   pOpts - FormulaParseOptions 
//   cOpts - CalculationOptions 
//   baseCellRow - int32 
//   baseCellColumn - int32 
//   calculationData - CalculationData 
// Returns:
//   Object  
func (instance *Worksheet) CalculateFormula_String_FormulaParseOptions_CalculationOptions_Int_Int_CalculationData(formula string, popts *FormulaParseOptions, copts *CalculationOptions, basecellrow int32, basecellcolumn int32, calculationdata *CalculationData)  (*Object,  error)  {
	
	var popts_ptr unsafe.Pointer = nil
	if popts != nil {
	  popts_ptr =popts.ptr
	}
	var copts_ptr unsafe.Pointer = nil
	if copts != nil {
	  copts_ptr =copts.ptr
	}
	var calculationdata_ptr unsafe.Pointer = nil
	if calculationdata != nil {
	  calculationdata_ptr =calculationdata.ptr
	}

	CGoReturnPtr := C.Worksheet_CalculateFormula_String_FormulaParseOptions_CalculationOptions_Integer_Integer_CalculationData( instance.ptr, C.CString(formula), popts_ptr, copts_ptr, C.int(basecellrow), C.int(basecellcolumn), calculationdata_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Object{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteObject) 

	return result, nil 
}
// Calculates a formula as array formula.
// Parameters:
//   formula - string 
//   opts - CalculationOptions 
// Returns:
//   []Vector<Object>  
func (instance *Worksheet) CalculateArrayFormula_String_CalculationOptions(formula string, opts *CalculationOptions)  ([][]Object,  error)  {
	
	var opts_ptr unsafe.Pointer = nil
	if opts != nil {
	  opts_ptr =opts.ptr
	}

	CGoReturnPtr := C.Worksheet_CalculateArrayFormula_String_CalculationOptions( instance.ptr, C.CString(formula), opts_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result:= make([][]Object, CGoReturnPtr.row_length)
	for i := 0; i < int(CGoReturnPtr.row_length); i++ {
	result[i] = make([]Object, int(CGoReturnPtr.column_length))
	}
	for i := 0; i < int(CGoReturnPtr.row_length); i++ {
	for j := 0; j < int(CGoReturnPtr.column_length); j++ {
	   offset := uintptr(C.size_t(i) * C.size_t(int(CGoReturnPtr.column_length))  +  C.size_t(j)  ) * uintptr(CGoReturnPtr.size) 
	   goObject := &Object{}
	   goObject.ptr =unsafe.Pointer(uintptr( unsafe.Pointer(CGoReturnPtr.return_value)) + offset)
	   result[i][j] = *goObject
	}
	}
	 

	return result, nil 
}
// Calculates a formula as array formula.
// Parameters:
//   formula - string 
//   opts - CalculationOptions 
//   maxRowCount - int32 
//   maxColumnCount - int32 
// Returns:
//   []Vector<Object>  
func (instance *Worksheet) CalculateArrayFormula_String_CalculationOptions_Int_Int(formula string, opts *CalculationOptions, maxrowcount int32, maxcolumncount int32)  ([][]Object,  error)  {
	
	var opts_ptr unsafe.Pointer = nil
	if opts != nil {
	  opts_ptr =opts.ptr
	}

	CGoReturnPtr := C.Worksheet_CalculateArrayFormula_String_CalculationOptions_Integer_Integer( instance.ptr, C.CString(formula), opts_ptr, C.int(maxrowcount), C.int(maxcolumncount))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result:= make([][]Object, CGoReturnPtr.row_length)
	for i := 0; i < int(CGoReturnPtr.row_length); i++ {
	result[i] = make([]Object, int(CGoReturnPtr.column_length))
	}
	for i := 0; i < int(CGoReturnPtr.row_length); i++ {
	for j := 0; j < int(CGoReturnPtr.column_length); j++ {
	   offset := uintptr(C.size_t(i) * C.size_t(int(CGoReturnPtr.column_length))  +  C.size_t(j)  ) * uintptr(CGoReturnPtr.size) 
	   goObject := &Object{}
	   goObject.ptr =unsafe.Pointer(uintptr( unsafe.Pointer(CGoReturnPtr.return_value)) + offset)
	   result[i][j] = *goObject
	}
	}
	 

	return result, nil 
}
// Calculates a formula as array formula.
// Parameters:
//   formula - string 
//   pOpts - FormulaParseOptions 
//   cOpts - CalculationOptions 
//   baseCellRow - int32 
//   baseCellColumn - int32 
//   maxRowCount - int32 
//   maxColumnCount - int32 
//   calculationData - CalculationData 
// Returns:
//   []Vector<Object>  
func (instance *Worksheet) CalculateArrayFormula_String_FormulaParseOptions_CalculationOptions_Int_Int_Int_Int_CalculationData(formula string, popts *FormulaParseOptions, copts *CalculationOptions, basecellrow int32, basecellcolumn int32, maxrowcount int32, maxcolumncount int32, calculationdata *CalculationData)  ([][]Object,  error)  {
	
	var popts_ptr unsafe.Pointer = nil
	if popts != nil {
	  popts_ptr =popts.ptr
	}
	var copts_ptr unsafe.Pointer = nil
	if copts != nil {
	  copts_ptr =copts.ptr
	}
	var calculationdata_ptr unsafe.Pointer = nil
	if calculationdata != nil {
	  calculationdata_ptr =calculationdata.ptr
	}

	CGoReturnPtr := C.Worksheet_CalculateArrayFormula_String_FormulaParseOptions_CalculationOptions_Integer_Integer_Integer_Integer_CalculationData( instance.ptr, C.CString(formula), popts_ptr, copts_ptr, C.int(basecellrow), C.int(basecellcolumn), C.int(maxrowcount), C.int(maxcolumncount), calculationdata_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result:= make([][]Object, CGoReturnPtr.row_length)
	for i := 0; i < int(CGoReturnPtr.row_length); i++ {
	result[i] = make([]Object, int(CGoReturnPtr.column_length))
	}
	for i := 0; i < int(CGoReturnPtr.row_length); i++ {
	for j := 0; j < int(CGoReturnPtr.column_length); j++ {
	   offset := uintptr(C.size_t(i) * C.size_t(int(CGoReturnPtr.column_length))  +  C.size_t(j)  ) * uintptr(CGoReturnPtr.size) 
	   goObject := &Object{}
	   goObject.ptr =unsafe.Pointer(uintptr( unsafe.Pointer(CGoReturnPtr.return_value)) + offset)
	   result[i][j] = *goObject
	}
	}
	 

	return result, nil 
}
// Calculates all formulas in this worksheet.
// Parameters:
//   options - CalculationOptions 
//   recursive - bool 
// Returns:
//   void  
func (instance *Worksheet) CalculateFormula_CalculationOptions_Bool(options *CalculationOptions, recursive bool)  error {
	
	var options_ptr unsafe.Pointer = nil
	if options != nil {
	  options_ptr =options.ptr
	}

	CGoReturnPtr := C.Worksheet_CalculateFormula_CalculationOptions_Boolean( instance.ptr, options_ptr, C.bool(recursive))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets collection of cells on this worksheet being watched in the 'watch window'.
// Returns:
//   CellWatchCollection  
func (instance *Worksheet) GetCellWatches()  (*CellWatchCollection,  error)  {
	
	CGoReturnPtr := C.Worksheet_GetCellWatches( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &CellWatchCollection{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteCellWatchCollection) 

	return result, nil 
}
// Refreshes all the PivotTables in this Worksheet.
// Returns:
//   void  
func (instance *Worksheet) RefreshPivotTables()  error {
	
	CGoReturnPtr := C.Worksheet_RefreshPivotTables( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Refreshes all the PivotTables in this Worksheet.
// Parameters:
//   option - PivotTableRefreshOption 
// Returns:
//   bool  
func (instance *Worksheet) RefreshPivotTables_PivotTableRefreshOption(option *PivotTableRefreshOption)  (bool,  error)  {
	
	var option_ptr unsafe.Pointer = nil
	if option != nil {
	  option_ptr =option.ptr
	}

	CGoReturnPtr := C.Worksheet_RefreshPivotTables_PivotTableRefreshOption( instance.ptr, option_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}



func DeleteWorksheet(worksheet *Worksheet){
	runtime.SetFinalizer(worksheet, nil)
	C.Delete_Worksheet(worksheet.ptr)
	worksheet.ptr = nil
}

// Class WorksheetCollection 

// Encapsulates a collection of <see cref="Worksheet"/> objects.
type WorksheetCollection struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *WorksheetCollection) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.WorksheetCollection_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the list of task panes.
// Returns:
//   WebExtensionTaskPaneCollection  
func (instance *WorksheetCollection) GetWebExtensionTaskPanes()  (*WebExtensionTaskPaneCollection,  error)  {
	
	CGoReturnPtr := C.WorksheetCollection_GetWebExtensionTaskPanes( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &WebExtensionTaskPaneCollection{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteWebExtensionTaskPaneCollection) 

	return result, nil 
}
// Gets the list of task panes.
// Returns:
//   WebExtensionCollection  
func (instance *WorksheetCollection) GetWebExtensions()  (*WebExtensionCollection,  error)  {
	
	CGoReturnPtr := C.WorksheetCollection_GetWebExtensions( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &WebExtensionCollection{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteWebExtensionCollection) 

	return result, nil 
}
// Gets the list of threaded comment authors.
// Returns:
//   ThreadedCommentAuthorCollection  
func (instance *WorksheetCollection) GetThreadedCommentAuthors()  (*ThreadedCommentAuthorCollection,  error)  {
	
	CGoReturnPtr := C.WorksheetCollection_GetThreadedCommentAuthors( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &ThreadedCommentAuthorCollection{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteThreadedCommentAuthorCollection) 

	return result, nil 
}
// Indicates whether refresh all connections on opening file in MS Excel.
// Returns:
//   bool  
func (instance *WorksheetCollection) IsRefreshAllConnections()  (bool,  error)  {
	
	CGoReturnPtr := C.WorksheetCollection_IsRefreshAllConnections( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether refresh all connections on opening file in MS Excel.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *WorksheetCollection) SetIsRefreshAllConnections(value bool)  error {
	
	CGoReturnPtr := C.WorksheetCollection_SetIsRefreshAllConnections( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Creates a <see cref="Range"/> object from an address of the range.
// Parameters:
//   address - string 
//   sheetIndex - int32 
// Returns:
//   Range  
func (instance *WorksheetCollection) CreateRange(address string, sheetindex int32)  (*Range,  error)  {
	
	CGoReturnPtr := C.WorksheetCollection_CreateRange( instance.ptr, C.CString(address), C.int(sheetindex))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Range{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteRange) 

	return result, nil 
}
// Creates a <see cref="Range"/> object from an address of the range.
// Parameters:
//   address - string 
//   sheetIndex - int32 
// Returns:
//   UnionRange  
func (instance *WorksheetCollection) CreateUnionRange(address string, sheetindex int32)  (*UnionRange,  error)  {
	
	CGoReturnPtr := C.WorksheetCollection_CreateUnionRange( instance.ptr, C.CString(address), C.int(sheetindex))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &UnionRange{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteUnionRange) 

	return result, nil 
}
// Gets the collection of all the Name objects in the spreadsheet.
// Returns:
//   NameCollection  
func (instance *WorksheetCollection) GetNames()  (*NameCollection,  error)  {
	
	CGoReturnPtr := C.WorksheetCollection_GetNames( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &NameCollection{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteNameCollection) 

	return result, nil 
}
// Gets the <see cref="Worksheet"/> element at the specified index.
// Parameters:
//   index - int32 
// Returns:
//   Worksheet  
func (instance *WorksheetCollection) Get_Int(index int32)  (*Worksheet,  error)  {
	
	CGoReturnPtr := C.WorksheetCollection_Get_Integer( instance.ptr, C.int(index))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Worksheet{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteWorksheet) 

	return result, nil 
}
// Gets the <see cref="Worksheet"/> element with the specified name.
// Parameters:
//   sheetName - string 
// Returns:
//   Worksheet  
func (instance *WorksheetCollection) Get_String(sheetname string)  (*Worksheet,  error)  {
	
	CGoReturnPtr := C.WorksheetCollection_Get_String( instance.ptr, C.CString(sheetname))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Worksheet{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteWorksheet) 

	return result, nil 
}
// Gets the worksheet by the code name.
// Parameters:
//   codeName - string 
// Returns:
//   Worksheet  
func (instance *WorksheetCollection) GetSheetByCodeName(codename string)  (*Worksheet,  error)  {
	
	CGoReturnPtr := C.WorksheetCollection_GetSheetByCodeName( instance.ptr, C.CString(codename))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Worksheet{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteWorksheet) 

	return result, nil 
}
// Represents the name of active worksheet when the spreadsheet is opened.
// Returns:
//   string  
func (instance *WorksheetCollection) GetActiveSheetName()  (string,  error)  {
	
	CGoReturnPtr := C.WorksheetCollection_GetActiveSheetName( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents the name of active worksheet when the spreadsheet is opened.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *WorksheetCollection) SetActiveSheetName(value string)  error {
	
	CGoReturnPtr := C.WorksheetCollection_SetActiveSheetName( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents the index of active worksheet when the spreadsheet is opened.
// Returns:
//   int32  
func (instance *WorksheetCollection) GetActiveSheetIndex()  (int32,  error)  {
	
	CGoReturnPtr := C.WorksheetCollection_GetActiveSheetIndex( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents the index of active worksheet when the spreadsheet is opened.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *WorksheetCollection) SetActiveSheetIndex(value int32)  error {
	
	CGoReturnPtr := C.WorksheetCollection_SetActiveSheetIndex( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Sorts the defined names.
// Returns:
//   void  
func (instance *WorksheetCollection) SortNames()  error {
	
	CGoReturnPtr := C.WorksheetCollection_SortNames( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Insert a worksheet.
// Parameters:
//   index - int32 
//   sheetType - int32 
// Returns:
//   Worksheet  
func (instance *WorksheetCollection) Insert_Int_SheetType(index int32, sheettype SheetType)  (*Worksheet,  error)  {
	
	CGoReturnPtr := C.WorksheetCollection_Insert_Integer_SheetType( instance.ptr, C.int(index), C.int( int32(sheettype)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Worksheet{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteWorksheet) 

	return result, nil 
}
// Insert a worksheet.
// Parameters:
//   index - int32 
//   sheetType - int32 
//   sheetName - string 
// Returns:
//   Worksheet  
func (instance *WorksheetCollection) Insert_Int_SheetType_String(index int32, sheettype SheetType, sheetname string)  (*Worksheet,  error)  {
	
	CGoReturnPtr := C.WorksheetCollection_Insert_Integer_SheetType_String( instance.ptr, C.int(index), C.int( int32(sheettype)), C.CString(sheetname))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Worksheet{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteWorksheet) 

	return result, nil 
}
// Adds a worksheet to the collection.
// Parameters:
//   type - int32 
// Returns:
//   int32  
func (instance *WorksheetCollection) Add_SheetType(type_ SheetType)  (int32,  error)  {
	
	CGoReturnPtr := C.WorksheetCollection_Add_SheetType( instance.ptr, C.int( int32(type_)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Swaps the two sheets.
// Parameters:
//   sheetIndex1 - int32 
//   sheetIndex2 - int32 
// Returns:
//   void  
func (instance *WorksheetCollection) SwapSheet(sheetindex1 int32, sheetindex2 int32)  error {
	
	CGoReturnPtr := C.WorksheetCollection_SwapSheet( instance.ptr, C.int(sheetindex1), C.int(sheetindex2))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Adds a worksheet to the collection.
// Returns:
//   int32  
func (instance *WorksheetCollection) Add()  (int32,  error)  {
	
	CGoReturnPtr := C.WorksheetCollection_Add( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Adds a worksheet to the collection.
// Parameters:
//   sheetName - string 
// Returns:
//   Worksheet  
func (instance *WorksheetCollection) Add_String(sheetname string)  (*Worksheet,  error)  {
	
	CGoReturnPtr := C.WorksheetCollection_Add_String( instance.ptr, C.CString(sheetname))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Worksheet{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteWorksheet) 

	return result, nil 
}
// Adds addin function into the workbook
// Parameters:
//   addInFile - string 
//   functionName - string 
//   lib - bool 
// Returns:
//   int32  
func (instance *WorksheetCollection) RegisterAddInFunction_String_String_Bool(addinfile string, functionname string, lib bool)  (int32,  error)  {
	
	CGoReturnPtr := C.WorksheetCollection_RegisterAddInFunction_String_String_Boolean( instance.ptr, C.CString(addinfile), C.CString(functionname), C.bool(lib))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Adds addin function into the workbook
// Parameters:
//   id - int32 
//   functionName - string 
// Returns:
//   string  
func (instance *WorksheetCollection) RegisterAddInFunction_Int_String(id int32, functionname string)  (string,  error)  {
	
	CGoReturnPtr := C.WorksheetCollection_RegisterAddInFunction_Integer_String( instance.ptr, C.int(id), C.CString(functionname))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Removes the element at a specified name.
// Parameters:
//   name - string 
// Returns:
//   void  
func (instance *WorksheetCollection) RemoveAt_String(name string)  error {
	
	CGoReturnPtr := C.WorksheetCollection_RemoveAt_String( instance.ptr, C.CString(name))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Removes the element at a specified index.
// Parameters:
//   index - int32 
// Returns:
//   void  
func (instance *WorksheetCollection) RemoveAt_Int(index int32)  error {
	
	CGoReturnPtr := C.WorksheetCollection_RemoveAt_Integer( instance.ptr, C.int(index))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Clear all worksheets.
// Returns:
//   void  
func (instance *WorksheetCollection) Clear()  error {
	
	CGoReturnPtr := C.WorksheetCollection_Clear( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Adds a worksheet to the collection and copies data from an existed worksheet.
// Parameters:
//   sheetName - string 
// Returns:
//   int32  
func (instance *WorksheetCollection) AddCopy_String(sheetname string)  (int32,  error)  {
	
	CGoReturnPtr := C.WorksheetCollection_AddCopy_String( instance.ptr, C.CString(sheetname))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Adds a worksheet to the collection and copies data from an existed worksheet.
// Parameters:
//   sheetIndex - int32 
// Returns:
//   int32  
func (instance *WorksheetCollection) AddCopy_Int(sheetindex int32)  (int32,  error)  {
	
	CGoReturnPtr := C.WorksheetCollection_AddCopy_Integer( instance.ptr, C.int(sheetindex))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Copy a group of worksheets.
// Parameters:
//   source - []Worksheet 
//   destSheetNames - []string 
// Returns:
//   void  
func (instance *WorksheetCollection) AddCopy_WorksheetArray_stringArray(source []Worksheet, destsheetnames []string)  error {
	
	source_length := len(source)
	vector_source:= make([]unsafe.Pointer, source_length)
	for i := 0; i < source_length; i++ {
		vector_source[i] = source[i].ptr
	}

	vector_destsheetnames := make([]*C.char, len(destsheetnames))
	for i, str := range destsheetnames {
	cStr := C.CString(str)
	defer C.free(unsafe.Pointer(cStr))
	vector_destsheetnames[i] = cStr
	}

	CGoReturnPtr := C.WorksheetCollection_AddCopy_WorksheetArray_U16StringArray( instance.ptr, unsafe.Pointer(&vector_source[0]), C.int( len(source)), unsafe.Pointer(&vector_destsheetnames[0]), C.int( len(destsheetnames)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the master differential formatting records.
// Returns:
//   DxfCollection  
func (instance *WorksheetCollection) GetDxfs()  (*DxfCollection,  error)  {
	
	CGoReturnPtr := C.WorksheetCollection_GetDxfs( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &DxfCollection{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteDxfCollection) 

	return result, nil 
}
// Gets Range object by pre-defined name.
// Parameters:
//   rangeName - string 
// Returns:
//   Range  
func (instance *WorksheetCollection) GetRangeByName_String(rangename string)  (*Range,  error)  {
	
	CGoReturnPtr := C.WorksheetCollection_GetRangeByName_String( instance.ptr, C.CString(rangename))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Range{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteRange) 

	return result, nil 
}
// Gets <see cref="Range"/> by pre-defined name or table's name
// Parameters:
//   rangeName - string 
//   currentSheetIndex - int32 
//   includeTable - bool 
// Returns:
//   Range  
func (instance *WorksheetCollection) GetRangeByName_String_Int_Bool(rangename string, currentsheetindex int32, includetable bool)  (*Range,  error)  {
	
	CGoReturnPtr := C.WorksheetCollection_GetRangeByName_String_Integer_Boolean( instance.ptr, C.CString(rangename), C.int(currentsheetindex), C.bool(includetable))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Range{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteRange) 

	return result, nil 
}
// Gets all pre-defined named ranges in the spreadsheet.
// Returns:
//   []Range  
func (instance *WorksheetCollection) GetNamedRanges()  ([]Range,  error)  {
	
	CGoReturnPtr := C.WorksheetCollection_GetNamedRanges( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result:= make([]Range, CGoReturnPtr.column_length)
	for i := 0; i < int(CGoReturnPtr.column_length); i++ {
	   offset := uintptr(C.size_t(i)) * uintptr(CGoReturnPtr.size)
	   goObject := &Range{}
	   goObject.ptr =unsafe.Pointer(uintptr( unsafe.Pointer(CGoReturnPtr.return_value)) + offset)
	   result[i] = *goObject
	}
	 

	return result, nil 
}
// Gets all pre-defined named ranges in the spreadsheet.
// Returns:
//   []Range  
func (instance *WorksheetCollection) GetNamedRangesAndTables()  ([]Range,  error)  {
	
	CGoReturnPtr := C.WorksheetCollection_GetNamedRangesAndTables( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result:= make([]Range, CGoReturnPtr.column_length)
	for i := 0; i < int(CGoReturnPtr.column_length); i++ {
	   offset := uintptr(C.size_t(i)) * uintptr(CGoReturnPtr.size)
	   goObject := &Range{}
	   goObject.ptr =unsafe.Pointer(uintptr( unsafe.Pointer(CGoReturnPtr.return_value)) + offset)
	   result[i] = *goObject
	}
	 

	return result, nil 
}
// Gets and sets the XML maps in the workbook.
// Returns:
//   XmlMapCollection  
func (instance *WorksheetCollection) GetXmlMaps()  (*XmlMapCollection,  error)  {
	
	CGoReturnPtr := C.WorksheetCollection_GetXmlMaps( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &XmlMapCollection{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteXmlMapCollection) 

	return result, nil 
}
// Gets and sets the XML maps in the workbook.
// Parameters:
//   value - XmlMapCollection 
// Returns:
//   void  
func (instance *WorksheetCollection) SetXmlMaps(value *XmlMapCollection)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.WorksheetCollection_SetXmlMaps( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Returns a <see cref="DocumentProperty"/> collection that represents all the built-in document properties of the spreadsheet.
// Returns:
//   BuiltInDocumentPropertyCollection  
func (instance *WorksheetCollection) GetBuiltInDocumentProperties()  (*BuiltInDocumentPropertyCollection,  error)  {
	
	CGoReturnPtr := C.WorksheetCollection_GetBuiltInDocumentProperties( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &BuiltInDocumentPropertyCollection{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteBuiltInDocumentPropertyCollection) 

	return result, nil 
}
// Returns a <see cref="DocumentProperty"/> collection that represents all the custom document properties of the spreadsheet.
// Returns:
//   CustomDocumentPropertyCollection  
func (instance *WorksheetCollection) GetCustomDocumentProperties()  (*CustomDocumentPropertyCollection,  error)  {
	
	CGoReturnPtr := C.WorksheetCollection_GetCustomDocumentProperties( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &CustomDocumentPropertyCollection{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteCustomDocumentPropertyCollection) 

	return result, nil 
}
// Gets and Sets displayed size when Workbook file is used as an Ole object.
// Returns:
//   Object  
func (instance *WorksheetCollection) GetOleSize()  (*Object,  error)  {
	
	CGoReturnPtr := C.WorksheetCollection_GetOleSize( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Object{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteObject) 

	return result, nil 
}
// Gets and Sets displayed size when Workbook file is used as an Ole object.
// Parameters:
//   value - Object 
// Returns:
//   void  
func (instance *WorksheetCollection) SetOleSize_Object(value *Object)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.WorksheetCollection_SetOleSize_Object( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Sets displayed size when Workbook file is used as an Ole object.
// Parameters:
//   startRow - int32 
//   endRow - int32 
//   startColumn - int32 
//   endColumn - int32 
// Returns:
//   void  
func (instance *WorksheetCollection) SetOleSize_Int_Int_Int_Int(startrow int32, endrow int32, startcolumn int32, endcolumn int32)  error {
	
	CGoReturnPtr := C.WorksheetCollection_SetOleSize_Integer_Integer_Integer_Integer( instance.ptr, C.int(startrow), C.int(endrow), C.int(startcolumn), C.int(endcolumn))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents external links in a workbook.
// Returns:
//   ExternalLinkCollection  
func (instance *WorksheetCollection) GetExternalLinks()  (*ExternalLinkCollection,  error)  {
	
	CGoReturnPtr := C.WorksheetCollection_GetExternalLinks( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &ExternalLinkCollection{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteExternalLinkCollection) 

	return result, nil 
}
// Gets <see cref="TableStyles"/> object.
// Returns:
//   TableStyleCollection  
func (instance *WorksheetCollection) GetTableStyles()  (*TableStyleCollection,  error)  {
	
	CGoReturnPtr := C.WorksheetCollection_GetTableStyles( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &TableStyleCollection{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteTableStyleCollection) 

	return result, nil 
}
// Clears pivot tables from the spreadsheet.
// Returns:
//   void  
func (instance *WorksheetCollection) ClearPivottables()  error {
	
	CGoReturnPtr := C.WorksheetCollection_ClearPivottables( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Represents revision logs.
// Returns:
//   RevisionLogCollection  
func (instance *WorksheetCollection) GetRevisionLogs()  (*RevisionLogCollection,  error)  {
	
	CGoReturnPtr := C.WorksheetCollection_GetRevisionLogs( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &RevisionLogCollection{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteRevisionLogCollection) 

	return result, nil 
}
// Refresh all pivot tables and charts with pivot source.
// Returns:
//   void  
func (instance *WorksheetCollection) RefreshAll()  error {
	
	CGoReturnPtr := C.WorksheetCollection_RefreshAll( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Refreshes all the PivotTables in the Excel file.
// Returns:
//   void  
func (instance *WorksheetCollection) RefreshPivotTables()  error {
	
	CGoReturnPtr := C.WorksheetCollection_RefreshPivotTables( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Refreshes all the PivotTables in the Excel file.
// Parameters:
//   option - PivotTableRefreshOption 
// Returns:
//   bool  
func (instance *WorksheetCollection) RefreshPivotTables_PivotTableRefreshOption(option *PivotTableRefreshOption)  (bool,  error)  {
	
	var option_ptr unsafe.Pointer = nil
	if option != nil {
	  option_ptr =option.ptr
	}

	CGoReturnPtr := C.WorksheetCollection_RefreshPivotTables_PivotTableRefreshOption( instance.ptr, option_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents all sensitivity labels.
// Returns:
//   SensitivityLabelCollection  
func (instance *WorksheetCollection) GetSensitivityLabels()  (*SensitivityLabelCollection,  error)  {
	
	CGoReturnPtr := C.WorksheetCollection_GetSensitivityLabels( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &SensitivityLabelCollection{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteSensitivityLabelCollection) 

	return result, nil 
}
// Returns:
//   int32  
func (instance *WorksheetCollection) GetCount()  (int32,  error)  {
	
	CGoReturnPtr := C.WorksheetCollection_GetCount( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}



func DeleteWorksheetCollection(worksheetcollection *WorksheetCollection){
	runtime.SetFinalizer(worksheetcollection, nil)
	C.Delete_WorksheetCollection(worksheetcollection.ptr)
	worksheetcollection.ptr = nil
}

// Class WriteProtection 

// Specifies write protection settings for a workbook.
type WriteProtection struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *WriteProtection) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.WriteProtection_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the author.
// Returns:
//   string  
func (instance *WriteProtection) GetAuthor()  (string,  error)  {
	
	CGoReturnPtr := C.WriteProtection_GetAuthor( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the author.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *WriteProtection) SetAuthor(value string)  error {
	
	CGoReturnPtr := C.WriteProtection_SetAuthor( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates if the Read Only Recommended option is selected.
// Returns:
//   bool  
func (instance *WriteProtection) GetRecommendReadOnly()  (bool,  error)  {
	
	CGoReturnPtr := C.WriteProtection_GetRecommendReadOnly( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates if the Read Only Recommended option is selected.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *WriteProtection) SetRecommendReadOnly(value bool)  error {
	
	CGoReturnPtr := C.WriteProtection_SetRecommendReadOnly( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether this workbook is write protected.
// Returns:
//   bool  
func (instance *WriteProtection) IsWriteProtected()  (bool,  error)  {
	
	CGoReturnPtr := C.WriteProtection_IsWriteProtected( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Sets the protected password to modify the file.
// Returns:
//   string  
func (instance *WriteProtection) GetPassword()  (string,  error)  {
	
	CGoReturnPtr := C.WriteProtection_GetPassword( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Sets the protected password to modify the file.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *WriteProtection) SetPassword(value string)  error {
	
	CGoReturnPtr := C.WriteProtection_SetPassword( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Returns true if the specified password is the same as the write-protection password the file was protected with.
// Parameters:
//   password - string 
// Returns:
//   bool  
func (instance *WriteProtection) ValidatePassword(password string)  (bool,  error)  {
	
	CGoReturnPtr := C.WriteProtection_ValidatePassword( instance.ptr, C.CString(password))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}



func DeleteWriteProtection(writeprotection *WriteProtection){
	runtime.SetFinalizer(writeprotection, nil)
	C.Delete_WriteProtection(writeprotection.ptr)
	writeprotection.ptr = nil
}

// Class XlsbSaveOptions 

// Represents the options for saving xlsb file.
type XlsbSaveOptions struct {
	ptr unsafe.Pointer
}

// Creates xlsb file save options.
func NewXlsbSaveOptions() ( *XlsbSaveOptions, error) {
	xlsbsaveoptions := &XlsbSaveOptions{}
	CGoReturnPtr := C.New_XlsbSaveOptions()
	if CGoReturnPtr.error_no == 0 {
		xlsbsaveoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(xlsbsaveoptions, DeleteXlsbSaveOptions)
		return xlsbsaveoptions, nil
	} else {
		xlsbsaveoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return xlsbsaveoptions, err
	}	
}
// Constructs from a parent object.
// Parameters:
//   src - SaveOptions 
func NewXlsbSaveOptions_SaveOptions(src *SaveOptions) ( *XlsbSaveOptions, error) {
	xlsbsaveoptions := &XlsbSaveOptions{}
	var src_ptr unsafe.Pointer = nil
	if src != nil {
	  src_ptr =src.ptr
	}

	CGoReturnPtr := C.New_XlsbSaveOptions_SaveOptions(src_ptr)
	if CGoReturnPtr.error_no == 0 {
		xlsbsaveoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(xlsbsaveoptions, DeleteXlsbSaveOptions)
		return xlsbsaveoptions, nil
	} else {
		xlsbsaveoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return xlsbsaveoptions, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *XlsbSaveOptions) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.XlsbSaveOptions_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the compression type for ooxml file.
// Returns:
//   int32  
func (instance *XlsbSaveOptions) GetCompressionType()  (OoxmlCompressionType,  error)  {
	
	CGoReturnPtr := C.XlsbSaveOptions_GetCompressionType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToOoxmlCompressionType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets and sets the compression type for ooxml file.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *XlsbSaveOptions) SetCompressionType(value OoxmlCompressionType)  error {
	
	CGoReturnPtr := C.XlsbSaveOptions_SetCompressionType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether exporting all column indexes for cells.
// Returns:
//   bool  
func (instance *XlsbSaveOptions) GetExportAllColumnIndexes()  (bool,  error)  {
	
	CGoReturnPtr := C.XlsbSaveOptions_GetExportAllColumnIndexes( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether exporting all column indexes for cells.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XlsbSaveOptions) SetExportAllColumnIndexes(value bool)  error {
	
	CGoReturnPtr := C.XlsbSaveOptions_SetExportAllColumnIndexes( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the save file format.
// Returns:
//   int32  
func (instance *XlsbSaveOptions) GetSaveFormat()  (SaveFormat,  error)  {
	
	CGoReturnPtr := C.XlsbSaveOptions_GetSaveFormat( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToSaveFormat(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Make the workbook empty after saving the file.
// Returns:
//   bool  
func (instance *XlsbSaveOptions) GetClearData()  (bool,  error)  {
	
	CGoReturnPtr := C.XlsbSaveOptions_GetClearData( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Make the workbook empty after saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XlsbSaveOptions) SetClearData(value bool)  error {
	
	CGoReturnPtr := C.XlsbSaveOptions_SetClearData( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// The folder for temporary files that may be used as data cache.
// Returns:
//   string  
func (instance *XlsbSaveOptions) GetCachedFileFolder()  (string,  error)  {
	
	CGoReturnPtr := C.XlsbSaveOptions_GetCachedFileFolder( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// The folder for temporary files that may be used as data cache.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *XlsbSaveOptions) SetCachedFileFolder(value string)  error {
	
	CGoReturnPtr := C.XlsbSaveOptions_SetCachedFileFolder( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether validate merged cells before saving the file.
// Returns:
//   bool  
func (instance *XlsbSaveOptions) GetValidateMergedAreas()  (bool,  error)  {
	
	CGoReturnPtr := C.XlsbSaveOptions_GetValidateMergedAreas( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether validate merged cells before saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XlsbSaveOptions) SetValidateMergedAreas(value bool)  error {
	
	CGoReturnPtr := C.XlsbSaveOptions_SetValidateMergedAreas( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether merge the areas of conditional formatting and validation before saving the file.
// Returns:
//   bool  
func (instance *XlsbSaveOptions) GetMergeAreas()  (bool,  error)  {
	
	CGoReturnPtr := C.XlsbSaveOptions_GetMergeAreas( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether merge the areas of conditional formatting and validation before saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XlsbSaveOptions) SetMergeAreas(value bool)  error {
	
	CGoReturnPtr := C.XlsbSaveOptions_SetMergeAreas( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// If true and the directory does not exist, the directory will be automatically created before saving the file.
// Returns:
//   bool  
func (instance *XlsbSaveOptions) GetCreateDirectory()  (bool,  error)  {
	
	CGoReturnPtr := C.XlsbSaveOptions_GetCreateDirectory( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// If true and the directory does not exist, the directory will be automatically created before saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XlsbSaveOptions) SetCreateDirectory(value bool)  error {
	
	CGoReturnPtr := C.XlsbSaveOptions_SetCreateDirectory( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether sorting defined names before saving file.
// Returns:
//   bool  
func (instance *XlsbSaveOptions) GetSortNames()  (bool,  error)  {
	
	CGoReturnPtr := C.XlsbSaveOptions_GetSortNames( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether sorting defined names before saving file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XlsbSaveOptions) SetSortNames(value bool)  error {
	
	CGoReturnPtr := C.XlsbSaveOptions_SetSortNames( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether sorting external defined names before saving file.
// Returns:
//   bool  
func (instance *XlsbSaveOptions) GetSortExternalNames()  (bool,  error)  {
	
	CGoReturnPtr := C.XlsbSaveOptions_GetSortExternalNames( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether sorting external defined names before saving file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XlsbSaveOptions) SetSortExternalNames(value bool)  error {
	
	CGoReturnPtr := C.XlsbSaveOptions_SetSortExternalNames( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether refreshing chart cache data
// Returns:
//   bool  
func (instance *XlsbSaveOptions) GetRefreshChartCache()  (bool,  error)  {
	
	CGoReturnPtr := C.XlsbSaveOptions_GetRefreshChartCache( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether refreshing chart cache data
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XlsbSaveOptions) SetRefreshChartCache(value bool)  error {
	
	CGoReturnPtr := C.XlsbSaveOptions_SetRefreshChartCache( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Whether check restriction of excel file when user modify cells related objects.
// For example, excel does not allow inputting string value longer than 32K.
// When you input a value longer than 32K, it will be truncated.
// Returns:
//   bool  
func (instance *XlsbSaveOptions) GetCheckExcelRestriction()  (bool,  error)  {
	
	CGoReturnPtr := C.XlsbSaveOptions_GetCheckExcelRestriction( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Whether check restriction of excel file when user modify cells related objects.
// For example, excel does not allow inputting string value longer than 32K.
// When you input a value longer than 32K, it will be truncated.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XlsbSaveOptions) SetCheckExcelRestriction(value bool)  error {
	
	CGoReturnPtr := C.XlsbSaveOptions_SetCheckExcelRestriction( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether updating smart art setting.
// The default value is false.
// Returns:
//   bool  
func (instance *XlsbSaveOptions) GetUpdateSmartArt()  (bool,  error)  {
	
	CGoReturnPtr := C.XlsbSaveOptions_GetUpdateSmartArt( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether updating smart art setting.
// The default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XlsbSaveOptions) SetUpdateSmartArt(value bool)  error {
	
	CGoReturnPtr := C.XlsbSaveOptions_SetUpdateSmartArt( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether encrypt document properties when saving as .xls file.
// The default value is true.
// Returns:
//   bool  
func (instance *XlsbSaveOptions) GetEncryptDocumentProperties()  (bool,  error)  {
	
	CGoReturnPtr := C.XlsbSaveOptions_GetEncryptDocumentProperties( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether encrypt document properties when saving as .xls file.
// The default value is true.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XlsbSaveOptions) SetEncryptDocumentProperties(value bool)  error {
	
	CGoReturnPtr := C.XlsbSaveOptions_SetEncryptDocumentProperties( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}


func (instance *XlsbSaveOptions) ToSaveOptions() *SaveOptions {
	parentClass := &SaveOptions{}
	parentClass.ptr = instance.ptr
	return parentClass
}

func DeleteXlsbSaveOptions(xlsbsaveoptions *XlsbSaveOptions){
	runtime.SetFinalizer(xlsbsaveoptions, nil)
	C.Delete_XlsbSaveOptions(xlsbsaveoptions.ptr)
	xlsbsaveoptions.ptr = nil
}

// Class XlsSaveOptions 

// Represents the save options for the Excel 97-2003 file format: xls and xlt.
type XlsSaveOptions struct {
	ptr unsafe.Pointer
}

// Creates options for saving Excel 97-2003 xls file.
func NewXlsSaveOptions() ( *XlsSaveOptions, error) {
	xlssaveoptions := &XlsSaveOptions{}
	CGoReturnPtr := C.New_XlsSaveOptions()
	if CGoReturnPtr.error_no == 0 {
		xlssaveoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(xlssaveoptions, DeleteXlsSaveOptions)
		return xlssaveoptions, nil
	} else {
		xlssaveoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return xlssaveoptions, err
	}	
}
// Creates options for saving Excel 97-2003 xls/xlt file.
// Parameters:
//   saveFormat - int32 
func NewXlsSaveOptions_SaveFormat(saveformat SaveFormat) ( *XlsSaveOptions, error) {
	xlssaveoptions := &XlsSaveOptions{}
	CGoReturnPtr := C.New_XlsSaveOptions_SaveFormat(C.int( int32(saveformat)))
	if CGoReturnPtr.error_no == 0 {
		xlssaveoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(xlssaveoptions, DeleteXlsSaveOptions)
		return xlssaveoptions, nil
	} else {
		xlssaveoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return xlssaveoptions, err
	}	
}
// Constructs from a parent object.
// Parameters:
//   src - SaveOptions 
func NewXlsSaveOptions_SaveOptions(src *SaveOptions) ( *XlsSaveOptions, error) {
	xlssaveoptions := &XlsSaveOptions{}
	var src_ptr unsafe.Pointer = nil
	if src != nil {
	  src_ptr =src.ptr
	}

	CGoReturnPtr := C.New_XlsSaveOptions_SaveOptions(src_ptr)
	if CGoReturnPtr.error_no == 0 {
		xlssaveoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(xlssaveoptions, DeleteXlsSaveOptions)
		return xlssaveoptions, nil
	} else {
		xlssaveoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return xlssaveoptions, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *XlsSaveOptions) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.XlsSaveOptions_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether matching font color because there are 56 colors in the standard color palette.
// Returns:
//   bool  
func (instance *XlsSaveOptions) GetMatchColor()  (bool,  error)  {
	
	CGoReturnPtr := C.XlsSaveOptions_GetMatchColor( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether matching font color because there are 56 colors in the standard color palette.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XlsSaveOptions) SetMatchColor(value bool)  error {
	
	CGoReturnPtr := C.XlsSaveOptions_SetMatchColor( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether to make the xls more compatible with WPS.
// Returns:
//   bool  
func (instance *XlsSaveOptions) GetWpsCompatibility()  (bool,  error)  {
	
	CGoReturnPtr := C.XlsSaveOptions_GetWpsCompatibility( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether to make the xls more compatible with WPS.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XlsSaveOptions) SetWpsCompatibility(value bool)  error {
	
	CGoReturnPtr := C.XlsSaveOptions_SetWpsCompatibility( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the save file format.
// Returns:
//   int32  
func (instance *XlsSaveOptions) GetSaveFormat()  (SaveFormat,  error)  {
	
	CGoReturnPtr := C.XlsSaveOptions_GetSaveFormat( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToSaveFormat(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Make the workbook empty after saving the file.
// Returns:
//   bool  
func (instance *XlsSaveOptions) GetClearData()  (bool,  error)  {
	
	CGoReturnPtr := C.XlsSaveOptions_GetClearData( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Make the workbook empty after saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XlsSaveOptions) SetClearData(value bool)  error {
	
	CGoReturnPtr := C.XlsSaveOptions_SetClearData( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// The folder for temporary files that may be used as data cache.
// Returns:
//   string  
func (instance *XlsSaveOptions) GetCachedFileFolder()  (string,  error)  {
	
	CGoReturnPtr := C.XlsSaveOptions_GetCachedFileFolder( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// The folder for temporary files that may be used as data cache.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *XlsSaveOptions) SetCachedFileFolder(value string)  error {
	
	CGoReturnPtr := C.XlsSaveOptions_SetCachedFileFolder( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether validate merged cells before saving the file.
// Returns:
//   bool  
func (instance *XlsSaveOptions) GetValidateMergedAreas()  (bool,  error)  {
	
	CGoReturnPtr := C.XlsSaveOptions_GetValidateMergedAreas( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether validate merged cells before saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XlsSaveOptions) SetValidateMergedAreas(value bool)  error {
	
	CGoReturnPtr := C.XlsSaveOptions_SetValidateMergedAreas( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether merge the areas of conditional formatting and validation before saving the file.
// Returns:
//   bool  
func (instance *XlsSaveOptions) GetMergeAreas()  (bool,  error)  {
	
	CGoReturnPtr := C.XlsSaveOptions_GetMergeAreas( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether merge the areas of conditional formatting and validation before saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XlsSaveOptions) SetMergeAreas(value bool)  error {
	
	CGoReturnPtr := C.XlsSaveOptions_SetMergeAreas( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// If true and the directory does not exist, the directory will be automatically created before saving the file.
// Returns:
//   bool  
func (instance *XlsSaveOptions) GetCreateDirectory()  (bool,  error)  {
	
	CGoReturnPtr := C.XlsSaveOptions_GetCreateDirectory( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// If true and the directory does not exist, the directory will be automatically created before saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XlsSaveOptions) SetCreateDirectory(value bool)  error {
	
	CGoReturnPtr := C.XlsSaveOptions_SetCreateDirectory( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether sorting defined names before saving file.
// Returns:
//   bool  
func (instance *XlsSaveOptions) GetSortNames()  (bool,  error)  {
	
	CGoReturnPtr := C.XlsSaveOptions_GetSortNames( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether sorting defined names before saving file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XlsSaveOptions) SetSortNames(value bool)  error {
	
	CGoReturnPtr := C.XlsSaveOptions_SetSortNames( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether sorting external defined names before saving file.
// Returns:
//   bool  
func (instance *XlsSaveOptions) GetSortExternalNames()  (bool,  error)  {
	
	CGoReturnPtr := C.XlsSaveOptions_GetSortExternalNames( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether sorting external defined names before saving file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XlsSaveOptions) SetSortExternalNames(value bool)  error {
	
	CGoReturnPtr := C.XlsSaveOptions_SetSortExternalNames( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether refreshing chart cache data
// Returns:
//   bool  
func (instance *XlsSaveOptions) GetRefreshChartCache()  (bool,  error)  {
	
	CGoReturnPtr := C.XlsSaveOptions_GetRefreshChartCache( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether refreshing chart cache data
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XlsSaveOptions) SetRefreshChartCache(value bool)  error {
	
	CGoReturnPtr := C.XlsSaveOptions_SetRefreshChartCache( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Whether check restriction of excel file when user modify cells related objects.
// For example, excel does not allow inputting string value longer than 32K.
// When you input a value longer than 32K, it will be truncated.
// Returns:
//   bool  
func (instance *XlsSaveOptions) GetCheckExcelRestriction()  (bool,  error)  {
	
	CGoReturnPtr := C.XlsSaveOptions_GetCheckExcelRestriction( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Whether check restriction of excel file when user modify cells related objects.
// For example, excel does not allow inputting string value longer than 32K.
// When you input a value longer than 32K, it will be truncated.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XlsSaveOptions) SetCheckExcelRestriction(value bool)  error {
	
	CGoReturnPtr := C.XlsSaveOptions_SetCheckExcelRestriction( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether updating smart art setting.
// The default value is false.
// Returns:
//   bool  
func (instance *XlsSaveOptions) GetUpdateSmartArt()  (bool,  error)  {
	
	CGoReturnPtr := C.XlsSaveOptions_GetUpdateSmartArt( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether updating smart art setting.
// The default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XlsSaveOptions) SetUpdateSmartArt(value bool)  error {
	
	CGoReturnPtr := C.XlsSaveOptions_SetUpdateSmartArt( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether encrypt document properties when saving as .xls file.
// The default value is true.
// Returns:
//   bool  
func (instance *XlsSaveOptions) GetEncryptDocumentProperties()  (bool,  error)  {
	
	CGoReturnPtr := C.XlsSaveOptions_GetEncryptDocumentProperties( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether encrypt document properties when saving as .xls file.
// The default value is true.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XlsSaveOptions) SetEncryptDocumentProperties(value bool)  error {
	
	CGoReturnPtr := C.XlsSaveOptions_SetEncryptDocumentProperties( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}


func (instance *XlsSaveOptions) ToSaveOptions() *SaveOptions {
	parentClass := &SaveOptions{}
	parentClass.ptr = instance.ptr
	return parentClass
}

func DeleteXlsSaveOptions(xlssaveoptions *XlsSaveOptions){
	runtime.SetFinalizer(xlssaveoptions, nil)
	C.Delete_XlsSaveOptions(xlssaveoptions.ptr)
	xlssaveoptions.ptr = nil
}

// Class XmlColumnProperty 

// Represents Xml Data Binding information.
type XmlColumnProperty struct {
	ptr unsafe.Pointer
}

// Default constructor.
func NewXmlColumnProperty() ( *XmlColumnProperty, error) {
	xmlcolumnproperty := &XmlColumnProperty{}
	CGoReturnPtr := C.New_XmlColumnProperty()
	if CGoReturnPtr.error_no == 0 {
		xmlcolumnproperty.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(xmlcolumnproperty, DeleteXmlColumnProperty)
		return xmlcolumnproperty, nil
	} else {
		xmlcolumnproperty.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return xmlcolumnproperty, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *XmlColumnProperty) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.XmlColumnProperty_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}



func DeleteXmlColumnProperty(xmlcolumnproperty *XmlColumnProperty){
	runtime.SetFinalizer(xmlcolumnproperty, nil)
	C.Delete_XmlColumnProperty(xmlcolumnproperty.ptr)
	xmlcolumnproperty.ptr = nil
}

// Class XmlDataBinding 

// Represents Xml Data Binding information.
type XmlDataBinding struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *XmlDataBinding) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.XmlDataBinding_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets source url of this data binding.
// Returns:
//   string  
func (instance *XmlDataBinding) GetUrl()  (string,  error)  {
	
	CGoReturnPtr := C.XmlDataBinding_GetUrl( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}



func DeleteXmlDataBinding(xmldatabinding *XmlDataBinding){
	runtime.SetFinalizer(xmldatabinding, nil)
	C.Delete_XmlDataBinding(xmldatabinding.ptr)
	xmldatabinding.ptr = nil
}

// Class XmlLoadOptions 

// Represents the options of loading xml.
type XmlLoadOptions struct {
	ptr unsafe.Pointer
}

// Represents the options of loading xml file.
func NewXmlLoadOptions() ( *XmlLoadOptions, error) {
	xmlloadoptions := &XmlLoadOptions{}
	CGoReturnPtr := C.New_XmlLoadOptions()
	if CGoReturnPtr.error_no == 0 {
		xmlloadoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(xmlloadoptions, DeleteXmlLoadOptions)
		return xmlloadoptions, nil
	} else {
		xmlloadoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return xmlloadoptions, err
	}	
}
// Represents the options of loading xml file.
// Parameters:
//   type - int32 
func NewXmlLoadOptions_LoadFormat(type_ LoadFormat) ( *XmlLoadOptions, error) {
	xmlloadoptions := &XmlLoadOptions{}
	CGoReturnPtr := C.New_XmlLoadOptions_LoadFormat(C.int( int32(type_)))
	if CGoReturnPtr.error_no == 0 {
		xmlloadoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(xmlloadoptions, DeleteXmlLoadOptions)
		return xmlloadoptions, nil
	} else {
		xmlloadoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return xmlloadoptions, err
	}	
}
// Constructs from a parent object.
// Parameters:
//   src - LoadOptions 
func NewXmlLoadOptions_LoadOptions(src *LoadOptions) ( *XmlLoadOptions, error) {
	xmlloadoptions := &XmlLoadOptions{}
	var src_ptr unsafe.Pointer = nil
	if src != nil {
	  src_ptr =src.ptr
	}

	CGoReturnPtr := C.New_XmlLoadOptions_LoadOptions(src_ptr)
	if CGoReturnPtr.error_no == 0 {
		xmlloadoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(xmlloadoptions, DeleteXmlLoadOptions)
		return xmlloadoptions, nil
	} else {
		xmlloadoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return xmlloadoptions, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *XmlLoadOptions) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.XmlLoadOptions_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the start cell.
// Returns:
//   string  
func (instance *XmlLoadOptions) GetStartCell()  (string,  error)  {
	
	CGoReturnPtr := C.XmlLoadOptions_GetStartCell( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the start cell.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *XmlLoadOptions) SetStartCell(value string)  error {
	
	CGoReturnPtr := C.XmlLoadOptions_SetStartCell( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether mapping xml to Excel.
// The default value is false.
// Returns:
//   bool  
func (instance *XmlLoadOptions) IsXmlMap()  (bool,  error)  {
	
	CGoReturnPtr := C.XmlLoadOptions_IsXmlMap( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether mapping xml to Excel.
// The default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XmlLoadOptions) SetIsXmlMap(value bool)  error {
	
	CGoReturnPtr := C.XmlLoadOptions_SetIsXmlMap( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether importing xml as multiple worksheets.
// Returns:
//   bool  
func (instance *XmlLoadOptions) GetContainsMultipleWorksheets()  (bool,  error)  {
	
	CGoReturnPtr := C.XmlLoadOptions_GetContainsMultipleWorksheets( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether importing xml as multiple worksheets.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XmlLoadOptions) SetContainsMultipleWorksheets(value bool)  error {
	
	CGoReturnPtr := C.XmlLoadOptions_SetContainsMultipleWorksheets( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether converting the value in xml file to numeric or date.
// Returns:
//   bool  
func (instance *XmlLoadOptions) GetConvertNumericOrDate()  (bool,  error)  {
	
	CGoReturnPtr := C.XmlLoadOptions_GetConvertNumericOrDate( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether converting the value in xml file to numeric or date.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XmlLoadOptions) SetConvertNumericOrDate(value bool)  error {
	
	CGoReturnPtr := C.XmlLoadOptions_SetConvertNumericOrDate( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the format of numeric value.
// Returns:
//   string  
func (instance *XmlLoadOptions) Get_NumberFormat()  (string,  error)  {
	
	CGoReturnPtr := C.XmlLoadOptions_Get_NumberFormat( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the format of numeric value.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *XmlLoadOptions) SetNumberFormat(value string)  error {
	
	CGoReturnPtr := C.XmlLoadOptions_SetNumberFormat( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the format of date value.
// Returns:
//   string  
func (instance *XmlLoadOptions) Get_DateFormat()  (string,  error)  {
	
	CGoReturnPtr := C.XmlLoadOptions_Get_DateFormat( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and sets the format of date value.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *XmlLoadOptions) SetDateFormat(value string)  error {
	
	CGoReturnPtr := C.XmlLoadOptions_SetDateFormat( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether ignore attributes of the root element.
// Returns:
//   bool  
func (instance *XmlLoadOptions) GetIgnoreRootAttributes()  (bool,  error)  {
	
	CGoReturnPtr := C.XmlLoadOptions_GetIgnoreRootAttributes( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether ignore attributes of the root element.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XmlLoadOptions) SetIgnoreRootAttributes(value bool)  error {
	
	CGoReturnPtr := C.XmlLoadOptions_SetIgnoreRootAttributes( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the load format.
// Returns:
//   int32  
func (instance *XmlLoadOptions) GetLoadFormat()  (LoadFormat,  error)  {
	
	CGoReturnPtr := C.XmlLoadOptions_GetLoadFormat( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToLoadFormat(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets and set the password of the workbook.
// Returns:
//   string  
func (instance *XmlLoadOptions) GetPassword()  (string,  error)  {
	
	CGoReturnPtr := C.XmlLoadOptions_GetPassword( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets and set the password of the workbook.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *XmlLoadOptions) SetPassword(value string)  error {
	
	CGoReturnPtr := C.XmlLoadOptions_SetPassword( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether parsing the formula when reading the file.
// Returns:
//   bool  
func (instance *XmlLoadOptions) GetParsingFormulaOnOpen()  (bool,  error)  {
	
	CGoReturnPtr := C.XmlLoadOptions_GetParsingFormulaOnOpen( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether parsing the formula when reading the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XmlLoadOptions) SetParsingFormulaOnOpen(value bool)  error {
	
	CGoReturnPtr := C.XmlLoadOptions_SetParsingFormulaOnOpen( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether parsing pivot cached records when loading the file.
// The default value is false.
// Returns:
//   bool  
func (instance *XmlLoadOptions) GetParsingPivotCachedRecords()  (bool,  error)  {
	
	CGoReturnPtr := C.XmlLoadOptions_GetParsingPivotCachedRecords( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether parsing pivot cached records when loading the file.
// The default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XmlLoadOptions) SetParsingPivotCachedRecords(value bool)  error {
	
	CGoReturnPtr := C.XmlLoadOptions_SetParsingPivotCachedRecords( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Sets the default print paper size from default printer's setting.
// Parameters:
//   type - int32 
// Returns:
//   void  
func (instance *XmlLoadOptions) SetPaperSize(type_ PaperSizeType)  error {
	
	CGoReturnPtr := C.XmlLoadOptions_SetPaperSize( instance.ptr, C.int( int32(type_)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the user interface language of the Workbook version based on CountryCode that has saved the file.
// Returns:
//   int32  
func (instance *XmlLoadOptions) GetLanguageCode()  (CountryCode,  error)  {
	
	CGoReturnPtr := C.XmlLoadOptions_GetLanguageCode( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToCountryCode(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets or sets the user interface language of the Workbook version based on CountryCode that has saved the file.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *XmlLoadOptions) SetLanguageCode(value CountryCode)  error {
	
	CGoReturnPtr := C.XmlLoadOptions_SetLanguageCode( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the regional settings used for the Workbook that will be loaded.
// Returns:
//   int32  
func (instance *XmlLoadOptions) GetRegion()  (CountryCode,  error)  {
	
	CGoReturnPtr := C.XmlLoadOptions_GetRegion( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToCountryCode(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets or sets the regional settings used for the Workbook that will be loaded.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *XmlLoadOptions) SetRegion(value CountryCode)  error {
	
	CGoReturnPtr := C.XmlLoadOptions_SetRegion( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the default style settings for initializing styles of the workbook
// Returns:
//   DefaultStyleSettings  
func (instance *XmlLoadOptions) GetDefaultStyleSettings()  (*DefaultStyleSettings,  error)  {
	
	CGoReturnPtr := C.XmlLoadOptions_GetDefaultStyleSettings( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &DefaultStyleSettings{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteDefaultStyleSettings) 

	return result, nil 
}
// Gets and sets the interrupt monitor.
// Returns:
//   AbstractInterruptMonitor  
func (instance *XmlLoadOptions) GetInterruptMonitor()  (*AbstractInterruptMonitor,  error)  {
	
	CGoReturnPtr := C.XmlLoadOptions_GetInterruptMonitor( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &AbstractInterruptMonitor{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteAbstractInterruptMonitor) 

	return result, nil 
}
// Gets and sets the interrupt monitor.
// Parameters:
//   value - AbstractInterruptMonitor 
// Returns:
//   void  
func (instance *XmlLoadOptions) SetInterruptMonitor(value *AbstractInterruptMonitor)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.XmlLoadOptions_SetInterruptMonitor( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Ignore the data which are not printed if directly printing the file
// Returns:
//   bool  
func (instance *XmlLoadOptions) GetIgnoreNotPrinted()  (bool,  error)  {
	
	CGoReturnPtr := C.XmlLoadOptions_GetIgnoreNotPrinted( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Ignore the data which are not printed if directly printing the file
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XmlLoadOptions) SetIgnoreNotPrinted(value bool)  error {
	
	CGoReturnPtr := C.XmlLoadOptions_SetIgnoreNotPrinted( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Check whether data is valid in the template file.
// Returns:
//   bool  
func (instance *XmlLoadOptions) GetCheckDataValid()  (bool,  error)  {
	
	CGoReturnPtr := C.XmlLoadOptions_GetCheckDataValid( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Check whether data is valid in the template file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XmlLoadOptions) SetCheckDataValid(value bool)  error {
	
	CGoReturnPtr := C.XmlLoadOptions_SetCheckDataValid( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Whether check restriction of excel file when user modify cells related objects.
// For example, excel does not allow inputting string value longer than 32K.
// When you input a value longer than 32K such as by Cell.PutValue(string), if this property is true, you will get an Exception.
// If this property is false, we will accept your input string value as the cell's value so that later
// you can output the complete string value for other file formats such as CSV.
// However, if you have set such kind of value that is invalid for excel file format,
// you should not save the workbook as excel file format later. Otherwise there may be unexpected error for the generated excel file.
// Returns:
//   bool  
func (instance *XmlLoadOptions) GetCheckExcelRestriction()  (bool,  error)  {
	
	CGoReturnPtr := C.XmlLoadOptions_GetCheckExcelRestriction( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Whether check restriction of excel file when user modify cells related objects.
// For example, excel does not allow inputting string value longer than 32K.
// When you input a value longer than 32K such as by Cell.PutValue(string), if this property is true, you will get an Exception.
// If this property is false, we will accept your input string value as the cell's value so that later
// you can output the complete string value for other file formats such as CSV.
// However, if you have set such kind of value that is invalid for excel file format,
// you should not save the workbook as excel file format later. Otherwise there may be unexpected error for the generated excel file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XmlLoadOptions) SetCheckExcelRestriction(value bool)  error {
	
	CGoReturnPtr := C.XmlLoadOptions_SetCheckExcelRestriction( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Whether keep the unparsed data in memory for the Workbook when it is loaded from template file. Default is true.
// Returns:
//   bool  
func (instance *XmlLoadOptions) GetKeepUnparsedData()  (bool,  error)  {
	
	CGoReturnPtr := C.XmlLoadOptions_GetKeepUnparsedData( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Whether keep the unparsed data in memory for the Workbook when it is loaded from template file. Default is true.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XmlLoadOptions) SetKeepUnparsedData(value bool)  error {
	
	CGoReturnPtr := C.XmlLoadOptions_SetKeepUnparsedData( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// The filter to denote how to load data.
// Returns:
//   LoadFilter  
func (instance *XmlLoadOptions) GetLoadFilter()  (*LoadFilter,  error)  {
	
	CGoReturnPtr := C.XmlLoadOptions_GetLoadFilter( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &LoadFilter{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteLoadFilter) 

	return result, nil 
}
// The filter to denote how to load data.
// Parameters:
//   value - LoadFilter 
// Returns:
//   void  
func (instance *XmlLoadOptions) SetLoadFilter(value *LoadFilter)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.XmlLoadOptions_SetLoadFilter( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the memory usage options.
// Returns:
//   int32  
func (instance *XmlLoadOptions) GetMemorySetting()  (MemorySetting,  error)  {
	
	CGoReturnPtr := C.XmlLoadOptions_GetMemorySetting( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToMemorySetting(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets or sets the memory usage options.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *XmlLoadOptions) SetMemorySetting(value MemorySetting)  error {
	
	CGoReturnPtr := C.XmlLoadOptions_SetMemorySetting( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets the auto fitter options
// Returns:
//   AutoFitterOptions  
func (instance *XmlLoadOptions) GetAutoFitterOptions()  (*AutoFitterOptions,  error)  {
	
	CGoReturnPtr := C.XmlLoadOptions_GetAutoFitterOptions( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &AutoFitterOptions{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteAutoFitterOptions) 

	return result, nil 
}
// Gets and sets the auto fitter options
// Parameters:
//   value - AutoFitterOptions 
// Returns:
//   void  
func (instance *XmlLoadOptions) SetAutoFitterOptions(value *AutoFitterOptions)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.XmlLoadOptions_SetAutoFitterOptions( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether auto filtering the data when loading the files.
// Returns:
//   bool  
func (instance *XmlLoadOptions) GetAutoFilter()  (bool,  error)  {
	
	CGoReturnPtr := C.XmlLoadOptions_GetAutoFilter( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether auto filtering the data when loading the files.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XmlLoadOptions) SetAutoFilter(value bool)  error {
	
	CGoReturnPtr := C.XmlLoadOptions_SetAutoFilter( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets and sets individual font configs.
// Only works for the <see cref="Workbook"/> which uses this <see cref="LoadOptions"/> to load.
// Returns:
//   IndividualFontConfigs  
func (instance *XmlLoadOptions) GetFontConfigs()  (*IndividualFontConfigs,  error)  {
	
	CGoReturnPtr := C.XmlLoadOptions_GetFontConfigs( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &IndividualFontConfigs{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteIndividualFontConfigs) 

	return result, nil 
}
// Gets and sets individual font configs.
// Only works for the <see cref="Workbook"/> which uses this <see cref="LoadOptions"/> to load.
// Parameters:
//   value - IndividualFontConfigs 
// Returns:
//   void  
func (instance *XmlLoadOptions) SetFontConfigs(value *IndividualFontConfigs)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.XmlLoadOptions_SetFontConfigs( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether ignoring useless shapes.
// Returns:
//   bool  
func (instance *XmlLoadOptions) GetIgnoreUselessShapes()  (bool,  error)  {
	
	CGoReturnPtr := C.XmlLoadOptions_GetIgnoreUselessShapes( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether ignoring useless shapes.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XmlLoadOptions) SetIgnoreUselessShapes(value bool)  error {
	
	CGoReturnPtr := C.XmlLoadOptions_SetIgnoreUselessShapes( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether preserve those spaces and line breaks that are padded between formula tokens
// while getting and setting formulas.
// Default value is false.
// Returns:
//   bool  
func (instance *XmlLoadOptions) GetPreservePaddingSpacesInFormula()  (bool,  error)  {
	
	CGoReturnPtr := C.XmlLoadOptions_GetPreservePaddingSpacesInFormula( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether preserve those spaces and line breaks that are padded between formula tokens
// while getting and setting formulas.
// Default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XmlLoadOptions) SetPreservePaddingSpacesInFormula(value bool)  error {
	
	CGoReturnPtr := C.XmlLoadOptions_SetPreservePaddingSpacesInFormula( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}


func (instance *XmlLoadOptions) ToLoadOptions() *LoadOptions {
	parentClass := &LoadOptions{}
	parentClass.ptr = instance.ptr
	return parentClass
}

func DeleteXmlLoadOptions(xmlloadoptions *XmlLoadOptions){
	runtime.SetFinalizer(xmlloadoptions, nil)
	C.Delete_XmlLoadOptions(xmlloadoptions.ptr)
	xmlloadoptions.ptr = nil
}

// Class XmlMap 

// Represents Xml map information.
type XmlMap struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *XmlMap) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.XmlMap_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Returns or sets the name of the object.
// Returns:
//   string  
func (instance *XmlMap) GetName()  (string,  error)  {
	
	CGoReturnPtr := C.XmlMap_GetName( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Returns or sets the name of the object.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *XmlMap) SetName(value string)  error {
	
	CGoReturnPtr := C.XmlMap_SetName( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets root element name.
// Returns:
//   string  
func (instance *XmlMap) GetRootElementName()  (string,  error)  {
	
	CGoReturnPtr := C.XmlMap_GetRootElementName( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets an <see cref="XmlDataBinding"/> of this map.
// Returns:
//   XmlDataBinding  
func (instance *XmlMap) GetDataBinding()  (*XmlDataBinding,  error)  {
	
	CGoReturnPtr := C.XmlMap_GetDataBinding( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &XmlDataBinding{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteXmlDataBinding) 

	return result, nil 
}



func DeleteXmlMap(xmlmap *XmlMap){
	runtime.SetFinalizer(xmlmap, nil)
	C.Delete_XmlMap(xmlmap.ptr)
	xmlmap.ptr = nil
}

// Class XmlMapCollection 

// A collection of <see cref="XmlMap"/> objects that represent XmlMap information.
type XmlMapCollection struct {
	ptr unsafe.Pointer
}


// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *XmlMapCollection) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.XmlMapCollection_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets the xml map by the specific index.
// Parameters:
//   index - int32 
// Returns:
//   XmlMap  
func (instance *XmlMapCollection) Get(index int32)  (*XmlMap,  error)  {
	
	CGoReturnPtr := C.XmlMapCollection_Get( instance.ptr, C.int(index))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &XmlMap{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteXmlMap) 

	return result, nil 
}
// Add a <see cref="XmlMap"/> by the url/path of a xml/xsd file.
// Parameters:
//   url - string 
// Returns:
//   int32  
func (instance *XmlMapCollection) Add(url string)  (int32,  error)  {
	
	CGoReturnPtr := C.XmlMapCollection_Add( instance.ptr, C.CString(url))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Removes all XmlMaps.
// Returns:
//   void  
func (instance *XmlMapCollection) Clear()  error {
	
	CGoReturnPtr := C.XmlMapCollection_Clear( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Returns:
//   int32  
func (instance *XmlMapCollection) GetCount()  (int32,  error)  {
	
	CGoReturnPtr := C.XmlMapCollection_GetCount( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}



func DeleteXmlMapCollection(xmlmapcollection *XmlMapCollection){
	runtime.SetFinalizer(xmlmapcollection, nil)
	C.Delete_XmlMapCollection(xmlmapcollection.ptr)
	xmlmapcollection.ptr = nil
}

// Class XmlSaveOptions 

// Represents the options of saving the workbook as an xml file.
type XmlSaveOptions struct {
	ptr unsafe.Pointer
}

// Creates options for saving xml file.
func NewXmlSaveOptions() ( *XmlSaveOptions, error) {
	xmlsaveoptions := &XmlSaveOptions{}
	CGoReturnPtr := C.New_XmlSaveOptions()
	if CGoReturnPtr.error_no == 0 {
		xmlsaveoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(xmlsaveoptions, DeleteXmlSaveOptions)
		return xmlsaveoptions, nil
	} else {
		xmlsaveoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return xmlsaveoptions, err
	}	
}
// Constructs from a parent object.
// Parameters:
//   src - SaveOptions 
func NewXmlSaveOptions_SaveOptions(src *SaveOptions) ( *XmlSaveOptions, error) {
	xmlsaveoptions := &XmlSaveOptions{}
	var src_ptr unsafe.Pointer = nil
	if src != nil {
	  src_ptr =src.ptr
	}

	CGoReturnPtr := C.New_XmlSaveOptions_SaveOptions(src_ptr)
	if CGoReturnPtr.error_no == 0 {
		xmlsaveoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(xmlsaveoptions, DeleteXmlSaveOptions)
		return xmlsaveoptions, nil
	} else {
		xmlsaveoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return xmlsaveoptions, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *XmlSaveOptions) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.XmlSaveOptions_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Represents the indexes of exported sheets.
// Returns:
//   []int32_t  
func (instance *XmlSaveOptions) GetSheetIndexes()  ([]int32,  error)  {
	
	CGoReturnPtr := C.XmlSaveOptions_GetSheetIndexes( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result:= make([]int32, CGoReturnPtr.column_length)
	for i := 0; i < int(CGoReturnPtr.column_length); i++ {
	   offset := uintptr(C.size_t(i)) * uintptr(CGoReturnPtr.size)
	   cObject := *(*C.int)(unsafe.Pointer( uintptr( unsafe.Pointer(CGoReturnPtr.return_value)) + offset))
	   goObject :=int32(cObject)
	   result[i] = goObject
	}
	 

	return result, nil 
}
// Represents the indexes of exported sheets.
// Parameters:
//   value - []int32_t 
// Returns:
//   void  
func (instance *XmlSaveOptions) SetSheetIndexes(value []int32)  error {
	
	CGoReturnPtr := C.XmlSaveOptions_SetSheetIndexes( instance.ptr, unsafe.Pointer(&value[0]), C.int( len(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the exporting range.
// Returns:
//   CellArea  
func (instance *XmlSaveOptions) GetExportArea()  (*CellArea,  error)  {
	
	CGoReturnPtr := C.XmlSaveOptions_GetExportArea( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &CellArea{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteCellArea) 

	return result, nil 
}
// Gets or sets the exporting range.
// Parameters:
//   value - CellArea 
// Returns:
//   void  
func (instance *XmlSaveOptions) SetExportArea(value *CellArea)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.XmlSaveOptions_SetExportArea( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether the range contains header row.
// Returns:
//   bool  
func (instance *XmlSaveOptions) GetHasHeaderRow()  (bool,  error)  {
	
	CGoReturnPtr := C.XmlSaveOptions_GetHasHeaderRow( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether the range contains header row.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XmlSaveOptions) SetHasHeaderRow(value bool)  error {
	
	CGoReturnPtr := C.XmlSaveOptions_SetHasHeaderRow( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether exporting xml map in the file.
// Returns:
//   string  
func (instance *XmlSaveOptions) GetXmlMapName()  (string,  error)  {
	
	CGoReturnPtr := C.XmlSaveOptions_GetXmlMapName( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether exporting xml map in the file.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *XmlSaveOptions) SetXmlMapName(value string)  error {
	
	CGoReturnPtr := C.XmlSaveOptions_SetXmlMapName( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether exporting sheet's name as the name of the element.
// Returns:
//   bool  
func (instance *XmlSaveOptions) GetSheetNameAsElementName()  (bool,  error)  {
	
	CGoReturnPtr := C.XmlSaveOptions_GetSheetNameAsElementName( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether exporting sheet's name as the name of the element.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XmlSaveOptions) SetSheetNameAsElementName(value bool)  error {
	
	CGoReturnPtr := C.XmlSaveOptions_SetSheetNameAsElementName( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether exporting data as attributes of element.
// Returns:
//   bool  
func (instance *XmlSaveOptions) GetDataAsAttribute()  (bool,  error)  {
	
	CGoReturnPtr := C.XmlSaveOptions_GetDataAsAttribute( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether exporting data as attributes of element.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XmlSaveOptions) SetDataAsAttribute(value bool)  error {
	
	CGoReturnPtr := C.XmlSaveOptions_SetDataAsAttribute( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the save file format.
// Returns:
//   int32  
func (instance *XmlSaveOptions) GetSaveFormat()  (SaveFormat,  error)  {
	
	CGoReturnPtr := C.XmlSaveOptions_GetSaveFormat( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToSaveFormat(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Make the workbook empty after saving the file.
// Returns:
//   bool  
func (instance *XmlSaveOptions) GetClearData()  (bool,  error)  {
	
	CGoReturnPtr := C.XmlSaveOptions_GetClearData( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Make the workbook empty after saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XmlSaveOptions) SetClearData(value bool)  error {
	
	CGoReturnPtr := C.XmlSaveOptions_SetClearData( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// The folder for temporary files that may be used as data cache.
// Returns:
//   string  
func (instance *XmlSaveOptions) GetCachedFileFolder()  (string,  error)  {
	
	CGoReturnPtr := C.XmlSaveOptions_GetCachedFileFolder( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// The folder for temporary files that may be used as data cache.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *XmlSaveOptions) SetCachedFileFolder(value string)  error {
	
	CGoReturnPtr := C.XmlSaveOptions_SetCachedFileFolder( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether validate merged cells before saving the file.
// Returns:
//   bool  
func (instance *XmlSaveOptions) GetValidateMergedAreas()  (bool,  error)  {
	
	CGoReturnPtr := C.XmlSaveOptions_GetValidateMergedAreas( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether validate merged cells before saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XmlSaveOptions) SetValidateMergedAreas(value bool)  error {
	
	CGoReturnPtr := C.XmlSaveOptions_SetValidateMergedAreas( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether merge the areas of conditional formatting and validation before saving the file.
// Returns:
//   bool  
func (instance *XmlSaveOptions) GetMergeAreas()  (bool,  error)  {
	
	CGoReturnPtr := C.XmlSaveOptions_GetMergeAreas( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether merge the areas of conditional formatting and validation before saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XmlSaveOptions) SetMergeAreas(value bool)  error {
	
	CGoReturnPtr := C.XmlSaveOptions_SetMergeAreas( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// If true and the directory does not exist, the directory will be automatically created before saving the file.
// Returns:
//   bool  
func (instance *XmlSaveOptions) GetCreateDirectory()  (bool,  error)  {
	
	CGoReturnPtr := C.XmlSaveOptions_GetCreateDirectory( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// If true and the directory does not exist, the directory will be automatically created before saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XmlSaveOptions) SetCreateDirectory(value bool)  error {
	
	CGoReturnPtr := C.XmlSaveOptions_SetCreateDirectory( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether sorting defined names before saving file.
// Returns:
//   bool  
func (instance *XmlSaveOptions) GetSortNames()  (bool,  error)  {
	
	CGoReturnPtr := C.XmlSaveOptions_GetSortNames( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether sorting defined names before saving file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XmlSaveOptions) SetSortNames(value bool)  error {
	
	CGoReturnPtr := C.XmlSaveOptions_SetSortNames( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether sorting external defined names before saving file.
// Returns:
//   bool  
func (instance *XmlSaveOptions) GetSortExternalNames()  (bool,  error)  {
	
	CGoReturnPtr := C.XmlSaveOptions_GetSortExternalNames( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether sorting external defined names before saving file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XmlSaveOptions) SetSortExternalNames(value bool)  error {
	
	CGoReturnPtr := C.XmlSaveOptions_SetSortExternalNames( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether refreshing chart cache data
// Returns:
//   bool  
func (instance *XmlSaveOptions) GetRefreshChartCache()  (bool,  error)  {
	
	CGoReturnPtr := C.XmlSaveOptions_GetRefreshChartCache( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether refreshing chart cache data
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XmlSaveOptions) SetRefreshChartCache(value bool)  error {
	
	CGoReturnPtr := C.XmlSaveOptions_SetRefreshChartCache( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Whether check restriction of excel file when user modify cells related objects.
// For example, excel does not allow inputting string value longer than 32K.
// When you input a value longer than 32K, it will be truncated.
// Returns:
//   bool  
func (instance *XmlSaveOptions) GetCheckExcelRestriction()  (bool,  error)  {
	
	CGoReturnPtr := C.XmlSaveOptions_GetCheckExcelRestriction( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Whether check restriction of excel file when user modify cells related objects.
// For example, excel does not allow inputting string value longer than 32K.
// When you input a value longer than 32K, it will be truncated.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XmlSaveOptions) SetCheckExcelRestriction(value bool)  error {
	
	CGoReturnPtr := C.XmlSaveOptions_SetCheckExcelRestriction( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether updating smart art setting.
// The default value is false.
// Returns:
//   bool  
func (instance *XmlSaveOptions) GetUpdateSmartArt()  (bool,  error)  {
	
	CGoReturnPtr := C.XmlSaveOptions_GetUpdateSmartArt( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether updating smart art setting.
// The default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XmlSaveOptions) SetUpdateSmartArt(value bool)  error {
	
	CGoReturnPtr := C.XmlSaveOptions_SetUpdateSmartArt( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether encrypt document properties when saving as .xls file.
// The default value is true.
// Returns:
//   bool  
func (instance *XmlSaveOptions) GetEncryptDocumentProperties()  (bool,  error)  {
	
	CGoReturnPtr := C.XmlSaveOptions_GetEncryptDocumentProperties( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether encrypt document properties when saving as .xls file.
// The default value is true.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XmlSaveOptions) SetEncryptDocumentProperties(value bool)  error {
	
	CGoReturnPtr := C.XmlSaveOptions_SetEncryptDocumentProperties( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}


func (instance *XmlSaveOptions) ToSaveOptions() *SaveOptions {
	parentClass := &SaveOptions{}
	parentClass.ptr = instance.ptr
	return parentClass
}

func DeleteXmlSaveOptions(xmlsaveoptions *XmlSaveOptions){
	runtime.SetFinalizer(xmlsaveoptions, nil)
	C.Delete_XmlSaveOptions(xmlsaveoptions.ptr)
	xmlsaveoptions.ptr = nil
}

// Class XpsSaveOptions 

// Represents the additional options when saving the file as the Xps.
type XpsSaveOptions struct {
	ptr unsafe.Pointer
}

// Creates options for saving xps file.
func NewXpsSaveOptions() ( *XpsSaveOptions, error) {
	xpssaveoptions := &XpsSaveOptions{}
	CGoReturnPtr := C.New_XpsSaveOptions()
	if CGoReturnPtr.error_no == 0 {
		xpssaveoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(xpssaveoptions, DeleteXpsSaveOptions)
		return xpssaveoptions, nil
	} else {
		xpssaveoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return xpssaveoptions, err
	}	
}
// Constructs from a parent object.
// Parameters:
//   src - PaginatedSaveOptions 
func NewXpsSaveOptions_PaginatedSaveOptions(src *PaginatedSaveOptions) ( *XpsSaveOptions, error) {
	xpssaveoptions := &XpsSaveOptions{}
	var src_ptr unsafe.Pointer = nil
	if src != nil {
	  src_ptr =src.ptr
	}

	CGoReturnPtr := C.New_XpsSaveOptions_PaginatedSaveOptions(src_ptr)
	if CGoReturnPtr.error_no == 0 {
		xpssaveoptions.ptr = CGoReturnPtr.return_value
		runtime.SetFinalizer(xpssaveoptions, DeleteXpsSaveOptions)
		return xpssaveoptions, nil
	} else {
		xpssaveoptions.ptr = nil
		err := errors.New(C.GoString(CGoReturnPtr.error_message))
		return xpssaveoptions, err
	}	
}

// Checks whether the implementation object is nullptr.
// Returns:
//   bool  
func (instance *XpsSaveOptions) IsNull()  (bool,  error)  {
	
	CGoReturnPtr := C.XpsSaveOptions_IsNull( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// When characters in the Excel are Unicode and not be set with correct font in cell style,
// They may appear as block in pdf,image.
// Set the DefaultFont such as MingLiu or MS Gothic to show these characters.
// If this property is not set, Aspose.Cells will use system default font to show these unicode characters.
// Returns:
//   string  
func (instance *XpsSaveOptions) GetDefaultFont()  (string,  error)  {
	
	CGoReturnPtr := C.XpsSaveOptions_GetDefaultFont( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// When characters in the Excel are Unicode and not be set with correct font in cell style,
// They may appear as block in pdf,image.
// Set the DefaultFont such as MingLiu or MS Gothic to show these characters.
// If this property is not set, Aspose.Cells will use system default font to show these unicode characters.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *XpsSaveOptions) SetDefaultFont(value string)  error {
	
	CGoReturnPtr := C.XpsSaveOptions_SetDefaultFont( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// When characters in the Excel are Unicode and not be set with correct font in cell style,
// They may appear as block in pdf,image.
// Set this to true to try to use workbook's default font to show these characters first.
// Returns:
//   bool  
func (instance *XpsSaveOptions) GetCheckWorkbookDefaultFont()  (bool,  error)  {
	
	CGoReturnPtr := C.XpsSaveOptions_GetCheckWorkbookDefaultFont( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// When characters in the Excel are Unicode and not be set with correct font in cell style,
// They may appear as block in pdf,image.
// Set this to true to try to use workbook's default font to show these characters first.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XpsSaveOptions) SetCheckWorkbookDefaultFont(value bool)  error {
	
	CGoReturnPtr := C.XpsSaveOptions_SetCheckWorkbookDefaultFont( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether to check font compatibility for every character in text.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XpsSaveOptions) SetCheckFontCompatibility(value bool)  error {
	
	CGoReturnPtr := C.XpsSaveOptions_SetCheckFontCompatibility( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether to check font compatibility for every character in text.
// Returns:
//   bool  
func (instance *XpsSaveOptions) GetCheckFontCompatibility()  (bool,  error)  {
	
	CGoReturnPtr := C.XpsSaveOptions_GetCheckFontCompatibility( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether to only substitute the font of character when the cell font is not compatibility for it.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XpsSaveOptions) SetIsFontSubstitutionCharGranularity(value bool)  error {
	
	CGoReturnPtr := C.XpsSaveOptions_SetIsFontSubstitutionCharGranularity( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether to only substitute the font of character when the cell font is not compatibility for it.
// Returns:
//   bool  
func (instance *XpsSaveOptions) IsFontSubstitutionCharGranularity()  (bool,  error)  {
	
	CGoReturnPtr := C.XpsSaveOptions_IsFontSubstitutionCharGranularity( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// If OnePagePerSheet is true , all content of one sheet will output to only one page in result.
// The paper size of pagesetup will be invalid, and the other settings of pagesetup
// will still take effect.
// Returns:
//   bool  
func (instance *XpsSaveOptions) GetOnePagePerSheet()  (bool,  error)  {
	
	CGoReturnPtr := C.XpsSaveOptions_GetOnePagePerSheet( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// If OnePagePerSheet is true , all content of one sheet will output to only one page in result.
// The paper size of pagesetup will be invalid, and the other settings of pagesetup
// will still take effect.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XpsSaveOptions) SetOnePagePerSheet(value bool)  error {
	
	CGoReturnPtr := C.XpsSaveOptions_SetOnePagePerSheet( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// If AllColumnsInOnePagePerSheet is true , all column content of one sheet will output to only one page in result.
// The width of paper size of pagesetup will be ignored, and the other settings of pagesetup
// will still take effect.
// Returns:
//   bool  
func (instance *XpsSaveOptions) GetAllColumnsInOnePagePerSheet()  (bool,  error)  {
	
	CGoReturnPtr := C.XpsSaveOptions_GetAllColumnsInOnePagePerSheet( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// If AllColumnsInOnePagePerSheet is true , all column content of one sheet will output to only one page in result.
// The width of paper size of pagesetup will be ignored, and the other settings of pagesetup
// will still take effect.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XpsSaveOptions) SetAllColumnsInOnePagePerSheet(value bool)  error {
	
	CGoReturnPtr := C.XpsSaveOptions_SetAllColumnsInOnePagePerSheet( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates if you need to hide the error while rendering.
// The error can be error in shape, image, chart rendering, etc.
// Returns:
//   bool  
func (instance *XpsSaveOptions) GetIgnoreError()  (bool,  error)  {
	
	CGoReturnPtr := C.XpsSaveOptions_GetIgnoreError( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates if you need to hide the error while rendering.
// The error can be error in shape, image, chart rendering, etc.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XpsSaveOptions) SetIgnoreError(value bool)  error {
	
	CGoReturnPtr := C.XpsSaveOptions_SetIgnoreError( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether to output a blank page when there is nothing to print.
// Returns:
//   bool  
func (instance *XpsSaveOptions) GetOutputBlankPageWhenNothingToPrint()  (bool,  error)  {
	
	CGoReturnPtr := C.XpsSaveOptions_GetOutputBlankPageWhenNothingToPrint( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether to output a blank page when there is nothing to print.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XpsSaveOptions) SetOutputBlankPageWhenNothingToPrint(value bool)  error {
	
	CGoReturnPtr := C.XpsSaveOptions_SetOutputBlankPageWhenNothingToPrint( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the 0-based index of the first page to save.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *XpsSaveOptions) SetPageIndex(value int32)  error {
	
	CGoReturnPtr := C.XpsSaveOptions_SetPageIndex( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the 0-based index of the first page to save.
// Returns:
//   int32  
func (instance *XpsSaveOptions) GetPageIndex()  (int32,  error)  {
	
	CGoReturnPtr := C.XpsSaveOptions_GetPageIndex( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Gets or sets the number of pages to save.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *XpsSaveOptions) SetPageCount(value int32)  error {
	
	CGoReturnPtr := C.XpsSaveOptions_SetPageCount( instance.ptr, C.int(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the number of pages to save.
// Returns:
//   int32  
func (instance *XpsSaveOptions) GetPageCount()  (int32,  error)  {
	
	CGoReturnPtr := C.XpsSaveOptions_GetPageCount( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result := int32(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates which pages will not be printed.
// Returns:
//   int32  
func (instance *XpsSaveOptions) GetPrintingPageType()  (PrintingPageType,  error)  {
	
	CGoReturnPtr := C.XpsSaveOptions_GetPrintingPageType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToPrintingPageType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Indicates which pages will not be printed.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *XpsSaveOptions) SetPrintingPageType(value PrintingPageType)  error {
	
	CGoReturnPtr := C.XpsSaveOptions_SetPrintingPageType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets gridline type.
// Returns:
//   int32  
func (instance *XpsSaveOptions) GetGridlineType()  (GridlineType,  error)  {
	
	CGoReturnPtr := C.XpsSaveOptions_GetGridlineType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToGridlineType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets or sets gridline type.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *XpsSaveOptions) SetGridlineType(value GridlineType)  error {
	
	CGoReturnPtr := C.XpsSaveOptions_SetGridlineType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets gridline color.
// Returns:
//   Color  
func (instance *XpsSaveOptions) GetGridlineColor()  (*Color,  error)  {
	
	CGoReturnPtr := C.XpsSaveOptions_GetGridlineColor( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &Color{}
	result.ptr = CGoReturnPtr.return_value 

	return result, nil 
}
// Gets or sets gridline color.
// Parameters:
//   value - Color 
// Returns:
//   void  
func (instance *XpsSaveOptions) SetGridlineColor(value *Color)  error {
	
	CGoReturnPtr := C.XpsSaveOptions_SetGridlineColor( instance.ptr, value.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets displaying text type when the text width is larger than cell width.
// Returns:
//   int32  
func (instance *XpsSaveOptions) GetTextCrossType()  (TextCrossType,  error)  {
	
	CGoReturnPtr := C.XpsSaveOptions_GetTextCrossType( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToTextCrossType(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets or sets displaying text type when the text width is larger than cell width.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *XpsSaveOptions) SetTextCrossType(value TextCrossType)  error {
	
	CGoReturnPtr := C.XpsSaveOptions_SetTextCrossType( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets default edit language.
// Returns:
//   int32  
func (instance *XpsSaveOptions) GetDefaultEditLanguage()  (DefaultEditLanguage,  error)  {
	
	CGoReturnPtr := C.XpsSaveOptions_GetDefaultEditLanguage( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToDefaultEditLanguage(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Gets or sets default edit language.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *XpsSaveOptions) SetDefaultEditLanguage(value DefaultEditLanguage)  error {
	
	CGoReturnPtr := C.XpsSaveOptions_SetDefaultEditLanguage( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets the sheets to render. Default is all visible sheets in the workbook: <see cref="Aspose.Cells.Rendering.SheetSet.Visible"/>.
// Returns:
//   SheetSet  
func (instance *XpsSaveOptions) GetSheetSet()  (*SheetSet,  error)  {
	
	CGoReturnPtr := C.XpsSaveOptions_GetSheetSet( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &SheetSet{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteSheetSet) 

	return result, nil 
}
// Gets or sets the sheets to render. Default is all visible sheets in the workbook: <see cref="Aspose.Cells.Rendering.SheetSet.Visible"/>.
// Parameters:
//   value - SheetSet 
// Returns:
//   void  
func (instance *XpsSaveOptions) SetSheetSet(value *SheetSet)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.XpsSaveOptions_SetSheetSet( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Implements this interface to get DrawObject and Bound when rendering.
// Returns:
//   DrawObjectEventHandler  
func (instance *XpsSaveOptions) GetDrawObjectEventHandler()  (*DrawObjectEventHandler,  error)  {
	
	CGoReturnPtr := C.XpsSaveOptions_GetDrawObjectEventHandler( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &DrawObjectEventHandler{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteDrawObjectEventHandler) 

	return result, nil 
}
// Implements this interface to get DrawObject and Bound when rendering.
// Parameters:
//   value - DrawObjectEventHandler 
// Returns:
//   void  
func (instance *XpsSaveOptions) SetDrawObjectEventHandler(value *DrawObjectEventHandler)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.XpsSaveOptions_SetDrawObjectEventHandler( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Setting for rendering Emf metafile.
// Returns:
//   int32  
func (instance *XpsSaveOptions) GetEmfRenderSetting()  (EmfRenderSetting,  error)  {
	
	CGoReturnPtr := C.XpsSaveOptions_GetEmfRenderSetting( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToEmfRenderSetting(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Setting for rendering Emf metafile.
// Parameters:
//   value - int32 
// Returns:
//   void  
func (instance *XpsSaveOptions) SetEmfRenderSetting(value EmfRenderSetting)  error {
	
	CGoReturnPtr := C.XpsSaveOptions_SetEmfRenderSetting( instance.ptr, C.int( int32(value)))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets or sets custom settings during rendering.
// Returns:
//   CustomRenderSettings  
func (instance *XpsSaveOptions) GetCustomRenderSettings()  (*CustomRenderSettings,  error)  {
	
	CGoReturnPtr := C.XpsSaveOptions_GetCustomRenderSettings( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  nil, err
	}
	result := &CustomRenderSettings{}
	result.ptr = CGoReturnPtr.return_value 
	runtime.SetFinalizer(result, DeleteCustomRenderSettings) 

	return result, nil 
}
// Gets or sets custom settings during rendering.
// Parameters:
//   value - CustomRenderSettings 
// Returns:
//   void  
func (instance *XpsSaveOptions) SetCustomRenderSettings(value *CustomRenderSettings)  error {
	
	var value_ptr unsafe.Pointer = nil
	if value != nil {
	  value_ptr =value.ptr
	}

	CGoReturnPtr := C.XpsSaveOptions_SetCustomRenderSettings( instance.ptr, value_ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Gets the save file format.
// Returns:
//   int32  
func (instance *XpsSaveOptions) GetSaveFormat()  (SaveFormat,  error)  {
	
	CGoReturnPtr := C.XpsSaveOptions_GetSaveFormat( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  0, err
	}
	result , err := Int32ToSaveFormat(int32(CGoReturnPtr.return_value)) 
	if err != nil {
		return 0, err
	}

	return result, nil 
}
// Make the workbook empty after saving the file.
// Returns:
//   bool  
func (instance *XpsSaveOptions) GetClearData()  (bool,  error)  {
	
	CGoReturnPtr := C.XpsSaveOptions_GetClearData( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Make the workbook empty after saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XpsSaveOptions) SetClearData(value bool)  error {
	
	CGoReturnPtr := C.XpsSaveOptions_SetClearData( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// The folder for temporary files that may be used as data cache.
// Returns:
//   string  
func (instance *XpsSaveOptions) GetCachedFileFolder()  (string,  error)  {
	
	CGoReturnPtr := C.XpsSaveOptions_GetCachedFileFolder( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  "", err
	}
	result := C.GoString(CGoReturnPtr.return_value) 

	return result, nil 
}
// The folder for temporary files that may be used as data cache.
// Parameters:
//   value - string 
// Returns:
//   void  
func (instance *XpsSaveOptions) SetCachedFileFolder(value string)  error {
	
	CGoReturnPtr := C.XpsSaveOptions_SetCachedFileFolder( instance.ptr, C.CString(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether validate merged cells before saving the file.
// Returns:
//   bool  
func (instance *XpsSaveOptions) GetValidateMergedAreas()  (bool,  error)  {
	
	CGoReturnPtr := C.XpsSaveOptions_GetValidateMergedAreas( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether validate merged cells before saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XpsSaveOptions) SetValidateMergedAreas(value bool)  error {
	
	CGoReturnPtr := C.XpsSaveOptions_SetValidateMergedAreas( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether merge the areas of conditional formatting and validation before saving the file.
// Returns:
//   bool  
func (instance *XpsSaveOptions) GetMergeAreas()  (bool,  error)  {
	
	CGoReturnPtr := C.XpsSaveOptions_GetMergeAreas( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether merge the areas of conditional formatting and validation before saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XpsSaveOptions) SetMergeAreas(value bool)  error {
	
	CGoReturnPtr := C.XpsSaveOptions_SetMergeAreas( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// If true and the directory does not exist, the directory will be automatically created before saving the file.
// Returns:
//   bool  
func (instance *XpsSaveOptions) GetCreateDirectory()  (bool,  error)  {
	
	CGoReturnPtr := C.XpsSaveOptions_GetCreateDirectory( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// If true and the directory does not exist, the directory will be automatically created before saving the file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XpsSaveOptions) SetCreateDirectory(value bool)  error {
	
	CGoReturnPtr := C.XpsSaveOptions_SetCreateDirectory( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether sorting defined names before saving file.
// Returns:
//   bool  
func (instance *XpsSaveOptions) GetSortNames()  (bool,  error)  {
	
	CGoReturnPtr := C.XpsSaveOptions_GetSortNames( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether sorting defined names before saving file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XpsSaveOptions) SetSortNames(value bool)  error {
	
	CGoReturnPtr := C.XpsSaveOptions_SetSortNames( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether sorting external defined names before saving file.
// Returns:
//   bool  
func (instance *XpsSaveOptions) GetSortExternalNames()  (bool,  error)  {
	
	CGoReturnPtr := C.XpsSaveOptions_GetSortExternalNames( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether sorting external defined names before saving file.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XpsSaveOptions) SetSortExternalNames(value bool)  error {
	
	CGoReturnPtr := C.XpsSaveOptions_SetSortExternalNames( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether refreshing chart cache data
// Returns:
//   bool  
func (instance *XpsSaveOptions) GetRefreshChartCache()  (bool,  error)  {
	
	CGoReturnPtr := C.XpsSaveOptions_GetRefreshChartCache( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether refreshing chart cache data
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XpsSaveOptions) SetRefreshChartCache(value bool)  error {
	
	CGoReturnPtr := C.XpsSaveOptions_SetRefreshChartCache( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Whether check restriction of excel file when user modify cells related objects.
// For example, excel does not allow inputting string value longer than 32K.
// When you input a value longer than 32K, it will be truncated.
// Returns:
//   bool  
func (instance *XpsSaveOptions) GetCheckExcelRestriction()  (bool,  error)  {
	
	CGoReturnPtr := C.XpsSaveOptions_GetCheckExcelRestriction( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Whether check restriction of excel file when user modify cells related objects.
// For example, excel does not allow inputting string value longer than 32K.
// When you input a value longer than 32K, it will be truncated.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XpsSaveOptions) SetCheckExcelRestriction(value bool)  error {
	
	CGoReturnPtr := C.XpsSaveOptions_SetCheckExcelRestriction( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether updating smart art setting.
// The default value is false.
// Returns:
//   bool  
func (instance *XpsSaveOptions) GetUpdateSmartArt()  (bool,  error)  {
	
	CGoReturnPtr := C.XpsSaveOptions_GetUpdateSmartArt( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether updating smart art setting.
// The default value is false.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XpsSaveOptions) SetUpdateSmartArt(value bool)  error {
	
	CGoReturnPtr := C.XpsSaveOptions_SetUpdateSmartArt( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}
// Indicates whether encrypt document properties when saving as .xls file.
// The default value is true.
// Returns:
//   bool  
func (instance *XpsSaveOptions) GetEncryptDocumentProperties()  (bool,  error)  {
	
	CGoReturnPtr := C.XpsSaveOptions_GetEncryptDocumentProperties( instance.ptr)
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  true, err
	}
	result := bool(CGoReturnPtr.return_value) 

	return result, nil 
}
// Indicates whether encrypt document properties when saving as .xls file.
// The default value is true.
// Parameters:
//   value - bool 
// Returns:
//   void  
func (instance *XpsSaveOptions) SetEncryptDocumentProperties(value bool)  error {
	
	CGoReturnPtr := C.XpsSaveOptions_SetEncryptDocumentProperties( instance.ptr, C.bool(value))
	if CGoReturnPtr.error_no != 0 {
		err := errors.New(C.GoString(CGoReturnPtr.error_message))	
		return  err
	}

	return nil 
}


func (instance *XpsSaveOptions) ToPaginatedSaveOptions() *PaginatedSaveOptions {
	parentClass := &PaginatedSaveOptions{}
	parentClass.ptr = instance.ptr
	return parentClass
}
func (instance *XpsSaveOptions) ToSaveOptions() *SaveOptions {
	parentClass := &SaveOptions{}
	parentClass.ptr = instance.ptr
	return parentClass
}

func DeleteXpsSaveOptions(xpssaveoptions *XpsSaveOptions){
	runtime.SetFinalizer(xpssaveoptions, nil)
	C.Delete_XpsSaveOptions(xpssaveoptions.ptr)
	xpssaveoptions.ptr = nil
}
